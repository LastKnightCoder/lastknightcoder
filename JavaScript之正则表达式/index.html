<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript之正则表达式 | Coder</title><meta name="description" content="JavaScript正则表达式"><meta name="keywords" content="JavaScript 正则表达式"><meta name="author" content="熊滔"><meta name="copyright" content="熊滔"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://lastknightcoder.gitee.io/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaScript之正则表达式"><meta name="twitter:description" content="JavaScript正则表达式"><meta name="twitter:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200528095141.png"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript之正则表达式"><meta property="og:url" content="https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><meta property="og:site_name" content="Coder"><meta property="og:description" content="JavaScript正则表达式"><meta property="og:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200528095141.png"><meta property="article:published_time" content="2020-05-27T16:00:00.000Z"><meta property="article:modified_time" content="2020-05-27T16:00:00.000Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><link rel="next" title="Spring常见注解" href="https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: 'https://lastknightcoder.gitee.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lastknightcoder.gitee.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="https://lastknightcoder.gitee.io/atom.xml" title="Coder" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://lastknightcoder.gitee.io/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="https://lastknightcoder.gitee.io/archives/"><div class="headline">文章</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="https://lastknightcoder.gitee.io/tags/"><div class="headline">标签</div><div class="length_num">43</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="https://lastknightcoder.gitee.io/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正则对象"><span class="toc-number">1.</span> <span class="toc-text">正则对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则对象中的属性"><span class="toc-number">1.1.</span> <span class="toc-text">正则对象中的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则对象中的方法"><span class="toc-number">1.2.</span> <span class="toc-text">正则对象中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#test"><span class="toc-number">1.2.1.</span> <span class="toc-text">test</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec"><span class="toc-number">1.2.2.</span> <span class="toc-text">exec</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数RegExp的属性"><span class="toc-number">1.3.</span> <span class="toc-text">构造函数RegExp的属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串方法"><span class="toc-number">2.</span> <span class="toc-text">字符串方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#replace"><span class="toc-number">2.1.</span> <span class="toc-text">replace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#match"><span class="toc-number">2.2.</span> <span class="toc-text">match</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符匹配"><span class="toc-number">3.</span> <span class="toc-text">字符匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符组"><span class="toc-number">3.1.</span> <span class="toc-text">字符组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#量词"><span class="toc-number">3.2.</span> <span class="toc-text">量词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪婪匹配与惰性匹配"><span class="toc-number">3.3.</span> <span class="toc-text">贪婪匹配与惰性匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分支"><span class="toc-number">3.4.</span> <span class="toc-text">分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#括号的作用"><span class="toc-number">4.</span> <span class="toc-text">括号的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分组与分支"><span class="toc-number">4.1.</span> <span class="toc-text">分组与分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获数据"><span class="toc-number">4.2.</span> <span class="toc-text">捕获数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp的属性-1…"><span class="toc-number">4.2.1.</span> <span class="toc-text">RegExp的属性$1…</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#括号嵌套"><span class="toc-number">4.2.2.</span> <span class="toc-text">括号嵌套</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向引用"><span class="toc-number">4.3.</span> <span class="toc-text">反向引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位置匹配"><span class="toc-number">5.</span> <span class="toc-text">位置匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关元字符"><span class="toc-number">5.1.</span> <span class="toc-text">相关元字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#千位分隔符案例"><span class="toc-number">5.2.</span> <span class="toc-text">千位分隔符案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多行模式"><span class="toc-number">5.3.</span> <span class="toc-text">多行模式</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200528095141.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="https://lastknightcoder.gitee.io/">Coder</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JavaScript之正则表达式</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-28 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-28 00:00:00"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="https://lastknightcoder.gitee.io/categories/Web/">Web</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="https://lastknightcoder.gitee.io/categories/Web/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-comments" aria-hidden="true"></i><span>评论数:</span><a href="https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>在字符串的处理中，我们经常要进行字符串的匹配，校验等等操作。比如校验字符串的格式是否符合邮箱，电话号码的格式，校验密码是否符合要求，密码中是否包含数字和字母等等；又或者匹配得到某种规则的字符串。这一些操作如果使用常规的方法进行字符串操作，会花费较大的代价，包括时间和精力。</p>
<p>正则表达式是用来表达字符串的规则，它可以检验字符串是否符合某个特定的规则，或者匹配字符串中符合规则的字符，在一般的使用中，正则表达式一般用来匹配字符串中的字符或者字符串中特定的位置。</p>
<h2 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h2><p><code>JavaScript</code> 正则对象的创建有两种常见的方法，一是使用 <code>RegExp</code> 构造函数进行创建，二是使用字面量的方法进行创建，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'hello'</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> regex2 = <span class="regexp">/hello/g</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>hello</code> 表示字符串的规则，用来匹配字符串中的<code>&quot;hello&quot;</code>，<code>g</code> 表示进行全局匹配(<code>global</code>)，像这样的标志还有两个，<code>m</code> 表示进行多行匹配(<code>multiline</code>)，<code>i</code> 表示忽略大小写(<code>ignoreCase</code>)，这三个标志互不冲突，可以同时使用，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/igm</span>;</span><br></pre></td></tr></table></figure>

<p>具体标志的作用在后面讲解。在实际的使用中，我们一般会使用字面量的形式创建正则对象，相对于使用构造函数，字面量的创建比较简便，不过如果需要动态的创建正则对象，或者根据字符串创建正则对象，那么可以考虑使用构造函数的方式。</p>
<h3 id="正则对象中的属性"><a href="#正则对象中的属性" class="headerlink" title="正则对象中的属性"></a>正则对象中的属性</h3><ul>
<li><code>global</code>：布尔值，是否设置了 <code>g</code> 标志</li>
<li><code>ignoreCase</code>：布尔值，是否设置了 <code>i</code> 标志</li>
<li><code>lastIndex</code>：整数，从字符串的某个位置开始匹配，默认为 <code>0</code></li>
<li><code>multiline</code>：布尔值，是否设置了 <code>m</code> 标志</li>
<li><code>source</code>：正则表达式的字符串表示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d&#123;3&#125;hello$/ig</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.global); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.source); <span class="comment">// \d&#123;3&#125;hello$</span></span><br></pre></td></tr></table></figure>

<h3 id="正则对象中的方法"><a href="#正则对象中的方法" class="headerlink" title="正则对象中的方法"></a>正则对象中的方法</h3><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><code>test()</code>，该方法接收一个字符串参数，返回一个布尔值，用来判断该字符串是否符合正则对象的规则，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec()</code> 方法是用来捕获匹配到的字符，该方法接收一个字符串，返回一个数组，数组的第一项表示与整个模式匹配的字符串，第二项表示第一个捕获组(捕获组的概念如果不懂，可以看了括号的作用在回来看)，第三项表示第二个捕获组，以此类推。返回的数组与普通数组不同的是，该数组还有三个属性，<code>index</code> 、 <code>input</code> 和 <code>groups</code>，<code>index</code> 表示匹配到的字符在原始字符串中的位置，从 <code>0</code> 开始；<code>input</code> 表示输入的原始字符串，<code>groups</code> 表示捕获组的名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(he)(ll)(o)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"so hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200527135642.png" width="80%"/>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">3</span>,</span><br><span class="line">  input: <span class="string">'so hello'</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果正则对象的标志有 <code>g</code> 的话，那么在执行 <code>exec()</code> 方法后会改变 <code>lastIndex</code> 为匹配字符串后字符的 <code>index</code>，接下来再次执行 <code>exec()</code> 方法时将会从 <code>lastIndex</code> 处开始匹配，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"ab abc abc"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/ab/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">regex.exec(string); <span class="comment">// 匹配不到会返回 null</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 重新变为 0</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数RegExp的属性"><a href="#构造函数RegExp的属性" class="headerlink" title="构造函数RegExp的属性"></a>构造函数RegExp的属性</h3><p>构造函数 <code>RegExp</code> 中有一些静态属性，这些属性会保存最近一次正则对象操作的一些信息，并且这些属性有两种方法访问，一种是具有语义的长属性名，一种是简短的短属性名，具体如下：</p>
<ul>
<li><code>input</code>：短属性名为 <code>$_</code>，最近一次要匹配的字符串</li>
<li><code>lastMatch</code>：<code>$&amp;</code>，最近一次的匹配项</li>
<li><code>leftContext</code>：$`， <code>input</code> 中 <code>lastMatch</code> 的左边部分</li>
<li><code>rightContext</code>：<code>$&#39;</code>，<code>input</code> 中 <code>lastMatch</code> 的右边部分</li>
<li><code>$1, $2, ...</code>：后面介绍</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"he hello llo"</span>;</span><br><span class="line">regex.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input); <span class="comment">// he hello llo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// he_ (从_表示空格)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// _llo</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>在字符串中，有许多的方法也是与正则表达式有关的，如 <code>replace</code>，<code>match</code>，下面就简单介绍一下。</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p><code>replace()</code> 方法的作用是使用新的字符串替换字符串中的某些内容，该方法接收两个参数，第一个参数表示字符串中要被替换的内容，它可以是一个具体的字符串或者是一个正则对象，第二个参数为一个字符串，这个参数是用来替换第一个参数的，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"gello"</span>;</span><br><span class="line">string = string.replace(<span class="string">'g'</span>, <span class="string">'h'</span>); <span class="comment">// 将 string 中的 g 替换为 h</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"abc"</span>;</span><br><span class="line">string = string.replace(<span class="regexp">/[ab]/g</span>, <span class="string">'#'</span>); <span class="comment">// 将字符串中的 a 或 b 替换为 #</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// ##c</span></span><br></pre></td></tr></table></figure>

<p>在上面中使用了 <code>[ab]</code>，这个表示 <code>a</code> 或者 <code>b</code>，具体会在元字符那里讲解。</p>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>match</code> 方法的作用与 <code>exec</code> 的作用差不多，不过一个是 <code>RegExp</code> 对象的方法，一个是 <code>String</code> 对象的方法。<code>match</code> 方法接收一个正则对象，它返回一个数组，根据正则对象是否设置了 <code>g</code> 标志，返回的结果也不相同。</p>
<p>如果没有设置 <code>g</code> 标志，即不会全局匹配，只会匹配一次，那么它返回的结果与 <code>exec</code> 返回的结果相同，数组的第一个元素表示匹配的字符串，后面的元素表示捕获组，并且也有 <code>input</code>，<code>index</code>，<code>groups</code>等属性，表示的含义也痛 <code>exec</code>，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(<span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello'</span>,</span><br><span class="line">  groups: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">h</span>: <span class="string">'he'</span>, <span class="attr">l</span>: <span class="string">'ll'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这次的正则表达式跟以往的不同，这次我设置了捕获组的名称，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?<span class="xml"><span class="tag">&lt;<span class="name">h</span>&gt;</span>he)</span></span><br></pre></td></tr></table></figure>

<p>即将捕获组 <code>(he)</code> 的名称设置为了 <code>h</code>，设置捕获组名称的格式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?&lt;捕获组名称&gt;捕获组内容)</span><br></pre></td></tr></table></figure>

<p>为捕获组设置名称，可以方便在后面进行引用。</p>
<p>如果设置了 <code>g</code> 标志，这时返回值与 <code>exec</code> 方法就不同了，它会将字符串中所有符合正则表达式规则的内容都匹配出来，并放入数组中，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello' ]</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">"hello helloworld"</span>;</span><br><span class="line">result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure>

<p>这时设置的捕获组的信息就提取不到了，所以从某种程度上说，<code>exec</code> 的功能比 <code>match</code> 更加的强大，不过 <code>exec</code> 并不能一次提取出字符串中所有符合规则的内容，而是需要做一个循环，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello helloworld"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 当 re.exec()不为 null 时</span></span><br><span class="line"><span class="keyword">while</span> (result = re.exec(string)) &#123;</span><br><span class="line">    results.push(result[<span class="number">0</span>]); <span class="comment">// result 中还包含了捕获组的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><p>上面使用正则表达式进行匹配都是进行精确的匹配，如 <code>/hello/</code>，匹配字符串中的 <code>hello</code> 内容，这样我们根本无法领会到正则表达式的强大，正则表达式正是强大在它模糊匹配的能力，比如我们在 <code>Windows</code> 中进行文件查找，有时我们不记得文件的具体名称，比如忘了某个字母，这个时候我们会用 <code>.</code> 去表示任意的字母去进行查找。现在我们就来讲讲正则表达式模糊匹配的能力。</p>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>在进行匹配的时候，如果我们不确定某个位置的字符是什么，我们可以使用表示特定含义的字符来占据这个位置，比如 <code>[abc]</code> 表示这个位置是 <code>a</code>，<code>b</code>，<code>c</code> 中的某个字符。如果我们想表示这个字符是小写字母，按照上面的写法，你可能会这么写 <code>[abcdefghijklmnopqrstuvwxyz]</code>，这样的写法有点反人类，我们可以使用范围表示法来代替上面的写法，如 <code>[a-z]</code> 的写法就表示所有的小写字母，同理 <code>[A-Z]</code> 就表示所有的大写字母，<code>[0-9]</code> 就表示数字，<code>[0-9a-zA-Z]</code> 表示这个位置可以是数字，小写字母，大写字母。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let re = /[a-zA-Z0-<span class="number">9</span>]/;</span><br><span class="line">console.log(re.test(<span class="string">'0'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'s'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'S'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'?'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>[]</code> 中加入 <code>^</code> 表示取反，如 <code>[^0-9]</code> 表示非数字，即它可以匹配所有的非数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/[^0-9]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"?"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用<strong>元字符</strong>来占据位置，比如 <code>\d</code> 就代表数字，它的作用与 <code>[0-9]</code> 是一样的，常见的元字符如下所示(不包含表示位置的元字符，表示位置的元字符在后面介绍)</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>表示数字</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>表示空白字符，包括空格，回车，制表符等等</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>表示数字，大小写字母和下划线，相当于 <code>[0-9a-zA-Z_]</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>表示任意一个字符</td>
</tr>
</tbody></table>
<p>来看几个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示数字</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空白字符</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\s/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示大小写字母，数字和下划线</span></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\w/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"A"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"_"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与在 <code>[]</code> 中加入 <code>^</code>表示取反，上面的元字符也有对应的元字符表示取反的概念</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\D</code></td>
<td>与 <code>\d</code> 相反，表示非数字</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>与 <code>\s</code> 相反，表示非空白字符</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>与 <code>\w</code> 相反，表示非单词</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\S/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"9"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\W/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"0"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>现在我们假设使用正则表达式去匹配电话号码，假设电话号码就是 <code>11</code> 位数字，所以写出来的正则表达式是这样的 <code>\d\d\d\d\d\d\d\d\d\d\d</code>，这种写法也相当的反人类，不仅难读(需要一个个数才知道有多少个数)，而且写起来也麻烦，我们可以使用量词来简写上面的表达式，如 <code>\d{11}</code> 就表示 <code>\d</code> 连续出现 <code>11</code> 次，常见的量词写法如下</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>{n}</code></td>
<td>表示连续出现 <code>n</code> 次</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>表示连续出现 <code>m-n</code>，最少出现 <code>m</code>，最多出现 <code>n</code> 次</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>表示连续出现最少 <code>n</code> 次(包括 <code>n</code> 次)</td>
</tr>
<tr>
<td><code>*</code></td>
<td>表示连续出现<strong>任意</strong>多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>表示连续出现 <code>1</code> 次或 <code>1</code> 次以上</td>
</tr>
<tr>
<td><code>?</code></td>
<td>表示出现 <code>0</code> 次或 <code>1</code> 次</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 5 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;5&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"123 1234 12345 654321"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12345', '65432' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 2-3 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;2,3&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12', '123', '123' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现 4 位及 4 位以上的数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4,&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234 12345"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '1234', '12345' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 可以出现任意次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab*c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ac', 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 1 次或 1 次以上</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 0 次或 1 次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab?c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re));</span><br></pre></td></tr></table></figure>

<h3 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h3><p>所谓的贪婪匹配就是尽可能的多匹配，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abbbb' ]</span></span><br></pre></td></tr></table></figure>

<p>明明匹配 <code>ab</code> 也可以，但是它会尽可能多的匹配，这就是贪婪模式，与此相对的是惰性匹配，惰性匹配就是在满足条件的情况下会尽可能的少匹配，如上例就会匹配 <code>ab</code>，在默认的情况下是贪婪匹配，要使用惰性匹配就要使用惰性量词</p>
<table>
<thead>
<tr>
<th>贪婪</th>
<th>惰性</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>+?</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>*?</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>??</code></td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td><code>{n,m}?</code></td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td><code>{n,}?</code></td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+?/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ab' ]</span></span><br></pre></td></tr></table></figure>

<p>现在考虑根据 <code>html</code> 字符串获得某 <code>id</code> 属性，如 <code>&lt;div id=&quot;container&quot; class=&quot;active&quot;&gt;&lt;/div&gt;</code>，如果我们使用贪婪匹配的话，考虑这样的匹配规则 <code>/id=&quot;.*&quot;/</code>，那么捕获到的并不是我们想要的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container" class="active"</span></span><br></pre></td></tr></table></figure>

<p>我们发现匹配到的是 <code>id=&quot;container&quot; class=&quot;active&quot;</code>，因为在贪婪模式下再符合条件的情况下会尽可能多的匹配，所以会直接匹配到最后一个双引号，解决办法有两种，其中简单的解决办法就是使用惰性匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*?"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure>

<p>另一种办法就比较 <code>trick</code>，我觉得只可意会，难以言传</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id="[^"]*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure>

<p>仔细体会上面的写法吧，我觉得很好用，比如获得某标签的标签名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/&lt;[^&gt;]*&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// &lt;div&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>有时候我们需要在多个分支之间进行选择，比如匹配十六进制表示的颜色，有两种表示，一种是 <code>#F4E242</code> 六位的，一种是简写的 <code>#FFF</code> 三位表示的，我们可以使用 <code>|</code> 来表示或的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"#FFF"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"#F34E23"</span></span><br><span class="line"><span class="built_in">console</span>.log(string1.match(regex)); <span class="comment">// [ '#FFF' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(string2.match(regex)); <span class="comment">// [ '#F34E23' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><h3 id="分组与分支"><a href="#分组与分支" class="headerlink" title="分组与分支"></a>分组与分支</h3><p>假设我们要匹配 <code>I love Java</code> 和 <code>I love C</code> 这两句话，你可能会写出这样的正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love Java|C/</span><br></pre></td></tr></table></figure>

<p>但是这个正则表达式表示的是 <code>I love Java</code> 或者 <code>C</code> 而不是 <code>I love C</code>，正确的写法应该是这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love (Java|C)/</span><br></pre></td></tr></table></figure>

<p><code>Java</code> 和 <code>C</code> 选其一。</p>
<h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>假设我们要匹配一个格式为 <code>yyyy-mm-dd</code> 格式的日期，并且希望获得年月日，那么可能会这么写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string)[<span class="number">0</span>]; <span class="comment">// 2020-05-27</span></span><br><span class="line"><span class="keyword">let</span> results = result.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + results[<span class="number">0</span>]); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + results[<span class="number">1</span>]); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + results[<span class="number">2</span>]); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure>

<p>其实我们可以通过添加括号来捕获数据，对于被括号包起来的数据，其匹配的内容会被提取出来，添加到返回的数组中，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + result[<span class="number">1</span>]); <span class="comment">// 第一个捕获组 \d&#123;4&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + result[<span class="number">2</span>]); <span class="comment">// 第二个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + result[<span class="number">3</span>]); <span class="comment">// 第三个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br></pre></td></tr></table></figure>

<p>上面我们对年月日的规则使用括号包了起来，在进行匹配时，对应被匹配到的数据会添加到数组中，在介绍 <code>exec</code> 方法时，其返回的数组，第一个元素表示匹配到的字符串，后面的元素表示捕获组(括号包起来)中捕获的内容。</p>
<h4 id="RegExp的属性-1…"><a href="#RegExp的属性-1…" class="headerlink" title="RegExp的属性$1…"></a>RegExp的属性$1…</h4><p>除了可以根据返回的数组 <code>result</code> 来得到捕获的数据，还可以通过在上面提过一嘴的 <code>RegExp</code> 构造函数的属性 <code>$1, $2, $3 ...</code> 等等来获得所捕获的内容，其中 <code>$1</code> 表示第一个捕获组所匹配的内容，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + <span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure>

<p>每次在使用正则表达式进行匹配时，<code>RegExp</code> 中的 <code>$1, $2, $3 ...</code> 也会相应的更新。</p>
<h4 id="括号嵌套"><a href="#括号嵌套" class="headerlink" title="括号嵌套"></a>括号嵌套</h4><p>现在考虑如果括号有嵌套的情况，比如上面日期格式捕获更精准的表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(\d&#123;<span class="number">4</span>&#125;)-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|([<span class="number">1</span><span class="number">-2</span>]\d)|(<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>]))/</span><br></pre></td></tr></table></figure>

<p>上面括号嵌套的很复杂，在原理上，被括号包起来的规则所匹配的内容都会被捕获，那么嵌套带来的问题就是，捕获的顺序哪个在前，哪个在后，其实也很简单，根据左括号来，比如上式中的捕获顺序为</p>
<ol>
<li><code>(\d{4})</code></li>
<li><code>((0\d)|(1[0-2]))</code></li>
<li><code>(0\d)</code></li>
<li><code>(1[0-2])</code></li>
<li><code>((0[1-9])|([1-2]\d)|(3[0-1]))</code></li>
<li><code>(0[1-9])</code></li>
<li><code>([1-2]\d)</code></li>
<li><code>(3[0-1])</code></li>
</ol>
<p>所以如果使用上面的正则表达式进行捕获得到年月日的信息，根据分析年是第一捕获组，月是第二捕获组，日是第五捕获组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">5</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>由于无用的捕获组太多，导致想要提取包含信息的捕获组获取困难，其实仔细观察，里面的大多数括号主要是为分支做准备的，对于这些捕获组，我们可以考虑不捕获，仅仅作为分支使用，我们在括号里面的前方加入 <code>?:</code> 表示该括号匹配的内容不进行捕获，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((?:0[1-9])|(?:1[0-2]))-((?:0[1-9])|(?:[1-2]\d)|(?:3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">3</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>如果作为分支的括号太多，为每一个分支添加 <code>?:</code> 也比较费力，那么可以考虑给包含信息的捕获组命名，命名的方法在上面有提到过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;(0[1-9])|(1[0-2]))-(?&lt;day&gt;(0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"><span class="keyword">let</span> groups = result.groups;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groups.year, groups.month, groups.day); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>通过给捕获组命名，可以方便的通过 <code>groups</code> 对象得到想要的数据。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>现在再次考虑匹配日期，已知下面这三种日期格式都可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-12</span></span><br><span class="line"><span class="number">2017</span> <span class="number">02</span> <span class="number">12</span></span><br><span class="line"><span class="number">2017</span>/<span class="number">02</span>/<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>所以你可能会写出这样的正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d&#123;<span class="number">4</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;/</span><br></pre></td></tr></table></figure>

<p>经过测试，发现能符合要求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是你会发现一些意外的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>前后的分隔符不一致的情况也能够匹配，而我们要求的是前后的分隔符是一样的，这个时候我们可以通过引用分组，使得前面和后面的分隔符是一样的，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;(-| |\/)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>注意到我们对于后面的分组，我们使用了 <code>\1</code> 去进行替代，<code>\1</code> 的意思就是代表引用第一个分组，这样就可以做到这个地方与前面的分组相同。同理我们也可以使用 <code>\2</code> 表示引用第二个分组(如果有的话，如果没有就单纯的表示匹配字符串 <code>&quot;\2&quot;</code>)。</p>
<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="相关元字符"><a href="#相关元字符" class="headerlink" title="相关元字符"></a>相关元字符</h3><p>正则表达式中的最后一个内容就是关于位置的匹配，与字符匹配不同，位置匹配时匹配字符间的位置，常见有关位置的元字符如下</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>开头位置</td>
</tr>
<tr>
<td><code>$</code></td>
<td>结尾位置</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>单词边界，即 <code>\w</code> 与 <code>\W</code> 之间的位置</td>
</tr>
<tr>
<td><code>(?=p)</code></td>
<td>匹配 <code>p</code> 模式前面的位置，具体见例子</td>
</tr>
<tr>
<td><code>(?&lt;=p)</code></td>
<td>匹配 <code>p</code> 模式后面的位置</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/^/</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[JS] hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/$/</span>, <span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/\b/g</span>, <span class="string">"#"</span>); <span class="comment">// \b 是 \w 与 \W 之间的位置，表示单词的边界</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [#JS#] #hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 前面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] #hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 后面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br></pre></td></tr></table></figure>

<p>同理，也有元字符表示与上面相反的意义</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\B</code></td>
<td>与 <code>\b</code> 相反，表示非单词边界</td>
</tr>
<tr>
<td><code>(?!p)</code></td>
<td>与 <code>(?=p)</code> 相反，表示不是 <code>p</code> 前面位置的所有位置</td>
</tr>
<tr>
<td><code>(?&lt;!p)</code></td>
<td>与 <code>(?&lt;=p)</code> 相反，表示不是 <code>p</code> 后面位置的所有位置</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/\B/g</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[J#S]# h#e#l#l#o</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 前面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# h#e#l#l#o#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 后面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# #h#e#l#l#o</span></span><br></pre></td></tr></table></figure>

<h3 id="千位分隔符案例"><a href="#千位分隔符案例" class="headerlink" title="千位分隔符案例"></a>千位分隔符案例</h3><p>现在来做一个案例，将数字转化为千位分隔符表示法，如 <code>12345678</code> 转化为 <code>12,345,678</code>，我们首先找到后三位数字的前面位置，然后添加逗号，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 12345,678</span></span><br></pre></td></tr></table></figure>

<p>进一步弄出所有的逗号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>); <span class="comment">// 12,345,678</span></span><br></pre></td></tr></table></figure>

<p>但是还是有一个小小问题，测试的数字个数是三的倍数的时候，在开头也会添加一个逗号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"123456789"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// ,123,456,789</span></span><br></pre></td></tr></table></figure>

<p>我们可以修改正则表达式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(?!^)(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br></pre></td></tr></table></figure>

<p>其中 <code>(?!^)</code> 表示不是开头的位置。如果希望支持更多的格式，比如 <code>1234567 12345678</code> 转换为 <code>1,234,567 12,345,678</code>，只要将上面的表达式中的开头，结尾替换为 <code>\b</code> 即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"1234567 12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(?!\b)(\d&#123;3&#125;)+\b)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1,234,567 12,345,678</span></span><br></pre></td></tr></table></figure>

<p>考虑到 <code>(?!\b)</code> 就相当于 <code>\B</code>，所以上面的表达式也可简写如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(?=\B(\d&#123;<span class="number">3</span>&#125;)+\b)/g</span><br></pre></td></tr></table></figure>

<h3 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h3><p>正则表达式有三个常见的标志，分别为全局模式 <code>g</code>，表示进行全局匹配，如果不设置该标志，那么只会匹配一次，如果字符串后面还要符合规则的字符串，是不会被匹配的，对于 <code>exec()</code> 方法，非全局模式下不会更改 <code>lastIndex</code>，即 <code>lastIndex</code> 始终是 <code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非全局替换 只会替换匹配到的第一个 hello</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re1, <span class="string">"#"</span>)); <span class="comment">// # hello</span></span><br><span class="line"><span class="comment">// 全局替换 字符串中所以的 hello 都会被替换</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re2, <span class="string">"#"</span>)); <span class="comment">// # #</span></span><br></pre></td></tr></table></figure>

<p>第二标志 <code>i</code> 很好理解，即忽略大小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(string)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(string)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第三个标志 <code>m</code> 表示多行模式，它只会影响 <code>^,$</code>，如果不是多行模式，那么 <code>^, $</code> 就表示字符串的开头和结尾，如果是多行模式，那么 <code>^,$</code> 就表示每一行的开头和结尾。</p>
<p>非多行模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 非多行 ^,$ 表示字符串的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/g</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#I </span></span><br><span class="line"><span class="attribute">love</span> </span><br><span class="line">java<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>多行模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 多行模式 ^,$ 表示每一行的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/gm</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#I #</span><br><span class="line">#love #</span><br><span class="line">#java#</span><br></pre></td></tr></table></figure>







</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">熊滔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lastknightcoder.gitee.io" target="_blank">Coder</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="https://lastknightcoder.gitee.io/tags/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript 正则表达式</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200528095141.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://lastknightcoder.gitee.io/img/wechatpay.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://lastknightcoder.gitee.io/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"><img class="next_cover" data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522214503.png" onerror="onerror=null;src='https://lastknightcoder.gitee.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring常见注解</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'be3279b05a3d99c8e41f',
  clientSecret: '5a2f84ce9033ebf48f72253dc06940844f8dfa13',
  repo: 'lastknightcoder.github.io',
  owner: 'LastKnightCoder',
  admin: ['LastKnightCoder'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 100,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 熊滔</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://lastknightcoder.gitee.io/js/utils.js"></script><script src="https://lastknightcoder.gitee.io/js/main.js"></script><script src="https://lastknightcoder.gitee.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://lastknightcoder.gitee.io/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="https://lastknightcoder.gitee.io/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
      pangu.spacingElementById('content-inner')
})</script><script src="https://lastknightcoder.gitee.io/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>