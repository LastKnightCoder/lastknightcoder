<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Node.js之Koa | Coder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="中间件,Koa,HTTP">
    <meta name="description" content="Koa 是号称是 Node.js 的下一代 Web 开发框架，它是原 Express 团队设计的新的 Web 开发框架，不像 Express 使用回调函数的开发方式，在 Koa 中使用 asnyc 函数，使用同步的写法写出异步的代码，让开发有更好的开发体验。 入门按照惯例，我们使用 Koa 建立一个简单的 Web 服务器，向前端返回 Hello World!。首先下载 koa npm instal">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js之Koa">
<meta property="og:url" content="https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/">
<meta property="og:site_name" content="Coder">
<meta property="og:description" content="Koa 是号称是 Node.js 的下一代 Web 开发框架，它是原 Express 团队设计的新的 Web 开发框架，不像 Express 使用回调函数的开发方式，在 Koa 中使用 asnyc 函数，使用同步的写法写出异步的代码，让开发有更好的开发体验。 入门按照惯例，我们使用 Koa 建立一个简单的 Web 服务器，向前端返回 Hello World!。首先下载 koa npm instal">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210313162455.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210313190007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314122050.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314123132.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314125913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314131712.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314130753.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314132111.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314154337.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314165115.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314185808.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314194752.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315153816.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315153900.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315155534.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315155847.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315160802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315201940.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315203247.png">
<meta property="article:published_time" content="2021-03-15T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-15T16:00:00.000Z">
<meta property="article:author" content="熊滔">
<meta property="article:tag" content="中间件">
<meta property="article:tag" content="Koa">
<meta property="article:tag" content="HTTP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210313162455.png">
    
        <link rel="alternate" type="application/atom+xml" title="Coder" href="https://lastknightcoder.github.io/lastknightcoder/atom.xml">
    
    <link rel="shortcut icon" href="https://lastknightcoder.github.io/lastknightcoder/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://lastknightcoder.github.io/lastknightcoder/img/brand.jpg)">
      <div class="brand">
        <a href="https://lastknightcoder.github.io/lastknightcoder/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">熊滔</h5>
          <a href="mailto:2223106858@qq.com" title="2223106858@qq.com" class="mail">2223106858@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/LastKnightCoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Node.js之Koa</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Node.js之Koa</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-03-15T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2021-03-16
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.github.io/lastknightcoder/categories/Node/">Node</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#入门"><span class="post-toc-number">1.</span> <span class="post-toc-text">入门</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#中间件"><span class="post-toc-number">2.</span> <span class="post-toc-text">中间件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#洋葱模型"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">洋葱模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简易实现"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">简易实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Context"><span class="post-toc-number">3.</span> <span class="post-toc-text">Context</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Request"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Request</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#header、headers、get"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">header、headers、get</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#method、url"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">method、url</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#origin、protocol、host"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">origin、protocol、host</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#href"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">href</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#path、querystring、search"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">path、querystring、search</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Response"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Response</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#body"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">body</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#header、headers"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">header、headers</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#type"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">type</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#length"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">length</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#status、message"><span class="post-toc-number">3.2.5.</span> <span class="post-toc-text">status、message</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lastModified、etag"><span class="post-toc-number">3.2.6.</span> <span class="post-toc-text">lastModified、etag</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#get、set、append、remove"><span class="post-toc-number">3.2.7.</span> <span class="post-toc-text">get、set、append、remove</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#redirect"><span class="post-toc-number">3.2.8.</span> <span class="post-toc-text">redirect</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#attachment"><span class="post-toc-number">3.2.9.</span> <span class="post-toc-text">attachment</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#路由"><span class="post-toc-number">4.</span> <span class="post-toc-text">路由</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#获取请求数据"><span class="post-toc-number">5.</span> <span class="post-toc-text">获取请求数据</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#暴露静态资源"><span class="post-toc-number">6.</span> <span class="post-toc-text">暴露静态资源</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件上传"><span class="post-toc-number">7.</span> <span class="post-toc-text">文件上传</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文章"><span class="post-toc-number">8.</span> <span class="post-toc-text">参考文章</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Node.js之Koa"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Node.js之Koa</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-03-16 00:00:00" datetime="2021-03-15T16:00:00.000Z"  itemprop="datePublished">2021-03-16</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.github.io/lastknightcoder/categories/Node/">Node</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>Koa 是号称是 Node.js 的下一代 Web 开发框架，它是原 Express 团队设计的新的 Web 开发框架，不像 Express 使用回调函数的开发方式，在 Koa 中使用 asnyc 函数，使用同步的写法写出异步的代码，让开发有更好的开发体验。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>按照惯例，我们使用 Koa 建立一个简单的 Web 服务器，向前端返回 <code>Hello World!</code>。首先下载 <code>koa</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install koa --save</span><br></pre></td></tr></table></figure>

<p>接着在文件中导入 <code>koa</code> 使用即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码我们引入了 <code>Koa</code>，接着使用 <code>new Koa()</code> 创建了一个服务，并且监听了 <code>3000</code> 端口。当有请求到来时，我们会直接返回 <code>Hello World!</code>。下面使用 <code>Postman</code> 发出一个 GET 请求，响应如下</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210313162455.png" style="zoom:50%;" />

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h3><p>当请求到来时，需要经过一系列的处理函数进行处理，然后才会对请求进行处理，中间经过的处理函数，我们就称为中间件。这些中间件可以我们添加很多的功能，例如解析请求参数，管理静态资源文件，处理 cookie 等等，这些功能我们都可以抽象为一个中间件。</p>
<p>上述我们说中间件就是一个函数，这个函数接收两个参数：</p>
<ul>
<li><code>ctx</code>：上下文对象，包含请求信息，也可以使用它写响应信息</li>
<li><code>next</code>：下一个中间件</li>
</ul>
<p>我们通过下面这张图来看中间件的执行过程(洋葱模型)</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210313190007.png" style="zoom: 33%;" />



<p>当请求到来时，首先会经过我们添加的中间件，当我们在中间件时调用 <code>next</code> 方法时，便会来到下一个中间件，直到某个中间件没有调用 <code>next</code> 方法便执行完毕，接着便会回到上一个中间件调用 <code>next</code> 处的地方，执行之后的代码。</p>
<p>当经过中间件处理过后，一般中间件会对上下文 <code>ctx</code> 进行设置，我们便根据对 <code>ctx</code> 的设置，产生相应的响应给前端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件 1</span></span><br><span class="line"><span class="keyword">const</span> middleware1 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"中间件 1 before"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"中间件 1 after"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件 2</span></span><br><span class="line"><span class="keyword">const</span> middleware2 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"中间件 2 before"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"中间件 2 after"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件 3</span></span><br><span class="line"><span class="keyword">const</span> middleware3 = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"中间件 3"</span>);</span><br><span class="line">    ctx.body = <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 use 方法为应用添加中间件</span></span><br><span class="line">app.use(middleware1);</span><br><span class="line">app.use(middleware2);</span><br><span class="line">app.use(middleware3);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>上面我们使用 <code>use</code> 方法添加了三个中间件，根据上面的模型，不难得出控制台的打印结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">中间件 <span class="number">1</span> before</span><br><span class="line">中间件 <span class="number">2</span> before</span><br><span class="line">中间件<span class="number">3</span></span><br><span class="line">中间件 <span class="number">2</span> after</span><br><span class="line">中间件 <span class="number">1</span> after</span><br></pre></td></tr></table></figure>

<p>我们在 <code>中间件 3</code> 中设置了 <code>ctx.body</code> 为 <code>Hello World</code>，<code>Koa</code> 便会根据此信息向前端发送 <code>Hello World!</code>。</p>
<h3 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h3><p>为了加深对中间件执行的理解，这里给出简易版的中间件的实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加中间件</span></span><br><span class="line">    use(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 req 和 res 创建上下文对象</span></span><br><span class="line">    createContext(req, res) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line">        context.req = req;</span><br><span class="line">        context.res = res;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串联所有的中间件</span></span><br><span class="line">    compose(middleware) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">                <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整体的执行流程</span></span><br><span class="line">    callback() &#123;</span><br><span class="line">        <span class="comment">// 串联中间件，当执行返回的函数时，会以洋葱模型形式执行中间件</span></span><br><span class="line">        <span class="keyword">let</span> fn = <span class="keyword">this</span>.compose(<span class="keyword">this</span>.middleware);</span><br><span class="line">        <span class="comment">// 处理请求，生成上下文 --&gt; 执行中间件 --&gt; 产生响应</span></span><br><span class="line">        <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> handleRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听端口时创建一个 HTTP 服务器</span></span><br><span class="line">    listen(...args) &#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">        <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何处理请求</span></span><br><span class="line">    handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">        res.statusCode = <span class="number">404</span>;</span><br><span class="line">        <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.respond(ctx);</span><br><span class="line">        <span class="comment">// 执行中间件 --&gt; 产生响应</span></span><br><span class="line">        <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上下文产生响应</span></span><br><span class="line">    respond(ctx) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">        res.setHeader(<span class="string">"Context-Type"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line">        res.end(ctx.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行流程是，当我们调用 <code>listen</code> 方法监听端口时，会利用 Node 内置的 <code>http</code> 模块创建一个服务器，并将 <code>this.callback</code> 返回的函数作为处理函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callback() &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="keyword">this</span>.compose(<span class="keyword">this</span>.middleware);</span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>this.callback</code>  函数中，我们首先调用了 <code>compose</code> 方法，这个方法可以将通过 <code>use</code> 方法添加的中间件建模为洋葱模型，返回一个函数 <code>fn</code>，当我们调用这个函数时，便会以洋葱模型执行所有的中间件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compose(middleware) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">            <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>this.callback</code> 返回处理请求的函数中，首先根据  <code>req</code> 和 <code>res</code> 创建上下文对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示代码，只是将 req，res 挂载在 ctx 上面</span></span><br><span class="line">createContext(req, res) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line">    context.req = req;</span><br><span class="line">    context.res = res;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着便将上下文对象 <code>ctx</code> 传递给 <code>fn</code> 中间件进行处理，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.respond(ctx);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间件处理完成之后，便根据上下文对象作出响应(这里为了演示，只是将 <code>ctx.body</code> 的内容直接返回)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">respond(ctx) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.setHeader(<span class="string">"Context-Type"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line">    <span class="comment">// 直接将 ctx.body 的内容返回</span></span><br><span class="line">    res.end(ctx.body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码只是为了演示 Koa 整体的执行流程以及中间件是如何执行的，在实现的过程中忽略了错误的处理，上述产生上下文的代码以及根据上下文对象产生响应的代码只是为了演示。</p>
</blockquote>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Koa Context 封装了 Node 的 request 和 response 对象，每次请求都会创建一个 Context，并将此 Context 传递给中间件进行处理，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Context 传递给中间件进行处理</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>下面介绍 Context 的 API。</p>
<ul>
<li>ctx.req：Node 原生的 Request 对象</li>
<li>ctx.res：Node 原生的 Response 对象</li>
<li>ctx.request：Koa 的 Request 对象</li>
<li>ctx.response：Koa 的 Response 对象</li>
</ul>
<p>虽然我们可以通过 <code>ctx.res</code> 直接返回结果，但是这种绕过 Koa 的 response 对象的行为，会破坏 Koa 的整体流程，所以不推荐使用如下方法和属性</p>
<ul>
<li>res.statusCode</li>
<li>res.write()</li>
<li>res.end()</li>
<li>res.writeHead()</li>
</ul>
<p>其实 <code>ctx</code> 上很多的属性都是 <code>ctx.request</code> 与 <code>ctx.response</code> 的代理</p>
<ul>
<li><code>ctx.header</code> ： <code>ctx.request.header</code></li>
<li><code>ctx.method</code> ： <code>ctx.request.method</code></li>
<li><code>ctx.body</code> ：<code>ctx.response.body</code></li>
<li><code>ctx.type</code> ：<code>ctx.response.type</code></li>
<li>…</li>
</ul>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>以下介绍的属性和方法都属于 <code>ctx.request</code>。</p>
<h4 id="header、headers、get"><a href="#header、headers、get" class="headerlink" title="header、headers、get"></a>header、headers、get</h4><p>通过 <code>header</code> 获得所有的请求头(也可以通过 <code>ctx.header</code> 获得)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将请求头返回</span></span><br><span class="line">    ctx.body = ctx.header;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314122050.png" style="zoom:50%;" />



<p><code>headers</code> 是 <code>header</code> 的别名，二者的值是一样的(<code>header === headers</code>)，也可以通过 <code>ctx.headers</code> 访问。</p>
<p>通过 <code>get()</code> 方法可以获得某一个请求头的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.get(<span class="string">"Host"</span>)); <span class="comment">// localhost:3000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="method、url"><a href="#method、url" class="headerlink" title="method、url"></a>method、url</h4><p>通过 <code>method</code> 与 <code>url</code> 可以知道请求方法以及请求路径，这个两个属性也可以通过 <code>ctx.xxx</code> 直接访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        method: ctx.method,</span><br><span class="line">        url: ctx.url</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314123132.png" style="zoom:50%;" />

<h4 id="origin、protocol、host"><a href="#origin、protocol、host" class="headerlink" title="origin、protocol、host"></a>origin、protocol、host</h4><p>通过 <code>origin</code> 可以获得协议 (protocol) 和主机 (host) 名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        origin: ctx.origin</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314125913.png" style="zoom:50%;" />

<p>协议以及主机名称可以直接通过 <code>protocol</code> 与 <code>host</code> 属性获得</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        protocol: ctx.protocol,</span><br><span class="line">        host: ctx.host</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314131712.png" style="zoom:50%;" />

<h4 id="href"><a href="#href" class="headerlink" title="href"></a>href</h4><p>获得全部的请求路径，包括协议、主机和 url，相当于 <code>origin + url</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        origin: ctx.origin,</span><br><span class="line">        url: ctx.url,</span><br><span class="line">        href: ctx.href</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314130753.png" style="zoom:50%;" />

<h4 id="path、querystring、search"><a href="#path、querystring、search" class="headerlink" title="path、querystring、search"></a>path、querystring、search</h4><p>通过 <code>path</code> 可以获得请求路径，即 <code>url</code> 中 <code>?</code> 之前的内容，而 <code>querystring</code> 中保存的是 <code>?</code> 之后的内容(不包括 <code>?</code>)，与 <code>querystring</code> 及其相似的一个属性是 <code>search</code>，它保存的也是 <code>?</code> 之后的内容，不过是包括 <code>?</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        path: ctx.path,</span><br><span class="line">        querystring: ctx.querystring,</span><br><span class="line">        search: ctx.search</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314132111.png" style="zoom:50%;" />

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>以下属性都是 <code>ctx.response</code> 的属性，如果在代码中直接通过 <code>ctx</code> 访问如下属性，说明 <code>ctx</code> 对这些属性做了代理。</p>
<h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p>通过 <code>body</code> 来设置响应体，它可以是如下几种类型：</p>
<ul>
<li>String</li>
<li>Buffer</li>
<li>Stream</li>
<li>Object</li>
<li>null</li>
</ul>
<p>当我们设置 <code>ctx.body</code> 时，如果状态码还未被设置，会自动的帮我们将状态码设置为 200 或 204。并且根据返回的类型设置 <code>Content-Type</code> 响应头：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>Content-Type</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>text/plain，text/html，默认编码为 utf-8</td>
</tr>
<tr>
<td>Buffer</td>
<td>application/octet-stream</td>
</tr>
<tr>
<td>Stream</td>
<td>application/octet-stream</td>
</tr>
<tr>
<td>Object</td>
<td>application/json</td>
</tr>
</tbody></table>
<p>对于 String 和 Buffer 类型的数据，还会计算内容的长度，并且设置 <code>Content-Length</code> 响应头。</p>
<h4 id="header、headers"><a href="#header、headers" class="headerlink" title="header、headers"></a>header、headers</h4><p>通过 <code>header</code> 可以获得响应头对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.response.header);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">  <span class="string">'content-type'</span>: <span class="string">'text/plain; charset=utf-8'</span>,</span><br><span class="line">  <span class="string">'content-length'</span>: <span class="string">'12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们对 <code>ctx.body</code> 进行设置时，它会根据设置给 <code>ctx.body</code> 的内容，对 <code>content-type</code> 响应头进行设置，并且会计算 <code>ctx.body</code> 的长度，对 <code>content-length</code> 响应头进行设置。</p>
<p><code>headers</code> 是 <code>header</code> 的别名，二者是一模一样的。</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><code>type</code> 是用来设置返回的数据类型是什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">"./girl.jpg"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述我们为前端返回了一张图片的二进制流，它默认的类型为 <code>application/octet-stream</code>，当我们返回给浏览器时，浏览器会自动下载内容，而不是将其解析为图片。这时我们可以通过 <code>type</code> 属性设置返回的数据为图片，这样浏览器便可以对流进行解析然后在页面展示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.type = <span class="string">"jpg"</span>;</span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">"./girl.jpg"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们知道浏览器是根据 <code>MIME</code> 类型来是识别数据类型的，但是上面我们设置的类型为 <code>jpg</code>，而不是 <code>jpg</code> 对应的 <code>MIME</code> 类型 <code>image/jpeg</code>，这时因为 <code>Koa</code> 会根据我们设置的类型，找到对应的 <code>MIME</code> 类型然后设置 <code>type</code> 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.type = <span class="string">"jpg"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.type); <span class="comment">// image/jpeg</span></span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">"./girl.jpg"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还可以直接为 <code>type</code> 属性直接设置为响应的 <code>MIME</code> 类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.type = <span class="string">"image/jpeg"</span>;</span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">"./girl.jpg"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在设置 <code>type</code> 属性时，会同时设置 <code>Content-Type</code> 响应头。</p>
<h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>当我们设置 <code>ctx.body</code> 为 String 或者为 Buffer 类型时，会自动设置 <code>Content-Length</code> 响应头，通过 <code>length</code> 属性我们可以知道内容长度为多少，即 <code>Content-Length</code> 对应的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.length);    <span class="comment">// 12</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们也可以通过 <code>length</code> 属性来设置 <code>Content-Length</code> 响应头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Hello World!"</span>;</span><br><span class="line">    ctx.length = <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>实际我们发送的内容有 <code>12</code> 个字节，但是我们设置 <code>Conetnt-Length</code> 只有 <code>10</code> 个字节，浏览器根据 <code>Content-Length</code> 的大小来接收数据，这会导致浏览器只接收到 <code>10</code> 个字节的数据</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314154337.png" style="zoom:50%;" />

<h4 id="status、message"><a href="#status、message" class="headerlink" title="status、message"></a>status、message</h4><p>可以通过 <code>status</code> 来设置返回的状态码，通过 <code>message</code> 属性来设置返回的信息。当我们设置状态码时，会自动的帮我们设置 <code>message</code> 的值，例如当我们设置状态码为  <code>200</code> 时，<code>message</code> 的值就会被设置为 <code>OK</code>，当我们设置状态码为 <code>404</code> 时，<code>message</code> 就会被设置为 <code>Not Found</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.message); <span class="comment">// Not Found</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们返回的状态码为 <code>404</code> 并且没有设置 <code>body</code> 属性时，会向前端返回字符串 <code>Not Found</code>。</p>
</blockquote>
<p>状态码以及对应的默认 <code>message</code> 如下(不必记忆)</p>
<ul>
<li>100 “continue”</li>
<li>101 “switching protocols”</li>
<li>102 “processing”</li>
<li>200 “ok”</li>
<li>201 “created”</li>
<li>202 “accepted”</li>
<li>203 “non-authoritative information”</li>
<li>204 “no content”</li>
<li>205 “reset content”</li>
<li>206 “partial content”</li>
<li>207 “multi-status”</li>
<li>208 “already reported”</li>
<li>226 “im used”</li>
<li>300 “multiple choices”</li>
<li>301 “moved permanently”</li>
<li>302 “found”</li>
<li>303 “see other”</li>
<li>304 “not modified”</li>
<li>305 “use proxy”</li>
<li>307 “temporary redirect”</li>
<li>308 “permanent redirect”</li>
<li>400 “bad request”</li>
<li>401 “unauthorized”</li>
<li>402 “payment required”</li>
<li>403 “forbidden”</li>
<li>404 “not found”</li>
<li>405 “method not allowed”</li>
<li>406 “not acceptable”</li>
<li>407 “proxy authentication required”</li>
<li>408 “request timeout”</li>
<li>409 “conflict”</li>
<li>410 “gone”</li>
<li>411 “length required”</li>
<li>412 “precondition failed”</li>
<li>413 “payload too large”</li>
<li>414 “uri too long”</li>
<li>415 “unsupported media type”</li>
<li>416 “range not satisfiable”</li>
<li>417 “expectation failed”</li>
<li>418 “I’m a teapot”</li>
<li>422 “unprocessable entity”</li>
<li>423 “locked”</li>
<li>424 “failed dependency”</li>
<li>426 “upgrade required”</li>
<li>428 “precondition required”</li>
<li>429 “too many requests”</li>
<li>431 “request header fields too large”</li>
<li>500 “internal server error”</li>
<li>501 “not implemented”</li>
<li>502 “bad gateway”</li>
<li>503 “service unavailable”</li>
<li>504 “gateway timeout”</li>
<li>505 “http version not supported”</li>
<li>506 “variant also negotiates”</li>
<li>507 “insufficient storage”</li>
<li>508 “loop detected”</li>
<li>510 “not extended”</li>
<li>511 “network authentication required”</li>
</ul>
<p>当我们设置 <code>ctx.body</code> 为<strong>除 <code>null</code> 以外外</strong>的数据时，状态码会被自动设置为 <code>200</code>，对应的消息会会被设置为 <code>OK</code>。当我们设置 <code>ctx.body</code> 为 <code>null</code> 时，状态码会被设置为 <code>204</code>，对应的消息会被设置为 <code>No Content</code>。</p>
<h4 id="lastModified、etag"><a href="#lastModified、etag" class="headerlink" title="lastModified、etag"></a>lastModified、etag</h4><p>这是用来设置 <code>LastModified</code> 与 <code>ETag</code> 响应头，<code>LastModified</code> 的格式应该为一个 <code>UTC</code> 字符串，你也可以直接为 <code>lastModified</code> 设置为一个 Date 对象，Koa 内部会帮我们转化为 <code>UTC</code> 字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.lastModified = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314165115.png" style="zoom:50%;" />



<blockquote>
<p>虽然 <code>Koa</code> 会将 <code>Date</code> 转化为 <code>UTC</code> 字符串，但是我发现时区不对，目前没有找到解决办法。</p>
</blockquote>
<p>通过 <code>etag</code> 属性设置 <code>ETag</code> 响应头，设置的内容会使用 <code>&quot;&quot;</code> 包裹起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.etag = <span class="string">"hi"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314185808.png" style="zoom:50%;" />

<h4 id="get、set、append、remove"><a href="#get、set、append、remove" class="headerlink" title="get、set、append、remove"></a>get、set、append、remove</h4><p>上述四个方法都是与响应头相关的：</p>
<ul>
<li>get(filed)：获得指定响应头的内容</li>
<li>set：分为两种<ul>
<li>set(field, value)：设置一个响应头</li>
<li>set(fields)：设置多个响应头</li>
</ul>
</li>
<li>append(field, value)：向响应头追加内容</li>
<li>remove(field)：删除响应头</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.set(&#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>,</span><br><span class="line">        <span class="string">"Last-Modified"</span>: (<span class="keyword">new</span> <span class="built_in">Date</span>()).toUTCString()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 删除 Last-Modified 响应头</span></span><br><span class="line">    ctx.remove(<span class="string">"Last-Modified"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不要使用 ctx.get，这是获取请求头的方法</span></span><br><span class="line">    ctx.body = ctx.response.get(<span class="string">"Content-Type"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h4><p>通过 <code>redirect(url)</code> 方法重定向到新的路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.redirect(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当我们访问 <code>http://localhost:3000/</code> 时会被重定向到 <code>http://www.baidu.com</code>，使用 <code>redirect</code> 方法进行重定向，会默认设置状态码为 <code>302</code>，如果需要更改状态码，可以通过 <code>status</code> 属性直接更改，在调用 <code>redirct</code> 方法之前或之后都可以。</p>
<h4 id="attachment"><a href="#attachment" class="headerlink" title="attachment"></a>attachment</h4><p> 调用 <code>attachment</code> 方法，会设置 <code>Content-Disposition</code> 响应头，浏览器接收到该响应头之后，会对前端返回的内容进行下载。<code>attachment</code> 方法接收一个文件名作为参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">"./girl.jpg"</span>);</span><br><span class="line">    ctx.attachment(<span class="string">"girl.jpg"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当我们使用浏览器访问 <code>http://localhost:3000/</code> 时，会弹出下面的窗口提示我们进行下载</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210314194752.png" style="zoom:50%;" />

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>我们应当根据不同的请求路径，产生不同的响应，而路由正是定义这些行为的。我们通过对 <code>url、path、method</code> 等属性进行判断，然后返回不同的响应</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.routers = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当请求以 method 方法访问 path 路径时，添加对应的处理函数到 routers</span></span><br><span class="line">    addHandle(method, path, handle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.routers[path] = <span class="keyword">this</span>.routers[path] || &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> handles = <span class="keyword">this</span>.routers[path][method] = <span class="keyword">this</span>.routers[path][method] || [];</span><br><span class="line">        handles.push(handle);</span><br><span class="line">        <span class="comment">// 可链式执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>(path, handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addHandle(<span class="string">"get"</span>, path, handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    post(path, handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addHandle(<span class="string">"post"</span>, path, handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将多个处理函数串联起来</span></span><br><span class="line">    compose(middleware = []) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">                <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个中间件</span></span><br><span class="line">    routes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 找到匹配的路径</span></span><br><span class="line">            <span class="keyword">let</span> matchedPath = <span class="keyword">this</span>.routers[ctx.path];</span><br><span class="line">            <span class="comment">// 找到对应方法的处理函数</span></span><br><span class="line">            <span class="keyword">const</span> handles = matchedPath[ctx.method.toLowerCase()] || [];</span><br><span class="line">            <span class="comment">// 将处理函数串联起来，然后执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.compose(handles)(ctx, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Router;</span><br></pre></td></tr></table></figure>

<p>上面我们写了一个 <code>Router</code> 类，如下使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">userRouter.get(<span class="string">'/user/name'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的程序表示，当请求以 <code>get</code> 方法访问 <code>/user/name</code> 路径时，便执行对应的处理函数，并且可以为同一路径添加多个处理函数，会根据添加的顺序依次执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">userRouter.get(<span class="string">'/user/name'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;).get(<span class="string">'/user/name'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.type = <span class="string">"html"</span>;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用时，调用 <code>Router</code> 实例的 <code>routes</code> 方法就会返回一个中间件，通过 <code>app.use</code> 将该中间件插入即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'./Router'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userRouter = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当以 get 方法访问 /user/name 路径时，返回 Alice</span></span><br><span class="line">userRouter.get(<span class="string">'/user/name'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当以 post 方法访问 /user/name 路径时，将请求参数返回</span></span><br><span class="line">userRouter.post(<span class="string">'/user/name'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> req = ctx.req;</span><br><span class="line">    <span class="keyword">const</span> postData = <span class="keyword">await</span> getPostData(req);</span><br><span class="line">    ctx.body = postData;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 post 请求参数的函数</span></span><br><span class="line"><span class="keyword">const</span> getPostData = <span class="keyword">async</span> req =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> buffers = [];</span><br><span class="line">        req.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">            buffers.push(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">            resolve(queryString.parse(data));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 使用路由中间件</span></span><br><span class="line">app.use(userRouter.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>发送 <code>get</code> 请求</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315153816.png" style="zoom:50%;" />

<p>发送 <code>post</code> 请求</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315153900.png" style="zoom:50%;" />

<p>上面是使用了我们自己写了 <code>Router</code> 类，支持的功能不多，我们可以使用官网提供的 <code>Router</code> 插件，首先进行下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @koa&#x2F;router --save</span><br></pre></td></tr></table></figure>

<p>然后引入 <code>Router</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'@koa/router'</span>);</span><br></pre></td></tr></table></figure>

<p>使用方法同上一样。</p>
<h2 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h2><p>通过 <code>ctx.query</code> 可以获得 <code>get</code> 请求的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> query = ctx.query;</span><br><span class="line">    ctx.body = query;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315155534.png" style="zoom:50%;" />

<p>获取 <code>post</code> 请求的数据需要手动解析请求体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getPostData = <span class="keyword">async</span> req =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> buffers = [];</span><br><span class="line">        req.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">            buffers.push(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">            <span class="comment">// 借助了 Node 提供的核心模块 querystring 解析请求参数为对象</span></span><br><span class="line">            resolve(queryString.parse(data));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> postData = <span class="keyword">await</span> getPostData(ctx.req);</span><br><span class="line">    ctx.body = postData;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315155847.png" style="zoom:50%;" />

<p>除了手动解析参数外，我们还可以借助于中间件，这里我们使用 <code>koa-bodyparser</code>，首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i koa-bodyparser --save</span><br></pre></td></tr></table></figure>

<p><code>koa-bodyparser</code> 解析请求参数之后会将请求参数放在 <code>ctx.request.body</code> 上面，所以我们可以访问 <code>ctx.request.body</code> 来获取 <code>post</code> 请求参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = ctx.request.body;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315160802.png" style="zoom:50%;" />

<h2 id="暴露静态资源"><a href="#暴露静态资源" class="headerlink" title="暴露静态资源"></a>暴露静态资源</h2><p>对于我们在网页里面引用的 JavaScript、CSS、图片等静态资源文件，它也会走我们的路由，所以我们也要为它们写处理函数，其实就是直接将文件返回。我们首先看如果不做处理的情况，首先有这个一个 HTML 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/public/css/index.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>HTML</code>  文件中引用了一个 <code>CSS</code> 文件，<code>CSS</code> 文件内容如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是设置了字体的颜色和大小，浏览器会向服务器请求 <code>CSS</code> 文件，但是我们服务器没有对这种静态资源的请求做处理，所以并不能返回 <code>CSS</code> 文件，服务器端代码如下，只是直接返回了一个 <code>HTML</code> 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'@koa/router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.type = <span class="string">'html'</span>;</span><br><span class="line">    ctx.body = fs.createReadStream(path.resolve(<span class="string">'public/index.html'</span>));</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们使用浏览器访问</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315201940.png" style="zoom:50%;" />

<p>字体的颜色和大小没有变化，说明没有加载到 <code>CSS</code> 文件，并且控制台也显示文件资源加载失败。现在我们使用一个中间件 <code>koa-static</code> 来处理静态资源，首先进行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i koa-static --save</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'@koa/router'</span>);</span><br><span class="line"><span class="comment">// 使用 koa-static 中间件</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.type = <span class="string">'html'</span>;</span><br><span class="line">    ctx.body = fs.createReadStream(path.resolve(<span class="string">'public/index.html'</span>));</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前目录当做静态服务的根目录</span></span><br><span class="line">app.use(server(path.resolve(<span class="string">'.'</span>)));</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>再次访问</p>
<img src="https://cdn.jsdelivr.net/gh/LastKnightCoder/ImgHosting2/20210315203247.png" style="zoom:50%;" />

<p>样式生效了，说明 <code>koa-static</code> 起作用了。上面我们使用当前目录作为静态资源的根目录，如果我们使用 <code>public</code> 目录作为静态资源的根目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(server(path.resolve(<span class="string">'public'</span>)));</span><br></pre></td></tr></table></figure>

<p>那么引用 <code>CSS</code> 文件的方式需要修改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/index.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>本节研究如何处理上传文件，前端上传文件的代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> upload = <span class="built_in">document</span>.getElementById(<span class="string">"upload"</span>);</span></span><br><span class="line"><span class="actionscript">        upload.addEventListener(<span class="string">"change"</span>, event =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 获得上传的文件</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> file = event.target.files[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 添加到 FormData 对象中</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> data = <span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="actionscript">            data.append(<span class="string">"file"</span>, file);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 上传文件</span></span></span><br><span class="line"><span class="actionscript">            fetch(<span class="string">'http://localhost:3000/upload'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">                method: <span class="string">'post'</span>,</span></span><br><span class="line">                body: data,</span><br><span class="line"><span class="actionscript">                <span class="comment">// 设置上传的文件类型为 multipart/form-data，表示上传的为文件</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// headers: &#123;</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">//     'Content-Type': 'multipart/form-data'</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(res);</span></span><br><span class="line"><span class="javascript">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(err);</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里记录一个坑，在使用 fetch 上传文件时，不要手动设置 <code>&#39;Content-Type&#39;: &#39;multipart/form-data&#39;</code>，因为还需要设置分界字符，这个分界字符是随机生成，所以 <code>Content-Type</code> 头部就由 <code>fetch</code> 自己去生成，否则后端的一些中间件不能解析内容。</p>
</blockquote>
<p>为了解析上传的数据，我们首先需要了解 <code>multipart/form-data</code> 的数据格式。这里我们假设上传了两个字段，第一个字段的名称为 <code>file</code>，它是一个文本文件，其中的内容为 <code>Hello World!</code>；第二个字段为 <code>name</code>，它的值为 <code>Alice</code>。那么它们形成的请求体的数据如下</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">------WebKitFormBoundaryHdpL0f6HyVyJAFok</span></span><br><span class="line">Content-Disposition: form-data; <span class="type">name</span>="file"; filename="hello.txt"</span><br><span class="line">Content-<span class="keyword">Type</span>: <span class="type">text</span>/plain</span><br><span class="line"></span><br><span class="line">Hello World!</span><br><span class="line"><span class="comment">------WebKitFormBoundaryHdpL0f6HyVyJAFok</span></span><br><span class="line">Content-Disposition: form-data; <span class="type">name</span>="name"</span><br><span class="line"></span><br><span class="line">Alice</span><br><span class="line"><span class="comment">------WebKitFormBoundaryHdpL0f6HyVyJAFok--</span></span><br></pre></td></tr></table></figure>

<p>每个字段之间都会使用一个分界线分开，这个分界线的组成是 <code>------WebKitFormBoundary</code> 加上一个随机的 16 位哈希，在每个字段中也分为两部分，第一部分是字段有关的请求头，例如 <code>Content-Type</code>、<code>Content-Disposition</code> ，第二部分就是字段的具体内容，两部分使用空行进行隔开。</p>
<blockquote>
<p>我尝试过自己解析数据，但是花费数个小时，还是没有成功，因此放弃，感兴趣可以尝试自己解析！</p>
</blockquote>
<p>这里介绍使用中间件 <code>koa-body</code> 来获得上传的文件首先进行下载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i koa-body --save</span><br></pre></td></tr></table></figure>

<p>然后使用便可以使用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);</span><br><span class="line">app.use(koaBody(&#123;</span><br><span class="line">    multipart: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p><code>koa-body</code> 会将上传的文件设置在 <code>ctx.request.files</code> 属性，我们通过 <code>files.file</code> 属性来获得上传的文件，如果上传的是一个文件，那么它就是一个 <code>File</code> 对象，如果上传多个文件，那么它就是一个由 <code>File</code> 对象组成的数组；其他表单请求字段设置在 <code>ctx.request.body</code> 属性上。</p>
<p><code>koa-body</code> 会先将文件保存在 <code>C:\\Users\\User\\AppData\\Local\\Temp\\</code> 目录下，具体的路径可以由 <code>File</code> 对象的 <code>path</code> 属性获得，通过 <code>name</code> 属性可以获得上传的文件名，通过 <code>type</code> 属性可得知上传的文件类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'@koa/router'</span>);</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line">router.post(<span class="string">'/upload'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> file = ctx.request.files.file;</span><br><span class="line">    <span class="comment">// 将接收到的文件保存在当前目录</span></span><br><span class="line">    fs.createReadStream(file.path).pipe(fs.createWriteStream(path.resolve(file.name)));</span><br><span class="line">    ctx.body = <span class="string">"上传成功"</span>;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(koaBody(&#123;</span><br><span class="line">    multipart: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://koajs.com/" target="_blank" rel="noopener">Koa官网</a></li>
<li><a href="https://chenshenhai.com/koa2-note" target="_blank" rel="noopener">Koa进阶学习笔记</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53609310" target="_blank" rel="noopener">玩转Koa-核心原理分析</a></li>
<li><a href="https://segmentfault.com/a/1190000038182946" target="_blank" rel="noopener">手写@koa/router源码</a></li>
<li><a href="https://www.jianshu.com/p/34d0e1a5ac70" target="_blank" rel="noopener">NodeJs koa2实现文件上传</a></li>
<li><a href="https://github.com/github/fetch/issues/505" target="_blank" rel="noopener">Error when POST file multipart/form-data #505</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34291688" target="_blank" rel="noopener">踩坑篇–使用 fetch 上传文件</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-03-15T16:00:00.000Z" itemprop="dateUpdated">2021-03-16 00:00:00</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://lastknightcoder.github.io/lastknightcoder">
            <img src="https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" alt="熊滔">
            熊滔
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.github.io/lastknightcoder/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.github.io/lastknightcoder/tags/Koa/" rel="tag">Koa</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.github.io/lastknightcoder/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/&title=《Node.js之Koa》 — Coder&pic=https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/&title=《Node.js之Koa》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Node.js之Koa》 — Coder&url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/&via=https://lastknightcoder.github.io/lastknightcoder" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="https://lastknightcoder.github.io/lastknightcoder/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">罗马数字与数字的转换</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="https://lastknightcoder.github.io/lastknightcoder/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">盛水最多的容器</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'lastknightcoder';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
</section>



















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://lastknightcoder.github.io/lastknightcoder/img/wechatpay.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://lastknightcoder.github.io/lastknightcoder/img/wechatpay.png" data-alipay="https://lastknightcoder.github.io/lastknightcoder/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="https://lastknightcoder.github.io/lastknightcoder/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>熊滔 &copy; 2019 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/&title=《Node.js之Koa》 — Coder&pic=https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/&title=《Node.js之Koa》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Node.js之Koa》 — Coder&url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/&via=https://lastknightcoder.github.io/lastknightcoder" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BKoa/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACrElEQVR42u3aQY7jMAwEQP//07vXARajNEkx60P5FMSJw1IAS27qeeLjz4/j5zvnT/77+fN1fvvM+RcvHHh4eHiD0pPiklLOpSdn86t9qAQPDw9vjZdcrnq2UMS4nl/fx8PDw3sZLyn3DN5Y0OPh4eG9jZdjcmoyBHh4eHhv41UvPYlxe8O3nrXg4eHhdXKA6Eb/htcr/T08PDy8cVd9csPtjfR500C5Wjw8PLwFXjVcqG4USLYd3I198fDw8P4XLw8mzpNBsuHgDOgFu3h4eHh7vMmmqFuN/+q0kQ83Hh4e3gZvezk7CTLyGsqhCR4eHt4lXr78vdU2y2/uyWK9nCvj4eHhtXj5ttH8lj1f8vYW31F/Dw8PD2/MSzDVW3MywVTDhV6IjIeHh7fBy7+WD0H5xl0MF5ImGR4eHt53eEmLK48M5vHrSnSLh4eHd6npVQ0XNlatk5jjw9+Ah4eH9xVetRGVlJtHCb1JotwGw8PDw2vx8h/Ll8jVK1QHqPD34OHh4S3zqhND0qaqFp1PCVGMgoeHh7fAqxaat/l7pedDUNjogIeHh7fA6zXAehFDHuY+xaPwLTw8PLwBr9rgrwYQ1eJ67A9hBB4eHt5VXg+TL6zPS+fJxoXkanh4eHh7vPzhvxqh5rDeJJFs1cLDw8Pb4yWRa37rz4ODPJbNp6JngsHDw8Mr8qpxwOTsvMFWnhjw8PDwrvIm7a5qO7+6TH8mBx4eHt5VXu/xvrf8ncQQzbN4eHh431jfNnvuvdgin2zublPAw8PDm/PyySBvd+VTy+RbyQMAHh4e3h6vuhX1VixbbmhVAws8PDy8F/C2W1y3lul4eHh47+HNF83VJtzkynh4eHh7vF65SaF566s3VUQTAx4eHt5V3uSBv7eBoFrKfDjw8PDwLvH+AogfK/CbcuV7AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://lastknightcoder.github.io/lastknightcoder/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
