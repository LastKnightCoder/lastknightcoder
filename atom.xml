<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coder</title>
  
  
  <link href="https://lastknightcoder.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://lastknightcoder.gitee.io/"/>
  <updated>2020-06-10T16:00:00.000Z</updated>
  <id>https://lastknightcoder.gitee.io/</id>
  
  <author>
    <name>熊滔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://lastknightcoder.gitee.io/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://lastknightcoder.gitee.io/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-06-10T16:00:00.000Z</published>
    <updated>2020-06-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：请实现一个函数，输入一个整数，输出该数二进制表示中 $1$ 的个数。例如，把 $9$ 表示成二进制是 $1001$，有 $2$ 位是 $1$。因此，如果输入 $9$，则该函数输出 $2$。</p></blockquote><p>我们通过将数字与 $1$ 相与，即可知道数字的二进制的最后一位是否为 $1$，我们只要逐渐的将数字进行右移，即可统计出数字中 $1$ 的数目，所以会写下这样的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numbersOfOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码有一个问题，那就是如果输入的整数为负数呢? 根据负数的表示原则，它的首位是 $1$ 来表示数字的正负性，在右移的过程中，首位会进行补 $1$ 以表示它的符号还是负的，这个时候统计出的数字就是错误的了，并且会造成上面代码的死循环，如下以 $8$ 位表示的 $-7$ 为例</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200610234544.png" width="70%"/><p>为了解决负数引起的问题，我们可以反其道而行之，让 $1$ 进行左移，然后与数字相与，同样也可以统计出数字 $1$ 的个数，所以修改代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numbersOfOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现统计负数中 $1$ 的个数的结果与我们想象的不符，比如我们统计 $-7$ 的个数，结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(numbersOfOne(-<span class="number">7</span>)); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是 $30$ 而不是 $4$，难道是我们的算法错了，其实不是，而是计算机存储数字是以其补码进行存储的，对于正数来说，它的补码是它本身，而对于负数，则是将除符号位进行取反，然后加 $1$，所以 $-7$ 的补码为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200611000157.png" width="80%"/><p>上面计算出一个数字二进制表示的 $1$ 的个数需要进行 $32$ 次循环(对于 <code>int</code> 类型的数据)，我们可以进一步对算法进行改进，使得二进制中有几个 $1$ 则进行几次循环。为了理解下面讲的算法，我们来看一下将一个数字减去 $1$ 它的二进制会发生什么变化? </p><p>先说结论，假设数字二进制最右边的 $1$ 在第 $m$ 位，即第 $m$ 位后面的位全是 $0$，在减去 $1$ 之后，第 $m$ 位的 $1$ 变成 $0$，后面的 $0$ 全部变为 $1$，而第 $m$ 位前面的数字保持不变，以 $8$ 位表示的 $10$ 为例</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200611001514.png" width="60%"/><p>那么我们将数字 $n$ 与 $n - 1$ 进行相与会得到什么，因为 $n - 1$ 第 $m$ 位前面的数字不变，所以 $n - 1$ 的第 $m$ 位以前的数字与 $n$ 相同，所以 $n , &amp; , n - 1$ 得到的第 $m$ 位以前的二进制是不变的，而 $n - 1$ 第 $m$ 位变成 $0$，以及第 $m$ 位以后的 $0$ 变为 $1$，所以 $n , &amp; , n - 1$ 得到的第 $m$ 位及第 $m$ 位以后的二进制是 $0$，所以 $n , &amp; , n - 1$ 的效果就是将数字 $n$ 中最右边的 $1$ 给去除了</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200611002519.png" width="50%"/><p>所以我们就可以写出这样的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numbersOfOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环会去除一个 $1$，所以二进制中有几个 $1$，便会进行几次循环。</p><blockquote><p><strong>扩展：</strong></p><ul><li>用一条语句判断一个整数是不是 $2$ 的整数次方。一个整数如果是 $2$ 的整数次方，那么它的二进制表示中有且只有一位是 $1$，而其他所有位都是 $0$。所以我们统计该数二进制中 $1$ 的个数，如果是一个，那么就是 $2$ 的整数次方。</li><li>输入两个整数 $m$ 和 $n$，计算需要改变 $m$ 的二进制表示中的多少位才能得到 $n$。比如 $10$ 的二进制表示为 $1010$，$13$ 的二进制表示为 $1101$，需要改变 $1010$ 中的 $3$ 位才能得到 $1101$。我们可以分两步解决这个问题，首先将这两个数进行异或，这样 $m$ 和 $n$ 二进制不同的位会得到 $1$，相同的位是 $0$，我们只要统计异或后二进制中 $1$ 的个数，即可得到需要改变的位数。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：请实现一个函数，输入一个整数，输出该数二进制表示中 $1$ 的个数。例如，把 $9$ 表示成二进制是 $1001$，有 $2$ 位是 $1$。因此，如果输入 $9$，则该函数输出 $2$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通过将
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剪绳子</title>
    <link href="https://lastknightcoder.gitee.io/%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://lastknightcoder.gitee.io/%E5%89%AA%E7%BB%B3%E5%AD%90/</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2020-06-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：给你一根长度为 $n$ 的绳子，请把绳子剪成 $m$ 段($m、n$ 都是整数，$m &gt; 1, n &gt; 1$)，每段绳子的长度记为 $k[0], k[1], …, k[m]$。请问 $k[0] \times k[1] \times … \times k[m]$ 可能的最大乘积是多少? 例如当绳子的长度是 $8$ 时，我们把它剪成长度分别为 $2、3、3$ 的三段，此时得到的最大乘积是 $18$。</p></blockquote><p>我们定义长度为 $n$ 的绳子剪成若干段后，所能得到的最大长度为 $f(n)$。如果我们将绳子一段剪为长度为 $i$ 和 $n - i$，那么这时长度为 $n$ 能够被剪成的乘积是：长度为 $i$ 能够剪成的乘积 × 长度为 $n-i$ 能够剪成的乘积，因为 $f(i)$ 和 $f(n - i)$ 分别表示长度为 $i$ 和 $n - i$ 能够剪成的乘积最大值，所以这时长度为 $n$ 能够被剪成的乘积的最大值是 $f(i) \times f(n - i)$，所以 $f(n) = \max{f(i) \times f(n - i)}(i = 1, 2, …, n - 1)$。所以我们只要遍历 $i$，找出所有 $f(i) \times f(n - i)$ 中的最大值，这个值便是 $f(n)$。</p><p>为了求出 $f(n)$，我们还需要知道 $f(2), f(3)$ 这些初始值。当长度为 $2$ 时，只能剪成两段都为 $1$ 的两段，这时乘积的长度为 $f(2) = 1 \times 1 = 1$；当长度为 $3$ 时，可以被剪成 $1$ 和 $2$ 的两段或者三段为 $1$ 的三段，因为 $1 \times 2 &gt; 1 \times 1 \times 1$，所以 $f(3) = 2$。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 results 数组保存 f(2) f(3) ... f(n)</span></span><br><span class="line">        <span class="comment">// results[n] = f(n)</span></span><br><span class="line">        <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        results[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// results[1] = 1 而不是 0 因为已经被切成两段，所以这里可以不继续切</span></span><br><span class="line">        results[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// results[2] = 2 而不是 1 也是同理</span></span><br><span class="line">        results[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// results[3] = 3 而不是 2 也是同理</span></span><br><span class="line">        results[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历所有 j，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> result = results[j] * results[i - j];</span><br><span class="line">                <span class="keyword">if</span> (max &lt; result) &#123;</span><br><span class="line">                    max = result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            results[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cut(<span class="number">8</span>)); <span class="comment">// 18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><p>我们将一个大问题切分为多个小问题，并且将小问题的解组合起来得到大问题的解，这样的解法我们称之为动态规划。如果题目是求一个问题的最优解(通常是最大值或最小值)，并且该问题可以被分为若干个子问题，子问题之间还有重叠的更小的问题，那么就考虑可以使用动态规划的解法。</p><p>在使用动态规划求解问题最优解时，为了防止多次重复计算子问题，我们一般会先将子问题的最优解存储下来，再根据此来计算问题的最优解。我们在之前的斐波那契数列的求解过程中，便是将原来的前两项值先保存下来，然后计算后一项的值；在上面的问题中，我们也是使用 <code>results</code> 数字将子问题的最优解保存下来，然后据此计算最优解。</p><p>所以在使用动态规划解决问题时，我们往往从上往下分析问题，找到问题最优解与子问题最优解之间的关系，然后从下往上求解问题，存储子问题的最优解，以防产生重复的计算。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：给你一根长度为 $n$ 的绳子，请把绳子剪成 $m$ 段($m、n$ 都是整数，$m &amp;gt; 1, n &amp;gt; 1$)，每段绳子的长度记为 $k[0], k[1], …, k[m]$。请问 $k[0] \times k[1] \times
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="动态规划" scheme="https://lastknightcoder.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>回溯法</title>
    <link href="https://lastknightcoder.gitee.io/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>https://lastknightcoder.gitee.io/%E5%9B%9E%E6%BA%AF%E6%B3%95/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2020-06-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在解决算法问题时，我们的第一个想法可能就是暴力法，比如暴力枚举所有可能的结果，但是暴力法的效率太低了，有时候达不到我们的要求。在这里我们介绍一种比暴力法稍微高级一点的算法，回溯法。回溯法是在多个可能的分支中选择一支，如果满足条件则继续查找，如果不满足结果，则回溯到上一个节点。</p><p>假如我们有下图所示结构</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200609112837.png" width="50%"/><p>我们想在该树形结构中找到 <code>&quot;abc&quot;</code> 的路径，过程如下所示</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200609120529.png" width="80%"/><blockquote><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p></blockquote><p>这是一个可以使用回溯法解决的问题。首先判断矩阵的某个位置是否为字符串的第 $i$ 个字符，如果是继续向四周查找第 $i+1$ 个字符，并以此类推，直到找到最后一个字符；如果不是第 $i$ 个字符，则回溯到上一个位置去查找第 $i$ 个字符。因为已经经过了的路径不能重复经过，所以我们使用一个布尔矩阵 <code>visited</code> 来表示是否访问过矩阵中的某个位置。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line">    <span class="comment">// matrix：字符矩阵</span></span><br><span class="line">    <span class="comment">// str：要查找的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对输入参数合法性的判断</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得矩阵的行数和列数</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个布尔矩阵，用以确定矩阵某个元素已经被访问过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] vistied = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="comment">// 初始化布尔矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; columns; column++) &#123;</span><br><span class="line">                vistied[row][column] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pathLength表示以匹配的字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历矩阵进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; columns; column++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathCore(matrix, row, column, str, pathLength, vistied)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断位置 (row, column) 是否有第 pathLength 个字符后的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>[][] martix, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">char</span>[] str, <span class="keyword">int</span> pathLength, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pathLength 表示以匹配的字符的个数，如果个数大于等于(其实这里等于就可以)字符串的长度，则匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (pathLength &gt;= str.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续是否匹配</span></span><br><span class="line">        <span class="keyword">boolean</span> hasPath = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该位置匹配，且该位置在矩阵内</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; martix.length &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; martix[<span class="number">0</span>].length &amp;&amp; martix[row][column] == str[pathLength] &amp;&amp; !visited[row][column]) &#123;</span><br><span class="line">            <span class="comment">// 匹配长度+1</span></span><br><span class="line">            pathLength++;</span><br><span class="line">            <span class="comment">// 设置为已访问</span></span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 在四周进行匹配</span></span><br><span class="line">            hasPath = hasPathCore(martix, row, column - <span class="number">1</span>, str, pathLength, visited)</span><br><span class="line">                    || hasPathCore(martix, row - <span class="number">1</span>, column, str, pathLength, visited)</span><br><span class="line">                    || hasPathCore(martix, row + <span class="number">1</span>, column, str, pathLength, visited)</span><br><span class="line">                    || hasPathCore(martix, row, column + <span class="number">1</span>, str, pathLength, visited);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果四周的路径都不匹配，进行回溯，匹配的长度和已访问设置为false</span></span><br><span class="line">            <span class="keyword">if</span> (!hasPath) &#123;</span><br><span class="line">                pathLength--;</span><br><span class="line">                visited[row][column] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'t'</span>, <span class="string">'g'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'c'</span>, <span class="string">'f'</span>, <span class="string">'c'</span>, <span class="string">'s'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'j'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'h'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123;<span class="string">'t'</span>, <span class="string">'c'</span>, <span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'j'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(hasPath(matrix, str));  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目：地上有一个 $m$ 行 $n$ 列的方格。一个机器人从坐标 $(0, 0)$ 的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。例如当 $k$ 为 $18$ 时，机器人能进入 $(35, 37)$，因为 $3 + 5 + 3 + 7 = 18$。但它不能进入方格 $(35, 38)$，因为 $3 + 5 + 3 + 8 = 19$。请问该机器人能够到达多少个格子?</p></blockquote><p>这道题目和上道题很相似，同样可以使用回溯法进行解决。当机器人进入 $(i,j)$ 的格子时，判断它是否能进入，如果能进入，则继续判断相邻的四个格子是否能进入。同理，我们也会用一个布尔矩阵来标记是否访问过该矩阵，以防重复统计，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotCount</span> </span>&#123;</span><br><span class="line">    <span class="comment">// threshold：阈值，即题目中的 k 值</span></span><br><span class="line">    <span class="comment">// rows, columns 矩阵的行数和列数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输入参数合法性验证</span></span><br><span class="line">        <span class="keyword">if</span> (threshold &lt;= <span class="number">0</span> || rows &lt;= <span class="number">0</span> || columns &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔矩阵</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔矩阵初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; columns; column++) &#123;</span><br><span class="line">                visited[row][column] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从坐标 (0, 0) 开始移动</span></span><br><span class="line">        <span class="keyword">return</span> movingCountCore(threshold, rows, columns, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从坐标 (row, column) 开始移动能够访问的格子数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果能进入坐标 (row, column)</span></span><br><span class="line">        <span class="keyword">if</span> (check(threshold, rows, columns, row, column, visited)) &#123;</span><br><span class="line">            <span class="comment">// 标记以访问</span></span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 进入相邻的四个格子</span></span><br><span class="line">            count = <span class="number">1</span> + movingCountCore(threshold, rows, columns, row - <span class="number">1</span>, column, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, columns, row, column - <span class="number">1</span>, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, columns, row + <span class="number">1</span>, column, visited)</span><br><span class="line">                    + movingCountCore(threshold, rows, columns, row, column + <span class="number">1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否能进入坐标 (row, column)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows</span><br><span class="line">                &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">                &amp;&amp; (getDigitalNumber(row) + getDigitalNumber(column)) &lt;= threshold</span><br><span class="line">                &amp;&amp; !visited[row][column]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得数字 n 的数位和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigitalNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += number % <span class="number">10</span>;</span><br><span class="line">            number = number / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(movingCount(<span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)); <span class="comment">// 309</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><ul><li>通常在二维矩阵中查找路径这类问题都可以使用回溯法解决。</li><li>通常物体或人在二维方格运动这类问题都可以使用回溯法解决。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在解决算法问题时，我们的第一个想法可能就是暴力法，比如暴力枚举所有可能的结果，但是暴力法的效率太低了，有时候达不到我们的要求。在这里我们介绍一种比暴力法稍微高级一点的算法，回溯法。回溯法是在多个可能的分支中选择一支，如果满足条件则继续查找，如果不满足结果，则回溯到上一个节点
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="https://lastknightcoder.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://lastknightcoder.gitee.io/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://lastknightcoder.gitee.io/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2020-06-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>{3, 4, 5, 1, 2}</code> 为 <code>{1, 2, 3, 4, 5}</code> 的一个旋转，该数组的最小值为 <code>1</code>。</p></blockquote><p>最简单的方法就是直接扫描一遍数组，找到数组中最小的数字，这样做它的时间复杂度是 $O(n)$，并且没有利用数组原来是已排好序的信息，我们要利用这个信息，以进一步降低时间复杂度。我们分析这个旋转的数组，可以将数组分为两部分：</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200608091907.png" width="35%"/><p>观察到最小值在第一部分和第二部分的分界处，且在第二部分，另外可以观察到，由于第二部分是数组的前半部分搬到末尾的，所以第二部分中的值是小于等于第一部分中的值。</p><p>对于顺序查找问题，我们可以使用二分查找法。我们使用两个指针分别指向第一部分的开头和第二部分的结尾，然后将这两个值与数组中间的值进行比较，如果中间的值比第一部分的开头大，说明中间的值还在第一部分，我们将第一部分的开头指针移动到中间；同理，如果中间值比第二部分末尾的值小，则中间的值还在第二部分，则将第二部分末尾的指针移动到中间。以此类推，直到两个指针相差一个距离，则到了分界处，取第二部分指针所对应的值，该值即为最小值。图示如下：</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200608094725.png" width="70%"/><p>但是上面的方法却又一个特例，即中间值与两个指针所指的值相等时，则无法知道如何移动指针</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200608095413.png" width="80%"/><p>上面两个数组都是 <code>{0, 1, 1, 1, 1}</code> 的旋转，并且中间的值与两个指针指向的值相同，但是中间值一个在第一部分，一个在第二部分，所以我们这时是无法知道如何移动指针，碰到这种情况，我们只能顺序查找了，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Min</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果 start 的值小于 end，说明数组没有进行旋转，则返回数组的第一个值，这就是 mid = 0 的原因</span></span><br><span class="line">        <span class="keyword">while</span> (arr[start] &gt;= arr[end]) &#123;</span><br><span class="line">            <span class="comment">// 如果两个指针相差 1 个距离，则返回第二个指针指向的值</span></span><br><span class="line">            <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 如何中间的值和两个指针的值相等，则进行顺序查找</span></span><br><span class="line">            <span class="keyword">if</span> (arr[start] == arr[end] &amp;&amp; arr[start] == arr[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> minInOrder(arr, start, end);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果中间的值比 start 的值大，则将 start 移至中间</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt;= arr[start]) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; arr[end]) &#123;</span><br><span class="line">                <span class="comment">// 否则中间的值比 end 小，则将 end 移至中间</span></span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺序查找的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minInOrder</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minResult = arr[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minResult &gt; arr[i]) &#123;</span><br><span class="line">                minResult = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(min(arr)); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 &lt;code&gt;{3, 4, 5, 1, 2}&lt;/code&gt; 为 &lt;code&gt;{1, 2, 3, 4, 5}&lt;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://lastknightcoder.gitee.io/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://lastknightcoder.gitee.io/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-06-03T16:00:00.000Z</published>
    <updated>2020-06-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>栈的特点是后进先出，队列的特点是先进先出，如何使用两个栈来实现队列的效果呢? 假设当添加数据时，我们把数据添加到第一个栈中，我们称之为 <code>stack1</code>，例如连续添加 <code>1, 2, 3, 4</code> 四个数据，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200604102923.png" width="60%"/><p>我们添加数据时向 <code>stack1</code> 添加数据，而取出数据时从 <code>stack2</code> 取出数据，我们再次把 <code>stack1</code> 中的数据依次放入 <code>stack2</code> 中，经过两次入栈的操作，两个后进先出变成了先进先出</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200604103625.png" width="90%"/><p>现在我们入队和出队的规则应该如下，即入队时将数据压入 <code>stack1</code> 中，出队时从 <code>stack2</code> 中弹出，现在的问题是什么时候将 <code>stack1</code> 中的数据弹出压入到 <code>stack2</code> 中，其实很简单，出队时将 <code>stack2</code> 中的数据弹出，直到 <code>stack2</code> 为空，这时将 <code>stack1</code> 中的数据弹出压入到 <code>stack2</code> 中，然后从 <code>stack2</code> 弹出数据。下面演示一个完整的例子</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200604110658.png" width="80%"/><p>完整的代码示例如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加数据从 stack1 添加</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stack2 不为空时 从stack2 弹出数据</span></span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// stack2 为空时 且stack1 不为空时，将stack1的数据弹出压入到stack2中</span></span><br><span class="line">            <span class="keyword">if</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                    stack2.push(stack1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 然后从 stack2 弹出数据</span></span><br><span class="line">                <span class="keyword">return</span> stack2.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// stack1 和 stack2 都为空，说明队列为空 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is Empty"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展：那如何使用两个队列实现一个栈呢?</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 &lt;code&gt;appendTail&lt;/code&gt; 和 &lt;code&gt;deleteHead&lt;/code&gt;，分别完成在队列尾部插入节点和在队列头部删除节点的功能。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>offsetX,pageX,clientX和screenX</title>
    <link href="https://lastknightcoder.gitee.io/offsetX,pageX,clientX,screenX/"/>
    <id>https://lastknightcoder.gitee.io/offsetX,pageX,clientX,screenX/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用的 <code>JavaScript</code> 的过程中，对 <code>offset</code>，<code>page</code>，<code>client</code> 等等所表示的距离一直不是很清楚，现趁有时间系统的学习了一下。上面所述的 <code>offsetX</code>，<code>pageX</code> 等等都是事件对象 <code>event</code> 的属性，当有鼠标事件触发时，可以获得相应的事件对象，该对象中包含着鼠标的各种距离，现总结如下</p><ul><li><code>offsetX</code>：离触发事件元素左边的距离</li><li><code>pageX</code>：离页面左边的距离</li><li><code>clientX</code>：离浏览器左边的距离</li><li><code>screenX</code>：离电脑显示器左边的距离</li></ul><p>现在就演示一下，假设有下面的页面结构</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200603101028.png" width="80%"/><p>上图已经基本可以明白 <code>offsetX</code> 和 <code>clientX</code>的大小，如果没有横向的滚动条的话，<code>pageX</code> 与 <code>clientX</code> 的大小是一样的。如果有滚动条的话，那么 <code>pageX</code> 的距离一般是大于 <code>clientX</code> 的距离的，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200603102818.png"/><p>上图应该已经阐释了 <code>pageX</code> 与 <code>clientX</code> 的不同，那么只剩最后一个 <code>screenX</code>，这个也较好理解，就是鼠标位置离电脑显示器左侧的位置，如果浏览器是最大化的话，屏幕的左侧与浏览器的左侧相同，那么 <code>screenX</code> 的大小与 <code>clientX</code> 的大小相同，如果不是最大化，那么</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200603103752.png"/><p>上面介绍的是横向距离，纵向距离也是相似，<code>offsetY</code>，<code>pageY</code>，<code>clientY</code>，<code>screenY</code> 计算将左侧距离换为上侧距离。</p><blockquote><p>这里还可以在扩展一个距离，<code>scrollX</code> 指的是横向滚动的距离，其实通过分析可以发现<br>$$<br>scrollX = pageX - clientX<br>$$<br>如下图所示</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200603104625.png"/></blockquote>]]></content>
    
    <summary type="html">
    
      讲解JavaScript中的各种距离
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="offset client page screen scroll" scheme="https://lastknightcoder.gitee.io/tags/offset-client-page-screen-scroll/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的下一个节点</title>
    <link href="https://lastknightcoder.gitee.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://lastknightcoder.gitee.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2020-06-01T16:00:00.000Z</published>
    <updated>2020-06-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点? 树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。(树的中序遍历指的是先打印左子树，然后打印根节点，最后打印右子树)</p></blockquote><p>我们以下图来分析二叉树的下一个节点</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602192821.png" width="40%"/><p>其中标在节点旁边的数字表示打印的顺序，比如节点 <code>4</code> 旁边标注 <code>1</code>，表示它是第一个被打印的，它的中序遍历的结果如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602192943.png" width="60%"/><p>我们分以下几种情况分析：</p><ol><li><p>该节点有右子树，例如节点 <code>4</code>，节点 <code>3</code>等等，那么它的下一个节点就是它右子树中最左的节点，例如节点 <code>4</code> 右子树最左的节点是 <code>7</code>，所以它的下一个节点是 <code>7</code>，节点 <code>3</code> 的右子树的最左的节点是 <code>8</code>，所以它的下一个节点是 <code>8</code></p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602194252.png" width="60%"/></li><li><p>该节点没有右子树，且父节点存在，并且它是它父节点的左孩子，那么它的父节点就是它的下一个节点，所以节点 <code>5</code> 的下一个节点是节点 <code>3</code></p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602194633.png" width="60%" /></li><li><p>该节点没有右子树，父节点存在，并且也不是它父节点的左孩子，如节点 <code>7</code>，那么它就要一直向上寻找，直到某个节点是它父节点的左孩子，此时父节点就是下一个节点。如节点 <code>7</code> 不是它父节点的左孩子，向上寻找，来到父节点 <code>4</code>，它是它父节点的左孩子，所以节点 <code>4</code> 的父节点 <code>2</code> 是节点 <code>7</code> 的下一个节点</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602195125.png" width="60%"/><p>如果向上寻找，没有找到某个节点是它父节点的左孩子，那么说明没有下一个节点，如节点 <code>6</code> 没有下一个节点</p></li><li><p>没有右子树，且父节点不存在，没有下一个节点</p></li></ol><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二叉树的定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="comment">// 还有一个指向父节点的指针</span></span><br><span class="line">        BinaryTree parent;</span><br><span class="line">        BinaryTree left;</span><br><span class="line">        BinaryTree right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTree <span class="title">findNext</span><span class="params">(BinaryTree node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 如果有右子树，下一个节点是右子树的最左子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BinaryTree next = node.right;</span><br><span class="line">            <span class="keyword">while</span> (next.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next = next.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">            <span class="comment">// 没有右子树，且父节点存在</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果是父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">                <span class="keyword">return</span> node.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 如果不是父节点的左孩子，向上寻找</span></span><br><span class="line">                <span class="keyword">while</span> (node.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 直到找到某节点是它父节点的左孩子，父节点是下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">                        <span class="keyword">return</span> node.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有找到某节点是父节点的左孩子，没有下一个节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 没有右子树，也没有父节点，那么也没有下一个节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点? 树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。(树的中序遍历指的是先打印左子树，然后打印根节点，最后打印右子树)&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://lastknightcoder.gitee.io/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lastknightcoder.gitee.io/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p></blockquote><p>首先通过一个例子看看前序遍历和中序遍历的特点，如下二叉树</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/image-20200602190620264.png" width="50%"/><p>它的前序遍历和中序遍历的结果为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200601125610.png" width="60%"/><p>我们分析一下前序遍历和中序遍历的结构</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200601125638.png" width="60%"/><p>我们的思路是首先根据前序遍历找到根节点的值(第一个)，接着根据找到的根节点的值，在中序遍历中找到根节点的位置，在中序遍历中根节点左边的值是它的左子树的中序遍历，右边是它的右子树的中序遍历，并且进一步可以得到左右子树的长度，根据左右子树的长度，可以在前序遍历中找到左子树的前序遍历和右子树的前序遍历，然后重复上面的过程，又可以找到左右子树的根节点的值以及相应的左右子树，以此类推，即可重建二叉树。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二叉树的定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        BinaryTree left;</span><br><span class="line">        BinaryTree right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preorder 前序遍历的数组</span></span><br><span class="line">    <span class="comment">// inorder 中序遍历的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTree <span class="title">constructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"preorder or inorder is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helpContructBinaryTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据前序遍历数组和中序遍历数组获得根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTree <span class="title">helpContructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历的第一个值就是根节点</span></span><br><span class="line">        BinaryTree root = <span class="keyword">new</span> BinaryTree(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有数组只有一个值</span></span><br><span class="line">        <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inStart == inEnd &amp;&amp; preorder[preStart] == inorder[inStart]) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"wrong input"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得中序遍历根节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> inOrderRoot = inStart;</span><br><span class="line">        <span class="keyword">for</span> (; inOrderRoot &lt;= inEnd; inOrderRoot++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[inOrderRoot] == root.value) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在中序遍历中没有找到根节点 则输入的数组有错误</span></span><br><span class="line">        <span class="keyword">if</span> (inOrderRoot &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"wrong input"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右子树的长度</span></span><br><span class="line">        <span class="keyword">int</span> leftLength = inOrderRoot - inStart;</span><br><span class="line">        <span class="keyword">int</span> rightLength = inEnd - inOrderRoot;</span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据左子树的前序遍历和中序遍历获得左子树的根节点</span></span><br><span class="line">            <span class="comment">// [preStart + 1, preStart + leftLength] 左子树的前序遍历的范围</span></span><br><span class="line">            <span class="comment">// [inStart, inOrderRoot - 1] 左子树的中序遍历的范围</span></span><br><span class="line">            root.left = helpContructBinaryTree(preorder, preStart + <span class="number">1</span>, preStart + leftLength,</span><br><span class="line">                    inorder, inStart, inOrderRoot - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 同左子树</span></span><br><span class="line">            root.right = helpContructBinaryTree(preorder, preStart + leftLength + <span class="number">1</span>, preEnd,</span><br><span class="line">                    inorder, inOrderRoot + <span class="number">1</span>, inEnd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先通过一个例子看看前序遍历和中序遍历的特点，如下二叉树&lt;/p&gt;
&lt;img src=&quot;h
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript入门指南</title>
    <link href="https://lastknightcoder.gitee.io/TypeScript%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://lastknightcoder.gitee.io/TypeScript%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</id>
    <published>2020-05-29T16:00:00.000Z</published>
    <updated>2020-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="TypeScript是什么"><a href="#TypeScript是什么" class="headerlink" title="TypeScript是什么"></a>TypeScript是什么</h3><p><code>TypeScript</code> 是什么? 引用官方的定义</p><blockquote><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p></blockquote><p>简单翻译就是</p><blockquote><p><code>TypeScript</code> 是 <code>JavaScript</code> 的超集，并且可以被编译成 <code>JavaScript</code>。它可以运行在任何浏览器，任何主机，任何操作系统上。并且它是开源的。</p></blockquote><p>看到这里你可能对 <code>TypeScript</code> 还是没有什么感觉，其实在我看来 <code>TypeScript</code> 是对 <code>JavaScript</code> 做了各种限制，这里说的限制并不是贬义的意思，因为 <code>JavaScript</code> 实在是太灵活了，很多的问题只有在运行的时候才会暴露出来，比如对于函数，即使定义时要求传两个参数，但是在使用时却可以传入任意的参数，所以你无法限制使用该函数的用户传入正确的参数，如果碰到不仔细看 <code>API</code> 文档的用户，鬼知道它使用的时候会传入什么，出了问题说不定会甩锅你兼容性做的不好。而 <code>TypeScript</code> 则限制了这一点，在使用时传入的参数必须与定义传入的相同，并且有提示每个参数的作用，用户使用该函数时必须按规定的来。</p><h3 id="TypeScript的优势"><a href="#TypeScript的优势" class="headerlink" title="TypeScript的优势"></a>TypeScript的优势</h3><p>那么 <code>TypeScript</code> 可以为我们带来什么好处：</p><ol><li><p>错误在编译时就可以暴露出来，而不必等到运行时才暴露出来</p><p>如下 <code>js</code> 文件</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529101513.png" width="50%"><p>如上，一不小心将变量名写错了，写成了 <code>MyNane</code>，这种错误是很有可能发生的，但是在很多的时候我们自己却很难发现，只有当我们运行该程序报错的时候，我们才有可能根据报错信息，确定报错的原因；更糟糕的是，如果报错的信息不明确，你几乎无法确定是哪里出现问题，到时候要靠一双肉眼去找出这么一个小小的不同，曾经我就有因为变量名写错的问题，我找了半个小时。但是如果我们使用 <code>TypeScript</code> 的话，这样的问题在编译时就会被发现，如下 <code>ts</code> 文件</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529101914.png" width="70%"/><p>我们可以发现，在 <code>MyNane</code> 下面出现了红色的波浪线，将鼠标放在上面，还会贴心的给出提示。</p></li><li><p>智能提示</p><p>对于现代的程序员来说，代码的智能提示那是能够大大的提高工作效率的，不仅如此，还可以减少出错的概率，如果你手动写出一个对象的方法名，出错的概率可是很高的，特别是对于一些英语不好的同学。但是问题来了，因为 <code>JavaScript</code> 不是静态类型，而是动态类型，所有的变量都使用 <code>var, let, const</code> 声明，而不是像 <code>C</code> 语言这样静态类型语言，不同的类型使用不同的关键字，如 <code>int, char[]</code> 等等。所以这就意味着 <code>JavaScript</code> 这个类型是可变的，一会儿这是字符串类型，一会儿是数字类型，编译器根本在编译阶段根本不能确定你是什么类型，所以无法给出相应类型的特有方法，比如字符串类型的 <code>toUpperCase()</code> 方法，如下 <code>js</code> 文件</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202005291040.gif" width="60%"/><p>如上，上面的函数的功能是将传入的单词首字母大写，我们只是简单的调用字符串对象的函数 <code>toUpperCase()</code>，但是我们发现当我们打出 <code>word.</code> 时没有给出任何的提出，因为 <code>JavaScript</code> 根本不能确定你传入的是不是字符串，毕竟 <code>JavaScript</code> 是如此的灵活，使用时你可以传入任何类型的参数。但是对于 <code>TypeScript</code> 就不一样了，因为它会对参数的类型做出限制，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202005291046.gif" width="60%"/><p>我们限制了传入的参数必须为 <code>string</code> 类型，在编译的阶段，我们能够肯定传入的一定是 <code>string</code> 类型，所以在函数的方法里面，当我们输入 <code>word.</code> 时会给出字符串对象的所有方法。除此之外，我们还规定了函数必须传入什么类型，这样用户在使用时就不能随便的传入参数，所有的一切必须按规定的来，这又无形的减少了 <code>bug</code> 的产生，并且用户在调用该方法时，还会给出提出，需要传入什么参数类型，必要的时候还可以给出传入参数的意义，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202005291057.gif" width="60%"/></li></ol><p><code>TypeScript</code> 的好处还不止这一些，不过就我列举的这两个，就有足够的理由来学 <code>TypeScript</code> 了，<code>TypeScript</code> 更多的好处就需要你在使用的过程中慢慢理会了。</p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><p>下面就将介绍 <code>TypeScript</code> 的安装，以及如何将 <code>TypeScript</code> 转化为 <code>JavaScript</code> 代码，毕竟浏览器和 <code>Node</code> 只能运行 <code>JavaScript</code> 代码。</p><h3 id="安装TypeScript"><a href="#安装TypeScript" class="headerlink" title="安装TypeScript"></a>安装TypeScript</h3><p>在安装 <code>TypeScript</code> 之前，确保你的计算机按照好了 <code>Node</code>，如果没有安装，可以去网上搜如何安装，教程很多。安装完成之后，使用 <code>npm</code> 下载 <code>typescript</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>查看版本(主要是验证是否成功安装)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tsc -V</span><br><span class="line"></span><br><span class="line">Version 3.8.3</span><br></pre></td></tr></table></figure><h3 id="编写TypeScript程序"><a href="#编写TypeScript程序" class="headerlink" title="编写TypeScript程序"></a>编写TypeScript程序</h3><p>新建 <code>greeter.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'XT'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greeter(user));</span><br></pre></td></tr></table></figure><p>在命令行中使用 <code>tsc</code> 命令将它编译为 <code>js</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tsc greeter.ts</span><br></pre></td></tr></table></figure><p>这时会在该目录下生成 <code>greeter.js</code>，<code>greeter.js</code> 的内容为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">'XT'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greeter(user));</span><br></pre></td></tr></table></figure><p>接着我们使用 <code>node</code> 运行该 <code>js</code> 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node greeter.js</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Hello XT</span></span><br></pre></td></tr></table></figure><p>所以我们一般的流程为，编写 <code>ts</code> 文件，然后使用 <code>tsc</code> 编译为 <code>js</code> 文件，然后使用 <code>node</code> 运行 <code>js</code> 文件查看结果，那有没有什么工具帮我们做这件事情，一个命令直接到位。这里我们推荐使用 <code>ts-node</code>，该命令可以一步到位，就相当于是直接运行 <code>ts</code> 文件，首先下载 <code>ts-node</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g ts-node</span><br></pre></td></tr></table></figure><p>现在我们可以直接使用 <code>ts-node greeter.ts</code> 查看结果。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p><code>TypeScript</code> 与 <code>JavaScript</code> 最大的不同就是 <code>TypeScript</code> 是一个有类型的语言，我们一般使用下面的方式声明变量</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量名: 类型 = 值;</span><br></pre></td></tr></table></figure><p>那么 <code>TypeScript</code> 有哪些类型呢? 下面就简单介绍一下。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值只能为true或者false</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decNumber: <span class="built_in">number</span> = <span class="number">20</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> hexNumber: <span class="built_in">number</span> = <span class="number">0x14</span>; <span class="comment">// 十六进制 20</span></span><br><span class="line"><span class="keyword">let</span> binNumber: <span class="built_in">number</span> = <span class="number">0b10100</span>; <span class="comment">// 二进制 20</span></span><br><span class="line"><span class="keyword">let</span> octNumber: <span class="built_in">number</span> = <span class="number">0o24</span>; <span class="comment">//八进制 20</span></span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"bob"</span>; <span class="comment">// 单引号，双引号都可以</span></span><br><span class="line"><span class="keyword">let</span> greetStr: <span class="built_in">string</span> = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// 支持模板字符串</span></span><br></pre></td></tr></table></figure><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 数字数组</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 数组泛型</span></span><br></pre></td></tr></table></figure><h3 id="元祖-Turple"><a href="#元祖-Turple" class="headerlink" title="元祖(Turple)"></a>元祖(Turple)</h3><p>规定了数组的长度，以及每个元素的类型</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]; <span class="comment">// x有两个元素，第一个元素为字符串，第二个元素为数字</span></span><br><span class="line">x = [<span class="string">"hello"</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colorName: Color = Color.Blue;</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型，与写 <code>JavaScript</code> 一样</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不清楚是什么类型，或者不希望做语法检查，就相当于写JavaScript</span></span><br><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p><code>void</code> 一般用于表示函数不返回任何值，将它声明为一个变量没有意义</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不返回任何值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printUser</span>(<span class="params">user</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个void类型变量是没有意义的</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">void</span> = <span class="literal">null</span>; <span class="comment">// 只能被赋值为null和undefined</span></span><br></pre></td></tr></table></figure><h3 id="undefined-null"><a href="#undefined-null" class="headerlink" title="undefined, null"></a>undefined, null</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>; <span class="comment">// 通常声明变量意义不大</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>函数抛出异常或者死循环是可以使用 <code>nerver</code> 作为返回值</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示不存在的数据类型 函数抛出异常的时候就可以用never </span></span><br><span class="line"><span class="comment">// never是任何类型的子类型，可以赋值给任何的类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"something error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环，函数不能结束，也可以返回never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inifiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示非原始类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123;prop: <span class="number">0</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：当没有将变量声明为某个基本类型时，<code>TypeScript</code> 会进行类型推断，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>; <span class="comment">// str 会被推断为 string 类型</span></span><br></pre></td></tr></table></figure><p>如上，变量 <code>str</code> 会被推断为 <code>string</code> 类型，这时 <code>str</code> 不能被赋值为别的类型</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529131440.png" width="60%"/><p>如果变量在声明时并没有被赋值，那么它的类型会被推断为 <code>any</code>，这时它可以被赋予任何类型的值</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str; <span class="comment">// str 被推断为 any，可以为赋予任何类型的值</span></span><br><span class="line">str = <span class="string">'hello'</span>;</span><br><span class="line">str = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529131926.png" width="35%"/></blockquote><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>我们使用 <code>enum</code> 来定义枚举类型，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    Mon,</span><br><span class="line">    Tue,</span><br><span class="line">    Wen,</span><br><span class="line">    Thu,</span><br><span class="line">    Fri,</span><br><span class="line">    Sat,</span><br><span class="line">    Sun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型会被编译为从零递增的数字</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Week;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Week</span>) </span>&#123;</span><br><span class="line">    Week[Week[<span class="string">"Mon"</span>] = <span class="number">0</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Tue"</span>] = <span class="number">1</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Wen"</span>] = <span class="number">2</span>] = <span class="string">"Wen"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Thu"</span>] = <span class="number">3</span>] = <span class="string">"Thu"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Fri"</span>] = <span class="number">4</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Sat"</span>] = <span class="number">5</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Sun"</span>] = <span class="number">6</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">&#125;)(Week || (Week = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>通过编译后的代码可以看出，枚举名和枚举值可以互相引用</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">0</span>] === <span class="string">'Mon'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">1</span>] === <span class="string">'Tue'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">2</span>] === <span class="string">'Wen'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">3</span>] === <span class="string">'Thu'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="string">'Fri'</span>] === <span class="number">4</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="string">'Sat'</span>] === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="string">'Sun'</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们还可以为枚举名手动赋值，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    Mon = <span class="number">1</span>,</span><br><span class="line">    Tue,</span><br><span class="line">    Wen,</span><br><span class="line">    Thu,</span><br><span class="line">    Fri,</span><br><span class="line">    Sat,</span><br><span class="line">    Sun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为 <code>Mon</code> 手动赋值为 <code>1</code>，未手动赋值的项会接着上一项递增，所以 <code>Tue</code> 的值为 <code>2</code>，<code>Wen</code> 的值为 <code>3</code>，以此递增。如果后面递增的数字与前面定义数字重复了，这时是不会报错的，而是会覆盖之前的项</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">    Mon = <span class="number">3</span>,</span><br><span class="line">    Tue = <span class="number">1</span>,</span><br><span class="line">    Wen,</span><br><span class="line">    Thu,</span><br><span class="line">    Fri,</span><br><span class="line">    Sat,</span><br><span class="line">    Sun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 <code>Thu</code> 的值也是 <code>3</code>，这个时候它的值与 <code>Mon</code> 重复了，但是此时 <code>Week[3]</code> 的值是 <code>Thu</code> 而不是 <code>Mon</code>，因为后面的 <code>Thu</code> 将前面的 <code>Mon</code> 覆盖了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Week;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Week</span>) </span>&#123;</span><br><span class="line">    Week[Week[<span class="string">"Mon"</span>] = <span class="number">3</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Tue"</span>] = <span class="number">1</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Wen"</span>] = <span class="number">2</span>] = <span class="string">"Wen"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Thu"</span>] = <span class="number">3</span>] = <span class="string">"Thu"</span>; <span class="comment">// Week[3] 被重新赋值为了"Thu"</span></span><br><span class="line">    Week[Week[<span class="string">"Fri"</span>] = <span class="number">4</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Sat"</span>] = <span class="number">5</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">    Week[Week[<span class="string">"Sun"</span>] = <span class="number">6</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">&#125;)(Week || (Week = &#123;&#125;));</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>对于函数来说，我们使用函数类型来规范它，一个函数有输入和输出，所以我们使用如下的形式来表示函数类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(x: <span class="built_in">number</span>, y:<span class="built_in">number</span>) =&gt; <span class="built_in">number</span></span><br></pre></td></tr></table></figure><p>上面就规范这个函数类型的输入为两个 <code>number</code> 类型的参数，输出为 <code>number</code> 类型的参数，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> add:<span class="function">(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>add</code> 函数是一个 <code>(x: number, y:number) =&gt; number</code> 类型的函数，它必须接受两个 <code>number</code> 类型的参数，返回一个 <code>number</code> 类型的参数，如果 <code>add</code> 函数不满足此规则，那么就会报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529135041.png" width="80%"/><p>在上面 <code>add</code> 返回的是一个 <code>string</code> 类型的值，而不是 <code>number</code> 类型，这时编译器就会报错。</p><p>现在考虑有一个减法函数，它也满足上面的函数类型，所以它可以被声明如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> substract: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还有很多的函数也满足上面的函数类型的话，那是不是每次都要写一般函数类型，所以我们可不可以为这个函数类型起一个别名，这样方便引用，我们可以通过 <code>type</code> 起别名，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> compute = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> substract: compute = (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add: compute = (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还有别的函数时这个函数类型的话，我们使用起的别名 <code>compute</code> 进行申明就可以了。</p><p>如果我们使用匿名函数的形式声明一个函数，那么它会进行类型推断，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>add</code> 会被自动推断为 <code>(x: number, y:number) =&gt; number</code>，如果参数没有注明类型，那么会被推断为 <code>any</code>。</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示取值可以为多种类型的一种，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> score: <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// score 可以为数字，也可以为字符串</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">97</span>;</span><br><span class="line">score = <span class="string">"97"</span>; <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure><p>当我们为联合类型进行赋值时，会根据类型推断推断出一个类型，这个时候我们就可以访问该类型所拥有的属性和方法，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> score: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">score = <span class="string">"97"</span>; <span class="comment">// 被推断为 string 类型</span></span><br><span class="line">score.length; <span class="comment">// 可以访问 string 类型的属性和方法</span></span><br></pre></td></tr></table></figure><p>当 <code>TypeScript</code> 不能确定联合类型的具体类型时，那么只能访问联合类型中这些类型的共有的属性和方法，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span>|<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>something</code> 为 <code>string</code> 或者 <code>number</code> 类型，所以它只能访问 <code>string</code> 和 <code>number</code> 类型共有的属性和方法，但是因为 <code>number</code> 类型没有 <code>length</code> 属性，所以上面会报错，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529143721.png" width="90%"/><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口可以看做是对象的类型，接口规定了对象的结构，我们使用 <code>interface</code> 来定义一个接口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们定义一个叫做 <code>Person</code> 的接口，如果某个对象时这个接口类型，那么这个对象就必须含有 <code>name</code> 和 <code>age</code> 属性，并且 <code>name</code> 属性的值为 <code>string</code>，<code>age</code> 属性的值为 <code>number</code>，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'bob'</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说接口规定了对象的结构，定义了对象所必须拥有的属性名，不能多，也不能少，否则会报错，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'bob'</span>,</span><br><span class="line">    age: <span class="number">13</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>person</code> 中含有接口 <code>Person</code> 不曾定义过的属性 <code>gender</code>，这时就会报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529144813.png" width="80%"/><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>有时候我们并不需要对象完全匹配一个形状，这个时候可以定义可选属性，定义的规则如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    gender?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们定义了一个可选属性 <code>gender</code>，这个时候类型为 <code>Person</code> 的对象，可以有 <code>gender</code> 属性，也可以没有</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'bob'</span>,</span><br><span class="line">    age: <span class="number">13</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'bob'</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是可以的。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>有时候我们希望对象的某些属性在定义时被赋值，并且以后不能被更改，那么可以在这个属性定义为只读属性。我们使用 <code>readonly</code> 定义某个属性为只读属性</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对象的类型为 <code>Person</code> 时，在创建时要为 <code>id</code> 赋值(初始化)，并且这时 <code>id</code> 是只读的，不能被改变</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面我们尝试修改 <code>tom</code> 对象的 <code>id</code>，但是因为 <code>id</code> 是只读的，不能被修改，所以上面的程序会报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529153901.png" width="70%"/><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>如果我们希望某个接口可以有任意的属性，我们可以使用如下方式</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了 <code>Person</code> 接口可以有任意的属性，该属性的键值为 <code>string</code> 类型，值为 <code>any</code> 类型。一旦定义了任意属性，那么确定属性和可选属性的类型必须为任意属性所规定的类型的子集。比如修改上面的接口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>age</code> 的值类型为 <code>number</code>，而任意属性规定的值类型为 <code>string</code>，所以会报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529155945.png" width="80%"/><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类可以看做是创建对象的模板，我们使用 <code>class</code> 来定义一个类，一个类中有属性和方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>我们可以通过类来大量的创建对象。在类中有一个方法 <code>constructor()</code>，这个方法叫做构造函数，它的功能是用来初始化属性的。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>我们使用 <code>extends</code> 关键字来实现继承</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> score: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, score: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承，我们复用父类的属性和方法。在上面我们使用了 <code>super</code>，该方法的作用是调用父类的构造函数初始化父类的属性。</p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>访问权限有三种，分别为 <code>public</code>，<code>private</code>，<code>protected</code> 三种，在上面我们使用的都是 <code>public</code> 访问权限，使用该权限，可以在任何地方被访问到，例如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 可以直接访问</span></span><br><span class="line"><span class="built_in">console</span>.log(tom.name, tom.age); <span class="comment">// Tom 3</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>private</code>，那么该属性只能在类内部才能被访问，在类的外部不能被访问，如</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tom.name, tom.age);</span><br></pre></td></tr></table></figure><p>我们将 <code>name</code> 的访问权限修改为了 <code>private</code>，这个时候不能再类外被直接访问，所以上面通过 <code>tom.name</code> 访问属性 <code>name</code> 会报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529171039.png" width="90%"/><p>如果使用 <code>protected</code> 修饰，那么该属性只能在该类内部及其子类中才能被访问，除此之外不能被访问，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> score: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, score: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在子类中可以被访问</span></span><br><span class="line">    <span class="keyword">public</span> getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alice = <span class="keyword">new</span> Student(<span class="string">"Alice"</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(alice.getName()); <span class="comment">// Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下行语句会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(alice.name);</span><br></pre></td></tr></table></figure><p>如上所示，父类 <code>Person</code> 的 <code>name</code> 属性使用 <code>protected</code> 修饰，所以在子类 <code>Student</code> 中可以访问，但是在父类和子类的外部不能访问</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529181516.png" width="90%"/><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>我们可以使用 <code>static</code> 关键声明静态属性以及静态方法，静态属性和方法是属于类的，而不是具体的对象，使用属性和方法要使用类名调用，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> max_age:<span class="built_in">number</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age:<span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类对象访问实例属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Tom</span></span><br><span class="line"><span class="comment">// 通过类访问静态属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.max_age); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>我们可以使用 <code>readonly</code> 来修饰类的属性，来表示该属性是只读的，只有在构造函数中初始化该属性，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public readonly name:string;</span><br><span class="line">    public age:number;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string, age:number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"Bob"</span>;</span><br></pre></td></tr></table></figure><p>在上面我们声明了 <code>name</code> 属性为 <code>readonly</code>，表明 <code>name</code> 属性是只读的，但是在后面我们试图修改该属性，这个时候将会报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529202710.png" width="80%"/><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>接口的另一个作用就是对类进行抽象，一个类可以实现接口，当类实现接口时，要求类中必须有接口中定义的属性和方法，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> IPerson&#123;</span><br><span class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> age:<span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">public</span> gender: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span>, gender:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="number">12</span>, <span class="string">"male"</span>);</span><br></pre></td></tr></table></figure><p>其实我对接口的理解，其实就是定义了一个标准。定义了标准之后，对于具体的实现就不关心了，可以和具体的实现解耦。假设我们有一个方法接受一个操作数据库的对象，但是对于不同的厂家(数据库)，具体怎么操作数据库都是不一样的，所以这个对象不能写死是怎么类型。所以我们应该定义操作数据库的标准，比如操作数据库的方法名，方法接收的参数，而对于具体的实现应该由各自的产商编写。只要这些厂商实现了我们的标准，那么它就可以用，类比过来，我们定义的标准就是接口，而各自厂商的实现就是实现了接口的类。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> OperateDatabase &#123;</span><br><span class="line">    save: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params">obj: OperateDatabase</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    obj.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们定义一个操作数据库的接口 <code>OperateDatabase</code>，并且定义了一个方法 <code>saveData()</code>，该方法接收一个接口，注意这里我们没有指定是某个特定的对象类型，否则的就会与该类型绑定在一起。接着我们可以两个类实现该接口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MysqlDatabase <span class="keyword">implements</span> OperateDatabase &#123;</span><br><span class="line">    save() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"mysql 保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RedisDatabase <span class="keyword">implements</span> OperateDatabase &#123;</span><br><span class="line">    save() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"redis 保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个类就相当于是这个标准的具体实现。当我们调用 <code>saveData</code> 方法时，将具体的实现类传入即可</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">saveData(<span class="keyword">new</span> MysqlDatabase()); <span class="comment">// mysql 保存数据</span></span><br><span class="line">saveData(<span class="keyword">new</span> RedisDatabase()); <span class="comment">// redis 保存数据</span></span><br></pre></td></tr></table></figure><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><h3 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h3><p>现在有这么一个函数，它可以接受一个参数，这个参数可以是字符串或者数字，它的功能是将传入的数字或者字符串反转，比如输入 <code>123</code>，则输出 <code>321</code>，输入 <code>hello</code>，则输出 <code>olleh</code>，我们可以定义类如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span>|<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的定义有一个缺点，不能精确的表达输入数字时，输出也是数字，输入是字符串时，输出也是字符串。我们可以重载 <code>reverse</code> 的多个定义</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span>|<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><p>当我们定义了两个相同名字的接口时，接口中的属性会自动进行合并</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个接口有相同的属性，只要它们返回的值的类型相同，就不会有问题，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    gender:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两个接口中，它们有相同的属性名 <code>gender</code>，并且它们的定义时一样的，它们的合并也没有问题，相当于如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    gender:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果有相同的属性，但是定义却不同，即值的类型不同，那么会报错</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    gender:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个接口的 <code>gender</code> 的定义不同，报错如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202005292148.png" width="90%"/><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候我们需要将一个不确定的类型断言为具体的类型，比如将一个联合类型断言为其中的某一个具体的类型，这样就可以使用它特有的方法。类型断言的语法为</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">值 <span class="keyword">as</span> 类型</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br></pre></td></tr></table></figure><p>上面两种方法都是将值断言为某个具体的类型。因为在 <code>React</code> 中只支持 <code>as</code> 语法，所以推荐使用第一种方法。</p><h3 id="联合类型断言为其中具体类型"><a href="#联合类型断言为其中具体类型" class="headerlink" title="联合类型断言为其中具体类型"></a>联合类型断言为其中具体类型</h3><p>就如上面所说，有时候我们希望将联合类型断言为具体的类型，这样我们就可以使用类型特有的方法，否则只能使用二者公共的方法。我们第一个形状类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Circle | Square | Rectangle;</span><br></pre></td></tr></table></figure><p>接着我们定义一个方法，该方法接收 <code>Shape</code> 类型的参数，返回面积，我们可能会这么写</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> s.radius === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * s.radius * s.radius;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> s.size === <span class="string">'number'</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.width * s.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你会发现一片报红</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200529221611.png" width="50%"/><p>因为传入的类型 <code>s</code> 根本无法确定是什么具体的类型，我们只能访问 <code>Circle, Square, Rectangle</code> 的公共属性和方法，所以当我们访问他们特有的属性时就会报错，比如 <code>s.radius</code>，所以在访问具体的属性进行判断时，我们要断言为具体的类型，修改如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (s <span class="keyword">as</span> Circle).radius === <span class="string">'number'</span>) &#123;</span><br><span class="line">        s = s <span class="keyword">as</span> Circle;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * s.radius * s.radius;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> (s <span class="keyword">as</span> Square).size === <span class="string">'number'</span>) &#123;</span><br><span class="line">        s = s <span class="keyword">as</span> Square;</span><br><span class="line">         <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = s <span class="keyword">as</span> Rectangle;</span><br><span class="line">        <span class="keyword">return</span> s.width * s.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先进行断言为具体的类型，然后进行判断。</p><h3 id="父类或接口断言为子类或实现类"><a href="#父类或接口断言为子类或实现类" class="headerlink" title="父类或接口断言为子类或实现类"></a>父类或接口断言为子类或实现类</h3><p>有时候我们需要将父类或接口断言为具体的子类，这样就可以使用子类特有的属性或方法。首先定义一个父类和两个子类</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    score: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span>, score: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    level: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age: <span class="built_in">number</span>, level: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着定义一个方法，该方法接收 <code>Person</code> 类型的参数，我们需要断言为具体的子类才能使用子类的属性和方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStudent</span>(<span class="params">p: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (p <span class="keyword">as</span> Student).score === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isStudent(<span class="keyword">new</span> Student(<span class="string">'Bob'</span>, <span class="number">15</span>, <span class="number">100</span>))); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在定义函数、类和接口时，并不具体指定具体的类型，而是使用一个占位符表示类型，具体的类型在使用的时候传入决定。</p><h3 id="函数泛型"><a href="#函数泛型" class="headerlink" title="函数泛型"></a>函数泛型</h3><p>我们定义一个函数创建一个数组，并设置默认值，数组中存储的具体类型等到使用时确定</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, defaultValue: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;T&gt;(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        x.push(defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收两个参数，第一个参数为数组的长度，第二个参数为默认值。该数组的类型我们使用泛型 <code>T</code> 代替，具体的类型在使用时确定，如创建一个长度为 <code>5</code>，类型为 <code>number</code>，默认值为 <code>0</code> 的数组，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = createArray&lt;<span class="built_in">number</span>&gt;(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;5 empty items&gt;, 0, 0, 0, 0, 0 ]</span></span><br></pre></td></tr></table></figure><p>因为我们不知道泛型的具体类型，所以不能随意操作它的属性和方法，这个时候我们可以对象泛型做出约束，以便我们可以使用特定的属性或方法，如要求泛型必须符合某个接口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Length &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Length</span>&gt;(<span class="params">t: T</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们要求泛型 <code>T</code> 继承了接口 <code>Length</code>，即传入的对象 <code>t</code> 必须含有属性 <code>length</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getLength(<span class="string">"123"</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="接口泛型"><a href="#接口泛型" class="headerlink" title="接口泛型"></a>接口泛型</h3><p>同样的，我们也可以在接口中使用泛型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: <span class="built_in">number</span>, defaultValue: T): <span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, defaultValue: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: T[] = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        x.push(defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// [ 3, 3, 3, 3, 3 ]</span></span><br></pre></td></tr></table></figure><h3 id="类泛型"><a href="#类泛型" class="headerlink" title="类泛型"></a>类泛型</h3><p>我们也可以在类中使用泛型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">    data: T[];</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">capacity: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;T&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push (item: T): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.push(item);</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop (): T &#123;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.pop() <span class="keyword">as</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printStack(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个 <code>Stack</code> 栈，它里面存储的类型是一个泛型，在我们使用的时候确定，如下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个存储 number 类型数据的栈 容量为10</span></span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>); </span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">10</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">stack.printStack(); <span class="comment">// [ &lt;10 empty items&gt;, 10, 5 ]</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程</a></li><li><a href="https://juejin.im/post/5d8efeace51d45782b0c1bd6" target="_blank" rel="noopener">TypeScript安利指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      TypeScript快速入门
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="TypeScript" scheme="https://lastknightcoder.gitee.io/categories/Web/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://lastknightcoder.gitee.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之正则表达式</title>
    <link href="https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-05-27T16:00:00.000Z</published>
    <updated>2020-05-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在字符串的处理中，我们经常要进行字符串的匹配，校验等等操作。比如校验字符串的格式是否符合邮箱，电话号码的格式，校验密码是否符合要求，密码中是否包含数字和字母等等；又或者匹配得到某种规则的字符串。这一些操作如果使用常规的方法进行字符串操作，会花费较大的代价，包括时间和精力。</p><p>正则表达式是用来表达字符串的规则，它可以检验字符串是否符合某个特定的规则，或者匹配字符串中符合规则的字符，在一般的使用中，正则表达式一般用来匹配字符串中的字符或者字符串中特定的位置。</p><h2 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h2><p><code>JavaScript</code> 正则对象的创建有两种常见的方法，一是使用 <code>RegExp</code> 构造函数进行创建，二是使用字面量的方法进行创建，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'hello'</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> regex2 = <span class="regexp">/hello/g</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>hello</code> 表示字符串的规则，用来匹配字符串中的<code>&quot;hello&quot;</code>，<code>g</code> 表示进行全局匹配(<code>global</code>)，像这样的标志还有两个，<code>m</code> 表示进行多行匹配(<code>multiline</code>)，<code>i</code> 表示忽略大小写(<code>ignoreCase</code>)，这三个标志互不冲突，可以同时使用，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/igm</span>;</span><br></pre></td></tr></table></figure><p>具体标志的作用在后面讲解。在实际的使用中，我们一般会使用字面量的形式创建正则对象，相对于使用构造函数，字面量的创建比较简便，不过如果需要动态的创建正则对象，或者根据字符串创建正则对象，那么可以考虑使用构造函数的方式。</p><h3 id="正则对象中的属性"><a href="#正则对象中的属性" class="headerlink" title="正则对象中的属性"></a>正则对象中的属性</h3><ul><li><code>global</code>：布尔值，是否设置了 <code>g</code> 标志</li><li><code>ignoreCase</code>：布尔值，是否设置了 <code>i</code> 标志</li><li><code>lastIndex</code>：整数，从字符串的某个位置开始匹配，默认为 <code>0</code></li><li><code>multiline</code>：布尔值，是否设置了 <code>m</code> 标志</li><li><code>source</code>：正则表达式的字符串表示</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d&#123;3&#125;hello$/ig</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.global); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.source); <span class="comment">// \d&#123;3&#125;hello$</span></span><br></pre></td></tr></table></figure><h3 id="正则对象中的方法"><a href="#正则对象中的方法" class="headerlink" title="正则对象中的方法"></a>正则对象中的方法</h3><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><code>test()</code>，该方法接收一个字符串参数，返回一个布尔值，用来判断该字符串是否符合正则对象的规则，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec()</code> 方法是用来捕获匹配到的字符，该方法接收一个字符串，返回一个数组，数组的第一项表示与整个模式匹配的字符串，第二项表示第一个捕获组(捕获组的概念如果不懂，可以看了括号的作用在回来看)，第三项表示第二个捕获组，以此类推。返回的数组与普通数组不同的是，该数组还有三个属性，<code>index</code> 、 <code>input</code> 和 <code>groups</code>，<code>index</code> 表示匹配到的字符在原始字符串中的位置，从 <code>0</code> 开始；<code>input</code> 表示输入的原始字符串，<code>groups</code> 表示捕获组的名称。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(he)(ll)(o)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"so hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200527135642.png" width="80%"/><p>输出为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">3</span>,</span><br><span class="line">  input: <span class="string">'so hello'</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果正则对象的标志有 <code>g</code> 的话，那么在执行 <code>exec()</code> 方法后会改变 <code>lastIndex</code> 为匹配字符串后字符的 <code>index</code>，接下来再次执行 <code>exec()</code> 方法时将会从 <code>lastIndex</code> 处开始匹配，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"ab abc abc"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/ab/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">regex.exec(string); <span class="comment">// 匹配不到会返回 null</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 重新变为 0</span></span><br></pre></td></tr></table></figure><h3 id="构造函数RegExp的属性"><a href="#构造函数RegExp的属性" class="headerlink" title="构造函数RegExp的属性"></a>构造函数RegExp的属性</h3><p>构造函数 <code>RegExp</code> 中有一些静态属性，这些属性会保存最近一次正则对象操作的一些信息，并且这些属性有两种方法访问，一种是具有语义的长属性名，一种是简短的短属性名，具体如下：</p><ul><li><code>input</code>：短属性名为 <code>$_</code>，最近一次要匹配的字符串</li><li><code>lastMatch</code>：<code>$&amp;</code>，最近一次的匹配项</li><li><code>leftContext</code>：$`， <code>input</code> 中 <code>lastMatch</code> 的左边部分</li><li><code>rightContext</code>：<code>$&#39;</code>，<code>input</code> 中 <code>lastMatch</code> 的右边部分</li><li><code>$1, $2, ...</code>：后面介绍</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"he hello llo"</span>;</span><br><span class="line">regex.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input); <span class="comment">// he hello llo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// he_ (从_表示空格)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// _llo</span></span><br></pre></td></tr></table></figure><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>在字符串中，有许多的方法也是与正则表达式有关的，如 <code>replace</code>，<code>match</code>，下面就简单介绍一下。</p><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p><code>replace()</code> 方法的作用是使用新的字符串替换字符串中的某些内容，该方法接收两个参数，第一个参数表示字符串中要被替换的内容，它可以是一个具体的字符串或者是一个正则对象，第二个参数为一个字符串，这个参数是用来替换第一个参数的，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"gello"</span>;</span><br><span class="line">string = string.replace(<span class="string">'g'</span>, <span class="string">'h'</span>); <span class="comment">// 将 string 中的 g 替换为 h</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"abc"</span>;</span><br><span class="line">string = string.replace(<span class="regexp">/[ab]/g</span>, <span class="string">'#'</span>); <span class="comment">// 将字符串中的 a 或 b 替换为 #</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// ##c</span></span><br></pre></td></tr></table></figure><p>在上面中使用了 <code>[ab]</code>，这个表示 <code>a</code> 或者 <code>b</code>，具体会在元字符那里讲解。</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>match</code> 方法的作用与 <code>exec</code> 的作用差不多，不过一个是 <code>RegExp</code> 对象的方法，一个是 <code>String</code> 对象的方法。<code>match</code> 方法接收一个正则对象，它返回一个数组，根据正则对象是否设置了 <code>g</code> 标志，返回的结果也不相同。</p><p>如果没有设置 <code>g</code> 标志，即不会全局匹配，只会匹配一次，那么它返回的结果与 <code>exec</code> 返回的结果相同，数组的第一个元素表示匹配的字符串，后面的元素表示捕获组，并且也有 <code>input</code>，<code>index</code>，<code>groups</code>等属性，表示的含义也痛 <code>exec</code>，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(<span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello'</span>,</span><br><span class="line">  groups: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">h</span>: <span class="string">'he'</span>, <span class="attr">l</span>: <span class="string">'ll'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这次的正则表达式跟以往的不同，这次我设置了捕获组的名称，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?<span class="xml"><span class="tag">&lt;<span class="name">h</span>&gt;</span>he)</span></span><br></pre></td></tr></table></figure><p>即将捕获组 <code>(he)</code> 的名称设置为了 <code>h</code>，设置捕获组名称的格式如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?&lt;捕获组名称&gt;捕获组内容)</span><br></pre></td></tr></table></figure><p>为捕获组设置名称，可以方便在后面进行引用。</p><p>如果设置了 <code>g</code> 标志，这时返回值与 <code>exec</code> 方法就不同了，它会将字符串中所有符合正则表达式规则的内容都匹配出来，并放入数组中，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello' ]</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">"hello helloworld"</span>;</span><br><span class="line">result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure><p>这时设置的捕获组的信息就提取不到了，所以从某种程度上说，<code>exec</code> 的功能比 <code>match</code> 更加的强大，不过 <code>exec</code> 并不能一次提取出字符串中所有符合规则的内容，而是需要做一个循环，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello helloworld"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 当 re.exec()不为 null 时</span></span><br><span class="line"><span class="keyword">while</span> (result = re.exec(string)) &#123;</span><br><span class="line">    results.push(result[<span class="number">0</span>]); <span class="comment">// result 中还包含了捕获组的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure><h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><p>上面使用正则表达式进行匹配都是进行精确的匹配，如 <code>/hello/</code>，匹配字符串中的 <code>hello</code> 内容，这样我们根本无法领会到正则表达式的强大，正则表达式正是强大在它模糊匹配的能力，比如我们在 <code>Windows</code> 中进行文件查找，有时我们不记得文件的具体名称，比如忘了某个字母，这个时候我们会用 <code>.</code> 去表示任意的字母去进行查找。现在我们就来讲讲正则表达式模糊匹配的能力。</p><h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>在进行匹配的时候，如果我们不确定某个位置的字符是什么，我们可以使用表示特定含义的字符来占据这个位置，比如 <code>[abc]</code> 表示这个位置是 <code>a</code>，<code>b</code>，<code>c</code> 中的某个字符。如果我们想表示这个字符是小写字母，按照上面的写法，你可能会这么写 <code>[abcdefghijklmnopqrstuvwxyz]</code>，这样的写法有点反人类，我们可以使用范围表示法来代替上面的写法，如 <code>[a-z]</code> 的写法就表示所有的小写字母，同理 <code>[A-Z]</code> 就表示所有的大写字母，<code>[0-9]</code> 就表示数字，<code>[0-9a-zA-Z]</code> 表示这个位置可以是数字，小写字母，大写字母。如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let re = /[a-zA-Z0-<span class="number">9</span>]/;</span><br><span class="line">console.log(re.test(<span class="string">'0'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'s'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'S'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'?'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们可以在 <code>[]</code> 中加入 <code>^</code> 表示取反，如 <code>[^0-9]</code> 表示非数字，即它可以匹配所有的非数字</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/[^0-9]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"?"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们还可以使用<strong>元字符</strong>来占据位置，比如 <code>\d</code> 就代表数字，它的作用与 <code>[0-9]</code> 是一样的，常见的元字符如下所示(不包含表示位置的元字符，表示位置的元字符在后面介绍)</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\d</code></td><td>表示数字</td></tr><tr><td><code>\s</code></td><td>表示空白字符，包括空格，回车，制表符等等</td></tr><tr><td><code>\w</code></td><td>表示数字，大小写字母和下划线，相当于 <code>[0-9a-zA-Z_]</code></td></tr><tr><td><code>.</code></td><td>表示任意一个字符</td></tr></tbody></table><p>来看几个例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示数字</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空白字符</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\s/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示大小写字母，数字和下划线</span></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\w/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"A"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"_"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>与在 <code>[]</code> 中加入 <code>^</code>表示取反，上面的元字符也有对应的元字符表示取反的概念</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\D</code></td><td>与 <code>\d</code> 相反，表示非数字</td></tr><tr><td><code>\S</code></td><td>与 <code>\s</code> 相反，表示非空白字符</td></tr><tr><td><code>\W</code></td><td>与 <code>\w</code> 相反，表示非单词</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\S/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"9"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\W/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"0"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>现在我们假设使用正则表达式去匹配电话号码，假设电话号码就是 <code>11</code> 位数字，所以写出来的正则表达式是这样的 <code>\d\d\d\d\d\d\d\d\d\d\d</code>，这种写法也相当的反人类，不仅难读(需要一个个数才知道有多少个数)，而且写起来也麻烦，我们可以使用量词来简写上面的表达式，如 <code>\d{11}</code> 就表示 <code>\d</code> 连续出现 <code>11</code> 次，常见的量词写法如下</p><table><thead><tr><th>量词</th><th>含义</th></tr></thead><tbody><tr><td><code>{n}</code></td><td>表示连续出现 <code>n</code> 次</td></tr><tr><td><code>{m,n}</code></td><td>表示连续出现 <code>m-n</code>，最少出现 <code>m</code>，最多出现 <code>n</code> 次</td></tr><tr><td><code>{n,}</code></td><td>表示连续出现最少 <code>n</code> 次(包括 <code>n</code> 次)</td></tr><tr><td><code>*</code></td><td>表示连续出现<strong>任意</strong>多次</td></tr><tr><td><code>+</code></td><td>表示连续出现 <code>1</code> 次或 <code>1</code> 次以上</td></tr><tr><td><code>?</code></td><td>表示出现 <code>0</code> 次或 <code>1</code> 次</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 5 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;5&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"123 1234 12345 654321"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12345', '65432' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 2-3 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;2,3&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12', '123', '123' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现 4 位及 4 位以上的数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4,&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234 12345"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '1234', '12345' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 可以出现任意次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab*c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ac', 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 1 次或 1 次以上</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 0 次或 1 次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab?c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re));</span><br></pre></td></tr></table></figure><h3 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h3><p>所谓的贪婪匹配就是尽可能的多匹配，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abbbb' ]</span></span><br></pre></td></tr></table></figure><p>明明匹配 <code>ab</code> 也可以，但是它会尽可能多的匹配，这就是贪婪模式，与此相对的是惰性匹配，惰性匹配就是在满足条件的情况下会尽可能的少匹配，如上例就会匹配 <code>ab</code>，在默认的情况下是贪婪匹配，要使用惰性匹配就要使用惰性量词</p><table><thead><tr><th>贪婪</th><th>惰性</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>+?</code></td></tr><tr><td><code>*</code></td><td><code>*?</code></td></tr><tr><td><code>?</code></td><td><code>??</code></td></tr><tr><td><code>{n,m}</code></td><td><code>{n,m}?</code></td></tr><tr><td><code>{n,}</code></td><td><code>{n,}?</code></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+?/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ab' ]</span></span><br></pre></td></tr></table></figure><p>现在考虑根据 <code>html</code> 字符串获得某 <code>id</code> 属性，如 <code>&lt;div id=&quot;container&quot; class=&quot;active&quot;&gt;&lt;/div&gt;</code>，如果我们使用贪婪匹配的话，考虑这样的匹配规则 <code>/id=&quot;.*&quot;/</code>，那么捕获到的并不是我们想要的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container" class="active"</span></span><br></pre></td></tr></table></figure><p>我们发现匹配到的是 <code>id=&quot;container&quot; class=&quot;active&quot;</code>，因为在贪婪模式下再符合条件的情况下会尽可能多的匹配，所以会直接匹配到最后一个双引号，解决办法有两种，其中简单的解决办法就是使用惰性匹配</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*?"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure><p>另一种办法就比较 <code>trick</code>，我觉得只可意会，难以言传</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id="[^"]*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure><p>仔细体会上面的写法吧，我觉得很好用，比如获得某标签的标签名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/&lt;[^&gt;]*&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// &lt;div&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>有时候我们需要在多个分支之间进行选择，比如匹配十六进制表示的颜色，有两种表示，一种是 <code>#F4E242</code> 六位的，一种是简写的 <code>#FFF</code> 三位表示的，我们可以使用 <code>|</code> 来表示或的关系</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"#FFF"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"#F34E23"</span></span><br><span class="line"><span class="built_in">console</span>.log(string1.match(regex)); <span class="comment">// [ '#FFF' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(string2.match(regex)); <span class="comment">// [ '#F34E23' ]</span></span><br></pre></td></tr></table></figure><h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><h3 id="分组与分支"><a href="#分组与分支" class="headerlink" title="分组与分支"></a>分组与分支</h3><p>假设我们要匹配 <code>I love Java</code> 和 <code>I love C</code> 这两句话，你可能会写出这样的正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love Java|C/</span><br></pre></td></tr></table></figure><p>但是这个正则表达式表示的是 <code>I love Java</code> 或者 <code>C</code> 而不是 <code>I love C</code>，正确的写法应该是这样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love (Java|C)/</span><br></pre></td></tr></table></figure><p><code>Java</code> 和 <code>C</code> 选其一。</p><h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>假设我们要匹配一个格式为 <code>yyyy-mm-dd</code> 格式的日期，并且希望获得年月日，那么可能会这么写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string)[<span class="number">0</span>]; <span class="comment">// 2020-05-27</span></span><br><span class="line"><span class="keyword">let</span> results = result.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + results[<span class="number">0</span>]); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + results[<span class="number">1</span>]); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + results[<span class="number">2</span>]); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure><p>其实我们可以通过添加括号来捕获数据，对于被括号包起来的数据，其匹配的内容会被提取出来，添加到返回的数组中，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + result[<span class="number">1</span>]); <span class="comment">// 第一个捕获组 \d&#123;4&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + result[<span class="number">2</span>]); <span class="comment">// 第二个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + result[<span class="number">3</span>]); <span class="comment">// 第三个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br></pre></td></tr></table></figure><p>上面我们对年月日的规则使用括号包了起来，在进行匹配时，对应被匹配到的数据会添加到数组中，在介绍 <code>exec</code> 方法时，其返回的数组，第一个元素表示匹配到的字符串，后面的元素表示捕获组(括号包起来)中捕获的内容。</p><h4 id="RegExp的属性-1…"><a href="#RegExp的属性-1…" class="headerlink" title="RegExp的属性$1…"></a>RegExp的属性$1…</h4><p>除了可以根据返回的数组 <code>result</code> 来得到捕获的数据，还可以通过在上面提过一嘴的 <code>RegExp</code> 构造函数的属性 <code>$1, $2, $3 ...</code> 等等来获得所捕获的内容，其中 <code>$1</code> 表示第一个捕获组所匹配的内容，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + <span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure><p>每次在使用正则表达式进行匹配时，<code>RegExp</code> 中的 <code>$1, $2, $3 ...</code> 也会相应的更新。</p><h4 id="括号嵌套"><a href="#括号嵌套" class="headerlink" title="括号嵌套"></a>括号嵌套</h4><p>现在考虑如果括号有嵌套的情况，比如上面日期格式捕获更精准的表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(\d&#123;<span class="number">4</span>&#125;)-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|([<span class="number">1</span><span class="number">-2</span>]\d)|(<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>]))/</span><br></pre></td></tr></table></figure><p>上面括号嵌套的很复杂，在原理上，被括号包起来的规则所匹配的内容都会被捕获，那么嵌套带来的问题就是，捕获的顺序哪个在前，哪个在后，其实也很简单，根据左括号来，比如上式中的捕获顺序为</p><ol><li><code>(\d{4})</code></li><li><code>((0\d)|(1[0-2]))</code></li><li><code>(0\d)</code></li><li><code>(1[0-2])</code></li><li><code>((0[1-9])|([1-2]\d)|(3[0-1]))</code></li><li><code>(0[1-9])</code></li><li><code>([1-2]\d)</code></li><li><code>(3[0-1])</code></li></ol><p>所以如果使用上面的正则表达式进行捕获得到年月日的信息，根据分析年是第一捕获组，月是第二捕获组，日是第五捕获组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">5</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure><p>由于无用的捕获组太多，导致想要提取包含信息的捕获组获取困难，其实仔细观察，里面的大多数括号主要是为分支做准备的，对于这些捕获组，我们可以考虑不捕获，仅仅作为分支使用，我们在括号里面的前方加入 <code>?:</code> 表示该括号匹配的内容不进行捕获，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((?:0[1-9])|(?:1[0-2]))-((?:0[1-9])|(?:[1-2]\d)|(?:3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">3</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure><p>如果作为分支的括号太多，为每一个分支添加 <code>?:</code> 也比较费力，那么可以考虑给包含信息的捕获组命名，命名的方法在上面有提到过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;(0[1-9])|(1[0-2]))-(?&lt;day&gt;(0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"><span class="keyword">let</span> groups = result.groups;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groups.year, groups.month, groups.day); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure><p>通过给捕获组命名，可以方便的通过 <code>groups</code> 对象得到想要的数据。</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>现在再次考虑匹配日期，已知下面这三种日期格式都可以</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-12</span></span><br><span class="line"><span class="number">2017</span> <span class="number">02</span> <span class="number">12</span></span><br><span class="line"><span class="number">2017</span>/<span class="number">02</span>/<span class="number">12</span></span><br></pre></td></tr></table></figure><p>所以你可能会写出这样的正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d&#123;<span class="number">4</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;/</span><br></pre></td></tr></table></figure><p>经过测试，发现能符合要求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是你会发现一些意外的情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>前后的分隔符不一致的情况也能够匹配，而我们要求的是前后的分隔符是一样的，这个时候我们可以通过引用分组，使得前面和后面的分隔符是一样的，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;(-| |\/)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意到我们对于后面的分组，我们使用了 <code>\1</code> 去进行替代，<code>\1</code> 的意思就是代表引用第一个分组，这样就可以做到这个地方与前面的分组相同。同理我们也可以使用 <code>\2</code> 表示引用第二个分组(如果有的话，如果没有就单纯的表示匹配字符串 <code>&quot;\2&quot;</code>)。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="相关元字符"><a href="#相关元字符" class="headerlink" title="相关元字符"></a>相关元字符</h3><p>正则表达式中的最后一个内容就是关于位置的匹配，与字符匹配不同，位置匹配时匹配字符间的位置，常见有关位置的元字符如下</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>^</code></td><td>开头位置</td></tr><tr><td><code>$</code></td><td>结尾位置</td></tr><tr><td><code>\b</code></td><td>单词边界，即 <code>\w</code> 与 <code>\W</code> 之间的位置</td></tr><tr><td><code>(?=p)</code></td><td>匹配 <code>p</code> 模式前面的位置，具体见例子</td></tr><tr><td><code>(?&lt;=p)</code></td><td>匹配 <code>p</code> 模式后面的位置</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/^/</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[JS] hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/$/</span>, <span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/\b/g</span>, <span class="string">"#"</span>); <span class="comment">// \b 是 \w 与 \W 之间的位置，表示单词的边界</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [#JS#] #hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 前面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] #hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 后面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br></pre></td></tr></table></figure><p>同理，也有元字符表示与上面相反的意义</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\B</code></td><td>与 <code>\b</code> 相反，表示非单词边界</td></tr><tr><td><code>(?!p)</code></td><td>与 <code>(?=p)</code> 相反，表示不是 <code>p</code> 前面位置的所有位置</td></tr><tr><td><code>(?&lt;!p)</code></td><td>与 <code>(?&lt;=p)</code> 相反，表示不是 <code>p</code> 后面位置的所有位置</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/\B/g</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[J#S]# h#e#l#l#o</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 前面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# h#e#l#l#o#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 后面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# #h#e#l#l#o</span></span><br></pre></td></tr></table></figure><h3 id="千位分隔符案例"><a href="#千位分隔符案例" class="headerlink" title="千位分隔符案例"></a>千位分隔符案例</h3><p>现在来做一个案例，将数字转化为千位分隔符表示法，如 <code>12345678</code> 转化为 <code>12,345,678</code>，我们首先找到后三位数字的前面位置，然后添加逗号，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 12345,678</span></span><br></pre></td></tr></table></figure><p>进一步弄出所有的逗号</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>); <span class="comment">// 12,345,678</span></span><br></pre></td></tr></table></figure><p>但是还是有一个小小问题，测试的数字个数是三的倍数的时候，在开头也会添加一个逗号</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"123456789"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// ,123,456,789</span></span><br></pre></td></tr></table></figure><p>我们可以修改正则表达式如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(?!^)(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br></pre></td></tr></table></figure><p>其中 <code>(?!^)</code> 表示不是开头的位置。如果希望支持更多的格式，比如 <code>1234567 12345678</code> 转换为 <code>1,234,567 12,345,678</code>，只要将上面的表达式中的开头，结尾替换为 <code>\b</code> 即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"1234567 12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(?!\b)(\d&#123;3&#125;)+\b)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1,234,567 12,345,678</span></span><br></pre></td></tr></table></figure><p>考虑到 <code>(?!\b)</code> 就相当于 <code>\B</code>，所以上面的表达式也可简写如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(?=\B(\d&#123;<span class="number">3</span>&#125;)+\b)/g</span><br></pre></td></tr></table></figure><h3 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h3><p>正则表达式有三个常见的标志，分别为全局模式 <code>g</code>，表示进行全局匹配，如果不设置该标志，那么只会匹配一次，如果字符串后面还要符合规则的字符串，是不会被匹配的，对于 <code>exec()</code> 方法，非全局模式下不会更改 <code>lastIndex</code>，即 <code>lastIndex</code> 始终是 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非全局替换 只会替换匹配到的第一个 hello</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re1, <span class="string">"#"</span>)); <span class="comment">// # hello</span></span><br><span class="line"><span class="comment">// 全局替换 字符串中所以的 hello 都会被替换</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re2, <span class="string">"#"</span>)); <span class="comment">// # #</span></span><br></pre></td></tr></table></figure><p>第二标志 <code>i</code> 很好理解，即忽略大小写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(string)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(string)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>第三个标志 <code>m</code> 表示多行模式，它只会影响 <code>^,$</code>，如果不是多行模式，那么 <code>^, $</code> 就表示字符串的开头和结尾，如果是多行模式，那么 <code>^,$</code> 就表示每一行的开头和结尾。</p><p>非多行模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 非多行 ^,$ 表示字符串的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/g</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#I </span></span><br><span class="line"><span class="attribute">love</span> </span><br><span class="line">java<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>多行模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 多行模式 ^,$ 表示每一行的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/gm</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#I #</span><br><span class="line">#love #</span><br><span class="line">#java#</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JavaScript正则表达式
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="JavaScript 正则表达式" scheme="https://lastknightcoder.gitee.io/tags/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring常见注解</title>
    <link href="https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"/>
    <id>https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-21T16:00:00.000Z</published>
    <updated>2020-05-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 <code>Spring</code> 框架中的常见注解(<strong><code>NO XML</code></strong>)，在介绍 <code>Spring</code> 注解之前，简要的介绍一下 <code>IoC</code>。</p><h2 id="IoC简要介绍"><a href="#IoC简要介绍" class="headerlink" title="IoC简要介绍"></a>IoC简要介绍</h2><p><code>IoC(Inverse of Control)</code> 的意思是控制反转，意思就是控制权发生转换，以前我们需要某个类的对象，都是直接 <code>new</code> 出来的，现在有了<code>IoC</code>，对象创建的控制权交给 <code>Spring</code>，如果我们需要某个对象，向 <code>IoC</code> 容器拿，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/IoC202005201751.png" width="60%"/><p>上面将 <code>Dog</code> 类对象放入容器的过程我们成为<strong>注入</strong>，容器我们一般称为 <code>IoC</code> 容器或者 <code>Spring</code> 容器。上面做的好处可以减少类与类之间的耦合性，耦合性这个词可能高大尚，我举个例子，比如 <code>Dog</code> 类发生了改变，高耦合性意味着如果有类依赖 <code>Dog</code> 类的话，那么相应的该类有可能也要发生改变，如果耦合度低的话，也就是根本察觉不到自己依赖了 <code>Dog</code> 类，根本就不需要改变。</p><p>我们在像容器要某个对象时，察觉不到某个类的所在(因为一般使用接口去接收从容器中拿的对象)，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal = ioc.getObject(<span class="string">'dog'</span>);</span><br></pre></td></tr></table></figure><p>假设 <code>Dog</code> 实现了 <code>Animal</code> 接口，<code>ioc</code> 对象表示 <code>IoC</code> 容器，<code>getObject()</code> 表示从容器中获得对象的方法，而传入的参数表示对象在容器中的 <code>id</code>。如果 <code>Dog</code> 类发生改变(但是他在容器中的 <code>id</code> 是不会变的)，我们获取 <code>Dog</code> 对象的方式还是和上面一样，不需要发生改变。假设如果是直接 <code>new Dog()</code> 的话，如果 <code>Dog</code> 的类名变了，那么所有直接依赖 <code>Dog</code> 类的所有类都要发生改变，这就是低耦合的好处。</p><blockquote><p><strong>注意</strong>：要使用 <code>Spring IoC</code>，记得在 <code>pom.xml(Maven)</code> 中导入坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p><code>@Configuration</code> 的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(</span><br><span class="line">        annotation = Component<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    )</span></span><br><span class="line">    String value() default "";</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被 <code>@Configuration</code> 修饰的类是 <code>Spring</code> 的配置类，所谓的配置类就是用来配置用的，可以配置扫描哪些包，将这些包下的类注入到 <code>IoC</code> 容器中，也可以配置将特定的类注入到 <code>IoC</code> 容器中。</p><p>被 <code>@Configuration</code> 修饰的类也会被注入到 <code>IoC</code> 容器中，<code>@Configuration</code> 有一个 <code>value</code> 值，它是用来设置该类对象在 <code>IoC</code> 容器中的 <code>id</code>，如果不设置，那么默认是类名，不过首字母要改为小写，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringConfiguration</code> 是 <code>Spring</code> 的配置类，由于 <code>@Configuration</code> 没有配置<code>id</code>，所以它在 <code>IoC</code> 容器中的 <code>id</code> 为 <code>springConfiguration</code>，我们可以在测试类中测试，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        SpringConfiguration springConfiguration = ac.getBean(<span class="string">"springConfiguration"</span>, SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(springConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationConfigApplicationContext</code> 可以看做是 <code>IoC</code> 容器，我们传入配置类所在的包 <code>config</code> 给它，它会扫描该包找到配置类，然后根据配置类为容器注入对象，在上面我们在配置类中什么都没有做，所以不会向 <code>IoC</code> 容器注入别的对象。</p><p>接着我们通过获得对象的方法 <code>getBean()</code> 获得了配置类 <code>SpringConfiguration</code> 的对象，该方法需要传入在 <code>IoC</code> 容器中的 <code>id</code>，因为没有指定，默认是 <code>springConfiguration</code>。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p><code>@ComponentScan</code> 注解的定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(ComponentScans<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ComponentScan</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() <span class="keyword">default</span> AnnotationScopeMetadataResolver<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedProxyMode <span class="title">scopedProxy</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">resourcePattern</span><span class="params">()</span> <span class="keyword">default</span> "**<span class="comment">/*.class";</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    boolean useDefaultFilters() default true;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    ComponentScan.Filter[] includeFilters() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    ComponentScan.Filter[] excludeFilters() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    boolean lazyInit() default false;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    @Retention(RetentionPolicy.RUNTIME)</span></span></span><br><span class="line"><span class="function"><span class="comment">    @Target(&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="comment">    public @interface Filter &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        FilterType type() default FilterType.ANNOTATION;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">        @AliasFor("classes")</span></span></span><br><span class="line"><span class="function"><span class="comment">        Class&lt;?&gt;[] value() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">        @AliasFor("value")</span></span></span><br><span class="line"><span class="function"><span class="comment">        Class&lt;?&gt;[] classes() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">        String[] pattern() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure><p>该注解的作用是扫描包或者类，将扫描到类注入到 <code>IoC</code> 容器中。由上面可见，该类的属性还是挺多的，这里介绍几个重要的属性。</p><h3 id="value和basepackages"><a href="#value和basepackages" class="headerlink" title="value和basepackages"></a>value和basepackages</h3><p>这两个属性放在一起讲是因为他们互为别名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>它们的作用是一样的，规定要扫描哪些包，从定义看，它们的值都是字符串数组，我们在 <code>com.xt.service</code> 下定义 <code>ServiceTest</code> 类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spring</code> 的配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.xt.service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在配置类中规定了要扫描的包为<code>com.xt.service</code>，接着我们在测试类中测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.ServiceTest;</span><br><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        ServiceTest serviceTest = ac.getBean(<span class="string">"serviceTest"</span>, ServiceTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        serviceTest.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是却发生异常，在容器中没有名为 <code>serviceTest</code> 的对象</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520180852.png"/><p>这是因为即使扫描了 <code>ServiceTest</code> 所在的包，但并不是该包下所有的类都会被注入到容器中，而是被 <code>@Component</code> 注解所修饰的类才会被注入到容器中，所以我们要为 <code>ServiceTest</code> 加上 <code>@Component</code> 注解，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行测试类，结果如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520181342.png" width="40%"/><blockquote><p>注意：<code>@Component</code> 还有几个衍生注解，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，这些注解的作用与 <code>@Component</code> 一毛一样，那为什么要创建这些注解，主要是他们所代表的的语义，<code>@Controller</code> 主要用在 <code>Web</code> 层的类上，<code>@Service</code> 主要用在 <code>Service</code> 层上，而 <code>@Repository</code> 主要用在 <code>Dao</code> 层上，程序员看到某类被什么注解修饰，就可以明白该类的职责是什么了。</p></blockquote><p>如果 <code>@ComponentScan</code> 没有指定任何值，那么默认会扫描该类所在的包及其子包，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ComponentScan</code> 没有指定任何值，那么就会默认扫描 <code>config</code> 包下的类及其子包下的类。</p><h3 id="basePackageClasses"><a href="#basePackageClasses" class="headerlink" title="basePackageClasses"></a>basePackageClasses</h3><p><code>basePackageClasses</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>该属性的值是一个字节码数组，当设置指定字节码时，会扫描指定字节码所在包及其子包，假设有如下结构</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215316.png" width="30%"/><p><code>UserServiceImpl</code> 实现了 <code>UserService</code> 接口，二者内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spring</code> 的配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses = UserService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们配置 <code>basePackageClasses</code> 为 <code>UserService.class</code>，所以会扫描 <code>UserService</code> 所在的包及其子包，所以 <code>UserServiceImpl</code> 会被注入到容器中，我们在测试类中测试如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        UserService userService = ac.getBean(<span class="string">"userServiceImpl"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.doService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/><h3 id="nameGenerator"><a href="#nameGenerator" class="headerlink" title="nameGenerator"></a>nameGenerator</h3><p>该属性的作用是设置注入到容器中的对象(我们一般称这个对象为 <code>bean</code>)的 <code>id</code> 名称的生成规则，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><p>在上面我们可以看到，默认使用了 <code>BeanNameGenerator</code> 这个类去生成 <code>id</code> 的名称，而生成的规则在上面介绍过，即 <code>id</code> 为类名，不过首字母要小写， <code>Spring</code> 中的有关默认 <code>id</code> 名称生成的部分源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decapitalize</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; <span class="number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="number">1</span>)) &amp;&amp;</span><br><span class="line">                    Character.isUpperCase(name.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chars[] = name.toCharArray();</span><br><span class="line">    chars[<span class="number">0</span>] = Character.toLowerCase(chars[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，如果对于第一个字母和第二个字母都为大写的这种特殊的类名是不会将首字母变为小写的。</p><p>除了可以使用默认的生成规则，我们还可以自己自定义 <code>id</code> 的生成规则，在 <code>custom</code> 包下新建 <code>CustomBeanNameGenerator</code> 类，该类的作用就是 <code>id</code> 名称的生成规则，该类需要实现 <code>BeanNameGenerator</code> 接口，详细如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanNameGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        String beanName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 判断该类是否是由注解注入的</span></span><br><span class="line">        <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// 如果是强转为 AnnotatedBeanDefinition 以获得有关注解的信息</span></span><br><span class="line">            AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition;</span><br><span class="line">            <span class="comment">// 获得注解的信息</span></span><br><span class="line">            AnnotationMetadata annotationMetadata = annotatedBeanDefinition.getMetadata();</span><br><span class="line">            <span class="comment">// 获得所有注解</span></span><br><span class="line">            Set&lt;String&gt; types = annotationMetadata.getAnnotationTypes();</span><br><span class="line">            <span class="comment">// 遍历所有注解</span></span><br><span class="line">            <span class="keyword">for</span> (String type: types) &#123;</span><br><span class="line">                <span class="comment">// 获得注解的属性</span></span><br><span class="line">                AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(annotationMetadata.getAnnotationAttributes(type, <span class="keyword">false</span>));</span><br><span class="line">                <span class="comment">// 如果该注解为Component或其衍生注解(暂不考虑 JSR 规范，如 @Resource)且value属性有值</span></span><br><span class="line">                <span class="comment">// 并且 annotationAttributes 不为null</span></span><br><span class="line">                <span class="keyword">if</span> (annotationAttributes != <span class="keyword">null</span> &amp;&amp; isStereotypeWithNameValue(type, annotationMetadata.getMetaAnnotationTypes(type), annotationAttributes)) &#123;</span><br><span class="line">                    <span class="comment">// 获得 value 属性的值</span></span><br><span class="line">                    Object value = annotationAttributes.get(<span class="string">"value"</span>);</span><br><span class="line">                    <span class="comment">// 如果value为String，则强转</span></span><br><span class="line">                    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                        String strValue = (String) value;</span><br><span class="line">                        <span class="comment">// value 值长度不为 0</span></span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.hasLength(strValue)) &#123;</span><br><span class="line">                            <span class="comment">// 如果 beanName 有值，说明已经设置过了 此时 value 与 beanName 不同，说明产生了冲突，抛出异常</span></span><br><span class="line">                            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strValue.equals(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"多个注解设置了value，产生了冲突"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                beanName = strValue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 Component 及其衍生注解或者没有设置 value 值，则采用默认自定义的类名生成规则</span></span><br><span class="line">        <span class="keyword">return</span> beanName != <span class="keyword">null</span> ? beanName : buildDefaultBeanName(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该注解是否是Component及其衍生注解 并且有 value 属性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType, Set&lt;String&gt; metaAnnotationTypes, @Nullable Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isStereotype = annotationType.equals(<span class="string">"org.springframework.stereotype.Component"</span>) || metaAnnotationTypes.contains(<span class="string">"org.springframework.stereotype.Component"</span>) || annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) || annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">        <span class="keyword">return</span> isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 bean id 生成</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得全限定类名，如com.xt.service.impl.UserServiceImpl</span></span><br><span class="line">        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">        <span class="comment">// 获得类名 如UserServiceImpl</span></span><br><span class="line">        String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">        <span class="comment">// 默认生成规则为 my + 类名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"my"</span> + shortClassName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>id</code> 生成规则为如果 <code>@Component</code> 及其衍生注解设置了 <code>id</code> 名称，则使用设置的名称，否则默认的 <code>id</code> 名称为 <code>my +</code> 类名。现在将 <code>SpringConfiguration</code> 的 <code>@ComponentScan</code> 的 <code>nameGenerator</code> 设置为 <code>CustomBeanNameGenerator.class</code>，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> custom.CustomBeanNameGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(nameGenerator = CustomBeanNameGenerator<span class="class">.<span class="keyword">class</span>, <span class="title">basePackages</span> </span>= <span class="string">"com.xt.service.impl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserServiceImpl</code> 的内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见使用 <code>@Service</code> 修饰了，但是没用设置 <code>value</code> 值，所以默认生成的 <code>id</code> 是 <code>myUserServiceImpl</code>，在测试类中测试如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line">        <span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        <span class="comment">// id 已经改为了 myUserServiceImpl</span></span><br><span class="line">        UserService userService = ac.getBean(<span class="string">"myUserServiceImpl"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.doService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/><p>可见我们的自定义 <code>id</code> 生成规则生效了，现在修改 <code>UserServiceImpl</code> 如下，这次设置 <code>id</code> 值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们的规则，这时的 <code>id</code> 名为设定的值，即 <code>userService</code>，修改测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService userService = ac.getBean(<span class="string">"userService"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/><p>在此修改 <code>UserServiceImpl</code>，这次使用多个注解修饰，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"userServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类，这时会抛出异常，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520233312.png"/><h3 id="useDefaultFilters"><a href="#useDefaultFilters" class="headerlink" title="useDefaultFilters"></a>useDefaultFilters</h3><p>在 <code>@ComponentScan</code> 中有一个属性 <code>useDefaultFilters</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br></pre></td></tr></table></figure><p>它的值默认为 <code>true</code>，即如果被扫描的类被 <code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>这四个注解修饰时，那么将该类对象注入到容器中，如果为 <code>false</code>，那么被这四个注解修饰的类不会被添加到容器中(但是有可能通过其他注解或属性将该类添加到容器中，如 <code>includeFilters</code>，<code>@Import</code>)。</p><h3 id="includeFilters"><a href="#includeFilters" class="headerlink" title="includeFilters"></a>includeFilters</h3><p><code>includeFilters</code> 属性的作用是允许符合过滤规则的类对象注入到容器中，它的值是一个 <code>Filter</code> 注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Filter &#123;</span><br><span class="line">    <span class="function">FilterType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FilterType.ANNOTATION</span>;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"classes"</span>)</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] pattern() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有一个 <code>type</code> 属性，它的默认取值为 <code>FilterType.ANNOTATION</code>，表示过滤的规则为注解，如果我们设置 <code>value</code> 属性为某注解的字节码对象，那么被该注解修饰的类对象可以注入到容器中，比如允许自定义 <code>@MyAnno</code> 注解所修饰的类注入到容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(includeFilters = <span class="meta">@ComponentScan</span>.Filter(MyAnno<span class="class">.<span class="keyword">class</span>))</span></span><br></pre></td></tr></table></figure><p>在扫描的类中，如果该类被自定义注解 <code>@MyAnno</code> 修饰，那么该类对象会被注入到容器中。</p><h3 id="excludeFilters"><a href="#excludeFilters" class="headerlink" title="excludeFilters"></a>excludeFilters</h3><p>与 <code>includeFilters</code> 的作用相反，对于符合过滤规则的类对象不能被注入到容器中，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = <span class="meta">@ComponentScan</span>.Filter(Service<span class="class">.<span class="keyword">class</span>))</span></span><br></pre></td></tr></table></figure><p>上面的注解的作用是，扫描到的类如果被 <code>@Service</code> 修饰，那么该类对象不能被加入到容器中。</p><p>在上面我们知道 <code>Filter</code> 注解中，它的 <code>type</code> 属性为 <code>FilterType.ANNOTATION</code>，即被某注解修饰，他会(<code>includeFilters</code>)/不可以(<code>excludeFilters</code>)加入到容器中，其实 <code>type</code> 还可以有多种取值，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FilterType &#123;</span><br><span class="line">    ANNOTATION,</span><br><span class="line">    ASSIGNABLE_TYPE,</span><br><span class="line">    ASPECTJ,</span><br><span class="line">    REGEX,</span><br><span class="line">    CUSTOM;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们在介绍 <code>FilterType.CUSTOM</code>，这表示我们可以自定义过滤规则，定义过滤规则的类需要实现 <code>TypeFilter</code> 接口。在 <code>custom</code> 中新建 <code>CustomFilter</code> 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> custom.CustomFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">        basePackages = <span class="string">"com.xt.service"</span>, </span><br><span class="line">        includeFilters = </span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(</span><br><span class="line">                type = FilterType.CUSTOM, </span><br><span class="line">                classes = CustomFilter<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">        )</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>CustomFilter</code> 实现的 <code>match</code> 始终返回 <code>true</code>，所以被扫描到的类对象会被无条件的注入到容器中，我们修改 <code>com.xt.service.impl.UserServiceImpl</code> 如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类没有被任何注解修饰，就是一个普通的类，但是它的对象还是会注入到容器中，测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        UserService userService = ac.getBean(<span class="string">"userServiceImpl"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.doService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>对于我们自己写的类，我们可以通过 <code>@Component</code> 及其衍生注解，使得被扫描到时被注入到容器中，但是对于第三方的类库，由于已经被编译为了字节码，我们已经无法修改，即不能再别人的源码上加上注解，那么我们如果想将第三方类库对象注入到容器，我们该怎么办呢，使用 <code>@Bean</code> 可以解决这个问题。<code>@Bean</code> 的定义为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">Autowire <span class="title">autowire</span><span class="params">()</span> <span class="keyword">default</span> Autowire.NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> "<span class="params">(inferred)</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以数据源对象 <code>DataSource</code> 对象为例，首先导入坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在扫描配置类时，会扫描配置类中被 <code>@Bean</code> 注解的方法，会将该方法返回的对象注入到容器中，这是默认的 <code>id</code> 名称为<strong>方法名</strong>。测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        DataSource dataSource = ac.getBean(<span class="string">"createDataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521154944.png" width="70%"/><p>可见容器中有 <code>DataSource</code> 对象了。</p><blockquote><p>如果被 <code>@Bean</code> 注解的方法重载了的话，那么会将重载的方法返回的对象注入容器，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无参函数"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参函数"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个 <code>createJdbcTemplate</code> 方法，根据上面所说，重载的方法，即下面那个有参数的函数返回的对象会被注入到容器中，可以在测试类中测试如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        JdbcTemplate jdbcTemplate = ac.getBean(<span class="string">"createJdbcTemplate"</span>, JdbcTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521163655.png" width="50%"/></blockquote><h3 id="name和value"><a href="#name和value" class="headerlink" title="name和value"></a>name和value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>按照上面的定义，<code>name</code> 和 <code>value</code> 互为别名，它们的作用就是设置注入到容器对象的 <code>id</code> 名称。</p><h3 id="autowireCandidate"><a href="#autowireCandidate" class="headerlink" title="autowireCandidate"></a>autowireCandidate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br></pre></td></tr></table></figure><p>该属性的作用与 <code>@Autowired</code> 有关，当我们使用 <code>@Autowired</code> 自动注入时，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure><p>容器会将其中的 <code>dataSource</code> 对象注入到成员变量中，但是如果 <code>autowireCandidate</code> 设置为 <code>false</code>，那么该对象就不能使用 <code>@Autowired</code> 自动注入，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(autowireCandidate = <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就不能将 <code>dataSource</code> 对象通过 <code>@Autowired</code> 注解自动注入到成员变量 <code>dataSource</code> 中，再次运行测试代码，会抛出异常。</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>在实际的开发中，可能有多个配置类，比如数据库的配置类，那么主配置类就要导入数据库配置类的配置，这时就需要用到 <code>@Import</code> 注解。<code>@Import</code> 注解的定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Import</code> 注解的作用是导入 <code>value</code> 属性所指明的类，将这些类对象注入到容器中，如有下面的数据库配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(@Autowired DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在主配置类中导入该配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(JdbcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在导入 <code>JdbcConfiguration</code> 时，会扫描 <code>JdbcConfiguration</code> 中的方法，将被 <code>@Bean</code> 注解的方法返回的对象注入到容器中，所以这时 <code>DataSource</code> 对象和 <code>JdbcTemplate</code> 对象会被注入到容器中，在测试类测试如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        DataSource dataSource = ac.getBean(<span class="string">"dataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        JdbcTemplate jdbcTemplate = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">assert</span> dataSource != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">assert</span> jdbcTemplate != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类顺利运行，没有报错</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521171027.png" width="40%"/><blockquote><p><code>JdbcConfiguration</code> 它也会被注入容器中，这时它的 <code>id</code> 为它的全限定类名，而不是类名首字母小写，即<code>config.JdbcConfiguration</code></p></blockquote><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>当我们需要动态的决定导入哪些类时，或者需要大量导入类时，我们可以为 <code>@Import</code> 传入自定义导入类，该类需要实现 <code>ImportSelector</code> 接口。该接口中有一个方法 <code>String[] selectImports(AnnotationMetadata annotationMetadata)</code>，该方法返回一个字符串数组，这个数组包含的是要添加到容器中的类名。</p><p>因为我们过滤规则使用 <code>AspectJ</code> 表达式，所以需要导入相关坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们完成这么一个功能，读取配置文件中的过滤规则和要扫描的包，将扫描包中符合过滤规则的类对象添加到容器中，在 <code>resources</code> 下新建 <code>customImport.properties</code> 如下</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.expression</span>=<span class="string">com.xt.service.impl.*</span></span><br><span class="line"><span class="meta">custom.basePackage</span>=<span class="string">com.xt</span></span><br></pre></td></tr></table></figure><p>过滤规则使用 <code>ASPECTJ</code> 格式的过滤规则，扫描的包为 <code>com.xt</code>，新建类 <code>custom.CustomImport</code> 如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.AspectJTypeFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImport</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 AspectJ 表达式表示过滤规则</span></span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line">    <span class="comment">// 扫描的包</span></span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件 初始化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据配置文件获得过滤规则和扫描的包</span></span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadAllProperties(<span class="string">"customImport.properties"</span>);</span><br><span class="line">            expression = properties.getProperty(<span class="string">"custom.expression"</span>);</span><br><span class="line">            basePackage = properties.getProperty(<span class="string">"custom.basePackage"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner = <span class="keyword">new</span> ClassPathScanningCandidateComponentProvider(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 根据 aspectj 表达式转换为对应的过滤器</span></span><br><span class="line">        TypeFilter typeFilter = <span class="keyword">new</span> AspectJTypeFilter(expression, CustomImport<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="comment">// 将过滤器添加到扫描器中</span></span><br><span class="line">        scanner.addIncludeFilter(typeFilter);</span><br><span class="line">        <span class="comment">// 创建 Set 集合保存扫描到的符合过滤规则的类</span></span><br><span class="line">        Set&lt;String&gt; classes = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 使用过滤器扫描指定包，得到符合过滤规则的类 并添加到 classes 中</span></span><br><span class="line">        scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName()));</span><br><span class="line">        <span class="comment">// 将 classes 转换为字符串数组返回</span></span><br><span class="line">        <span class="keyword">return</span> classes.toArray(<span class="keyword">new</span> String[classes.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521205507.png" width="25%"/><p>根据上面的过滤规则，只有 <code>UserServiceImpl</code> 会被添加到容器中(除配置类)，在测试类中测试一番</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String[] names = ac.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name: names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类是获得容器所有对象的 <code>id</code>，并打印出来，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521205739.png" width="70%"/><p>除了前面五个做初始化工作的对象以及配置类对象，只有 <code>UserServiceImpl</code> 被添加到容器中，这次我们修改过滤规则为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">custom.expression=com.xt..*</span><br><span class="line">custom.basePackage=com.xt</span><br></pre></td></tr></table></figure><p><code>Aspectj</code> 表达式为将 <code>com.xt</code> 包及其子孙包下的所有类都添加到容器中，再次运算测试类，输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521210557.png" width="85%"/><p>这时 <code>com.xt.utils.Logger</code> 对象也被添加到容器中了。</p><blockquote><p>注意：上面的 <code>UserServiceImpl</code> 和 <code>Logger</code> 都没有使用任何注解进行修饰，就是一个普通的 <code>Java</code> 类。</p></blockquote><h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p><code>ImportBeanDefinitionRegistrar</code> 的功能同 <code>ImportSelector</code>，不过二者的返回值不同，<code>ImportSelector</code> 返回一个要添加到容器中类名名称组成的数组，而 <code>ImportBeanDefinitionRegistrar</code> 什么都不返回，说明在 <code>ImportBeanDefinitionRegistrar</code> 内部已经将扫描包下符合规则的类添加到容器中去了。现在我们要实现与上面相同的功能，新建 <code>custom.CustomImportBeanDefinitionRegistrar</code>，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.AspectJTypeFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomImportBeanDefinitionRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadAllProperties(<span class="string">"customImport.properties"</span>);</span><br><span class="line">            expression = properties.getProperty(<span class="string">"custom.expression"</span>);</span><br><span class="line">            basePackage = properties.getProperty(<span class="string">"custom.basePackage"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到扫描器</span></span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(registry, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 得到过滤器</span></span><br><span class="line">        TypeFilter typeFilter = <span class="keyword">new</span> AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        scanner.addIncludeFilter(typeFilter);</span><br><span class="line">        <span class="comment">// 扫描指定包 将符合过滤规则的类对象直接注入到容器中</span></span><br><span class="line">        scanner.scan(basePackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的大部分工作与 <code>CustomImport</code> 是一样的，就是最后使用了 <code>ClassPathBeanDefinitionScanner</code> 对象直接扫描包，将符合过滤规则的类对象注入到容器中。配置文件和配置类如下</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.expression</span>=<span class="string">com.xt..*</span></span><br><span class="line"><span class="meta">custom.basePackage</span>=<span class="string">com.xt</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> custom.CustomImportBeanDefinitionRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(CustomImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类与上面相同，运行测试类，结果如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521213142.png" width="70%"/><p>与 <code>ImportSelector</code> 实现的效果相同，不过有一点不同的是，<code>ImportSelector</code> 的 <code>id</code> 生成规则为<strong>全限定类名</strong>，而 <code>ImportBeanDefinitionRegistrar</code> 的 <code>id</code> 为<strong>类名首字母小写</strong>。</p><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p><code>@PropertySource</code> 注解的作用是用来读取资源文件，该注解的定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(PropertySources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">PropertySource</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他不仅可以读取 <code>properties</code> 文件，还可以读取 <code>xml</code> 文件，甚至可以通过自定义 <code>yml</code> 文件解析器读取 <code>yml</code> 文件。</p><p>主配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbc.properties"</span>)</span><br><span class="line"><span class="meta">@Import</span>(&#123;JdbcConfig<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主配置类中读取了配置文件 <code>jdbc.properties</code>，配置文件和 <code>JDBC</code> 配置类 <code>JdbcConfig</code> 如下所示</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/sb</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(@Autowired DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过 <code>PropertySource</code> 读取到的资源，通过 <code>@Value</code> 注解，以 <code>Spring EL</code> 表达式的形式注入到了成员变量中。同时也可以读取 <code>xml</code> 文件，我们新建 <code>jdbc.xml</code>， 内容如下</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM <span class="string">"http://java.sun.com/dtd/properties.dtd"</span>&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;entry key="jdbc.driver"&gt;com.mysql.jdbc.Driver&lt;/entry&gt;</span><br><span class="line">    &lt;entry key=<span class="string">"jdbc.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:3306/sb&lt;/entry&gt;</span></span><br><span class="line">    &lt;entry key="jdbc.username"&gt;root&lt;/entry&gt;</span><br><span class="line">    &lt;entry key="jdbc.password"&gt;root&lt;/entry&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>修改 <code>@PropertySource</code> 的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbc.xml"</span>)</span><br></pre></td></tr></table></figure><p>由上面可以看出，<code>xml</code> 文件相对于 <code>properties</code> 有更加明显的层级关系，结构比较清楚，但是这种优点的代价就是冗余性性很高，为了表达真正有用的信息，加入很多无用的内容。为了整合 <code>properties</code> 和 <code>xml</code> 的优点，人们提出了一个新的格式的文件 <code>YAML</code>(文件后缀名为<code>.yml</code>)，它不仅书写简单，并且可以表达层级关系，新建 <code>jdbc.yml</code> 如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">com.mysql.jdbc.driver</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sb</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>但是 <code>@PropertySource</code> 默认只支持 <code>propeties</code> 和 <code>xml</code> 文件的读取，如果要支持 <code>yml</code> 文件的读取，就需要自己定义解析类，我们可以借助第三方的类库来解析 <code>yml</code> 文件，在 <code>pom.xml</code> 中导入解析 <code>yml</code> 类库的坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在配置类中修改如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"jdbc.yml"</span>, factory = CustomYAMLPropertySourceFactory<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>新建 <code>custom.CustomYAMLPropertySourceFactory</code> 实现 <code>PropertySourceFactory</code> 接口，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertiesPropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.EncodedResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomYAMLPropertySourceFactory</span> <span class="keyword">implements</span> <span class="title">PropertySourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource encodedResource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean factoryBean = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        <span class="comment">// 解析 yaml 文件</span></span><br><span class="line">        factoryBean.setResources(encodedResource.getResource());</span><br><span class="line">        <span class="comment">// 将解析的文件转换为 properties</span></span><br><span class="line">        Properties properties = factoryBean.getObject();</span><br><span class="line">        <span class="comment">// spring 默认能解析 properties，使用 spring 源码的类去解析</span></span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? <span class="keyword">new</span> PropertiesPropertySource(name, properties) : <span class="keyword">new</span> PropertiesPropertySource(encodedResource.getResource().getFilename() ,properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DependsOn"><a href="#DependsOn" class="headerlink" title="@DependsOn"></a>@DependsOn</h2><p>有的时候一个 <code>Bean</code> 对象需要在另一个 <code>Bean</code> 对象注入到容器之后才能注入到容器，比如 <code>One</code> 类对 <code>Two</code> 类有依赖关系，在逻辑上需要先注入 <code>Two</code> 对象，<code>One, Two</code> 的定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">One</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"one被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Two被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522114839.png" width="20%"/><p><code>One</code> 先于 <code>Two</code> 先注入容器中，如果需要 <code>One</code> 在 <code>Two</code> 后，可以加上 <code>@DependsOn</code>,如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.DependsOn;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"two"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">One</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"one被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行测试类</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522115044.png" width="20%"/><p>这时 <code>Two</code> 类对象先被创建。</p><h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p><code>@Lazy</code> 是用来延迟加载时机的，一般我们在初始化容器时，就会将扫描到的类对象注入到容器中，如果对于一个大型的项目，可能会有成千上万个类，如果在一开始就将全部的对象注入到容器，会大大的延缓项目的启动时间，所以为了提高效率，我们可以在需要该类对象时才把对象注入到容器中，还是在上例中，新建 <code>Three</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Three</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"three被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522115609.png" width="40%"/><p>我们只是在测试类中初始化了容器，但是 <code>Three</code> 类对象已经被注入到容器中了。这时我们对 <code>Three</code> 使用 <code>@Lazy</code> 注解，再次运行测试类</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522115834.png" width="40%"/><p>这时 <code>Three</code> 类对象并没有被创建，只有我们第一次向容器获取所需对象时，才会被注入到容器中，修改测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> example.Three;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        Three three = ac.getBean(<span class="string">"three"</span>, Three<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522120057.png" width="40%"/><blockquote><p><strong>注意：</strong><code>@Lazy</code> 注解对于范围为单例的类有效。</p></blockquote><h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p><code>@Conditional</code> 注解是用来设定注入条件的，当扫描到某类或者方法时，是否将该类对象或返回对象注入到容器，根据 <code>@Conditional</code> 指定的条件决定。<code>@Conditional</code> 注解的定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解只有一个 <code>value</code> 属性，该属性的值是一个继承了 <code>Condition</code> 接口的字节码对象，<code>Condition</code> 接口有一个 <code>match</code> 方法，该方法返回一个布尔值，当返回 <code>true</code> 时，可以将对象注入到容器中，否则不行。</p><p>现在我们有两个数据源，一个是 <code>Windows</code> 下的数据源，一个是 <code>Linux</code> 下的数据源，现在我们的任务根据操作系统来决定使用哪个数据源注入到容器中，<code>JdbcConfig</code> 类定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> condition.LinuxCondition;</span><br><span class="line"><span class="keyword">import</span> condition.WindowsCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Conditional</span>(WindowsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataSource</span> <span class="title">createWindowsDataSource</span>() </span>&#123;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="comment">// 用以观察哪个数据源被注入到容器中</span></span><br><span class="line">        System.out.println(<span class="string">"Windows Env"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataSource</span> <span class="title">createLinuxDataSource</span>() </span>&#123;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="comment">// 用以观察哪个数据源被注入到容器中</span></span><br><span class="line">        System.out.println(<span class="string">"Linux Env"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们对 <code>Windows</code> 和 <code>Linux</code> 的数据源都使用了 <code>Conditional</code> 注解，分别使用 <code>WindowsCondition</code> 和 <code>LinuxCondition</code> 类来决定是否注入到容器中，二类的内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得环境对象</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">// 获得操作系统名称</span></span><br><span class="line">        String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(osName);</span><br><span class="line">        <span class="comment">// 如果包含 Windows 则可以注入</span></span><br><span class="line">        <span class="keyword">if</span> (osName.contains(<span class="string">"Windows"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(osName);</span><br><span class="line">        <span class="keyword">if</span> (osName.contains(<span class="string">"Linux"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类和测试类如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="meta">@Import</span>(JdbcConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        DataSource dataSource = ac.getBean(<span class="string">"dataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类，输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522130104.png" width="40%"/><h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p>有的时候我们在不同的环境下注入到容器中的类是不同的，比如开发环境、测试环境和生产环境下三者注入的类是不同的，要实现这样的效果，我们可以使用上面提及的 <code>@Conditional</code> 注解，但是考虑到上述问题比较常见，所以 <code>Spring</code> 为我们提供了 <code>@Profile</code> 注解来实现这样的功能， <code>@Profile</code> 的定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以观察到 <code>@Profile</code> 的底层也是使用了 <code>@Conditional</code> 注解，<code>@Profile</code> 注解只有一个属性值 <code>value</code>，它是用来定义环境名称的，比如我们一般使用 <code>dev</code> 代表开发环境，<code>test</code> 代表测试环境，<code>prod</code> 代表生产环境。</p><p>在配置好类属于哪个环境后，可以通过容器对象中环境对象中的<code>setActiveProfiles()</code>方法来激活对应的环境，这样只有对应环境的类会被注入到容器中，我们新建三个测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dev</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开发环境"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试环境"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产环境"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能传入配置类的所在包 或者配置字节码对象 否则所有三个类都不会被注入</span></span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 设置激活的环境</span></span><br><span class="line">        ac.getEnvironment().setActiveProfiles(<span class="string">"dev"</span>);</span><br><span class="line">        <span class="comment">// 设置配置类</span></span><br><span class="line">        ac.register(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 刷新容器</span></span><br><span class="line">        ac.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522132300.png" width="30%"/><h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><p>我们一般在 <code>Service</code> 层中会用到 <code>Dao</code> 层中的对象，所以在 <code>Service</code> 中一般会有一个 <code>Dao</code> 层的成员变量，这个对象一般是在容器中的，所以 <code>Service</code> 层需要向容器索取对象，我们可以使用注解使得容器中的对象自动注入到对应的成员变量中，下面就介绍几个常用的自动注入注解。</p><h3 id="Autowired和-Qualifier"><a href="#Autowired和-Qualifier" class="headerlink" title="@Autowired和@Qualifier"></a>@Autowired和@Qualifier</h3><p><code>@Autowired</code> 注解首先会根据成员变量的类型去容器中找对应类型的注解，如果有多个相同类型的对象，那么会使用成员变量的名称作为 <code>id</code> 去容器中寻找对应的对象。</p><p><code>JdbcConfig</code> 类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们向容器中注入了两个 <code>DataSource</code> 对象，这时我们在 <code>TestAutowired</code> 中使用 <code>@AutoWired</code> 注解，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAutowired</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在容器中有两个 <code>DataSource</code> 类型的对象，所以 <code>@Autowired</code> 无法根据类型自动注入，所以 <code>@Autowired</code> 会根据变量名 <code>dataSource</code> 作为 <code>id</code> 去容器中寻找对象注入，但是在容器中并没有 <code>id</code> 为 <code>dataSource</code> 的对象，所以不能够成功注入。</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522203827.png"/><p>为了解决上面 <code>@Autowired</code> 注解存在的问题，我们可以通过 <code>@Qualifier</code> 注解指定自动注入的 <code>id</code> 名称，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"dataSource1"</span>)</span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><code>@Qualifier</code> 注解不能单独使用，必须配合 <code>@Autowired</code> 注解或后面提到的 <code>@Inject</code> 注解使用</li><li><code>@Autowired</code> 有一个属性为 <code>required</code>，该属性是规定是否要求一定要注入成功，默认为 <code>true</code>，即必须注入成功，否则抛出异常。</li></ul></blockquote><h3 id="Inject和-Named"><a href="#Inject和-Named" class="headerlink" title="@Inject和@Named"></a>@Inject和@Named</h3><p>使用 <code>@Inject</code> 和 <code>@Named</code> 需要导入对象的坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@Inject</code> 注解是 <code>JSR330</code> 规范规定的注解，它的作用也是实现自动注入注解，它的规则是根据类型自动注入，如果有多个相同类型的对象，那么会保错，与 <code>@Autowired</code> 注解不同，并不会以变量名作为 <code>id</code> 继续寻找。</p><p><code>@Named</code> 注解也是 <code>JSR330</code> 规范规定的注解，它可以和 <code>@Inject</code> 注解配合使用，它是用来设置在容器中的 <code>id</code> 名称的，与 <code>@Qualifier</code> 注解一样，<code>@Named</code> 注解不能单独使用，必须配合 <code>@Autowired</code> 注解或 <code>@Inject</code> 使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"dataSource1"</span>)</span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p><code>@Resource</code> 注解是 <code>JSR250</code> 规范规定的注解，它有一个 <code>name</code> 属性，该属性是用来指定自动注入对象在容器中的 <code>id</code>，同 <code>@Named</code> 和 <code>@Qualifier</code> 不同，他可以单独使用，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"dataSource1"</span>)</span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure><h2 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h2><p>当我们仅仅使用 <code>Autowired</code> 时，如果容器中有多个相同类型的对象且容器没有与成员变量名相同的对象，那么注入是会失败的，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure><p>这时自动注入会失败，这时我们可以使用 <code>@Primary</code> 来表明那个对象时主要的，当有多个类型相同的对象时，优先注入该对象，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时使用 <code>@Autowired</code> 注解，会默认注入这个 <code>DataSource</code> 对象。</p><h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><p>在创建 <code>Bean</code> 后，可能需要做一些初始化的工作，这时我们可以使用 <code>@PostConstruct</code> 注解，在对象被销毁前，可能需要做一些资源的回收工作，这时我们可以使用 <code>@PreDestroy</code>，这两个注解只能放在方法上，新建一个 <code>utils.Logger</code> 类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化工作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"资源回收工作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>@PostContruct</code> 注解了 <code>init</code> 方法和使用 <code>PreDestroy</code> 注解了 <code>destroy</code> 方法，这意味着当创建<code>Logger</code> 对象后会执行 <code>init</code> 方法进行初始化，在 <code>Logger</code> 对象销毁前，会执行 <code>destroy</code> 执行资源回收工作。现进行验证，配置类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"utils"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在创建容器时 会创建 Logger 对象并注入，创建对象后会执行 init 方法</span></span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        <span class="comment">// 销毁容器， Logger 对象会被一同销毁 在销毁前会执行 destroy 方法</span></span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522213747.png" width="50%"/><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1hE411o7w7" target="_blank" rel="noopener">Spring高级之注解驱动开发</a></li><li><a href="https://blog.csdn.net/baidu_37107022/article/details/89163959" target="_blank" rel="noopener">@Profile进行环境切换</a></li></ul>]]></content>
    
    <summary type="html">
    
      Spring常见注解
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Java/Web/"/>
    
    
      <category term="Java Spring 注解开发" scheme="https://lastknightcoder.gitee.io/tags/Java-Spring-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Ajax跨域</title>
    <link href="https://lastknightcoder.gitee.io/Ajax%E8%B7%A8%E5%9F%9F/"/>
    <id>https://lastknightcoder.gitee.io/Ajax%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-04-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>什么是同源策略：同 <code>domain</code>(或<code>IP</code>)，同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源，这种安全限制称为同源策略。我们看几个例子判断两个链接是否是同源</p><table><thead><tr><th><code>url1</code></th><th><code>url2</code></th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://example.com:8080" target="_blank" rel="noopener">http://example.com:8080</a></td><td><a href="http://example.com:80" target="_blank" rel="noopener">http://example.com:80</a></td><td>否</td><td>端口不同</td></tr><tr><td><a href="http://example.com:8080" target="_blank" rel="noopener">http://example.com:8080</a></td><td><a href="https://example.com:8080" target="_blank" rel="noopener">https://example.com:8080</a></td><td>否</td><td>协议不同</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></td><td><a href="http://www.taobao.com" target="_blank" rel="noopener">http://www.taobao.com</a></td><td>否</td><td>域名不同</td></tr><tr><td><a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a></td><td><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></td><td>否</td><td>域名与域名对应的IP地址不同源</td></tr><tr><td><a href="http://example.com:8000/a.js" target="_blank" rel="noopener">http://example.com:8000/a.js</a></td><td><a href="http://example.com:8000/b.js" target="_blank" rel="noopener">http://example.com:8000/b.js</a></td><td>是</td><td>协议，域名，端口相同，子域名不同</td></tr></tbody></table><p>我们首先启动一个 <code>Node</code> 程序作为服务端，启动在本地的 <code>4000</code> 端口，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">4000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务启动在4000端口...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在我们同时在本地的 <code>5501</code> 端口启动一个静态服务器显示网页，在网页中我们发起一个 <code>ajax</code> 请求，向本地的 <code>4000</code> 端口请求数据，即我们刚刚搭的 <code>Node</code> 程序</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.error(<span class="string">'出错了'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://127.0.0.1:4000'</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>这个时候我们打开控制台，发现给出这样的错误信息</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-21_21-23-10.png"/></center><p>因为网页的地址 <code>http://127.0.0.1:5501</code> 与服务器的地址 <code>http://127.0.0.1:4000</code> 它们的端口是不同的，所以它们是不同源的，所以这个请求是跨域的请求，而浏览器是不允许跨域请求的。那么浏览器为什么会提出同源策略，这是出于安全的考虑。同源策略包括两种：</p><ol><li><code>DOM</code> 同源策略：禁止对不同源页面 <code>DOM</code> 进行操作，这里主要场景是 <code>iframe</code> 跨域的情况，不同域名的 <code>iframe</code> 是限制互相访问的</li><li><code>XMLHttpRequest</code> 同源策略：禁止使用 <code>xhr</code> 对象向不同源的服务器地址发起 <code>HTTP</code> 请求</li></ol><p>在这里我们只关注 <code>Ajax</code> 跨域，我们来看一下如果没有同源策略会有什么危害：</p><ol><li>用户登录了自己的银行页面 <a href="http://mybank.com，http://mybank.com" target="_blank" rel="noopener">http://mybank.com，http://mybank.com</a> 向用户的 <code>cookie</code> 中添加用户标识</li><li>用户浏览了恶意页面 <a href="http://evil.com，执行了页面中的恶意" target="_blank" rel="noopener">http://evil.com，执行了页面中的恶意</a> <code>Ajax</code> 请求代码</li><li><a href="http://evil.com" target="_blank" rel="noopener">http://evil.com</a> 向 <a href="http://mybank.com" target="_blank" rel="noopener">http://mybank.com</a> 发起 <code>Ajax HTTP</code> 请求，请求会默认把 <a href="http://mybank.com" target="_blank" rel="noopener">http://mybank.com</a> 对应 <code>cookie</code> 也同时发送过去</li><li>银行页面从发送的 <code>cookie</code> 中提取用户标识，验证用户无误，<code>response</code> 中返回请求数据，此时数据就泄露了</li><li>而且由于 <code>Ajax</code> 在后台执行，用户无法感知这一过程</li></ol><p>所以有了同源策略我们才能够安全的上网，但是很多时候我们还是有跨域的需求的，并且现在随着前后端分离的流行，前端与后端不同源是很有可能，所以迫切需要解决这个问题，下面就介绍两种跨域的方法。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>同源策略提升了 <code>Web</code> 前端的安全性，但牺牲了 <code>Web</code> 拓展上的灵活性。设想若把 <code>html</code>、<code>js</code>、<code>css</code>、<code>flash</code>、<code>image</code> 等文件全部布置在一台服务器上，小网站这样凑活还行，大中网站如果这样做服务器根本受不了的。所以，<strong>现代浏览器在安全性和可用性之间选择了一个平衡点。在遵循同源策略的基础上，选择性地为同源策略开放了后门，</strong> 例如 <code>img</code> <code>script</code> <code>style</code> 等标签，都允许垮域引用资源，严格说这都是不符合同源要求的。</p><p>正是利用 <code>script</code> 标签引用的资源没有同源策略的限制，我们可以通过 <code>script</code> 向服务器发送请求，而服务器返回一个回调，将数据作为参数返回，这一样就可以拿到想要的数据。可能你现在不能明白是什么意思，看下面的代码，我们在页面中添加下面的内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建一个 script 标签用以请求数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> scriptElement = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置请求的地址 并且设置了处理数据的回调函数名称</span></span></span><br><span class="line"><span class="actionscript">    scriptElement.src = <span class="string">'http://127.0.0.1:4000?callback=getData'</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 这一步很重要，不设置的话浏览器会报错 Uncaught SyntaxError: Unexpected identifier</span></span></span><br><span class="line"><span class="actionscript">    scriptElement.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 将这个 script 标签添加到 body 中</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(scriptElement);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Node</code> 服务端的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> qs = querystring.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]); <span class="comment">// 解析请求参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">"Hello World"</span>; <span class="comment">// 返回的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一定要在 $&#123;data&#125; 两端加上双引号，否则浏览器得到的是 getData(Hello World)会报错</span></span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;qs.callback&#125;</span>("<span class="subst">$&#123;data&#125;</span>")`</span>); <span class="comment">// 即getData(data)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">4000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务启动在4000端口...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-21_23-04-21.png"/></center><p>我来理一下上面的步骤</p><ol><li><p>首先创建了一个函数 <code>getData</code>，该函数的作用是用来处理数据的，接收的那个参数就是数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 <code>script</code> 标签，并且设置了请求的地址，以及将处理数据函数的名称即 <code>getData</code> 作为参数传入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script.src = <span class="string">'http://127.0.0.1:4000?callback=getData'</span>;</span><br></pre></td></tr></table></figure></li><li><p>服务器接到请求，将要返回的数据作为传入的回调函数的参数传入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.end(<span class="string">`<span class="subst">$&#123;qs.callback&#125;</span>("<span class="subst">$&#123;data&#125;</span>")`</span>); <span class="comment">// 即getData(data)</span></span><br></pre></td></tr></table></figure></li><li><p><code>script</code> 标签得到服务器返回的数据，即 <code>getData(&quot;Hello World&quot;)</code>，<code>script</code> 得到的数据是可执行的代码，所以会执行 <code>getData()</code> 方法，这样数据 <code>Hello World</code> 就作为参数传递给了 <code>getData()</code></p></li></ol><blockquote><p>优点：</p><ul><li>使用简便，没有兼容性问题，是目前最流行的跨域方法</li></ul><p>缺点：</p><ul><li>只支持 <code>GET</code> 请求，并且代码是从其他域得到的，不排除可能有恶意代码，所以使用该方法，服务端必须确保值得信任</li><li>要确定 <code>JSONP</code> 请求失败并不容易</li></ul></blockquote><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p><code>CORS</code>(<code>Cross-origin resource sharing</code>，跨域资源共享) 是一个 <code>W3C</code> 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。<code>CORS</code> 背后的基本思想，就是使用自定义的 <code>HTTP</code> 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。<code>CORS</code> 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，<code>IE</code> 浏览器不能低于 <code>IE10</code>。</p><p>对于开发者来说，我们只要正常的发出 <code>Ajax</code> 请求即可，与之前没有任何区别，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.error(<span class="string">'出错了'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://127.0.0.1:4000'</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>但是在服务端，我们要设置一下信赖的请求来源，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 表示来自 http://127.0.0.1:5501 的请求可以拿到数据</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://127.0.0.1:5501'</span>)</span><br><span class="line">    res.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">4000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务启动在4000端口...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了可以设置请求来源，还可以设置允许的方法，允许的头部等等</p><table><thead><tr><th>响应头</th><th>作用</th></tr></thead><tbody><tr><td><code>Access-Control-Allow-Origin</code></td><td>设置允许的请求来源，如果允许任意来源，可以设置为 <code>*</code></td></tr><tr><td><code>Access-Control-Allow-Methods</code></td><td>允许的方法，多个以逗号分隔，如 <code>GET</code>, <code>POST</code></td></tr><tr><td><code>Access-Control-Allow-Headers</code></td><td>允许的请求头，多个以逗号分隔</td></tr></tbody></table><p>浏览器将 <code>CORS</code> 请求分为两类，分别为简单请求和非简单请求。如果满足以下两类请求，就是简单请求</p><ol><li>请求方法是以下三种方法之一：<ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul></li><li><code>HTTP</code> 的头信息不超出以下几种字段：<ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code>：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li></ol><p>如果不满足以上的两大条件，那么就是非简单请求，而浏览器对于简单请求和非简单请求的处理是不一样的。</p><p><strong>简单请求</strong></p><ol><li><p>在请求中需要附加一个额外的 <code>Origin</code> 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：<code>Origin: http://127.0.0.1:5501</code></p></li><li><p>如果服务器认为这个请求可以接受，就在 <code>Access-Control-Allow-Origin</code> 头部中回发相同的源信息(如果是公共资源，可以回发 <code>*</code>)，例如：<code>Access-Control-Allow-Origin：http://127.0.0.1:5501</code></p></li><li><p>没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，注意，请求和响应都不包含 <code>cookie</code> 信息</p></li><li><p>如果需要包含 <code>cookie</code> 信息，<code>ajax</code> 请求需要设置 <code>xhr</code> 的属性 <code>withCredentials</code> 为 <code>true</code>，服务器需要设置响应头部 <code>Access-Control-Allow-Credentials: true</code></p></li></ol><p><strong>非简单请求</strong></p><p>非简单请求可能对服务器数据产生副作用，浏览器必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求(<code>preflight request</code>)，从而获知服务端是否允许该跨域请求，</p><ul><li><code>Origin</code>：与简单的请求相同</li><li><code>Access-Control-Request-Method</code>: 请求自身使用的方法</li><li><code>Access-Control-Request-Headers</code>: (可选)自定义的头部信息，多个头部以逗号分隔</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Origin</span>: http://127.0.0.1:5501</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: NCZ</span><br></pre></td></tr></table></figure><p>发送这个请求后，服务器可以决定是否允许这种类型的请求，一旦服务器通过 <code>Preflight</code> 请求，允许该请求之后，以后每次浏览器正常的 <code>CORS</code> 请求，就都跟简单请求一样了。</p><blockquote><p>优点：</p><ul><li><code>CORS</code> 通信与同源的 <code>AJAX</code> 通信没有差别，代码完全一样，容易维护</li><li>支持所有类型的 <code>HTTP</code> 请求</li></ul><p>缺点：</p><ul><li>存在兼容性问题，特别是 <code>IE10</code> 以下的浏览器</li><li>第一次发送非简单请求时会多一次请求</li></ul></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/28562290" target="_blank" rel="noopener">跨域的那些事儿</a></li><li><a href="https://juejin.im/post/5ba1d4fe6fb9a05ce873d4ad" target="_blank" rel="noopener">浏览器同源策略及跨域的解决方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      讲解Ajax跨域相关知识
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="Ajax" scheme="https://lastknightcoder.gitee.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript柯里化</title>
    <link href="https://lastknightcoder.gitee.io/JavaScript%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://lastknightcoder.gitee.io/JavaScript%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="柯里化介绍"><a href="#柯里化介绍" class="headerlink" title="柯里化介绍"></a>柯里化介绍</h2><p>函数柯里化指的是函数处理一部分的参数，然后返回一个函数来处理剩余的参数，如比如有一个加法函数如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>现在如果这个函数被柯里化，那么我们可以如下使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> increment = add(<span class="number">1</span>); <span class="comment">// 接收第一个参数，返回一个函数处理第二个参数</span></span><br><span class="line">increment(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">increment(<span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><p>现在怎么实现这种效果，如果只是针对上面的加法函数，那么可以如下实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法明显只对加法函数有效，我们现在是想设计一个函数，它接收一个函数为参数，作用就是把这个函数柯里化，并将这个柯里化的函数返回，比如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curryAdd = curry(add); <span class="comment">// 接收add函数，将函数add柯里化</span></span><br><span class="line"><span class="keyword">const</span> increment = curryAdd(<span class="number">1</span>);</span><br><span class="line">increment(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">increment(<span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>首先实现一个简单版本的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        fn(...args1, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个函数明显有一个缺陷，那就是只能传入两次参数，怎么解决，肯定使用递归了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length == args1.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(...args1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> curry(fn, ...args1, ...args2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数首先判断接收的参数的个数与函数要求参数的个数是否相同，如果相同则直接执行函数，否则返回一个函数来处理剩下的参数，这样就可以实现函数的柯里化。</p><h2 id="柯里化应用举例"><a href="#柯里化应用举例" class="headerlink" title="柯里化应用举例"></a>柯里化应用举例</h2><p>现在来看一下柯里化有什么用处，假设有一个 <code>ajax</code> 请求的函数如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">type, url, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onReadystateChange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(type, url);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将这个函数柯里化</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> curriedAjax = curry(ajax);</span><br><span class="line"><span class="keyword">let</span> post = curriedAjax(<span class="string">'post'</span>);</span><br></pre></td></tr></table></figure><p>我们向 <code>curriedAjax</code> 传入一个参数 <code>post</code>，得到一个函数，这个函数的作用是用来发 <code>post</code> 请求的，我们每次发 <code>post</code> 请求时，只需要使用 <code>post</code> 方法即可，这样函数的复用性有了极大的增强，我们可以继续传入参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postGoogle = post(<span class="string">'https://www.google.com'</span>);</span><br></pre></td></tr></table></figure><p>我们又得到了一个函数，该函数的作用是向 <code>https://www.google.com</code> 发送 <code>post</code> 请求，函数的复用性又进一步的提升。</p><blockquote><p>使用过 <code>jQuery</code> 的都知道，可以使用 <code>$.ajax()</code> 这样的通用方法，但是也有 <code>$.get()</code> 和 <code>$.post()</code> 这样的语法糖，但是 <code>jQuery</code> 底部是不是这样实现的就不得而知了。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.im/post/5af13664f265da0ba266efcf" target="_blank" rel="noopener">大佬，JavaScript 柯里化，了解一下</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li></ul>]]></content>
    
    <summary type="html">
    
      JavaScript柯里化
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="JavaScript 柯里化" scheme="https://lastknightcoder.gitee.io/tags/JavaScript-%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="https://lastknightcoder.gitee.io/JavaScript%E9%97%AD%E5%8C%85/"/>
    <id>https://lastknightcoder.gitee.io/JavaScript%E9%97%AD%E5%8C%85/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-04-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript的作用域"><a href="#JavaScript的作用域" class="headerlink" title="JavaScript的作用域"></a>JavaScript的作用域</h2><p><code>JavaScript</code> 的作用域有两种</p><ul><li>全局作用域</li><li>函数作用域</li></ul><p>与其他语言不同的是，<code>JavaScript</code> 没有块级作用域，参考以下程序</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的变量 <code>x</code> 定义在 <code>if</code> 的语句块中，在其他的语言中，<code>x</code> 在语句块外是访问不到的，但是由于 <code>JavaScript</code> 没有块级作用域，所以变量 <code>x</code> 是全局变量，所以在语句块外也可以被访问到。</p><blockquote><p>注意：</p><p>上面的讨论是基于 <code>ES5</code> 的，在 <code>ES6</code> 中，通过关键字 <code>let</code> 或 <code>const</code> 声明的变量，可以实现块级作用域的效果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// not defined</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="JavaScript-作用域链"><a href="#JavaScript-作用域链" class="headerlink" title="JavaScript 作用域链"></a>JavaScript 作用域链</h2><p><code>JavaScript</code> 作用域链指的是查找变量的顺序，比如下面的程序</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在上面的程序中，我们在 <code>bar()</code> 函数中访问了变量 <code>i</code>，这时 <code>bar()</code> 会先在 <code>bar()</code> 函数内部查找是否有变量 <code>i</code>，如果没有，则会去 <code>bar()</code> 函数的上一级作用域即 <code>foo()</code> 函数中寻找，如果还没有，则会去全局作用域寻找，如果没有找到，则会报错变量未定义，所以上述 <code>bar()</code> 函数的作用域链为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar --&gt; foo --&gt; 全局作用域</span><br></pre></td></tr></table></figure><p>编译器会根据作用域链去寻找变量，如果没有找到则会报错。</p><h2 id="闭包介绍"><a href="#闭包介绍" class="headerlink" title="闭包介绍"></a>闭包介绍</h2><p>什么是闭包，简单的说就是允许函数访问并操作函数外部的变量，只要该变量处于该函数的作用域链中，比如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = foo();</span><br><span class="line">func(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>函数 <code>foo()</code> 返回了一个函数，返回的这个函数中访问了变量 <code>x</code>，根据我们的讲解，会根据这个函数的作用域链去寻找这个变量 <code>x</code>，该匿名函数定义时的作用域链</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回的匿名函数 --&gt; foo --&gt; 全局作用域</span><br></pre></td></tr></table></figure><p>所以当执行该匿名函数时，会根据上述的作用域链去寻找变量 <code>x</code>，会在 <code>foo</code> 中找到变量 <code>x</code>，所以输出的结果是 <code>1</code>。</p><p>你可能会有这样的疑惑，当执行完函数 <code>foo()</code> 后，变量 <code>x</code> 不是应该已经被销毁了吗，为什么还能够被访问。之所以会有这样的想法，可能是受其他编程语言的影响，如 <code>C</code>，<code>Java</code> 等，但是要明白 <code>JavaScript</code> 与这些编程语言不同，至少 <code>Java</code> 不能够返回函数，因为返回的函数还保存着对变量 <code>x</code> 的引用，所以变量 <code>x</code> 在执行完 <code>foo()</code> 之后是不会被清除的，这就是还能够访问 <code>x</code> 的原因。</p><p>那接下来看一个例子，看看你是否明白了闭包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序的效果是延时 <code>i * 100 ms</code> 打印输出 <code>i</code>，你可能希望得到下面这样的输出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>但是真正的结果是</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>这是因为 <code>setTimeout</code> 是一个异步函数，当执行 <code>setTimeout</code> 时，并不会立即执行传入的回调函数，这些回调函数等到延迟时间到了以后，会将这些回调函数放入事件队列中，简单来说，当执行到 <code>setTimeout</code> 函数时，不会有任何的阻碍直接进入下一轮循环，等到循环执行完毕，编译器会取出事件队列中的函数执行(这些回调函数并不是执行到 <code>setTimeout</code> 方法时立即被添加到事件队列中的，而是等到设定的延迟时间后再添加到事件队列中的)，所以当执行这些回调函数时，循环已经执行完毕，变量 <code>i</code> 的值已经变为了 <code>10</code>，这些回调函数根据它的作用域链找到的变量 <code>i</code> 的值就全部是 <code>10</code> 了。</p><h2 id="闭包实现私有变量"><a href="#闭包实现私有变量" class="headerlink" title="闭包实现私有变量"></a>闭包实现私有变量</h2><p>在 <code>JavaScript</code> 中是没有关键字去声明私有变量的，但是我们可以通过闭包来实现这样的效果，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'ninja'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// 访问不到 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// ninja</span></span><br><span class="line">person.setName(<span class="string">'dummy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// dummy</span></span><br></pre></td></tr></table></figure><p>通过闭包，<code>setName</code> 和 <code>getName</code> 可以对 <code>name</code> 进行访问和操作，但是却不能够被实例变量 <code>person</code> 访问到，因为 <code>name</code> 并不是 <code>person</code> 的属性，这样我们就实现了私有变量。</p><h2 id="闭包处理回调函数"><a href="#闭包处理回调函数" class="headerlink" title="闭包处理回调函数"></a>闭包处理回调函数</h2><p>假设有这么一个动画函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tick = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animateIt</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tick &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            element.style.left = element.style.top = tick + <span class="string">"px"</span>;</span><br><span class="line">            tick++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现在 <code>1s</code> 内将元素向下和向右平移 <code>100px</code>，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    animateIt(<span class="string">"box1"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004172341.gif"/></center><p>但是当我们同时对两个元素使用动画时，由于二者共享变量 <code>tick</code>，则会导致二者的动画状态发生冲突，所以我们改动如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animateIt</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tick = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tick &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            element.style.left = element.style.top = tick + <span class="string">"px"</span>;</span><br><span class="line">            tick++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    animateIt(<span class="string">"box1"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box2"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    animateIt(<span class="string">"box2"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们将 <code>tick</code> 定义在函数内，由于闭包，<code>setInteval</code> 中的回调函数可以访问到tick，并且两个不同<code>id</code> 元素的<code>tick</code>是不同的，不会相互干扰</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004080010.gif"/></center>]]></content>
    
    <summary type="html">
    
      JavaScript闭包介绍
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="JavaScript 闭包" scheme="https://lastknightcoder.gitee.io/tags/JavaScript-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://lastknightcoder.gitee.io/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://lastknightcoder.gitee.io/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> ListNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果只是反过来打印节点的值，那么很简单，只要遍历链表，将节点的值 <code>push</code> 到一个栈里面，因为栈的特点是后进先出，所以最后我们遍历栈，达到的效果就是将链表从尾到头打印，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListReverse</span><span class="params">(ListNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode cur = root;</span><br><span class="line">    <span class="comment">// 遍历链表 将值添加到栈中</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(cur.value);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历栈 打印栈头的值</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种方法就是使用递归，对于任意一个节点，反过来打印即先打印下一个节点，然后在打印当前节点，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListReverse2</span><span class="params">(ListNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 既是递归退出的条件 也是对传入的链表进行检查</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printListReverse2(root.next);</span><br><span class="line">    System.out.println(root.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer 链表" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://lastknightcoder.gitee.io/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://lastknightcoder.gitee.io/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-04-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>首先将这个二维数组看做是一个矩阵，考虑这么一个思路，首先在矩阵中选取一个数，如果要查找的数大于这个数，那么该数应该在选取数字的下方或者右方，如果该数小于选取的数，那么这个数应该在选取数字的上方或者左方，无论怎样，查找的数都会在选取位置的两个区域都出现，并且这两个区域有重叠的部分，这使得问题较为复杂，</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200530165950.png" width="60%"/></center><p>现在不妨换一种思路，我们从右上角开始进行查找，如果查找的数比右上角的数小，那么该数只可能在左方，如果查找的数比右上角大，那么该数只可能在下方，查找的数都只会在一个区域出现，要么在左方，要么在下方，每一次查找都会使得查找的区域变小，下面以查找数字<code>5</code>为例</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200530170034.png" width="60%"/></center><p>代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findInMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得矩阵的行数和列数</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix != <span class="keyword">null</span> &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; columns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从右上角开始查找</span></span><br><span class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> column = columns - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 继续查找的条件</span></span><br><span class="line">            <span class="keyword">while</span> (row &lt; rows &amp;&amp; columns &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][column] == number) &#123;</span><br><span class="line">                    <span class="comment">// 找到退出while循环</span></span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &gt; number) &#123;</span><br><span class="line">                    <span class="comment">// 比右上角小 在左方</span></span><br><span class="line">                    column--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则比右上角大 在下方</span></span><br><span class="line">                    row++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> found = findInMatrix(matrix, <span class="number">2</span>);</span><br><span class="line">        System.out.println(found);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先将这个二维数组看做是一个矩阵
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组查找" scheme="https://lastknightcoder.gitee.io/tags/%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>jQuery系统教程</title>
    <link href="https://lastknightcoder.gitee.io/jQuery%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"/>
    <id>https://lastknightcoder.gitee.io/jQuery%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-07T15:00:00.000Z</published>
    <updated>2020-04-07T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是在完整学习 <code>jQuery</code> 以后，系统整理的教程，大纲如下</p><ul><li><code>jQuery</code> 的核心函数 <code>$, jQuery</code></li><li>操作 <code>jQuery</code> 集合</li><li>操作 <code>DOM</code> 元素的属性和类属性</li><li>操作样式</li><li>操作 <code>DOM</code> 元素(添加，删除…)</li><li><code>jQuery</code> 事件</li><li><code>jQuery</code> 显示与隐藏</li><li><code>jQuery</code> 动画</li><li><code>jQuery</code> 扩展及实用函数</li><li><code>Ajax</code></li></ul><h2 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h2><p><code>jQuery</code> 这个库中最重要的就是它提供的核心函数 <code>jQuery()</code> ，它提供了非常强大的功能，因为这个函数用的十分的频繁，所以提供了 <code>jQuery()</code> 的别名，那就是 <code>$()</code> ，在后面的演示中都将会以 <code>$</code> 为例，现在我们来看一下该核心函数提供了哪些功能</p><ul><li>选择多个 <code>DOM</code> 元素</li><li>将 <code>HTML</code> 字符串得解析为一个 <code>DOM</code> 元素</li><li>作为入口函数</li><li>将 <code>DOM</code> 元素转换为 <code>jQuery</code> 集合</li></ul><p>上面有些名词可能没有听过，这里只是感性了解一下，下面就具体讲解。</p><h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><p>考虑下面的 <code>DOM</code> 结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用原生的 <code>JavaScript</code> 选择上面的元素的写法如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">"container"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>而现在使用 <code>$()</code> 函数，为其传入 <code>CSS</code> 的选择器即可选中元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#box"</span>);</span><br><span class="line">$(<span class="string">".container"</span>);</span><br><span class="line">$(<span class="string">"p"</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>$()</code> 得到的是一个集合，即使使用了 <code>id</code> 选择器 <code>#box</code> ，得到也是一个只有一个元素的集合，如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_17-26-17.png"/></center><p>我们把它称为 <code>jQuery</code> 对象或者 <code>jQuery</code> 集合，在下面我将不会区分二者，可能会混合使用，请注意。由上可见， <code>jQuery</code> 对象的结构像是一个数组，但它不是真正的数组，因为他不是 <code>Array</code> 的实例，只是使用对象来模拟数组， <code>jQuery</code> 对象中的元素(借用数组的概念)是被选择的 <code>DOM</code> 元素。 <code>jQuery</code> 的核心函数支持几乎所有的 <code>CSS</code> 选择器，如</p><ul><li><p>属性选择器</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[value]</span> <span class="comment">/* 选择有 value 属性的 input 标签 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">'text'</span>]</span> <span class="comment">/* 选择 type 为 text 的 input 标签 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">'http://'</span>]</span> <span class="comment">/* 选择 href 以 http:// 开头的 a 标签 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">'pdf'</span>]</span> <span class="comment">/* 选择 href 以 pdf 结尾的 a 标签 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">'jquery'</span>]</span> <span class="comment">/* 选择 href 属性包含 jquery 的 a 标签 */</span></span><br></pre></td></tr></table></figure></li><li><p>伪类选择器</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:first</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:odd</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:even</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span></span><br></pre></td></tr></table></figure></li><li><p>过滤器</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:animated</span> <span class="comment">/* 处于动画状态的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:checkbox</span> <span class="comment">/* 相当于 input[type='chexkbox'] */</span></span><br><span class="line"><span class="selector-pseudo">:checked</span> <span class="comment">/* 选择处于选中状态的多选框或单选框 */</span></span><br><span class="line"><span class="selector-pseudo">:disabled</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>…</p></li></ul><p>选择器十分的多，由于重点不在于选择器，另外这个也没有什么原理可讲，也就是 <code>API</code> 的使用，随着使用 <code>jQuery</code> 的增多，自然会掌握，所以这里就点到即止。</p><h3 id="将-HTML-字符串转化为-jQuery-对象"><a href="#将-HTML-字符串转化为-jQuery-对象" class="headerlink" title="将 HTML 字符串转化为 jQuery 对象"></a>将 HTML 字符串转化为 jQuery 对象</h3><p>这里首先解释一下什么叫做 HTML 字符串，不给出具体的定义，很好理解，形如下面的字符串就叫做 HTML 字符串</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&lt;p&gt;123&lt;/p&gt;"</span></span><br><span class="line"><span class="string">"&lt;h1&gt;一级标题&lt;/h1&gt;"</span></span><br></pre></td></tr></table></figure><p>当我们向 <code>jQuery</code> 的核心函数传递这样的字符串时，核心函数会将该字符串解析得到一个 <code>jQuery</code> 对象，如</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_17-49-32.png"/></center><h3 id="作为入口函数"><a href="#作为入口函数" class="headerlink" title="作为入口函数"></a>作为入口函数</h3><p>因为我们一般会在 <code>JavaScript</code> 中操作 <code>DOM</code> ，所以我们一般会等到 <code>DOM</code> 树渲染完毕之后再去执行 <code>JavaScript</code> 代码，所以我们一般把 <code>script</code> 标签放在 <code>body</code> 元素的最后面，或者将代码放在 <code>window.onload</code> 中，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onload</code> 方法会在 <code>DOM</code> 树渲染完毕，并且外部资源如图片等等加载完毕后会执行，虽然能够满足我们的需求，但是在等待静态资源加载的时候，用户是不能与页面进行交互的，这时用户就会感觉页面卡死了，体验感十分不好。我们只是希望在 <code>DOM</code> 树渲染完毕后就执行代码，那么可以使用 <code>ready()</code> 函数，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里要执行的代码在 <code>DOM</code> 树渲染完毕后即可执行，而不必等到资源加载完毕。上面的写法可以简写为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="将-DOM-元素转化为-jQuery-对象"><a href="#将-DOM-元素转化为-jQuery-对象" class="headerlink" title="将 DOM 元素转化为 jQuery 对象"></a>将 DOM 元素转化为 jQuery 对象</h3><p>为核心函数传入 <code>DOM</code> 元素，会返回一个 <code>jQuery</code>对象，该对象包含了这个 <code>DOM</code> 元素，如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_18-42-49.png"/></center><p>将 <code>DOM</code> 元素转化为 <code>jQuery</code> 对象可以使用 <code>jQuery</code> 对象原型上的方法，这些方法想较于原生方法方便很多。</p><blockquote><p>如何将 <code>jQuery</code> 对象转化为DOM元素呢? 我们知道 <code>jQuery</code> 对象的结构是类似于数组，其中的每一个元素都是 <code>DOM</code> 对象，我们可以使用下标的方式获取 <code>DOM</code> 元素，如下两种方法都是可以的</p><ul><li><code>jQuery对象[index]</code></li><li><code>jQuery对象.get(index)</code>，该方法可以接受负数，表示倒数</li></ul></blockquote><h2 id="操作-jQuery-集合"><a href="#操作-jQuery-集合" class="headerlink" title="操作 jQuery 集合"></a>操作 jQuery 集合</h2><p>在本节会使用 <code>jQuery</code> 集合这一叫法，因为往里面添加元素或者删除元素等等操作，集合的叫法比对象的叫法更加的符合。如果不做说明，下面操作的<code>DOM</code>为以下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用 <code>jQuery</code> 集合调用 <code>add</code> 方法为集合添加元素， <code>add</code> 方法可以接收不同类型的参数，如下</p><ul><li><code>jQuery</code> 选择器：将与 <code>jQuery</code> 选择器匹配的所有 <code>DOM</code> 元素添加到集合中</li><li><code>DOM</code> 元素或 DOM 元素组成的数组：将 <code>DOM</code> 元素或数组中的元素添加到集合中</li><li><code>HTML</code> 字符串：将 <code>HTML</code> 字符串解析为 <code>DOM</code> 元素后添加到集合中</li></ul><p>该方法会返回一个新的 <code>jQuery</code> 集合，例子如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = $(<span class="string">"#box"</span>);</span><br><span class="line">collection = collection.add(<span class="string">".container"</span>); <span class="comment">// 添加一个 jQuery 选择器</span></span><br><span class="line">collection = collection.add(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>]); <span class="comment">// 添加一个 DOM 元素</span></span><br><span class="line">collection = collection.add(<span class="string">"&lt;h1&gt;123&lt;/h1&gt;"</span>); <span class="comment">// 添加一个 HTML 字符串</span></span><br><span class="line"><span class="built_in">console</span>.dir(collection);</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_19-33-07.png"/></center><h3 id="过滤元素"><a href="#过滤元素" class="headerlink" title="过滤元素"></a>过滤元素</h3><p>过滤集合中的元素有两种方法，一个是 <code>not</code>，一个是 <code>filter</code>，两个方法的侧重点不同， <code>not</code> 方法会删除掉集合中符合条件的元素，返回新集合；而 <code>filter</code> 的语义是保留集合中符合条件的元素，返回一个新集合。二者接收的参数同 <code>add</code> 方法一样，除此之外，还可以接受一个函数，集合中的每一个元会素调用该函数，根据函数的返回值来决定元素的去留，比如对于 <code>not</code> 方法，如果函数返回 <code>true</code>，则删除此元素，对于 <code>filter</code> 则相反，如果返回 <code>true</code>，则保留此元素。这些传入的函数中的上下文(也就是 <code>this</code>)指向调用该函数的元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = $(<span class="string">"#box"</span>);</span><br><span class="line">collection = collection.add(<span class="string">".container"</span>); <span class="comment">// 添加一个 jQuery 选择器</span></span><br><span class="line">collection = collection.add(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>]); <span class="comment">// 添加一个 DOM 元素</span></span><br><span class="line">collection = collection.add(<span class="string">"&lt;h1&gt;123&lt;/h1&gt;"</span>); <span class="comment">// 添加一个 HTML 字符串</span></span><br><span class="line">collection = collection.not(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="keyword">this</span>).html() === <span class="string">"123"</span>; <span class="comment">// 删除掉 html 内容为 123 的，也就是 h1 标签</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.dir(collection);</span><br></pre></td></tr></table></figure><p>根据上面的代码，此时集合中只有三个元素，将 <code>h1</code> 元素滤除了</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_19-48-05.png"/></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = $(<span class="string">"#box"</span>);</span><br><span class="line">collection = collection.add(<span class="string">".container"</span>); <span class="comment">// 添加一个 jQuery 选择器</span></span><br><span class="line">collection = collection.add(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>]); <span class="comment">// 添加一个 DOM 元素</span></span><br><span class="line">collection = collection.add(<span class="string">"&lt;h1&gt;123&lt;/h1&gt;"</span>); <span class="comment">// 添加一个 HTML 字符串</span></span><br><span class="line">collection = collection.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="keyword">this</span>).html() === <span class="string">"123"</span>; <span class="comment">// 保留 html 内容为 123 的，也就是 h1 标签</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.dir(collection);</span><br></pre></td></tr></table></figure><p>将上面的 <code>not</code> 改为 <code>filter</code>，这时集合里面就只有一个元素，那就是 <code>h1</code> 元素</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_19-50-33.png"/></center><blockquote><p>通过上面几个方法的学习，我们知道这些方法返回的都是一个新的 <code>jQuery</code> 集合，这意味着可以接着<code>.</code>，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = $(<span class="string">"#box"</span>)</span><br><span class="line">                    .add(<span class="string">".container"</span>)</span><br><span class="line">                    .add(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>])</span><br><span class="line">                    .add(<span class="string">"&lt;h1&gt;123&lt;/h1&gt;"</span>)</span><br><span class="line">                    .filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> $(<span class="keyword">this</span>).html() === <span class="string">"123"</span>;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>这样写起来明显比上面写起来爽多了，这种写法叫做链式编程，像链子一样，一个接着一个。</p></blockquote><h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><p>使用 <code>each</code> 方法遍历集合，该方法接收一个函数，集合中的每一个元素都会调用 <code>each</code> 中传入的函数，该函数的上下文会被设定为该元素，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="keyword">this</span>).html())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_20-44-18.png"/></center><h3 id="集合查找"><a href="#集合查找" class="headerlink" title="集合查找"></a>集合查找</h3><ul><li><p><code>is(selector)</code>：判断是否集合中是否包含与选择器匹配的元素，包含返回 <code>true</code>，否则返回 <code>false</code></p></li><li><p><code>has(test)</code>：<code>test</code> 可以为选择器，也可以为 <code>DOM</code> 元素，它判断的是集合中的元素的后代中是否包含与 <code>test</code> 匹配的元素，如果集合中某元素 <code>e</code> 的后代包含与 <code>test</code> 匹配的元素，则将元素 <code>e</code> 添加到新的集合中，最后返回该集合，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).has(<span class="string">"ol"</span>); <span class="comment">// $("div")中有两个元素，只有第一个div元素的后代有ol元素，所以返回的新的集合中包含一个元素，是第一个div元素</span></span><br><span class="line">$(<span class="string">"div"</span>).has(<span class="string">"li"</span>); <span class="comment">// 两个元素的后代都有li元素，所以新集合中的元素与原集合相同</span></span><br></pre></td></tr></table></figure></li><li><p><code>find(selector)</code>：该方法会遍历集合中的所有元素，在这些元素的后代找到匹配 <code>selector</code> 的元素，然后将这些匹配的元素添加到一个新的集合中，并返回该新的集合</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).find(<span class="string">"img"</span>) <span class="comment">// 在所有div标签中找到img标签，返回这些img标签组成的集合</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="转换集合"><a href="#转换集合" class="headerlink" title="转换集合"></a>转换集合</h3><p><code>jQuery</code> 对象有一个 <code>map</code> 方法，该方法与数组的 <code>map</code> 方法一样，接收一个回调函数，集合中的每一个元素都会调用该函数，该函数的返回值会被添加到新的集合中并返回(如果返回的是 <code>null</code> 或者 <code>undefined</code> 则不会添加到新的集合中)，该函数有两个参数，第一个参数是元素在集合中的下标，第二个参数是调用该函数的元素。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">    <span class="comment">// get()方法会将集合转变为一个真正的数组</span></span><br><span class="line">&#125;).get().join(<span class="string">", "</span>); <span class="comment">//"0, 1, 2, 3, 4"</span></span><br></pre></td></tr></table></figure><h2 id="操作-DOM-元素的属性和类属性"><a href="#操作-DOM-元素的属性和类属性" class="headerlink" title="操作 DOM 元素的属性和类属性"></a>操作 DOM 元素的属性和类属性</h2><h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><p>我们可以使用<code>attr()</code>方法方便的操作 <code>DOM</code> 元素的属性</p><ul><li><p><code>attr(name, value)</code>：为名字为 <code>name</code> 的属性设置值为 <code>value</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).attr(<span class="string">"id"</span>, <span class="string">"box"</span>); <span class="comment">// 将所有 div 标签的 id 设置为 box</span></span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-07_21-14-36.png"/></center></li><li><p><code>attr(name)</code>：获取集合中第一个元素中属性名字为 <code>name</code> 的值</p></li><li><p><code>attr(attributes)</code>：以对象的形式来设置属性值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">".attr"</span>).attr(&#123;</span><br><span class="line">    title: <span class="string">"cat"</span>, <span class="comment">// 设置 title 属性为 cat</span></span><br><span class="line">    id: <span class="string">"cat"</span> <span class="comment">// 设置 id 属性为 cat</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>removeAttr(name)</code>：删除指定名称的属性</p></li></ul><blockquote><p>经过测试，发现 <code>attr()</code> 方法可以设置任意属性的值(我的意思是指即使这些属性是不存在的，比如  <code>dog</code> 也可以设置，而这些不存在的属性称为自定义属性)，比如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">attr(<span class="string">"dog"</span>, <span class="string">"dog"</span>); <span class="comment">// 为 dog 属性设置值为 dog</span></span><br></pre></td></tr></table></figure><p>上面的 <code>dog</code> 就是自定义的属性名。在 <code>HTML5</code> 中建议自定义属性名以 <code>data-</code> 开头，如 <code>data-dog</code>， <code>HTML5</code> 会将 <code>data-</code> 开头的属性名添加到 <code>dataset</code> 的对象中，我们可以通过</p><ul><li><p><code>dataset[&quot;属性名&quot;]</code></p></li><li><p><code>dataset.属性名</code></p></li></ul><p>的方式访问，这时的属性名不需要加上 <code>data-</code> 前缀，如</p><ul><li><p><code>dataset[&quot;dog&quot;]</code></p></li><li><p><code>dataset.dog</code></p></li></ul><p>如果属性名之间使用 <code>-</code> 连接，如 <code>data-my-name</code>，则访问时需要使用驼峰命名法访问，即</p><ul><li><p><code>dataset[&quot;myName&quot;]</code></p></li><li><p><code>dataset.myName</code></p></li></ul></blockquote><h4 id="在新的页面打开标签"><a href="#在新的页面打开标签" class="headerlink" title="在新的页面打开标签"></a>在新的页面打开标签</h4><p>现在使用 <code>attr()</code> 方法来做几个例子，第一个要求页面内的链接都要在新的页面打开，做法就是将 <code>a</code> 标签的 <code>target</code> 属性设置为 <code>_blank</code> ，这种事情当然可以在写的时候就写好，但是有两个问题</p><ul><li><p>首先这个工作是重复性的工作，每写一个 <code>a</code> 都要重复同样的事情，既累又不够优雅</p></li><li><p>如果页面内的链接是用户加入的呢，比如百科，这时打开的链接就不一定是在新的页面打开了</p></li></ul><p>所以我们可以使用 <code>attr()</code> 批量设置 <code>a</code> 标签的 <code>target</code> 属性为 <code>_blank</code> ，但是并不是所有的 <code>a</code> 标签，因为有的 <code>a</code> 标签是在页面内跳转的，我们并不需要在新的页面内打开，所以应该设置 <code>href</code> 属性以 <code>http://</code> 开头的 <code>a</code> 标签在新的页面打开</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"a[href^='http://']"</span>).attr(<span class="string">"target"</span>, <span class="string">"_blank"</span>)</span><br></pre></td></tr></table></figure><h4 id="解决双重提交"><a href="#解决双重提交" class="headerlink" title="解决双重提交"></a>解决双重提交</h4><p>在提交表单时，有的时候由于不能够及时给予用户反馈，导致用户不确定是否提交成功，用户会多次点击提交按钮，这样会给服务器端带来麻烦，我们在捕获 <code>submit</code> 事件时，当用户第一次提交时，我们接着将 <code>disabled</code> 属性设置为 <code>true</code> (或者为 <code>disabled</code> )，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定表单的提交事件</span></span><br><span class="line">$(<span class="string">"form"</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// :submit 表示 type 为 submit 的元素</span></span><br><span class="line">    <span class="comment">// 提交之后将submit按钮设置为disabled</span></span><br><span class="line">    $(<span class="string">":submit"</span>, <span class="keyword">this</span>).attr(<span class="string">"disabled"</span>, <span class="string">"disabled"</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在上面中设置 <code>disabled</code> 属性时，<code>disabled</code> 属性的值不重要，重点是设置了 <code>disabled</code> 这个属性，所以即使将它设置为空字符串 <code>&quot;&quot;</code>，它也是生效的，如果想 <code>disabled</code> 属性设置为不生效，那么就将它的值设置为 <code>false</code> (注意不要设置为字符串 <code>&quot;false&quot;</code> )，下面的写法作用是一样的，都是使得 <code>disabled</code> 生效</p><ul><li><p><code>attr(&quot;disabled&quot;, &quot;disabled&quot;)</code></p></li><li><p><code>attr(&quot;disabled&quot;, &quot;&quot;)</code></p></li><li><p><code>attr(&quot;disabled&quot;, &quot;false&quot;)</code></p></li><li><p><code>attr(&quot;disabled&quot;, true)</code></p></li></ul><p>只有将 <code>disabled</code> 设置为布尔值 <code>false</code> 才会使得 <code>disabled</code> 失效</p><ul><li><strong><code>attr(&quot;disabled&quot;, false)</code></strong></li></ul></blockquote><h3 id="操作类属性"><a href="#操作类属性" class="headerlink" title="操作类属性"></a>操作类属性</h3><p>为什么类属性要单独拿出来呢? 假设有这么一个需求，为所有的 <code>div</code> 标签添加一个类 <code>box</code>，那下面这样的写法对不对</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).attr(<span class="string">"class"</span>, <span class="string">"box"</span>);</span><br></pre></td></tr></table></figure><p>上面的写法是错误的，因为上面的写法是为 <code>class</code> 属性赋值为 <code>box</code>，但是之前的类属性就会被覆盖掉，我们想做的仅仅是添加的操作，所以我们需要知道之前的类属性是什么，所以正确的写法如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得原来的类名列表 转化为数组</span></span><br><span class="line"><span class="keyword">const</span> classList = $(<span class="string">"div"</span>).attr(<span class="string">"class"</span>).split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 将要添加的类名添加到数组中</span></span><br><span class="line">classList.push(<span class="string">"box"</span>);</span><br><span class="line"><span class="comment">// 将数组中的元素以空格拼接为一个字符串</span></span><br><span class="line"><span class="keyword">const</span> newClassList = classList.join(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 设置class属性</span></span><br><span class="line">$(<span class="string">"div"</span>).attr(<span class="string">"class"</span>, newClassList);</span><br></pre></td></tr></table></figure><p>经过千辛万苦终于添加了一个类，考虑到这样的操作很频繁，所以最好将上面的操作抽象为一个方法，而 <code>jQuery</code> 为我们做了这件事情：</p><ul><li><p><code>addClass(names)</code></p><ul><li><p><code>names</code> 可以是单个类名，也可以是一个以空格分隔的字符串表示的多个类名</p></li><li><p><code>names</code> 还可以是一个函数，函数的返回值作为单个类名或者多个类名，这个函数会传入两个参数，元素的下标(元素在 <code>jQuery</code> 集合中的下标)和当前类名的值</p></li></ul></li><li><p><code>removeClass(names)</code></p><ul><li>参数同 <code>addClass</code> ，作用是删除单个或多个类名</li></ul></li><li><p><code>toggleClass(names)</code></p><ul><li><p>该函数的作用是切换类名，什么意思呢? 比如如果该元素存在 <code>names</code> 指定的类，则删除掉指定的类，如果不存在指定的类，则添加指定的类</p></li><li><p>参数同上</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addClass(<span class="string">"box"</span>); <span class="comment">// 为元素添加 box 类</span></span><br><span class="line">addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// index 是元素在 jQuery 中的下标</span></span><br><span class="line">    <span class="comment">// value 是元素当前类名的值</span></span><br><span class="line">    <span class="comment">// return "active big" </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"box"</span>; <span class="comment">// 返回值将会被作为类名添加</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">removeClass(<span class="string">"box"</span>); <span class="comment">// 删除该元素 box 类</span></span><br><span class="line"></span><br><span class="line">toggleClass(<span class="string">"box"</span>); <span class="comment">// 如果存在 box 类，则删除 box 类，如果不存在 box 类，则添加 box 类</span></span><br></pre></td></tr></table></figure><ul><li><code>hasClass(name)</code><ul><li>判断是否包含类名为 <code>name</code> 的类，包含则返回 <code>true</code>，否则返回 <code>false</code></li></ul></li></ul><blockquote><p><code>HTML5</code> 其实也提供了原生的操作类的方法，每个元素都有一个 <code>classList</code> 对象，它的原型对象提供了操作类名的方法</p><ul><li><p><code>classList.add()</code>：为元素添加<strong>一个</strong>类</p></li><li><p><code>classList.remove()</code>：为元素删除指定的类</p></li><li><p><code>classList.toggle()</code>：切换指定的类，存在则移除，不存在则添加</p></li><li><p><code>classList.contains()</code>：判断是否存在指定的类，存在返回 <code>true</code>，反之返回 <code>false</code></p></li></ul><p>据我试验所知，上面的每次操作只能对一个类操作，意思就是不能同时添加多个类或删除。</p></blockquote><h2 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h2><p>使用 <code>css()</code> 方法来设置样式，使用的方法与 <code>attr()</code> 类似</p><ul><li><code>css(name, value)</code>：设置样式 <code>name</code> 为 <code>value</code></li><li><code>css(properties)</code>：传入一个对象，通过对象来设置样式</li><li><code>css(name)</code>：获得样式，如果是含有多个元素的 <code>jQuery</code> 集合调用此方法，那么返回的是第一个元素的计算样式值</li></ul><p>看一个例子，有下面的 <code>div</code> 标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现为它设置高度和宽度</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).css(&#123;</span><br><span class="line">    width: <span class="string">"100px"</span>,</span><br><span class="line">    height: <span class="string">"100px"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>css(name, value)：其中 <code>value</code> 可以是一个函数，该函数的返回值将作为 <code>value</code> 值，这个函数会接收两个参数，第一个参数是元素在 <code>jQuery</code> 集合中的位置，第二个参数是样式当前的值，同时函数的内部上下文 <code>this</code> 指向当前元素</p></blockquote><h3 id="获取元素宽度"><a href="#获取元素宽度" class="headerlink" title="获取元素宽度"></a>获取元素宽度</h3><p>下面我们来获取某元素的 <code>width</code> 值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>); <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure><p>得到的结果是一个一个字符串，而不是数字，很多时候我们是希望得到数字用来计算或者其他用途，所以如果想得到数字的话就需要对字符串进行解析，但是 <code>jQuery</code> 有考虑这一方面，我们可以很方便的使用 <code>width(), height()</code> 方法获得数字的结果，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).width(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>width</code> 的大小是设置样式时的大小吗? 比如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>width()</code> 方法得到的数字是100吗? 为什么在这里我会提出这么一个疑问，因为这里设置的 <code>width</code> 不一定是标签的内容宽度，也可能包括 <code>padding, border</code> (当 <code>box-sizing</code> 设置为 <code>border-box</code> 时)，所以这里的 <code>width</code> 得到的是 <code>content-width</code> 还是在 <code>style</code> 标签中设置的 <code>width</code> ，我们设置 <code>div</code> 的样式为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候在 <code>style</code> 里面设置的 <code>width</code> 为 <code>100</code> ，但是实际的 <code>content-width</code> 应该是 <code>80</code> ，我们来看一下 <code>width()</code> 方法得到的结果是多少</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).width(); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure><p>上面得到的结果是 <code>80</code> ，所以 <code>width()</code> 方法得到的宽度是 <code>content-width</code> ，即是实际内容的宽度， <code>height()</code> 方法也是同理。</p></blockquote><p>除了可以使用 <code>width()</code> 方法获得元素的宽度以外，还可以设置元素的宽度</p><ul><li><code>width(value)</code><ul><li><code>value</code> 的值可以是一个数字，单位默认为 <code>px</code></li><li>也可以是带单位的字符串(如果没有指定单位，则默认为 <code>px</code>)</li><li>还可以是一个函数，函数的返回值作为要设置的值，该函数的上下文(<code>this</code>)是该元素</li></ul></li></ul><blockquote><p>这里又有一个疑问，如果我设定宽度，那么这里的宽度我设定的是内容宽度 <code>conetnt-width</code> 还是元素的 <code>width</code> 样式，这里我们还是以上面的 <code>div</code> 为例</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们设定 <code>width</code> 为 <code>200</code> ，然后通过 <code>width()</code> 方法获得宽度，如果得到的值是 <code>200</code> ，那说明设定的是 <code>content-width</code> ，如果得到的是 <code>180</code> ，说明设定的是 <code>width</code> 样式的值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).width(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>).width()); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><p>得到的结果是 <code>200</code> ，说明设定的是 <code>content-width</code> 。</p></blockquote><blockquote><p>在这里我突然又有一个想法，那就是 <code>css(&quot;width&quot;)</code> 与 <code>width()</code> 得到的结果是相同的吗，还是以上面的 <code>div</code> 为例</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>).width()); <span class="comment">// 80</span></span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>).css(<span class="string">"width"</span>)); <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure><p>惊讶的发现二者得到的结果是在数值上是不一样的，可见使用 <code>css(&quot;width&quot;)</code> 获得的是 <code>width</code> 样式的值，那么使用 <code>css(&quot;width&quot;, 200)</code> 设定的是 <code>width</code> 样式的值吗，测试一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>).width()); <span class="comment">// 180</span></span><br><span class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>).css(<span class="string">"width"</span>)); <span class="comment">// 200px</span></span><br></pre></td></tr></table></figure><p>果然 <code>css()</code> 方法设置的值也是 <code>width</code> 样式的值，所以这里总结一下：</p><ul><li><code>width()</code>(<code>height()</code>)方法设定或者获取的值是指<strong>内容的宽度(高度)</strong></li><li><code>css()</code> 设定或获取的宽度(高度)是指样式里面的 <code>width</code> 值的大小</li><li>在 <code>box-sizing</code> 为 <code>content-box</code> 下二者得到的数值结果是一样的，但是在 <code>box-sizing</code> 为 <code>border-box</code> 的情况下，由于 <code>padding</code> 和 <code>border</code> 的影响，二者的结果是不同的(在 <code>padding</code> 和 <code>border</code> 为 <code>0</code> 的情况下是相同的)。</li></ul></blockquote><blockquote><p>经过一次实践，我发现上面的描述也不太准确，<code>css(&quot;width&quot;)</code>与<code>width()</code>方法获得的值符合上面情况的条件是，它的大小没有超过它父元素的大小，如果超过了，那么<code>css(&quot;width&quot;)</code>就是父元素的<code>width</code>样式的大小，而<code>width()</code>方法的大小我觉得很复杂，还不知道怎么计算，自己动手试试吧。</p></blockquote><p>除了 <code>width()</code> 和 <code>height()</code> 方法，<code>jQuery</code> 还提供了特别的方法来获得特殊的宽度和高度</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>innerwidth()</code></td><td>内容宽度+内边距宽度</td></tr><tr><td><code>innerHeight()</code></td><td>同上</td></tr><tr><td><code>outerWidth(margin)</code></td><td><ul><li>margin为false时，内容宽度 + 内边距宽度 + 边框宽度</li><li>margin为true时，再加上外边距的宽度</li></ul></td></tr><tr><td><code>outerHeight(margin)</code></td><td>同上</td></tr></tbody></table><h3 id="获取元素位置"><a href="#获取元素位置" class="headerlink" title="获取元素位置"></a>获取元素位置</h3><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><p><code>offset()</code>，获取元素离文档原点的距离，返回一个对象，里面有 <code>left</code> 和 <code>top</code> 两个属性，表示离文档原点经过测试，应该是元素的 <code>border</code> 的左上角离文档原点的距离，考虑下面的 <code>html</code> 和 <code>css</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>offset<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body &#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span>: 0; <span class="comment">/* body有8px的margin */</span></span></span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        div &#123;</span><br><span class="line">            margin-top: 100px;</span><br><span class="line">            margin-left: 100px;</span><br><span class="line">            padding-left: 100px;</span><br><span class="line">            padding-top: 100px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            border: 100px solid red;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-03-30_16-13-37.png"/></center><p>来测试一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>).offset()); <span class="comment">// &#123;top: 100, left: 100&#125;</span></span><br></pre></td></tr></table></figure><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>另一个获取位置有关信息的是 <code>position()</code> ，它是获得与它元素左上角之间的距离，这个父元素是它所有父元素中使用了定位 <code>position</code> 且离他最近的父元素，虽然有点拗口，不过使用过绝对定位的话，就会很容易明白，因为它与绝对定位的规则是一样的。</p><blockquote><p>经过我的实验，发现这个距离不是边框与边框的距离，而是子元素 margin 离父元素 padding 之间的距离</p></blockquote><p>考虑下面这么一个<code>HTML</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>position<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body &#123;</span><br><span class="line">            font-size: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">            margin: 100px;</span><br><span class="line">            background-color: grey;</span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            position: relative;</span><br><span class="line"><span class="css">            <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>; <span class="comment">/* 防止外边距塌陷，下同 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#cccccc</span>;</span></span><br><span class="line">            padding: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            margin: 60px;</span><br><span class="line">            background-color: greenyellow;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">            margin: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log($(<span class="string">".inner"</span>).position()); <span class="comment">// outer的margin + container的padding = 70</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log($(<span class="string">".outer"</span>).position()); <span class="comment">// container的padding = 10</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-03-30_16-51-37.png"/></center><h2 id="操作-DOM-元素"><a href="#操作-DOM-元素" class="headerlink" title="操作 DOM 元素"></a>操作 DOM 元素</h2><h3 id="设置-html-内容以及文本内容"><a href="#设置-html-内容以及文本内容" class="headerlink" title="设置 html 内容以及文本内容"></a>设置 html 内容以及文本内容</h3><ul><li><code>html()</code>：获取jQuery集合中第一个元素的 <code>html</code> 内容</li><li><code>html(content)</code>：将传入的 <code>HTML</code> 片段，设置 <code>jQuery</code> 集合中元素的 <code>HTML</code> 内容</li><li><code>text()</code>：获得 <code>jQuery</code> 集合中所有元素的文本内容拼接的字符串</li><li><code>text(content)</code>：将 <code>jQuery</code> 集合元素的文本内容设置为传入的值</li></ul><blockquote><p><code>content</code> 可以为字符串，也可以是一个函数，函数的返回值作为要设置的内容，函数接受两个参数，第一个参数是元素在 <code>jQuery</code> 集合中的位置，第二个参数是当前<code>html</code>(<code>text</code>)的值。</p></blockquote><h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><ul><li><code>append(content)</code>：将 <code>content</code> 追加元素内容的最后面(子元素级别)</li><li><code>prepend(content)</code>：将 <code>content</code> 追加元素内容的最前面</li><li><code>before(content)</code>：将 <code>content</code> 追加到元素的前面(兄弟元素级别)</li><li><code>after(content)</code>：将 <code>content</code> 追加到元素的后面</li></ul><blockquote><p><code>content</code> 的值可以为字符串，元素，jQuery集合，函数，函数的返回值将被添加，函数将接受两个参数，元素的下标和原先的内容。</p><p>如果选择现有的DOM元素添加到某元素的最后，那么这是一个移动操作，而不是一个复制操作，比如有这么一个结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行下面的语句</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).append($(<span class="string">"p"</span>));</span><br></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果<code>jQuery</code>集合中有多个元素，那么被添加的元素会复制多份，添加到这些元素内容的后面(如果添加的是<code>DOM</code>中已有的元素，也是移动操作)，其它的操作(<code>prepend</code>…)也是同理。</p></blockquote><ul><li><code>appendTo(target)</code></li><li><code>prependTo(target)</code></li><li><code>insertBefore(target)</code></li><li><code>insertAfter(target)</code></li></ul><p>这些方法的作用同上面介绍的是个方法是一一对应的，不过是主动变为了被动，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).append(content); <span class="comment">// 向div中添加content</span></span><br><span class="line">$(<span class="string">"div"</span>).appendTo(target); <span class="comment">// 将div添加到target中</span></span><br></pre></td></tr></table></figure><blockquote><p><code>target</code> 只能为元素或者字符串</p></blockquote><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul><li><code>remove(selector)</code>：删除 <code>jQuery</code> 集合中的元素，<code>selector</code> 是一个可选的选择器，用来进一步筛选要删除的元素，被删除的元素会放入一个新的 <code>jQuery</code> 集合中返回，所以被删除的元素可以继续插入到 <code>DOM</code> 中，但是这个时候之前绑定的事件和数据全部被删除了。</li><li><code>empty()</code>：删除 <code>DOM</code> 元素中的内容，与 <code>remove</code> 不同， <code>remove</code> 是删除这个 <code>DOM</code> 元素，包括这个元素包括的内容，但是 <code>empty</code> 只是清除该 <code>DOM</code> 元素的内容。</li><li><code>detach(selector)</code>：该方法的作用与 <code>remove</code> 是一样的，但是保留绑定的事件和绑定的数据。</li></ul><h3 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h3><ul><li><code>clone(cloneHandler)</code>：复制 <code>jQuery</code> 集合中的元素，生成一个新的 <code>jQuery</code> 集合返回。 <code>cloneHandler</code> 如果为 <code>true</code>，那么就会复制绑定的事件，如果为 <code>false</code> 就不会复制绑定的事件</li></ul><h3 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h3><ul><li><code>replaceWith(content)</code>：使用 <code>content</code> 去替换 <code>jQuery</code> 集合中的元素，返回被替换的元素， <code>content</code> 可以是字符串，元素和函数，函数的返回值作为替换的内容，函数的上下文被设置为当前的元素，不传递任何的参数；如果 <code>content</code> 是已经在<code>DOM</code>中的元素，那么就相当于是移动到 <code>jQuery</code> 集合中元素的位置，如果 <code>jQuery</code> 集合中有多个元素，会复制多个 <code>content</code> 副本</li><li><code>replaceAll(selector)</code>：使用 <code>jQuery</code> 集合中的所有元素去替换匹配 <code>selector</code> 的元素，如果<code>jQuery</code>集合中的元素是已经在 <code>DOM</code> 中的元素，那么就相当于将符合 <code>selector</code> 的元素删除，然后将 <code>jQuery</code> 集合中的元素移动到这里，如果符合 <code>selector</code> 的元素有多个，那么会复制多个 <code>jQuery</code> 集合的副本移动</li></ul><h3 id="处理表单元素"><a href="#处理表单元素" class="headerlink" title="处理表单元素"></a>处理表单元素</h3><ul><li><p><code>val()</code>：获得集合中第一个元素的 <code>value</code> 值，如果该元素是一个可以多选的元素，那么返回所有选择项组成数组(比如<code>&lt;select mupltiple=&quot;mupltiple&quot;&gt;&lt;/select&gt;</code>)</p><blockquote><p>如果第一个元素不是表单元素，则会返回空字符串</p></blockquote></li><li><p><code>val(value)</code>：设置集合中表单元素的 <code>value</code> 值</p><blockquote><p>value值也可以是函数，函数的返回值作为被设置的内容，函数接收两个参数，元素的下标和当前的value值</p></blockquote></li><li><p><code>val(values)</code>：使得多选框，单选框，或者<code>select</code>元素中的可选项中，如果这些选项的值在<code>values</code>中，则它变为选中状态</p></li></ul><h2 id="jQuery-事件"><a href="#jQuery-事件" class="headerlink" title="jQuery 事件"></a>jQuery 事件</h2><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p><code>jQuery</code> 使用 <code>on</code> 方法绑定事件，如下</p><ul><li><code>on(eventType, childSelector, data, listener)</code><ul><li><code>eventType</code>，必需，要绑定的事件的类型，如 <code>click</code></li><li><code>childSelector</code>，可选，规定把事件绑定到子元素上</li><li><code>data</code>，可选，规定传递到函数的额外数据</li><li><code>listener</code>，可选，规定事件发生时运行的函数</li></ul></li></ul><p><code>on</code> 方法除了给已经存在于<code>DOM</code>中的元素绑定事件以外，还可以给现在还不存在于 <code>DOM</code> 中但是未来会添加到 <code>DOM</code> 中的元素绑定事件，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时 <code>DOM</code> 中只有 <code>div</code> 标签，这时我想给未来会被添加到 <code>DOM</code> 中的 <code>p</code> 标签绑定点击事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).appendTo($(<span class="string">"div"</span>)); <span class="comment">// 将p标签添加到div中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为div标签中的p标签绑定事件，即使p标签一开始并不在DOM中，也可以绑定成功</span></span><br><span class="line">$(<span class="string">"div"</span>).on(<span class="string">"click"</span>, <span class="string">"p"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>one()</code> 绑定事件，该事件在执行完一次后会被删除</p><ul><li><code>one(eventType, data, listener)</code><ul><li>各参数的含义与 <code>on</code> 是一致的</li></ul></li></ul><p>除了可以使用上面的方法绑定事件以外，<code>jQuery</code> 还提供了十分方便的绑定特定事件方法，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为div标签绑定点击事件</span></span><br><span class="line">$(<span class="string">"div"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样直接以事件的名字绑定事件，既方便，语义又明确，支持这种方式的 <code>eventTypeName</code> 如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-03-31_22-38-08.png"/></center><h3 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h3><ul><li><code>off(event, selector, listener)</code>：移除通过 <code>on</code> 方法绑定的事件</li></ul><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><ul><li><code>trigger(event, data)</code><ul><li>这个方法是用来触发事件的，比如 <code>$(&quot;#foo&quot;).trigger(&quot;click&quot;)</code> 会触发 <code>id</code> 为 <code>foo</code> 的点击事件</li><li><code>data</code> 是可选参数，是传递给事件处理的额外参数，它是一个数组或者对象</li></ul></li></ul><blockquote><p>来解释一下 <code>data</code>，加入在绑定事件时需要额外的参数，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要额外的参数a, b</span></span><br><span class="line">$(<span class="string">"#foo"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event, a, b</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时我们在触发事件时就需要传入额外的参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#foo"</span>).trigger(<span class="string">"click"</span>, [<span class="string">"foo"</span>, <span class="string">"bar"</span>])</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>triggerHandler(event, data)</code></p><ul><li><code>triggerHandler</code> 的作用与 <code>trigger</code> 类似，不过有几点不同</li></ul></li></ul><blockquote><ul><li><p><code>.triggerHandler()</code> 方法并不会触发事件的默认行为(例如，表单提交)。</p></li><li><p><code>.trigger()</code> 会影响所有与 <code>jQuery</code> 对象相匹配的元素，而 <code>.triggerHandler()</code> 仅影响第一个匹配到的元素。</p></li><li><p>使用 <code>.triggerHandler()</code> 创建的事件，并不会在 <code>DOM</code> 树中向上冒泡。</p></li><li><p><code>.triggerHandler()</code> 返回最后一个处理的事件的返回值，而不是 <code>jQuery</code> 集合，即不能进行链式调用</p></li></ul></blockquote><p>除了上述的方法外，<code>jQuery</code> 还提供了可以直接通过名字直接触发事件，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#foo"</span>).click() <span class="comment">// 触发点击事件</span></span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-03-31_23-03-06.png"/></center><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ul><li><p><code>toggle(listener1, listener2, ...)</code></p><ul><li>当点击元素时会依次触发事件</li><li>比如第一次点击触发 <code>listener1</code> ，第二次点击触发 <code>listener2</code> ，以此类推，如果 <code>toggle</code> 中的事件触发完了，那么会循环触发</li></ul></li><li><p><code>hover(enterHandle, leaveHadnler)</code></p><ul><li>当鼠标进入元素时触发 <code>enterHandle</code> ，离开元素时触发 <code>leaveHadnler</code></li></ul></li><li><p><code>hover(handler)</code></p><ul><li>当鼠标进入元素以及离开元素时均会触发 <code>handler</code></li></ul></li></ul><h3 id="Event实例"><a href="#Event实例" class="headerlink" title="Event实例"></a>Event实例</h3><p>我们向元素绑定事件时，会向监听器(绑定的处理函数)传入一个 <code>event</code> 对象，那么 <code>event</code> 对象中有什么信息可以为我们所用呢?</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-03-31_23-14-09.png"/>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-03-31_23-14-50.png"/></center><h2 id="jQuery-显示与隐藏"><a href="#jQuery-显示与隐藏" class="headerlink" title="jQuery 显示与隐藏"></a>jQuery 显示与隐藏</h2><h3 id="显示和隐藏元素"><a href="#显示和隐藏元素" class="headerlink" title="显示和隐藏元素"></a>显示和隐藏元素</h3><ul><li><code>hide()</code>：隐藏元素</li><li><code>show()</code>：显示元素</li></ul><blockquote><p>隐藏元素是将元素的 <code>display</code> 属性设置为 <code>none</code>，而显示属性会将 <code>display</code> 属性设置为与隐藏前的 <code>display</code> 相同，比如在隐藏前某元素的 <code>display</code> 为 <code>block</code>， <code>hide</code> 会将 <code>dispaly</code> 设置为 <code>none</code>，<code>show</code> 会将 <code>display</code> 设置为与之前相同为 <code>block</code>。</p></blockquote><ul><li><code>toggle()</code>：切换，如果为显示，则隐藏，如果隐藏，则显示</li></ul><h3 id="显示隐藏动画"><a href="#显示隐藏动画" class="headerlink" title="显示隐藏动画"></a>显示隐藏动画</h3><p>上面的方法其实还可以接受两个参数</p><ul><li><code>hide(speed, callback)</code><ul><li><code>speed</code> 用来规定隐藏的速度，默认是没有动画效果的，元素瞬间消失，可以传入数字，单位是毫秒，也可以传入以下预定义的字符串，<code>slow, normal, fast</code></li><li><code>callback</code> 是动画执行完毕后会执行的回调函数</li></ul></li></ul><blockquote><p>同理，<code>show()</code> 和<code>toggle()</code> 也由这两个参数，与<code>hide()</code> 的用法一模一样，所以不再赘述。</p></blockquote><p>假设有一个 <code>div</code> 标签，当我们点击它时，它会先隐藏，会显示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"div"</span>).hide(<span class="string">"slow"</span>).show(<span class="string">"fast"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011056.gif"/></center><p>除了上面方法显示和隐藏元素以外，<code>jQuery</code> 还提供了很多的方法，如</p><blockquote><p>淡入淡出(只改变元素的不透明度)：</p><ul><li><code>fadeIn(speed, callback)</code></li><li><code>fadeOut(speed, callback)</code></li><li><code>fadeTo(speed, opacity, callback)</code>：逐渐改变元素的透明度到设定的opacity</li></ul><p>我们在使用 <code>hide</code> 或者 <code>show</code> 时，除了改变透明度以外，还会改变高度和宽度，而 <code>fade...</code> 方法只会改变不透明度，当 <code>opacity</code> 为 <code>0</code> 时，将 <code>display</code> 设置为 <code>none</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> $(<span class="string">"div"</span>).fadeOut(<span class="string">"slow"</span>).fadeIn(<span class="string">"fast"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center> <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011103.gif"/></center><p>滑入滑出：</p><ul><li><code>slideDown(speed, callback)</code>：改变元素的垂直尺寸，使元素逐渐显示出来</li><li><code>slideUp(speed, callback)</code>：改变元素的垂直尺寸，使元素逐渐消失</li><li><code>slideToggle(speed, callback)</code>：隐藏则显示，显示则隐藏</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> $(<span class="string">"div"</span>).slideUp(<span class="string">"slow"</span>).slideDown(<span class="string">"fast"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center> <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011106.gif"/></center></blockquote><h2 id="jQuery-动画"><a href="#jQuery-动画" class="headerlink" title="jQuery 动画"></a>jQuery 动画</h2><ul><li><code>animate(properties, duration, easing, callback)</code><ul><li><code>properties</code>：元素最后达到的 <code>CSS</code> 状态</li><li><code>duration</code>：持续时间</li><li><code>easing</code>：动画曲线，<code>jQuery</code> 提供两个函数曲线 <code>linear</code> 和 <code>swing</code></li><li><code>callback</code>：动画执行完毕后的会执行的回调函数</li></ul></li></ul><p>我们通过给定希望元素最后能够达到的 <code>CSS</code> 状态，比如位置的变化，宽高的变化，而 <code>jQuery</code> 会自动根据持续的时间以及初始的状态计算出中间的过程，也就是帧，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"div"</span>).animate(&#123;</span><br><span class="line">        width: <span class="string">"200px"</span></span><br><span class="line">    &#125;, <span class="number">500</span>, <span class="string">"swing"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011118.gif"/></center><h3 id="自定义缩放动画"><a href="#自定义缩放动画" class="headerlink" title="自定义缩放动画"></a>自定义缩放动画</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 鼠标放上去时，放大两倍</span></span><br><span class="line">    $(<span class="string">"div"</span>).animate(&#123;</span><br><span class="line">        width: $(<span class="keyword">this</span>).width() * <span class="number">2</span>,</span><br><span class="line">        height: $(<span class="keyword">this</span>).height() * <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 离开时恢复原样</span></span><br><span class="line">    $(<span class="string">"div"</span>).animate(&#123;</span><br><span class="line">        width: $(<span class="keyword">this</span>).width() / <span class="number">2</span>,</span><br><span class="line">        height: $(<span class="keyword">this</span>).height() / <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011122.gif"/></center><h3 id="自定义掉落动画"><a href="#自定义掉落动画" class="headerlink" title="自定义掉落动画"></a>自定义掉落动画</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).css(&#123;</span><br><span class="line">        position: <span class="string">"relative"</span></span><br><span class="line">    &#125;).animate(&#123;</span><br><span class="line">        opacity: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 计算要下降的高度</span></span><br><span class="line">        top: $(<span class="built_in">window</span>).height() - $(<span class="keyword">this</span>).height() - $(<span class="keyword">this</span>).position().top</span><br><span class="line">    &#125;, <span class="string">"slow"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为 opacity 为 0 只是不可见，但是仍然占据位置，所以最后要hide隐藏一下</span></span><br><span class="line">        <span class="comment">// 可以将 opacity 最后的状态设置为 hide，那么这个回调函数可以省略</span></span><br><span class="line">        $(<span class="keyword">this</span>).hide()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011129.gif"/></center><blockquote><p>将 <code>$.fx.off</code> 设置为 <code>true</code> 会禁用动画</p></blockquote><h2 id="jQuery扩展及实用函数"><a href="#jQuery扩展及实用函数" class="headerlink" title="jQuery扩展及实用函数"></a>jQuery扩展及实用函数</h2><h3 id="jQuery与其他库并存"><a href="#jQuery与其他库并存" class="headerlink" title="jQuery与其他库并存"></a>jQuery与其他库并存</h3><ul><li><code>$.noConflict()</code>：将 <code>$</code> 控制权给其他库，在执行该行代码后不能使用 <code>$</code>，只能使用 <code>jQuery</code></li></ul><h3 id="jQuery实用函数"><a href="#jQuery实用函数" class="headerlink" title="jQuery实用函数"></a>jQuery实用函数</h3><ul><li><code>$.trim(value)</code>：去除字符串前后的空白字符(不仅仅是空格，还有回车等等)</li><li><code>$.each(container, callback)</code>：会为 <code>container</code> (数组|对象)中的每个元素调用 <code>callback</code>，<code>callback</code> 的参数就是 <code>container</code> 中的每个元素</li><li><code>$.grep(array, callback, invert)</code>：为数组中的每个元素调用 <code>callback</code>，根据 <code>callback</code> 的返回值决定是否将元素添加到新的数组，如果 <code>invert</code> 为 <code>true</code>，那么 <code>callback</code> 返回 <code>false</code> 则将元素添加到新数组，反之若 <code>invert</code> 为 <code>false</code>，则 <code>callback</code> 返回 <code>true</code> 则将元素添加到新的数组，最后将新数组返回</li><li><code>$.map(array, callback)</code>：这个方法不想多解释</li><li><code>$.inArray(value, array)</code>：方法 <code>value</code> 在 <code>array</code> 中第一次出现的下标</li><li><code>$.makeArray(object)</code>：将一个伪数组转换为一个真正的数组</li><li><code>$.unique(array)</code>：返回 <code>array</code> 中不重复的元素组成的数组</li><li><code>$.merge(array1, array2)</code>：将第二个数组合并到第一个数组中，并返回第一个数组</li></ul><blockquote><p>上面的方法大多数 <code>JavaScript</code> 已经有原生的实现了</p></blockquote><h3 id="扩展jQuery"><a href="#扩展jQuery" class="headerlink" title="扩展jQuery"></a>扩展jQuery</h3><p><code>$.fn.xxx</code>：该方法会被添加到 <code>jQuery</code> 对象的原型上，通过这种方法可以扩展 <code>jQuery</code></p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="启动一个Node来进行服务端测试"><a href="#启动一个Node来进行服务端测试" class="headerlink" title="启动一个Node来进行服务端测试"></a>启动一个Node来进行服务端测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理跨域 允许http://127.0.0.1:5500跨域请求 因为我在这个地址访问页面</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://127.0.0.1:5500'</span>);</span><br><span class="line">    res.end(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">4000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"服务启动在4000端口"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="回顾Ajax"><a href="#回顾Ajax" class="headerlink" title="回顾Ajax"></a>回顾Ajax</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>jquery/<span class="number">3.4</span><span class="number">.1</span>/jquery.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;发送请求&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        $("</span>button<span class="string">").click(function () &#123;</span></span><br><span class="line"><span class="string">            let xhr = new XMLHttpRequest();</span></span><br><span class="line"><span class="string">            // 设置请求方法和请求路径</span></span><br><span class="line"><span class="string">            xhr.open("</span>GET<span class="string">", "</span>http:<span class="comment">//localhost:4000");</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 监听onreadystatechange，当readyState改变时会触发此函数</span></span><br><span class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// readyState为4表示处理请求完成</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                        <span class="comment">// 成功</span></span><br><span class="line">                        $(<span class="string">"ul"</span>).append(<span class="string">`&lt;li&gt;<span class="subst">$&#123;<span class="keyword">this</span>.responseText&#125;</span>&lt;/li&gt;`</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 失败</span></span><br><span class="line">                        alert(<span class="string">"失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发送的请求体数据 get方法不传参数，或者传入null</span></span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码是当点击<code>button</code>时发送一个<code>ajax</code>请求，并且获得的内容添加到<code>ul</code>中，效果如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004011240.gif"/></center><p><code>XMLHttpRequest</code> 对象拥有的属性和方法为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-01_12-44-51.png"/>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-01_12-44-55.png"/></center><h3 id="jQuery-发起-Ajax-请求"><a href="#jQuery-发起-Ajax-请求" class="headerlink" title="jQuery 发起 Ajax 请求"></a>jQuery 发起 Ajax 请求</h3><ul><li><p><code>get(url, parameters, callback, type)</code></p><ul><li><code>url</code>：请求的路径</li><li><code>parameters</code>：请求参数，会被拼接到 <code>url</code> 后</li><li><code>callback</code>：请求成功后调用的函数</li><li><code>type</code>：以何种方式处理响应数据，如 <code>html</code>，<code>json</code></li></ul></li><li><p><code>getJSON(url, parameters, callback)</code>：相当于是 <code>get(url, parameters, callback, type)</code> 中 <code>type</code> 为 <code>json</code> 的快捷写法</p></li><li><p><code>post(url, parameters, callback, type)</code>：同 <code>get</code>，不过请求的方法是 <code>POST</code>，而且请求数据是放在请求体中的</p></li><li><p><code>ajax(options)</code>：</p><ul><li>用传入的选项来控制 <code>ajax</code> 请求，该方法可以控制发送 <code>ajax</code> 请求的各种细节</li></ul></li></ul><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-01_13-11-00.png"/>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-01_13-11-13.png"/><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-01_13-11-23.png"/><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Snipaste_2020-04-01_13-11-31.png"/></center><p><code>jQuery</code> 的 <code>ajax</code> 方法为我们提供了这么多可选项，如果没有设置一些选项的话，就会使用默认值，使用 <code>ajaxSetup</code> 方法来设置默认值</p><ul><li><code>ajaxSetup(options)</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    timeout: <span class="number">5000</span>,</span><br><span class="line">    dataType: <span class="string">'html'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么后面的每个 <code>ajax</code> 调用都会使用这些默认值(<code>$.get()</code> 的 <code>HTTP</code> 方法不会被改为 <code>POST</code>)。</p>]]></content>
    
    <summary type="html">
    
      jQuery系统教程
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="jQuery JavaScript" scheme="https://lastknightcoder.gitee.io/tags/jQuery-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用before和after实现一个hover遮罩效果</title>
    <link href="https://lastknightcoder.gitee.io/%E4%BD%BF%E7%94%A8before%E5%92%8Cafter%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhover%E9%81%AE%E7%BD%A9%E6%95%88%E6%9E%9C/"/>
    <id>https://lastknightcoder.gitee.io/%E4%BD%BF%E7%94%A8before%E5%92%8Cafter%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhover%E9%81%AE%E7%BD%A9%E6%95%88%E6%9E%9C/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习<code>CSS</code>效果，记录一下，成品如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004030004.gif"/></center><p>实现的思路很简单，使用到了<code>::before</code>和<code>::after</code>两个伪元素，默认两个伪元素的<code>width</code>为<code>0</code>，<code>height</code>与父元素的高度相同，当鼠标放上去时，伪元素的<code>width</code>变为<code>100%</code>，注意到两个伪元素变化的方向不一样，因为<code>::before</code>被设置为了</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">top</span>: 0;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br></pre></td></tr></table></figure><p>而<code>::after</code>被设置为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">bottom</span>: 0;</span><br><span class="line"><span class="selector-tag">right</span>: 0;</span><br></pre></td></tr></table></figure><p><code>talk is cheap, show me the code</code>，直接上代码吧</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="selector-tag">html</span>,</span><br><span class="line">        <span class="selector-tag">body</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span> &#123;</span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">margin</span>: auto;</span><br><span class="line">            <span class="attribute">text-decoration</span>: none;</span><br><span class="line">            <span class="attribute">text-align</span>: center;</span><br><span class="line">            <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">            <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">            <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">::before</span>,</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">            <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">            <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>,</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;a href="#"&gt;Move&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上面的代码不难理解，就一个地方需要注意的是，在<code>a</code>标签中设置了</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>: <span class="selector-tag">auto</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">top</span>: 0;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br><span class="line"><span class="selector-tag">bottom</span>: 0;</span><br><span class="line"><span class="selector-tag">right</span>: 0;</span><br></pre></td></tr></table></figure><p>这样的写法，这样做的目的是使得<code>a</code>标签在<code>body</code>中居中显示，因为设置了定位的属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">top</span>: 0;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br><span class="line"><span class="selector-tag">bottom</span>: 0;</span><br><span class="line"><span class="selector-tag">right</span>: 0;</span><br></pre></td></tr></table></figure><p>四个都为0，要达到这样的效果，设置<code>margin</code>为<code>auto</code>会为<code>a</code>元素四周充满外边距，如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200403002007.png"/></center><p>这样就可以到居中的效果。</p>]]></content>
    
    <summary type="html">
    
      使用before和after实现一个hover遮罩效果
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="CSS" scheme="https://lastknightcoder.gitee.io/categories/Web/CSS/"/>
    
    
      <category term="CSS" scheme="https://lastknightcoder.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>数组中的重复的数字</title>
    <link href="https://lastknightcoder.gitee.io/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://lastknightcoder.gitee.io/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目一：找出数组中重复的数字</p><p>在一个长度为n的数组里的所有数组都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数组2或者3。</p></blockquote><p>考虑如果没有数组中没有重复的数字，那么排序后会有<code>arr[i] = i</code>(因为元素在 0~n-1 的范围内)，那么现在我们遍历数组，让第<code>i</code>个位置的元素的值为<code>i</code>(从0开始)，做法是当<code>arr[i] != i</code>的时候，与第<code>arr[i]</code>的位置进行交换，这样可以使得第<code>arr[i]</code>个位置上的数是<code>arr[i]</code>，即<code>arr[arr[i]] = arr[i]</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[temp];</span><br><span class="line">arr[temp] = temp;</span><br></pre></td></tr></table></figure><p>如果有重复的数，由于<code>arr[arr[i]]</code>位置上的数已经被占了，所以这个时候我们就知道有重复的数，算法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">0</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[arr[i]] == arr[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                swap(arr, i, arr[i]);</span><br><span class="line">                printArr(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">", "</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// int[] arr = &#123;7, 5, 6, 3, 4, 1, 0, 2&#125;;</span></span><br><span class="line">        <span class="keyword">boolean</span> duplicated = duplicate(arr);</span><br><span class="line">        System.out.println(duplicated);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：不修改数组找出重复的数字</p><p>在一个长度为 n+1 的数组里的所有数字都在 1~n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。</p></blockquote><p>该算法有两种思路，第一种需要大小为 n+1 的辅助数组，我们遍历数组，将数组中的元素都复制到辅助数组中，原则如下，假设要复制的元素为m，那么将该数复制到辅助数组中下标为m的位置，这样很容易知道哪个元素重复了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] helpArr = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == helpArr[arr[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                helpArr[arr[i]] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num = duplicate(arr);</span><br><span class="line">        System.out.println(num); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种思路是二分查找，首先我们将数字分成两半，比如 1~m 和 m+1~n，接着我们在数组中统计数字在 1~m 区间中的个数，如果数量大于 m ，那么就说明在 1~m 中有重复的数字，否则在 m+1~n 中有重复的数字，假设在 1~m 中有重复的数字，那么继续分成两半，如此往复，直到两边只有一个元素，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (end &gt;= start) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 获得数字范围在[start, middle]范围内的数目</span></span><br><span class="line">            <span class="keyword">int</span> countNum = count(arr, start, middle);</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">if</span>(countNum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> start;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果范围只剩最后一个元素，但是数目不大于1，说明没有重复的</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (countNum &gt; (middle - start + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 在[start, middle]中继续找</span></span><br><span class="line">                end = middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在[middle + 1, end]中继续找</span></span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中数字范围在[start, end]范围内的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &lt;= arr[i] &amp;&amp; arr[i] &lt;= end) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num = duplicate(arr);</span><br><span class="line">        System.out.println(num); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目一：找出数组中重复的数字&lt;/p&gt;
&lt;p&gt;在一个长度为n的数组里的所有数组都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://lastknightcoder.gitee.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lastknightcoder.gitee.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：设计一个类，我们只能生成该类的一个实例。</p></blockquote><p>如果只能生成一个实例，这意味着构造方法必须为私有的，该类实例的创建不能由用户创建，一个容易想到的版本如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test01 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Test01();</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test01 one = Test01.getInstance();</span><br><span class="line">        Test01 two = Test01.getInstance();</span><br><span class="line">        System.out.println(one == two); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在类里面声明了一个instance变量，它是该类的一个实例，用户通过<code>getInstance()</code>来获得该类的实例，在该方法中，首先判断<code>instance</code>是不是为<code>null</code>，如果是<code>null</code>说明还没有创建过该实例，那么创建一个实例，如果不为<code>null</code>，说明已经创建过该实例，将之前创建过的实例返回，从而达到创建的始终是一个实例的效果。</p><p>但是使用上面的方法有一个缺点，那就是在多线程的情况下可能创建出多个实例，考虑这么一种情况，第一个线程执行<code>if (instance == null)</code>时，这时是成功的，会进入到<code>if</code>语句中，但是这个时候它失去了执行权，这个时候第二个线程执行<code>if (instance == null)</code>时，由于<code>instance</code>还没有赋值，它的值还为<code>null</code>，它也能够进入到<code>if</code>语句中，这个时候第一个线程和第二个线程都会使用<code>new</code>关键字创建出一个实例，它们是不同的。</p><p>简单的解决上面的问题就是加锁，上面会出现问题的语句为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们为这个语句块加上锁就行，这就出现了第二个版本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test02 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Test02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test02<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Test02();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test02 one = Test02.getInstance();</span><br><span class="line">        Test02 two = Test02.getInstance();</span><br><span class="line">        System.out.println(one == two); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方法还有一个小的缺点，那就是每次我们获取实例的时候，都需要加锁，这意味着性能的损失，当<code>instance</code>不为<code>null</code>的时候，已经不会由于多线程而产生问题了，也就不用加锁了，所以再次修改<code>getInstance()</code>，产生了第三个版本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test03 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Test03 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test03<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Test03();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test03 one = Test03.getInstance();</span><br><span class="line">        Test03 two = Test03.getInstance();</span><br><span class="line">        System.out.println(one == two); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个版本中，只有在<code>instance</code>为<code>null</code>的时候，我们才加锁。</p><p>上面的方法已经比较好了，这里再次推荐更好的办法，我们在<code>instance</code>声明的时候就为它赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在声明的时候就赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test04 instance = <span class="keyword">new</span> Test04();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test04 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test04 one = Test04.getInstance();</span><br><span class="line">        Test04 two = Test04.getInstance();</span><br><span class="line">        System.out.println(one == two); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于<code>instance</code>是静态变量，静态变量在类被主动使用时就会被初始化，而不是等我们需要创建类的实例时才被初始化，简单的说就是创建的时机过早，从而降低内存的使用效率，我们使用静态内部类来解决按需加载的问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Test05 instance = <span class="keyword">new</span> Test05();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test05 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerTest.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test05 one = Test05.getInstance();</span><br><span class="line">        Test05 two = Test05.getInstance();</span><br><span class="line">        System.out.println(one == two); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，只有我们需要用到类的实例时，才会初始化<code>instance</code>。</p><blockquote><p>在上面5种实现单例模式的方法中：</p><ul><li>第一种方法在多线程的环境下不能工作</li><li>第二种模式虽然能够在多线程的环境下工作，但是效率很低</li><li>第三种方法通过两次判断确保能够在多线程的情况下高效的工作</li><li>第四种方法在声明时就初始化，且只会被初始化一次，确保只创建一个实例</li><li>第五种方法利用内部类，做到只要在真正需要的时候才会创建实例，提高空间使用效率</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：设计一个类，我们只能生成该类的一个实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果只能生成一个实例，这意味着构造方法必须为私有的，该类实例的创建不能由用户创建，一个容易想到的版本如下&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://lastknightcoder.gitee.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="单例模式" scheme="https://lastknightcoder.gitee.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的冒泡与捕获</title>
    <link href="https://lastknightcoder.gitee.io/JavaScript%E4%B8%AD%E7%9A%84%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7/"/>
    <id>https://lastknightcoder.gitee.io/JavaScript%E4%B8%AD%E7%9A%84%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2020-03-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript中的冒泡与捕获"><a href="#JavaScript中的冒泡与捕获" class="headerlink" title="JavaScript中的冒泡与捕获"></a>JavaScript中的冒泡与捕获</h2><p>首先来看一个例子来明白什么是冒泡和捕获，来看下面的一个html结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: black;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: greenyellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是一个大盒子里面套着一个小盒子，为两个盒子设置了背景颜色以作区分，如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-17_150014.png"/></center><p>现在为二者都添加一个点击方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</span><br><span class="line">    <span class="keyword">let</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</span><br><span class="line">    outer.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'outer被点击了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    inner.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inner被点击了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>现在如果点击里面的盒子<code>inner</code>，那么<code>outer</code>的点击事件会不会触发，因为按道理也算是点击了<code>outer</code>的区域，所以<code>outer</code>的点击事件应该被触发。现在问题又来了，是先触发<code>inner</code>还是先触发<code>outer</code>的点击事件呢? 按照二者触发顺序的不同分为捕获和冒泡。</p><p>现在点击绿色的小盒子，看看输出是什么</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-17-15-09.gif"/></center><p>当我们点击里面的盒子即 <code>inner</code> 时，触发了它的点击事件，随后触发了 <code>outer</code> 的点击事件，这样触发子元素事件之后触发父元素事件的行为就叫做冒泡；捕获就是随之相反了，先处理 <code>outer</code>，然后处理 <code>inner</code> 的事件。</p><p>要实现捕获的效果，首先我们为 <code>addEventListener</code> 方法的第三个参数设置为 <code>true</code>，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">outer.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'outer被点击了'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">inner.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inner被点击了'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这时我们在点击里面的盒子</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-17-15-17.gif"/></center><p>这时是<code>outer</code>的点击事件先被执行，然后是<code>inner</code>的点击事件被执行。</p><p>冒泡和捕获的出现是因为以前的两大浏览器厂商 <code>Netscape</code> 和 <code>Microsoft</code> 对事件模型处理方法，<code>Microsoft</code> 采取的从目标元素(比如点击 <code>inner</code>，<code>inner</code> 就是目标元素)开始，按 <code>DOM</code> 树向上冒泡；而 <code>Netscape</code> 采取的是相反的原则，即从顶部元素开始，直到事件目标元素。通过上面的例子可以知道，可以通过设置 <code>addEventListener</code> 方法的第三个参数可以设置是冒泡还是捕获，当设置为 <code>true</code> 时，是捕获，当设置为 <code>false</code> 时，是冒泡，默认是 <code>false</code>。</p><p>现在考虑一个比较复杂的 <code>DOM</code> 结构，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.one</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: black;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.two</span> &#123;</span></span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.three</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: greenyellow;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.four</span> &#123;</span></span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background-color: blueviolet;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"four"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> one = <span class="built_in">document</span>.querySelector(<span class="string">'.one'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> two = <span class="built_in">document</span>.querySelector(<span class="string">'.two'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> three = <span class="built_in">document</span>.querySelector(<span class="string">'.three'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> four = <span class="built_in">document</span>.querySelector(<span class="string">'.four'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        one.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'one被点击了'</span>);</span></span><br><span class="line"><span class="actionscript">        &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        two.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'two被点击了'</span>);</span></span><br><span class="line"><span class="actionscript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="actionscript">        three.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'three被点击了'</span>);</span></span><br><span class="line"><span class="actionscript">        &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        four.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'four被点击了'</span>);</span></span><br><span class="line"><span class="actionscript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面四个盒子套在一起，我们为<code>one</code>和<code>three</code>设定为捕获模式，为<code>two</code>和<code>four</code>设定为冒泡模式，如果我们点击<code>four</code>，这时的输出会是什么呢?</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-17-15-50.gif"/></center><p>我们观察到输出的顺序为<code>one -&gt; three -&gt; four -&gt; two</code>，代码是怎么执行的呢? 首先事件处理器会从顶部开始即 <code>one</code>(严格的说是从 <code>window</code>)，一直到目标元素，在这个路径中，如果遇到设置为捕获模式的则执行，碰到冒泡模式的则跳过，达到目标元素后，开始转换为冒泡模式，向上冒泡到<code>one</code>，在这个路径中，如果碰到设置为冒泡模式的则执行，否则跳过。</p><p>现在我们来看看上面的执行流程：</p><ul><li>首先从<code>one</code>开始向下捕获，<code>one</code>设置为捕获模式，执行</li><li>遇到<code>two</code>，<code>two</code>设置为冒泡模式，不执行跳过</li><li>遇到<code>three</code>，<code>three</code>设置为捕获模式，执行</li><li>遇到<code>four</code>，到达目标元素，执行(此时不管four是冒泡还是捕获都没有关系，都会执行的)</li><li>接着转变为冒泡模式，遇到<code>three</code>，<code>three</code>为捕获模式，跳过</li><li>遇到<code>two</code>，<code>two</code>为冒泡模式，执行</li><li>遇到<code>one</code>，<code>one</code>为捕获模式，不执行，此时已经到达顶部，结束</li></ul><p>通过上面的流程，不难知道输出的顺序为什么是<code>one -&gt; three -&gt; four -&gt; two</code>。</p><h2 id="在父元素上代理事件"><a href="#在父元素上代理事件" class="headerlink" title="在父元素上代理事件"></a>在父元素上代理事件</h2><p>我们来看一个运用冒泡的小例子，假设有这个一个DOM结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;元素&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;元素&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;元素&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;元素&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;元素&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;元素&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;元素&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;元素&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;元素&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;元素&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望当点击 <code>li</code> 标签时，将 <code>li</code> 标签里面的文字变为红色，所以很有可能你会写出这样的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"ul li"</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">        e.target.style.color = <span class="string">'red'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样写当然能达到效果，但是如果 <code>ul</code> 下面有成千上万个 <code>li</code>，这样写未免性能太低，我们可以利用冒泡的特性，为 <code>ul</code> 绑定点击事件，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    e.target.style.color = <span class="string">'red'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样不管 <code>ul</code> 下面有多少个 <code>li</code> 都没有关系。</p><blockquote><p>解释：</p><p>这里可能有人不太懂 <code>e.target</code> 是什么，<code>e.target</code> 是指触发点击事件的元素，而不是 <code>ul</code>，因为我们点击的是 <code>li</code> 标签，所以这里的 <code>e.target</code> 是被点击的 <code>li</code> 元素。如果想在 <code>addEventListener</code> 里面访问 <code>ul</code> 元素，可以使用 <code>this</code>。</p></blockquote><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>有的时候我们不希望事件有冒泡操作，我们可以通过 <code>event</code> 对象的 <code>stopPropagation</code> 方法来阻止事件冒泡，以文章开头的 <code>inner</code> 和 <code>outer</code> 为例(<code>outer</code> 和 <code>inner</code> 都设置为冒泡模式)，我们给 <code>inner</code> 的 <code>addEventListener</code> 修改为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inner.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inner被点击了'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这时我们点击<code>inner</code>，这时只有<code>inner</code>的点击事件被执行了</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-17-16-22.gif"/></center>]]></content>
    
    <summary type="html">
    
      JavaScript中的冒泡与捕获
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="https://lastknightcoder.gitee.io/categories/Web/JavaScript/"/>
    
    
      <category term="JavaScript 冒泡与捕获" scheme="https://lastknightcoder.gitee.io/tags/JavaScript-%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7/"/>
    
  </entry>
  
  <entry>
    <title>SSM整合</title>
    <link href="https://lastknightcoder.gitee.io/SSM%E6%95%B4%E5%90%88/"/>
    <id>https://lastknightcoder.gitee.io/SSM%E6%95%B4%E5%90%88/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习完Spring, SpringMVC, MyBatis三大框架后，现在将记录如何整合这三个框架。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先新建一个Maven工程，在pom.xml中导入以下包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着创建一个User表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mybatis;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(username <span class="built_in">varchar</span>(<span class="number">20</span>), age <span class="built_in">int</span>, sex <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="string">"李四"</span>, <span class="number">19</span>, <span class="string">"male"</span>);</span><br></pre></td></tr></table></figure><p>此时的user表为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">----------+------+------+</span></span><br><span class="line">| username | age  | sex  |</span><br><span class="line">+<span class="comment">----------+------+------+</span></span><br><span class="line">| 张三     |   18 | male |</span><br><span class="line">| 李四     |   19 | male |</span><br><span class="line">+<span class="comment">----------+------+------+</span></span><br></pre></td></tr></table></figure><h2 id="Spring整合Dao层"><a href="#Spring整合Dao层" class="headerlink" title="Spring整合Dao层"></a>Spring整合Dao层</h2><p>首先在包com.pojo下新建实体类User如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在com.dao包下新建UserDao接口，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在resources目录下新建MyBatis的配置文件mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只是在其中配置了别名，数据源的配置会在Spring配置文件中配置，现在在resources下新建database.properties文件，如下</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>最后新建spring-dao.xml文件，这是Spring整合MyBatis的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  读取数据库信息  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:database.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  扫描com.dao下的包 动态生成实现类注册到Spring中  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resources下新建applicationContext.xml配置文件，将spring-dao.xml导入，该文件是Spring的主配置文件，主要的功能就是导入配置文件，如spring-dao.xml, spring-service.xml以及spring-mvc.xml，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:spring-dao.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在便是在test/java下新建TestSpringDao测试类，来验证Spring是否整合了MyBatis，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;userName=<span class="string">'张三'</span>, age=<span class="number">18</span>, sex=<span class="string">'male'</span>&#125;</span><br><span class="line">User&#123;userName=<span class="string">'李四'</span>, age=<span class="number">19</span>, sex=<span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>可见Spring以及整合MyBatis成功了。</p><h2 id="Spring整合Service层"><a href="#Spring整合Service层" class="headerlink" title="Spring整合Service层"></a>Spring整合Service层</h2><p>简单的模拟业务层，在com.service下新建UserService接口如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.com.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着建立它的实现类UserServiceImpl，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.com.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着新建spring-service.xml，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.service"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在applicationContext.xml中导入该配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:spring-service.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>接着新建TestSpringService测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userService.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;userName=<span class="string">'张三'</span>, age=<span class="number">18</span>, sex=<span class="string">'male'</span>&#125;</span><br><span class="line">User&#123;userName=<span class="string">'李四'</span>, age=<span class="number">19</span>, sex=<span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>Spring Service层整合成功。</p><h2 id="Spring整合Controller层"><a href="#Spring整合Controller层" class="headerlink" title="Spring整合Controller层"></a>Spring整合Controller层</h2><p>首先点击项目，右键选择Add Framework Support…，并选择Web Application</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-02000314.png"/><p>这时的项目就成为了一个Web项目，我们在web.xml中配置如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatch<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatch<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resources下新建spring-mvc.xml，内容如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并且在applicationContext.xml中导入该配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:spring-mvc.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在com.controller包下新建UserController类，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/users"</span>, produces = <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userService.findAll();</span><br><span class="line">        <span class="keyword">return</span> users.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着启动Tomcat(在启动Tomcat之前记得添加依赖的包)，在地址栏后输入<code>/users</code></p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-02_00-25-30.png"/><p>至此，SSM整合结束。</p>]]></content>
    
    <summary type="html">
    
      SSM整合
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Java/Web/"/>
    
    
      <category term="SSM Spring SpringMVC MyBatis" scheme="https://lastknightcoder.gitee.io/tags/SSM-Spring-SpringMVC-MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC笔记</title>
    <link href="https://lastknightcoder.gitee.io/Spring%20MVC%E7%AC%94%E8%AE%B0/"/>
    <id>https://lastknightcoder.gitee.io/Spring%20MVC%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-02-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本片文章是我记录学习Spring MVC的学习笔记，作为初学者，对于这个框架的理解可能并不深刻，所以这篇文章主要讲述的是Spring MVC框架的使用，所以对于有些内容为什么要这么做，这么做有什么好处，由于才疏学浅，却不是我能解释的，所以本篇文章以代码偏多，文字解释偏少。</p><h2 id="Hello-Spring-MVC"><a href="#Hello-Spring-MVC" class="headerlink" title="Hello Spring MVC"></a>Hello Spring MVC</h2><p>先简单的的把Spring MVC用起来，然后在解释一下Spring MVC的用法。首先在pom.xml中导入需要的包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-webmvc就是我们需要的包，而junit不用说，是用来测试用的。Java底层对浏览器做出响应是基于Servlet，所以Spring MVC也是基于Servlet的，所以我们还导入了Servlet的包，以及对JSP的支持和JSTL语言的支持的包。</p><p>由于我们建立的只是一个普通的Maven工程，我们要对项目添加支持，使其成为一个Web项目，单击项目右键选择Add Framework Support…，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200229235310.png"/><p>接着勾选WebApplication，点击OK</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200229235625.png"/><p>这时会在你的项目中为你生成一个web目录，如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200301000150.png"/><p>这时我们配置web.xml如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatch<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatch<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们知道JavaWeb的工作流程是根据浏览器的请求地址去找对应的Servlet去做处理，这里我们配置对所有的请求(<code>/</code>)都会使用Spring提供的DispatchServlet进行处理。具体的处理流程稍后会介绍，从上面的配置看出，DispatchServlet还需要一个配置文件地址的参数，这里我们写为了classpath:springmvc-config.xml，而这个文件还没有，所以我们在src/main/resources中新建springmvc-config.xml，内容如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.controller"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在这个配置文件中对com.controller中的类开启了mvc注解支持。还配置了一个ServletHandler和ViewResolver，这两个东西与后面讲的Spring MVC执行流程有关，后面再说。</p><p>现在新建com.controller.HandleRequest.java，内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleRequest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring MVC"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的作用是当浏览器访问<code>/hello</code>时，会返回浏览器一个字符串”Hello Spring MVC”，现在使用tomcat服务器启动该项目，并且在地址栏后输入<code>/hello</code>，这时我们会得到一个错误如下</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200301004227.png"/><p>这是因为我们没有在项目中加入所依赖的包，这时我们在IDEA中的左上角找到File并点击，选择Project Structure，接着在Project Structure中选择Artifacts</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200301110550.png"/><p>这时选择你的项目，比如我的是mvc-hello，右键选择Put into Output Root</p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/2020-03-01_11-39-48.png"/><p>接下来重新启动Tomcat，然后在浏览器地址栏后输入<code>/hello</code></p><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200301114644.png"/><p>就可以看到Hello Spring MVC在浏览器上显示了出来。</p><h2 id="Spring-MVC的执行流程"><a href="#Spring-MVC的执行流程" class="headerlink" title="Spring MVC的执行流程"></a>Spring MVC的执行流程</h2><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200301130123.png"/><p>上图演示了Spring MVC执行的流程，在这里稍作解释</p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用处理器映射器HandlerMapping</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter，执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器Handler(Controller，也叫页面控制器)</li><li>Handler执行完成返回ModelAndView</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图(即将模型数据model填充至视图中)</li><li>DispatcherServlet响应用户</li></ol><p>现在稍加解释上面牵涉到的组件：</p><ol><li>DispatcherServlet：前端控制器，用户请求到达前端控制器，它就相当于MVC模式中的C，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高</li><li>HandlerMapping：处理器映射器，HandlerMapping负责根据用户请求的url找到Handler即处理器，SpringMVC提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等</li><li>Handler：处理器,Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler</li><li>HandlAdapter：处理器适配器,通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</li><li>ModelAndView是SpringMVC的封装对象，将Model和View封装在一起。</li><li>ViewResolver：视图解析器,ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</li><li>View:是SpringMVC的封装对象，是一个接口, SpringMVC框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ol><h2 id="Spring-MVC注解"><a href="#Spring-MVC注解" class="headerlink" title="Spring MVC注解"></a>Spring MVC注解</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>@Controller注解表明了一个类是作为控制器的角色而存在的。Spring不要求你去继承任何控制器基类，也不要求你去实现Servlet的那套API。当然，如果你需要的话也可以去使用任何与Servlet相关的特性和设施。</p><p>@Controller注解可以认为是被标注类的原型(stereotype)，表明了这个类所承担的角色。分派器(DispatcherServlet)会扫描所有注解了@Controller的类，检测其中通过@RequestMapping注解配置的方法(详见下一小节)。</p><p>当然，你也可以不使用@Controller注解而显式地去定义被注解的bean，这点通过标准的Spring bean的定义方式，在dispather的上下文属性下配置即可做到。但是@Controller原型是可以被框架自动检测的，Spring支持classpath路径下组件类的自动检测，以及对已定义bean的自动注册。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>这里说的是与@Controller，被@Controller注解的类，如果在方法中方法字符串，则会被视图解析器解析，即如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问<code>/hello</code>时，会执行sayHello方法，这时返回的hello会被视图解析器解析，视图解析器会根据在springmvc-config.xml中的配置进行拼接</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以上面方法的hello会被拼接成WEB-INF/jsp/hello.jsp，接着会返回该jsp页面。</p><p>而使用@RestController注解，则不会经过视图解析器，而是会将该结果直接返回，就像在前一节演示的例子一样。因为最近流行前后端分离，所以后端不需要写页面了，只需要将前端请求的数据返回，而前端负责渲染展示数据，所以@RestController类用的还是比较多的。</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>你可以使用@RequestMapping注解来将请求URL，如/appointments等，映射到整个类上或某个特定的处理器方法上。一般来说，类级别的注解负责将一个特定(或符合某种模式)的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（”GET” “POST”方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。</p><p>现在来讲一下@RequestMapping中的属性，@RequestMapping的源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name, value, path：是用来设置匹配的url路径的</li><li>method：指定请求的method类型, GET、POST、PUT、DELETE等</li><li>consumes：指定处理请求的提交内容类型(Content-Type)，例如application/json, text/html</li><li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</li><li>params：指定request中必须包含某些参数值时，才让该方法处理</li><li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求</li></ul><p>给个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/hello"</span>,</span><br><span class="line">                method = RequestMethod.GET,</span><br><span class="line">                params = <span class="string">"myParam=myValue"</span>,</span><br><span class="line">                headers=<span class="string">"Referer=www.baidu.com"</span>,</span><br><span class="line">                consumes=<span class="string">"application/json"</span>,</span><br><span class="line">                produces=<span class="string">"application/json"</span>)</span><br></pre></td></tr></table></figure><p>除了可以使用method属性指定请求办法外，还可以使用注解：</p><ul><li>@GetMapping(“/hello”)</li><li>@PostMapping(“/hello”)</li><li>……</li></ul><p>这些注解与RequestMapping具有相同的属性，除了method属性。</p><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>该注解类型用于将指定的请求参数赋值给方法中的形参，那么@RequestParam注解有什么属性呢? 它有4种属性，下面将逐一介绍这四种属性：</p><ul><li>name属性：该属性的类型是String类型，它可以指定请求头绑定的名称</li><li>value属性：该属性的类型是String类型，它可以设置是name属性的别名</li><li>required属性：该属性的类型是boolean类型，它可以设置指定参数是否必须绑定</li><li>defalutValue属性：该属性的类型是String类型，它可以设置如果没有传递参数可以使用默认值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">@RequestParam(<span class="string">"loginname"</span>)</span> String loginname,</span></span><br><span class="line"><span class="function">@<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h3><p>@PathVaribale注解，该注解类型可以非常方便的获得请求url中的动态参数。 @PathVaribale注解只支持一个属性value，类型String，表示绑定的名称，如果省略则默认绑定同名参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/pathVariableTest/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathVariableTest</span><span class="params">(@PathVaribale Integer userId)</span></span></span><br></pre></td></tr></table></figure><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>绑定cookie的值到Controller方法参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/hello"</span> )</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testCookieValue</span><span class="params">( @CookieValue(<span class="string">"hello"</span>)</span> String cookieValue) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"cookieValue"</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>@RequestHeader注解，该注解类型用于将请求的头的信息区域数据映射到功能处理方法的参数上。那么@RequestHeader注解有什么属性呢? 它和@RequestParam注解一样，也有4种属性，分别如下</p><ul><li>name属性：该属性的类型是String类型，它可以指定请求头绑定的名称</li><li>value属性：该属性的类型是String类型，它可以设置是name属性的别名</li><li>required属性：该属性的类型是boolean类型，它可以设置指定参数是否必须绑定</li><li>defalutValue属性：该属性的类型是String类型，它可以设置如果没有传递参数可以使用默认值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/requestHeaderTest"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestHeaderTest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">@RequestHeader(<span class="string">"User-Agent"</span>)</span> String userAgent,</span></span><br><span class="line"><span class="function">@<span class="title">RequestHeader</span><span class="params">(value=<span class="string">"Accept"</span>)</span> String[] accepts) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody注解是将HTTP请求正文插入方法中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"..."</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestBody注解常用来处理Content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。</p><p>对于前端使用而言，form表单的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded，所以在前端传输数据时，需要将Content-type显示指定为application/json。</p><p><strong>总结：</strong></p><ul><li>ReuqestBody主要是处理json串格式的请求参数，要求使用方指定header Content-type:application/json</li><li>RequestBody通常要求调用方使用post请求</li></ul><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody注解的作用是将Controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，它的效果等同于通过response对象输出指定格式的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//User字段：userName pwd</span></span><br><span class="line">    <span class="comment">//那么在前台接收到的数据为：'&#123;"userName":"xxx","pwd":"xxx"&#125;'</span></span><br><span class="line">　　<span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//效果等同于如下代码：</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(User user, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">　　　response.getWriter.write(JSONObject.fromObject(user).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/8a20c547e245" target="_blank" rel="noopener">SpringMVC执行流程及工作原理</a></li><li><a href="https://wuyujia.github.io/2017/01/18/requestMapping/" target="_blank" rel="noopener">RequestMapping 属性解释</a></li><li><a href="https://juejin.im/post/5b5efff0e51d45198469acea#heading-0" target="_blank" rel="noopener">Spring之RequestBody的使用姿势小结</a></li><li><a href="https://www.jianshu.com/p/1233b22738d8" target="_blank" rel="noopener">@responseBody注解的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本片文章是我记录学习Spring MVC的学习笔记，作为初学者，对于这个框架的理解可能并不深刻，所以这篇文章主要讲述的是Spring MVC框架的使用，所以对于有些内容为什么要这么做，这么做有什么好处，由于才疏学浅，却不是我能解释的，所以本篇文章以代码偏多，文字解释偏少。&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Java/Web/"/>
    
    
      <category term="Java SpringMVC" scheme="https://lastknightcoder.gitee.io/tags/Java-SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中数学公式问题</title>
    <link href="https://lastknightcoder.gitee.io/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://lastknightcoder.gitee.io/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-29T04:23:42.000Z</published>
    <updated>2020-02-29T04:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前我的Hexo主题使用的是Next主题，Next主题因为对数学公式有进行处理，所以在用Next主题时写数学公式是十分的顺畅的，但是最近觉得Next主题颜色太淡了，所以就换了一个颜色比较鲜艳的Hexo主题，但是这一换，数学公式就有了麻烦。</p><p>首先我们要明白这个麻烦是怎么产生的，因为markdown的语法跟mathjax有重叠，比如<code>_</code>在mathjax中表示下标，但是在markdown中，被两个下划线<code>_</code>包裹起来的内容会被转为<code>&lt;em&gt;</code>标签，即其间的内容会被转为斜体，这就使得数学公式渲染不出来；另一个就是<code>//</code>在mathjax表示换行，但是在解析markdown时却会被转义。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这个时候我就去网上搜了解决办法，有好几种，比如第一种是修改marked.js(node_modules/marked/lib/marked.js)，修改两个关键字为excape和em的正则表达式，这个方法我试了，但是没有用；第二个办法是卸载hexo默认的markdown解析hexo-renderer-marked，然后安装hexo-renderer-pandoc(好像Next就是这么干的)，前提是要安装Pandoc，然后由于我的npm不知道出了什么原因，不能uninstall，只能寻求它法。(不过你们可以尝试，解决办法链接<a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="noopener">在这</a>)</p><p>不过功夫不负有心人，经过几个小时折腾，还是被我找到了解决办法，我在<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/394" target="_blank" rel="noopener">hexo的issue</a>中看到，将有问题的数学公式如下处理：</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200229131807.png"/></center><p>这样数学公式就不会被marked解析，但是会被mathjax解析。</p><p>上面的做法可以解决大部分的问题，但是我们数学公式里面包含一对<code>&lt;&gt;</code>的话，又会出现问题，通过F12检查元素，发现被<code>&lt;&gt;</code>包裹的内容被误认为是标签了，导致渲染不出来，要解决这个办法，把公式中所有的<code>&lt;</code>使用<code>\lt</code>替代，所有的<code>&gt;</code>使用<code>\gt</code>替代，这样就可以了。</p><p>Hexo的数学公式真的是折腾的我够呛，所以这次经历必须记录下来，为了下次遇到同样问题时能够迅速解决。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/ppoffice/hexo-theme-icarus/issues/394" target="_blank" rel="noopener">关于数学公式的渲染问题</a></li><li><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="noopener">Hexo下mathjax转义问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;之前我的Hexo主题使用的是Next主题，Next主题因为对数学公式有进行处理，所以在用Next主题时写数学公式是十分的顺畅的，但是最近觉得
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://lastknightcoder.gitee.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://lastknightcoder.gitee.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Spring笔记</title>
    <link href="https://lastknightcoder.gitee.io/Spring%E7%AC%94%E8%AE%B0/"/>
    <id>https://lastknightcoder.gitee.io/Spring%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-02-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring是一个什么东西? 简单的理解就是一个容器。既然是容器，那就是装东西的，装什么的呢? 里面装的都是对象。以前对象都是由我们自己管理，比如我们在User类中使用Student对象，那么我们会直接new，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>那如果使用Spring的话，会将Student对象放在Spring容器中，如果在User类中使用Student对象，那么就向Spring容器要。我们把这个称之为IOC(控制反转)，即控制权由程序员交给了Spring容器。</p><p>所以接下来就要讲如何将对象交给Spring容器，或者说Spring容器如何创建对象，主要是在创建对象时如何为对象里面的成员变量注入值。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>首先新建一个Maven工程，在pom.xml中导入依赖。说实话Spring框架是一个大家族，它有非常多的包，这里我们导入spring-webmvc，该包依赖了很多其他Spring的包，这样我们需要的包都会被导入，所以我们只要导入这一个包就可以，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在src/main/java下新建pojo.Hello.java，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要将这个Hello对象交给Spring，首先在resources下新建Spring的配置文件beans.xml(名字随便，官方名字是applicationContext.xml)，内容如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"pojo.Hello"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Hello"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"pojo.Hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Hello"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是在Spring容器中注册Hello，其中id是我们向Spring容器获取Hello对象用的，class是Hello类的全限定类名。在bean标签中的peoperty标签的作用是设置在创建Hello对象时其成员变量的值。上面设置为成员变量name注入值Hello。</p><p>现在在test/java下新建TestHello.java，内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Hello hello = (Hello) applicationContext.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello&#123;name=<span class="string">'Hello'</span>&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure><p>是根据配置文件beans.xml得到Spring容器，接着我们根据在beans,xml中配置的id获取Hello对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello hello = (Hello) applicationContext.getBean(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>接着我们打印出Hello对象，发现这个对象的成员变量name已经有值Hello，这是我们在beans.xml中注入的。</p><h2 id="IOC创建对象"><a href="#IOC创建对象" class="headerlink" title="IOC创建对象"></a>IOC创建对象</h2><p>IOC创建对象的过程，其实关键就是向对象的成员变量注入值，我们把这个东西叫做装配，而接下来就是介绍如何为成员变量注入值。</p><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>第一种方法就是通过构造函数注入(初始化)，上面那个例子IOC在创建对象时是调用的是无参构造函数，所以上面那个例子的装配不是通过构造函数装配的，为了演示构造函数装配，首先新建一个User类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在beans.xml注册该类(就是将它交给Spring容器)，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"奥特曼"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中constructor-arg标签就是通过构造函数注入值，这里是通过参数的位置注入值的，比如为第一个参数即index = 0的位置注入”奥特曼”，为第二个参数即index = 1的位置注入1。</p><p>接着我们可以在test/java中新建TestUser类，内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码想必无需解释，上面的结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;userName=<span class="string">'奥特曼'</span>, age=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>可见是注入成功了。</p><p>通过构造器注入，还有两种方法，比如通过类型注入，修改上面的constructor-arg标签如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"奥特曼"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的配置就是根据构造函数参数类型进行配置，再次运行代码，得到的结果还是一样的。</p><blockquote><p><strong>注意:</strong> 如果有多个成员变量的类型是相同的，那么此方法就不适用了。</p></blockquote><p>最后一种就是根据成员变量的名字进行配置，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"奥特曼"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h3><p>set方法注入就是指通过无参构造函数创建对象以后，通过set方法将值注入到成员变量中，所以使用该方法注入就需要为每个成员变量写set方法，修改上面的User类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在beans.xml中进行配置如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"奥特曼"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过property标签向对象注入值，这是通过成员变量的名字进行配置的。</p><h3 id="其它配置方法"><a href="#其它配置方法" class="headerlink" title="其它配置方法"></a>其它配置方法</h3><h4 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a>p命名空间注入</h4><p>要使用p命名空间，就得导入约束，修改beans.xml的约束</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... ... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所谓p命名空间注入与set方法注入是相同的，只不过写法不同，写法如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span> <span class="attr">p:userName</span>=<span class="string">"奥特曼"</span> <span class="attr">p:age</span>=<span class="string">"1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="c命名空间注入"><a href="#c命名空间注入" class="headerlink" title="c命名空间注入"></a>c命名空间注入</h4><p>要使用c命名空间同样要导入约束，再次修改beans.xml如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... ... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c命名空间注入与构造函数注入是相同的，写法同p命名空间注入，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span> <span class="attr">c:userName</span>=<span class="string">"奥特曼"</span> <span class="attr">c:age</span>=<span class="string">"1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span> <span class="attr">c:_0</span>=<span class="string">"奥特曼"</span> <span class="attr">c:_1</span>=<span class="string">"1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上面的0和1代表的是构造函数中参数的位置。</p><h3 id="各种类型成员变量的注入"><a href="#各种类型成员变量的注入" class="headerlink" title="各种类型成员变量的注入"></a>各种类型成员变量的注入</h3><p>这里以set的方式讲解怎么注入各种类型成员变量，比如复杂类型，数组，List等集合，首先新建一个Student类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] hobbies;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; scores;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getHobbies() &#123;</span><br><span class="line">        <span class="keyword">return</span> hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbies</span><span class="params">(String[] hobbies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobbies = hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getGames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGames</span><span class="params">(List&lt;String&gt; games)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getToys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToys</span><span class="params">(Set&lt;String&gt; toys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toys = toys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getScores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScores</span><span class="params">(Map&lt;String, Integer&gt; scores)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address="</span> + address +</span><br><span class="line">                <span class="string">", hobbies="</span> + Arrays.toString(hobbies) +</span><br><span class="line">                <span class="string">", games="</span> + games +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", scores="</span> + scores +</span><br><span class="line">                <span class="string">", wife='"</span> + wife + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的成员变量类型有String，复杂类型Address，数组，List, Map, Set集合，以及最后一个String类型的wife，我们将通过wife演示如果注入null。因为这里用到了复杂类型Address，所以新建类Address如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">                <span class="string">"address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Address注册到Spring容器中，在beans.xml中添加如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"pojo.Address"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"China"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在直接演示如果为Student中的成员变量注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>打球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>游泳<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>王者荣耀<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>吃鸡<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"toys"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>飞机<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>大炮<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scores"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"math"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"english"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>&gt;</span><span class="tag">&lt;/<span class="name">null</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于Address复杂类型，我们使用ref属性引用已经在Spring中注册过的类，其值就是它注册时的id。剩下的应该很容易看懂，就不解释了。</p><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><table><thead><tr><th align="left">标签</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">alias</td><td align="left">别名</td></tr><tr><td align="left">bean</td><td align="left">向Spring容器注册类</td></tr><tr><td align="left">import</td><td align="left">导入其它配置文件</td></tr></tbody></table><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>bean标签有一个scope属性，可以设置作用域，这里只介绍两种取值</p><ul><li>singleton：单例模式，从Spring容器中得到的对象是同一对象，默认值</li><li>prototype：原型模式，从Spring容器中得到的对象是不同对象</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span> <span class="attr">c:userName</span>=<span class="string">"奥特曼"</span> <span class="attr">c:age</span>=<span class="string">"1"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>比如在TestUser中修改如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br><span class="line">        <span class="comment">// 第二个参数传了User.class就不用强转了</span></span><br><span class="line">        User user2 = applicationContext.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user == user2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在修改scope为prototype，再次运行打印出的结果就是false了。</p><h2 id="自动装配Bean"><a href="#自动装配Bean" class="headerlink" title="自动装配Bean"></a>自动装配Bean</h2><p>首先准备几个类，新建Man.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Man有两个宠物，一个为Cat，一个为Dog，新建这两个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"miao"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wang"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在beans.xml中注册Dog和Cat</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Dog"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>现在考虑怎么向Man中注入Cat和Dog。</p><h3 id="按名字自动注入"><a href="#按名字自动注入" class="headerlink" title="按名字自动注入"></a>按名字自动注入</h3><p>在beans.xml添加如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"man"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.pojo.Man"</span> autowire=<span class="string">"byName"</span>/&gt;</span><br></pre></td></tr></table></figure><p>autowire就是用来设置自动注入的，这里设置为按名字自动注入(byName)。它会在Spring容器寻找到id与setXxx中Xxx名字相同的类注入，比如在Man中有setDog()方法，它会在Spring容器中找到id为dog的类(在Spring中注册的类，一般都称为bean)自动为它注入。</p><h3 id="按类型注入"><a href="#按类型注入" class="headerlink" title="按类型注入"></a>按类型注入</h3><p>修改Man的bean为</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"man"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Man"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这时会在Spring容器中寻找类型为Dog和Cat的bean为Man中的Dog和Cat自动注入，但是如果Spring容器中有多个类型相同的bean，那么就不能注入，比如我们向Spring容器中在注入一个Dog如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog2"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Dog"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这时我们发现在beans.xml中报错了</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200226111001.png"/></center><h3 id="使用注解注入"><a href="#使用注解注入" class="headerlink" title="使用注解注入"></a>使用注解注入</h3><p>使用@AutoWired注解在成员变量上，会在Spring容器找到符合条件的，自动注入，首先在beans.xml中注册Man类</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"man"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Man"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在Man.java中为成员变量加上注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><p>这时还是不行的，因为要在beans.xml中开启注解支持，首先导入约束，修改约束如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着开启注解支持，在beans.xml中添加如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>@AutoWired注解首先通过byType即类型寻找符合条件的bean，如果找到多个类型相同的bean符合条件，那么接着在这些bean中byName寻找符合条件的。</p><p>我们可以给成员变量加上@Qualifier注解，这样就会按照@Qualifier规定的name取寻找符合条件的bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"dog"</span>)</span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><p>@AutoWired也可以在setXxx方法上使用，并且如果在成员变量上使用，则可以不写setter方法了。</p><p>除了使用@AutoWired注解，我们还可以使用@Resource注解，这个注解不是Spring的，是J2EE的，我们修改注解如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><p>@Resource是默认byName去寻找符合条件的bean的，如果找不到则byType。</p><h2 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h2><p>要使用注解，首先导入约束(在上面演示过了)，并且开启注解支持，最后设置要扫描的包(即哪些包下的类是使用注解的)，beans.xml的内容如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.pojo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面定义扫描com.pojo下的包，首先新建Student类和Address类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address="</span> + address +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">                <span class="string">"address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>接下来本应该是在beans.xml中注册，但是这次我们不使用xml配置了，而是使用注解，要向Spring容器中注册，我们只需要在类上面加入@Component注解，而注入则可以使用我们在上面介绍的@AutoWired，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"Alice"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address="</span> + address +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"American"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">                <span class="string">"address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Value注解是向其中注入普通值的，如String，int等等，对于一些其他一些复杂类型，如数组，集合等，建议使用xml配置，更清晰。</p><p>接下来在test/java/TestStudent.java中进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Student student = applicationContext.getBean(<span class="string">"student"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">'Alice'</span>, address=Address&#123;address=<span class="string">'American'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>@Component衍生的注解:</strong><br>下面介绍@Component衍生的注解，这些注解的作用与@Component相同，只不过语义不同，如</p><ul><li>@Controller：使用在Web层(servlet)</li><li>@Service：使用在业务层(service)</li><li>@Repository：使用在持久层(dao)</li></ul><p>这些注解的功能相同，就是将类配置在Spring容器中。</p></blockquote><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>@Scope是用来设置bean的范围的，上面我们介绍过两种取值，一种是singleton，另一种是prototype，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br></pre></td></tr></table></figure><h2 id="通过JavaConfig实现配置"><a href="#通过JavaConfig实现配置" class="headerlink" title="通过JavaConfig实现配置"></a>通过JavaConfig实现配置</h2><p>新建工程并新建一个User类，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"biu"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中的内容都不洗解释了。之前我们的配置都是通过xml文件配置的，这次我们将彻底不需要xml文件，而是通过Java类来进行配置，在com.config包下新建JavaConfig.java，内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.pojo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此类中我们使用了一个@Configuration注解，代表这是一个配置类。@ComponentScan定义了扫描包的范围。@Bean注解就是相当于bean标签，其方法名就相当于是id，返回值类型就是class。</p><p>接在我们在test/java/TestUser中进行使用如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.config.JavaConfig;</span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">"getUser"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;name=<span class="string">'biu'</span>, age=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过@Bean注解来设置id，比如上面JavaConfig中的@Bean修改如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure><p>那么我们就可以通过”user”去Spring容器中拿User对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = applicationContext.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 这时不能通过方法名获得对象了。</p></blockquote><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>现在假设有这么一个需求，有下面这么一个dao类，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"query"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望每次在调用该类的方法的前后都打印出日志，我们当然不能在UserDao类中的每个方法中手动打印，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"add方法执行前"</span>);</span><br><span class="line">    System.out.println(<span class="string">"add"</span>);</span><br><span class="line">    System.out.println(<span class="string">"add方法执行后"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样将日志的代码与业务的代码揉在一起，不好；另一个对于每个方法都要写这样的代码，又累又low。</p><h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><p>Spring框架自诞生之日就拯救我等程序员于水火之中，它有两大法宝，一个是IoC控制反转，另一个便是AOP面向切面编程。AOP全名Aspect-oriented programming面向切面编程。</p><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</p><h4 id="目标对象-Target"><a href="#目标对象-Target" class="headerlink" title="目标对象(Target)"></a>目标对象(Target)</h4><p>目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。</p><h4 id="连接点-JoinPoint"><a href="#连接点-JoinPoint" class="headerlink" title="连接点(JoinPoint)"></a>连接点(JoinPoint)</h4><p>程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：</p><ul><li>方法(表示程序执行点，即在哪个目标方法)</li><li>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</li></ul><p>简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。</p><h4 id="切入点-PointCut"><a href="#切入点-PointCut" class="headerlink" title="切入点(PointCut)"></a>切入点(PointCut)</h4><p>切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。 一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。</p><h4 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h4><p>通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。</p><h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。</p><h4 id="增强器-Adviser"><a href="#增强器-Adviser" class="headerlink" title="增强器(Adviser)"></a>增强器(Adviser)</h4><p>Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。 Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。</p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>我们将使用AOP来实现上面的需求，要使用AOP，首先要导入一个包aspectj，如下</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>两个日志类分别表示在方法执行之前和执行之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogBefore</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在"</span> + method.getName() + <span class="string">"之前执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAfter</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在"</span> + method.getName() + <span class="string">"执行后， 返回值为"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在beans.xml中注册这三个类，为了使用AOP，我们要导入约束，beans.xml全部内容如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.dao.UserDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beforeLog"</span> <span class="attr">class</span>=<span class="string">"com.log.LogBefore"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.log.LogAfter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.dao.*.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"beforeLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在在TestUserDao中进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        UserDao userDao = applicationContext.getBean(<span class="string">"userDao"</span>, UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在add之前执行</span><br><span class="line">add</span><br><span class="line">在add执行后， 返回值为<span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="自定义类-AOP"><a href="#自定义类-AOP" class="headerlink" title="自定义类 AOP"></a>自定义类 AOP</h3><p>现在我们将使用另一种用法实现上面的效果，这次我们新建一个Log类，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改beans.xml如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.dao.UserDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.log.Log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"log"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.dao.*.*(..))"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次运行TestUserDao类，输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">add</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h3 id="注解-AOP"><a href="#注解-AOP" class="headerlink" title="注解 AOP"></a>注解 AOP</h3><p>修改beans.xml为</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改Log.java为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.dao.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.dao.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDao.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"query"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行TestUserDao，输出如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">add</span><br><span class="line">after</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Spring笔记
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Java/Web/"/>
    
    
      <category term="Java Spring IOC AOP" scheme="https://lastknightcoder.gitee.io/tags/Java-Spring-IOC-AOP/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习笔记</title>
    <link href="https://lastknightcoder.gitee.io/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lastknightcoder.gitee.io/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-13T16:00:00.000Z</published>
    <updated>2020-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis入门"><a href="#MyBatis入门" class="headerlink" title="MyBatis入门"></a>MyBatis入门</h2><p>新建Maven工程，在其中引入所需要的包，如mybatis, mysql-connector-java, junit。配置pom.xml如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xt.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在MySQL中新建一个mybatis的库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mybatis;</span><br></pre></td></tr></table></figure><p>然后使用该数据库并建一个book表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> mybatis;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> BOOK(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="built_in">NUMBER</span> <span class="built_in">int</span> );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> BOOK(<span class="keyword">NAME</span>,<span class="built_in">NUMBER</span>) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'Java程序设计'</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="string">'数据结构'</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="string">'设计模式'</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>如果出现由于中文不能插入的问题，输入以下语句然后插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mybatis <span class="keyword">change</span> <span class="keyword">name</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><p>在src/java中新建包com.xt.entity，新建Book实体类，实体类是用来保存数据库中查询到的结果，在这里实体类的属性要保持和数据库中的列名一致(后续会讲解不一致会出现什么以及解决办法)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", number="</span> + number +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在src/java中新建包com.xt.dao，新建一个接口BookDao</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.entity.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在src/resources下新建mybatis-config.xml文件配置如下</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">"development"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"development"</span>&gt;</span><br><span class="line">            &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/xt/dao/bookDao.xml"</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>mybatis-config.xml是mybatis的配置文件，我们在其中配置数据源，连接数据库的驱动，连接哪个数据库，以及用户和密码。</p><p>在src/resources下新建目录结构com/xt/dao，在dao文件夹中新建BookDao.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xt.mapper.BookMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.xt.entity.Book"</span>&gt;</span></span><br><span class="line">        select * from book</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在test/java下新建类MyBatisTest</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.mapper.BookDao;</span><br><span class="line"><span class="keyword">import</span> com.xt.entity.Book;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            is = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">            BookMapper bookMapper = sqlSession.getMapper(BookMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            List&lt;Book&gt; list = bookMapper.findAll();</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sqlSession.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Book&#123;id=<span class="number">1</span>, name=<span class="string">'Java程序设计'</span>, number=<span class="number">10</span>&#125;, Book&#123;id=<span class="number">2</span>, name=<span class="string">'数据结构'</span>, number=<span class="number">10</span>&#125;, Book&#123;id=<span class="number">3</span>, name=<span class="string">'设计模式'</span>, number=<span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure><p>如果能够顺利输出以上数据，说明配置没有问题了。</p><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><h3 id="保存操作"><a href="#保存操作" class="headerlink" title="保存操作"></a>保存操作</h3><p>在BookDao中添加方法saveBook(Book book)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Book book)</span></span>;</span><br></pre></td></tr></table></figure><p>然后在BookDao.xml中添加下面的语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;insert id="saveBook" parameterType="com.xt.entity.Book"&gt;</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> book(<span class="keyword">name</span>, <span class="built_in">number</span>) <span class="keyword">values</span> (<span class="comment">#&#123;Book.name&#125;, #&#123;Book.number&#125;);</span></span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的parameterType说明该方法传入的参数类型，需要写全类名。我们在下面一行sql语句中使用了传入Book对象的属性</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;Book.name&#125;, #&#123;Book.number&#125;</span></span><br></pre></td></tr></table></figure><p>由于已经指定了传入的是Book类，所以Book.可以不写，即</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;insert id="saveBook" parameterType="com.xt.entity.Book"&gt;</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> book(<span class="keyword">name</span>, <span class="built_in">number</span>) <span class="keyword">values</span> (<span class="comment">#&#123;name&#125;, #&#123;number&#125;);</span></span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure><p>接在在test/java下的测试类MybatisTest.java，加入下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">    sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    bookDao = sqlSession.getMapper(BookDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book();</span><br><span class="line">    book.setName(<span class="string">"C++"</span>);</span><br><span class="line">    book.setNumber(<span class="number">5</span>);</span><br><span class="line">    bookDao.saveBook(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上的程序做几点声明：</p><ul><li>init()添加了@Before注解，表示该方法会在被@Test注解的方法执行前执行；destroy()添加了@After注解，表示在被@Test注解的方法后执行</li><li>init()中是一些初始化的代码，因为SqlSession和BookDao对象会在@Test注解的方法中用到，为了不每次都初始化，我们把SqlSession和BookDao抽离出来作为成员变量，然后在init()方法中初始化；destroy()中是释放资源的代码</li></ul><p>在执行前我们先看数据库中的数据，以观察该保存操作是否执行成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------------+--------+</span><br><span class="line">| ID | name         | NUMBER |</span><br><span class="line">+----+--------------+--------+</span><br><span class="line">|  1 | Java程序设计 |     10 |</span><br><span class="line">|  2 | 数据结构     |     10 |</span><br><span class="line">|  3 | 设计模式     |     10 |</span><br><span class="line">+----+--------------+--------+</span><br></pre></td></tr></table></figure><p>执行程序之后，数据库中的数据为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------------+--------+</span><br><span class="line">| ID | name         | NUMBER |</span><br><span class="line">+----+--------------+--------+</span><br><span class="line">|  1 | Java程序设计 |     10 |</span><br><span class="line">|  2 | 数据结构     |     10 |</span><br><span class="line">|  3 | 设计模式     |     10 |</span><br><span class="line">+----+--------------+--------+</span><br></pre></td></tr></table></figure><p>发现数据库中的数据并没有发现改变，难道是程序写错了。其实是因为autocommit被设置为false了，所以进行回滚操作了，我们在destroy中加入下面的语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行程序观察数据库中的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------------+--------+</span><br><span class="line">| ID | name         | NUMBER |</span><br><span class="line">+----+--------------+--------+</span><br><span class="line">|  1 | Java程序设计 |     10 |</span><br><span class="line">|  2 | 数据结构     |     10 |</span><br><span class="line">|  3 | 设计模式     |     10 |</span><br><span class="line">|  5 | C++          |      5 |</span><br><span class="line">+----+--------------+--------+</span><br></pre></td></tr></table></figure><p>我们保存对象时并没有设置id的值，因为id是自增长的。如果我们在保存数据后希望获得自增长的id值，我们可以修改BookDao.xml为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;insert id="saveBook" parameterType="com.xt.entity.Book"&gt;</span><br><span class="line">  &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt;</span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">last_insert_id</span>();</span><br><span class="line">  &lt;/selectKey&gt;</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> book(<span class="keyword">name</span>, <span class="built_in">number</span>) <span class="keyword">values</span> (<span class="comment">#&#123;name&#125;, #&#123;number&#125;);</span></span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure><p>接着修改测试类中的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book();</span><br><span class="line">    book.setName(<span class="string">"C++"</span>);</span><br><span class="line">    book.setNumber(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">"更新前的Book对象"</span>);</span><br><span class="line">    System.out.println(book);</span><br><span class="line">    bookDao.saveBook(book);</span><br><span class="line">    System.out.println(<span class="string">"更新后的Book对象"</span>);</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">更新前的Book对象</span><br><span class="line">Book&#123;id=<span class="keyword">null</span>, name=<span class="string">'C++'</span>, number=<span class="number">5</span>&#125;</span><br><span class="line">更新后的Book对象</span><br><span class="line">Book&#123;id=<span class="number">6</span>, name=<span class="string">'C++'</span>, number=<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>可见已经获得了自增长的id。</p><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>在BookDao中添加updateBook(Book book)方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span></span>;</span><br></pre></td></tr></table></figure><p>然后在BookDao.xml中添加如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;update id="updateBook" parameterType="com.xt.entity.Book"&gt;</span><br><span class="line">    <span class="keyword">update</span> book <span class="keyword">set</span> <span class="keyword">name</span> = <span class="comment">#&#123;name&#125;, number = #&#123;number&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">&lt;/<span class="keyword">update</span>&gt;</span><br></pre></td></tr></table></figure><p>现在在测试类中添加测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book();</span><br><span class="line">    book.setId(<span class="number">5</span>);</span><br><span class="line">    book.setName(<span class="string">"PHP"</span>);</span><br><span class="line">    book.setNumber(<span class="number">20</span>);</span><br><span class="line">    bookDao.updateBook(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行并观察数据库中的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------------+--------+</span><br><span class="line">| ID | name         | NUMBER |</span><br><span class="line">+----+--------------+--------+</span><br><span class="line">|  1 | Java程序设计 |     10 |</span><br><span class="line">|  2 | 数据结构     |     10 |</span><br><span class="line">|  3 | 设计模式     |     10 |</span><br><span class="line">|  5 | PHP          |     20 |</span><br><span class="line">+----+--------------+--------+</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>在BookDao中添加deleteBook(Integer id)方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在BookDao.xml中添加如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;delete id="deleteBook" parameterType="int"&gt;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> book <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;id&#125;;</span></span><br><span class="line">&lt;/<span class="keyword">delete</span>&gt;</span><br></pre></td></tr></table></figure><p>这里的parameterType写为了int，其实这里可以写为INT,integer,Integer均可，在sql语句中使用了#{id}，其实这里可以随便写，如#{uid},#{bookId}，因为只传入一个值，不管写什么都会被认为是这个传入的值。现在在测试类中添加测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bookDao.deleteBook(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行并且查看数据库中的数据如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------------+--------+</span><br><span class="line">| ID | name         | NUMBER |</span><br><span class="line">+----+--------------+--------+</span><br><span class="line">|  1 | Java程序设计 |     10 |</span><br><span class="line">|  2 | 数据结构     |     10 |</span><br><span class="line">|  3 | 设计模式     |     10 |</span><br><span class="line">+----+--------------+--------+</span><br></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="查询一个"><a href="#查询一个" class="headerlink" title="查询一个"></a>查询一个</h4><p>在BookDao中添加findById(Integer id)方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Book <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在BookDao.xml中添加如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findById" parameterType="int" resultType="com.xt.entity.Book"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;id&#125;;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的resultType声明了返回的数据类型，接下来在测试了中添加测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = bookDao.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book&#123;id=<span class="number">1</span>, name=<span class="string">'Java程序设计'</span>, number=<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>在BookDao中添加findByName(String name)方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Book&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure><p>在BookDao.xml中添加如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findByName" parameterType="string" resultType="com.xt.entity.Book"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="comment">#&#123;name&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>接下来在测试了中添加测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Book&gt; list = bookDao.findByName(<span class="string">"%设计%"</span>);</span><br><span class="line">    <span class="keyword">for</span>(Book book:list) &#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book&#123;id=<span class="number">1</span>, name=<span class="string">'Java程序设计'</span>, number=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;id=<span class="number">3</span>, name=<span class="string">'设计模式'</span>, number=<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>当初我在使用中文模糊查询时查询不出来，使用英文可以，去网上查了一下，解决办法是是在my.ini文件的最后加上</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">character-set-server</span> = utf8 </span><br><span class="line"><span class="attr">collation-server</span> = utf8_general_ci</span><br></pre></td></tr></table></figure><p>然后重启mysql服务器。具体可以参考这个链接<a href="https://blog.csdn.net/tjzhaomengyi/article/details/52924729" target="_blank" rel="noopener">中文模糊查询</a>。</p><h4 id="查询一个值"><a href="#查询一个值" class="headerlink" title="查询一个值"></a>查询一个值</h4><p>比如我想查询数据库中有多少条数据，在BookDao中添加findTotal()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTotal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在BookDao.xml中添加如下</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id="findTotal" resultType="int"&gt;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> book;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>接下来在测试了中添加测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers = bookDao.findTotal();</span><br><span class="line">    System.out.println(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>上面我们要求实体类Book的属性要与数据库中类的列名相同，如果列名不同呢? 我们修改Book的实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer bookId;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter和setter以及toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在修改测试类中的Setxxx方法，以及BookDao.xml中的#{Xxx}，如修改#{name}为#{bookName}，接着运行findAll的测试方法，得到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>可见数据没有封装。这个时候有两种解决办法</p><ul><li>起别名</li><li>resultMap</li></ul><p>先介绍起别名，我们修改findAll的sql语句为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findAll" resultType="com.xt.entity.Book"&gt;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> bookId, <span class="keyword">name</span> bookName, <span class="built_in">number</span> bookNumber <span class="keyword">from</span> book</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>接着运行findAll的测试方法，结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book&#123;bookId=<span class="number">1</span>, bookName=<span class="string">'Java程序设计'</span>, bookNumber=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;bookId=<span class="number">2</span>, bookName=<span class="string">'数据结构'</span>, bookNumber=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;bookId=<span class="number">3</span>, bookName=<span class="string">'设计模式'</span>, bookNumber=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;bookId=<span class="number">6</span>, bookName=<span class="string">'C++'</span>, bookNumber=<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>可见数据封装好了。这种方法执行效率很高，但是所有的select语句都需要起别名，这里介绍resultMap，只要将实体类的属性名与数据库列名对应好，下面只需要引用即可，只需要写一次，在</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xt.dao.BookDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id是resultMap唯一标识，方便下面引用 type是要对应的实体类名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"bookMap"</span> <span class="attr">type</span>=<span class="string">"com.xt.entity.Book"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--主键的对应规则 property是实体类的属性名 column是数据库的列名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"bookId"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bookName"</span> <span class="attr">column</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bookNumber"</span> <span class="attr">column</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这里就不需要些resultType了，直接引用上面写的resultMap 下面同理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"bookMap"</span>&gt;</span></span><br><span class="line">        select * from book</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"bookMap"</span>&gt;</span></span><br><span class="line">        select * from book where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultMap</span>=<span class="string">"bookMap"</span>&gt;</span></span><br><span class="line">        select * from book where name like #&#123;bookName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次运行findAll的测试方法，输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book&#123;bookId=<span class="number">1</span>, bookName=<span class="string">'Java程序设计'</span>, bookNumber=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;bookId=<span class="number">2</span>, bookName=<span class="string">'数据结构'</span>, bookNumber=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;bookId=<span class="number">3</span>, bookName=<span class="string">'设计模式'</span>, bookNumber=<span class="number">10</span>&#125;</span><br><span class="line">Book&#123;bookId=<span class="number">6</span>, bookName=<span class="string">'C++'</span>, bookNumber=<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>所谓的动态SQL指的是SQL语句不是不变的，比如根据是否传入age以决定是否加入age验证项，下面介绍三种动态SQL。</p><p>加入有下面User表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-----------+------+</span></span><br><span class="line">| user_name | age  |</span><br><span class="line">+<span class="comment">-----------+------+</span></span><br><span class="line">| 张三      |   18 |</span><br><span class="line">| 李四      |   19 |</span><br><span class="line">+<span class="comment">-----------+------+</span></span><br></pre></td></tr></table></figure><p>实体类以及UserDao接口就不演示了。</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>首先在UserDao中创建下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByCondition</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法根据传入的User对象去查询，主要是根据该User对象所包含的userName和age去查询，但是这个User对象不一定设置了这两个属性，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">userDao.findByCondition(user);</span><br></pre></td></tr></table></figure><p>上面的Java代码只设置了age的值，这意味着我们在userDao.xml中的select语句不能写成这样</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name = <span class="comment">#&#123;userName&#125; and age = #&#123;age&#125;</span></span><br></pre></td></tr></table></figure><p>假设如果userName没有设置的话，那么where后面的结果永远是false，意味着查不到结果，而我们希望的是，如果存在什么，则根据什么是查，比如如果不存在userName，存在age，则相应的SQL语句应该是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age = <span class="comment">#&#123;age&#125;</span></span><br></pre></td></tr></table></figure><p>如果存在userName而不存在age，则只根据userName查，如果都不存在，则得到所有的User，即</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>这个时候仅仅靠我们上面的手段是得不到的，因为这时的SQL语句是动态的。明显，我们需要对userName和age进行判断，以决定是否加入到SQL语句中，而判断使用的就是if。满足上面要求的SQL语句如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findByCondition" parameterType="com.xt.domain.User" resultType="com.xt.domain.User"&gt;</span><br><span class="line">    <span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">    &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"userName != null"</span>&gt;</span><br><span class="line">        <span class="keyword">and</span> user_name = <span class="comment">#&#123;userName&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"age != null"</span>&gt;</span><br><span class="line">        <span class="keyword">and</span> age = <span class="comment">#&#123;age&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的if标签就是对User对象中的属性进行判断，判断语句要写在if标签的test属性中，如果为真，则if标签包含的内容则会添加到SQL语句后，否则不会添加。</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>大家注意上面的SQL语句中有</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">where 1 = 1</span><br></pre></td></tr></table></figure><p>那么为什么要加上1 = 1呢? 假设如果不加1 = 1，并且传过来的User对象的userName和age都为null，那么最后的SQL语句是什么样子?</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure><p>这明显是一个错误的SQL语句，但是如果加上1 = 1，即使userName和age都为null，SQL也是正确的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是这样未免有点hack的意味，像是一种奇淫技巧，那mybatis有没有提供比较好的写法，答案就是where标签了，现在我们将上面的sql语句改为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">&lt;<span class="keyword">where</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"userName != null"</span>&gt;</span><br><span class="line">        <span class="keyword">and</span> user_name = <span class="comment">#&#123;userName&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"age != null"</span>&gt;</span><br><span class="line">        <span class="keyword">and</span> age = <span class="comment">#&#123;age&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">where</span>&gt;</span><br></pre></td></tr></table></figure><p>我们将所有的if标签都放到了where标签里面，如果所有的if都不满足的话，那么在SQL语句中就不会出现where，如果if至少有一个成立的话，则会去掉第一个成立if标签中包含的and。假设该User对象包含userName不包含age，则最后的SQL语句是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name = <span class="comment">#&#123;userName&#125;</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>现在有一种的新的情况，如果传过来的参数是一个集合或者数组，那怎么处理呢? 在UserDao接口中添加下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByAges</span><span class="params">(List&lt;Integer&gt; ages)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法会接收一个List集合，我们的要求是去查询用户年龄在ages集合中的用户，相应的SQL语句如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findByAges" resultType="com.xt.domain.User" parameterType="java.util.List"&gt;</span><br><span class="line">    <span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    &lt;<span class="keyword">where</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"list != null"</span>&gt;</span><br><span class="line">            &lt;foreach collection=<span class="string">"list"</span> item=<span class="string">"age"</span> <span class="keyword">open</span>=<span class="string">"and age in("</span> <span class="keyword">close</span>=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">                <span class="comment">#&#123;age&#125;</span></span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">where</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的where和if标签想必不用再解释了，重点是forEach标签。forEach的作用就是遍历集合创建一个SQL语句。forEach中的collection标签的值就是传过来的list集合，item就是集合中的元素，forEach会遍历该集合拿到这些item，open是指创建的SQL语句以什么开头，close是以什么结尾，而separator是指分隔符是什么，而forEach中包含的内容即是分隔符分隔的一个个元素。所以假设传来这么一个List</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.append(<span class="number">15</span>);</span><br><span class="line">list.append(<span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>那么上面的SQL语句最后会被生成为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">15</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p>在上面，我们发现上面的SQL语句都包含这么一条SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>既然这是重复的内容，那我们就可以将其抽离出来成一个SQL片段，然后在SQL语句中引用该片段，在userDao.xml中的mapper标签下，我们加入以下内容</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;sql id="default"&gt;</span><br><span class="line">    <span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">&lt;/<span class="keyword">sql</span>&gt;</span><br></pre></td></tr></table></figure><p>上面的id名可以任意的取，这里的id是为了在后面引用该SQL片段。接下来将所有select中的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name userName, age <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;include refid="default"&gt;&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>如</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id="findByAges" resultType="com.xt.domain.User" parameterType="java.util.List"&gt;</span><br><span class="line">    &lt;include refid="selectAll"&gt;&lt;/include&gt;</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test="list != null"&gt;</span><br><span class="line">            &lt;foreach collection="list" item="age" open="and age in(" close=")" separator=","&gt;</span><br><span class="line">                <span class="comment">#&#123;age&#125;</span></span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="一对多与多对一"><a href="#一对多与多对一" class="headerlink" title="一对多与多对一"></a>一对多与多对一</h3><p>假设有两张表，用户表和账户表，二者之间的关系为</p><ul><li>一个用户可以有多个账户</li><li>一个账户对应一个用户</li></ul><p>现在我们的需求的是当我们查询用户时，同时查询它所包含的所有账户，当我们查询账户时，同时查询它所对应的用户。</p><p>现在创建两张表user和account。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`birthday`</span> datetime <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`user`</span>(<span class="string">`id`</span>,<span class="string">`username`</span>,<span class="string">`birthday`</span>,<span class="string">`sex`</span>,<span class="string">`address`</span>) <span class="keyword">values</span> (<span class="number">41</span>,<span class="string">'老王'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>), (<span class="number">42</span>,<span class="string">'小王'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>), (<span class="number">45</span>,<span class="string">'张三'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">46</span>,<span class="string">'超级玛丽'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'北京修正'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`account`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (</span><br><span class="line">  <span class="string">`ID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`UID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`MONEY`</span> <span class="keyword">double</span> <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'金额'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`ID`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_Reference_8`</span> (<span class="string">`UID`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_8`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`UID`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`account`</span>(<span class="string">`ID`</span>,<span class="string">`UID`</span>,<span class="string">`MONEY`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">46</span>,<span class="number">1000</span>),(<span class="number">2</span>,<span class="number">45</span>,<span class="number">1000</span>),(<span class="number">3</span>,<span class="number">46</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>现在这两张表的内容为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># user</span></span><br><span class="line">+<span class="comment">----+----------+---------------------+------+------------+</span></span><br><span class="line">| id | username | birthday            | sex  | address    |</span><br><span class="line">+<span class="comment">----+----------+---------------------+------+------------+</span></span><br><span class="line">| 41 | 老王     | 2018-02-27 17:47:08 | 男   | 北京       |</span><br><span class="line">| 42 | 小王     | 2018-03-02 15:09:37 | 女   | 北京金燕龙 |</span><br><span class="line">| 45 | 张三     | 2018-03-07 17:37:26 | 男   | 北京       |</span><br><span class="line">| 46 | 超级玛丽 | 2018-03-08 11:44:00 | 女   | 北京修正   |</span><br><span class="line">+<span class="comment">----+----------+---------------------+------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># account</span></span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| ID | UID  | MONEY |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 |   46 |  1000 |</span><br><span class="line">|  2 |   45 |  1000 |</span><br><span class="line">|  3 |   46 |  2000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>现在创建对应的实体类以及对应的接口以及相应的xml文件。二者的实体类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">getAccounts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", birthday="</span> + birthday +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", accounts="</span> + accounts +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(Integer uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", uid="</span> + uid +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">", user="</span> + user +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细注意这两个实体类，发现在User实体类中有一个Account的List列表，因为一个用户可以有多个账户。而在Account中有一个User对象，因为一个账户对应一个用户。</p><p>现在我们来实现第一个需求，当查询所有用户时，同时显示每个用户下的所有账户信息，在UserDao中加入下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAllUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>下面在userDao.xml中加入下面的查询语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace="dao.UserDao"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id="users" type="entity.User"&gt;</span><br><span class="line">        &lt;id column="id" property="id"&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result column="username" property="userName"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result column="sex" property="sex"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result column="address" property="address"&gt;&lt;/result&gt;</span><br><span class="line"></span><br><span class="line">        &lt;collection property="accounts" ofType="entity.Account"&gt;</span><br><span class="line">            &lt;id column="aid" property="id"&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result column="uid" property="uid"&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result column="money" property="money"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id="findAllUsers" resultMap="users"&gt;</span><br><span class="line">        <span class="keyword">select</span> user.*, account.id aid, account.uid, account.money <span class="keyword">from</span> <span class="keyword">user</span>, <span class="keyword">account</span> <span class="keyword">where</span> user.id = account.uid</span><br><span class="line">    &lt;/<span class="keyword">select</span>&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>由于User中包含一个Account类型的List，所以要设置这个List的对应规则，正是上面collection标签的部分，property是User中List对象的名称，ofType是List集合的类型。collection包含的部分就是List元素对应的规则。</p><p>现在实现第二个需求，当查询账户时，同时查询出对应的User信息，在AccountDao中添加下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Account&gt; <span class="title">findAllAccounts</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在accountDao.xml添加内容如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace="dao.AccountDao"&gt;</span><br><span class="line">    &lt;resultMap id="accounts" type="entity.Account"&gt;</span><br><span class="line">        &lt;id property="id" column="aid"&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property="uid" column="uid"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property="money" column="money"&gt;&lt;/result&gt;</span><br><span class="line"></span><br><span class="line">        &lt;association property="user" javaType="entity.User"&gt;</span><br><span class="line">            &lt;id property="id" column="id"&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property="userName" column="username"&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property="sex" column="sex"&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property="address" column="address"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id="findAllAccounts" resultMap="accounts"&gt;</span><br><span class="line">        <span class="keyword">select</span> user.*, account.id aid, account.uid, account.money <span class="keyword">from</span> <span class="keyword">account</span> </span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> <span class="keyword">on</span> user.id = account.uid</span><br><span class="line">    &lt;/<span class="keyword">select</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>在Account中有一个User对象，我们要设置这个的对应规则，使用的就是association，property就是Account中User对象的名称，javaType是指对应的实体类。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>其实多对多查询与一对多的查询是一样的，上述我们在User类中添加了一个类型为Account的List集合，已表示一对多，在Account中有一个User对象，已表示一对一。</p><p>那要如果表示多对多，假设一个账户对应多个用户，那么只要在Account中将一个User对象改为一个类型为User的List列表。</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>延迟加载又称为懒加载，又称按需加载，指的就是在需要的时候才加载，比如上面查询所有的User，但是这时不需要立即加载对应的账户信息，而是等我们使用账户信息时在进行加载，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.getAccounts();</span><br></pre></td></tr></table></figure><p>这时再向数据库发起查询。</p><p>MyBatis根据对关联对象查询的select语句的执行时机，分为三种类型：直接加载、侵入式加载与深度延迟加载</p><ul><li>直接加载：执行完对主加载对象的select语句，马上执行对关联对象的select查询。</li><li>侵入式延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的某个属性（该属性不是关联对象的属性）时，就会马上执行关联对象的select查询。</li><li>深度延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的select查询。只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。</li></ul><p>Mybatis的延迟加载，需要通过resultMap标签中的association和collection子标签才能演示成功。</p><p>要设置延迟加载，需要在mybatis-config.xml中设置，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lazyLoadingEnabled是设置是否深度延迟，当设置为true，就是设置为深度延迟，即当访问关联对象的详细信息时才会进行查询。aggressiveLazyLoading是用来设置侵入式延迟，默认为false，这里本应不用设置，只是为了演示。</p><h3 id="一对一延时加载"><a href="#一对一延时加载" class="headerlink" title="一对一延时加载"></a>一对一延时加载</h3><p>这里演示当查询账户时，同时查询对应的用户信息。首先我们看原先的查询语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user.*, account.id aid, account.uid, account.money <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> <span class="keyword">on</span> user.id = account.uid</span><br></pre></td></tr></table></figure><p>如果这么写的话，会立即查询相应User的信息，所以必须更改上面的sql语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span></span><br></pre></td></tr></table></figure><p>同时修改resultMap如下</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id="accounts" type="entity.Account"&gt;</span><br><span class="line">    &lt;id property="id" column="id"&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result property="uid" column="uid"&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result property="money" column="money"&gt;&lt;/result&gt;</span><br><span class="line"></span><br><span class="line">    &lt;association property="user" javaType="entity.User" select="dao.UserDao.findById" column="uid"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>注意到我们将association中的对应规则删除了，因为在上面的sql语句中我们只查询了account的内容。但是我们增加了两个属性，一个是select属性，这个是当我们使用account对象访问其中的User属性时会调用的sql语句，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">account.getUser();</span><br></pre></td></tr></table></figure><p>这时因为会访问Account关联对象User的具体信息，会调用userDao的findbyId(Integer id)进行查询，从而得到相应的User信息。</p><p>第二个参数是column，其值是上面findById方法所需要的id。</p><p>这里向UserDao中增加下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>并且在userDao.xml中增加select标签</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findById" resultType="entity.User" parameterType="Integer"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>此刻万事大吉，这里贴出accountDao.xml中的内容</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id="accounts" type="entity.Account"&gt;</span><br><span class="line">    &lt;id property="id" column="id"&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result property="uid" column="uid"&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result property="money" column="money"&gt;&lt;/result&gt;</span><br><span class="line"></span><br><span class="line">    &lt;association property="user" javaType="entity.User" select="dao.UserDao.findById" column="uid"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id="findAllAccounts" resultMap="accounts"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="一对多延时加载"><a href="#一对多延时加载" class="headerlink" title="一对多延时加载"></a>一对多延时加载</h3><p>一对多延时加载与一对一延时加载是一样，只不过association换成了collection。</p><p>这里我们以查询User信息时，同时查询该用户包含的所有账户，这里修改findAllUsers对应的sql语句为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findAllUsers" resultMap="users"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>修改对应的resultMap为</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id="users" type="entity.User"&gt;</span><br><span class="line">    &lt;id column="id" property="id"&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result column="username" property="userName"&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column="sex" property="sex"&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column="address" property="address"&gt;&lt;/result&gt;</span><br><span class="line">    &lt;collection column="id" property="accounts" ofType="entity.Account" select="dao.AccountDao.findByUid"&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>这时上面的代码已经不需要解释了，在AccountDao中添加findByUid的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Account&gt; <span class="title">findByUid</span><span class="params">(Integer uid)</span></span>;</span><br></pre></td></tr></table></figure><p>同时在accountDao.xml中添加对应的select标签</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findByUid" resultType="entity.Account" parameterType="Integer"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> uid = <span class="comment">#&#123;uid&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>所谓缓存，指的就是当我们向数据库查询数据时，将数据保存在内存中，当第二次查询时，不再向数据库进行查询，而是直接从内存拿数据，这就是缓存。由于数据在内存中，从内存中拿数据比从数据库中拿数据快很多，并且也可以减少数据库的压力。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>MyBatis中的一级缓存的范围是sqlSession，即相当于在sqlSession中有一个localCache，当sqlSession查询数据时会将数据保存在这个cache中，当该sqlSession再次查询数据时，会先在这个cache中查询数据，如果有，则会直接拿内存中的数据，如果没有，则会去数据库查询。</p><p>那怎么保证拿到的数据不会错呢? 比如当更新数据后，如果继续从缓存中拿数据，这时拿到的数据就会是错的，所以当发生更新、删除、commit()等操作时，就会将一级缓存清空，这就意味着当更新数据后，就得直接去数据库中拿数据了。当SqlSession对象调用clearCache()，也会清除sqlSession的缓存。</p><p>那么怎么开启一级缓存呢? 在mybatis-config.xml中添加下面的setting</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>localCacheScope有两种取值，一种是SESSION，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存；一种是STATEMENT级别，可以理解为缓存只对当前执行的这一个Statement有效。默认是SESSION级别，这就意味着一级缓存默认是开启的，上面的设置不用写。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>想象有两个sqlSession，暂且称之为sqlSession1和sqlSession2，二者连接了同一个表，假设sqlSession1对表进行了更新，sqlSession2向数据库查询数据，但是由于一级缓存的存在，并且sqlSession2没有进行增加、删除等等操作，意味着sqlSession2没有清楚缓存，所以sqlSession2拿到的是缓存中的数据，这种数据称之为脏数据。</p><p>那怎么解决这个问题? 这个时候就要使用二级缓存。二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200223232415.png"/></center><p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>那怎么开启二级缓存呢? 首先在mybatis-config.xml加入下面的设置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>接着在xxxDao.xml中的namespace(mapper标签内中)加入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果希望局部关闭二级缓存时，比如某查询标签关闭二级缓存，则在标签的属性useCache设置为false，如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findAllUsers" resultMap="users" useCache="false"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>二级缓存对于不同的命名空间namespace的数据是互不干扰的，倘若多个namespace中对一个表进行操作的话，就会导致这不同的namespace中的数据不一致的情况。例如，在单表上使用二级缓存 在做关联关系查询时，就会发生多表的操作，此时有可能这些表存在于多个namespace中，这就会出现上面出现的问题了。</p><p><strong>总结:</strong></p><ul><li>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li></ul><h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><p>使用注解开发，不需要对应的xxxDao.xml文件，因为我们将sql语句写在XxxDao接口的注解中。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>新建一个工程，配置好pom.xml文件以及mybatis-config.xml的主配置文件，在entity包下新建User实体类，在dao包下新建UserDao接口，内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在test/java/TestUser类中进行单元测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        userDao = sqlSession.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[User&#123;id=<span class="number">41</span>, userName=<span class="string">'老王'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>, address=<span class="string">'北京'</span>&#125;, User&#123;id=<span class="number">42</span>, userName=<span class="string">'小王'</span>, sex=<span class="string">'女'</span>, birthday=Fri Mar <span class="number">02</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37</span> CST <span class="number">2018</span>, address=<span class="string">'北京金燕龙'</span>&#125;, User&#123;id=<span class="number">45</span>, userName=<span class="string">'张三'</span>, sex=<span class="string">'男'</span>, birthday=Wed Mar <span class="number">07</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">26</span> CST <span class="number">2018</span>, address=<span class="string">'北京'</span>&#125;, User&#123;id=<span class="number">46</span>, userName=<span class="string">'超级玛丽'</span>, sex=<span class="string">'女'</span>, birthday=Thu Mar <span class="number">08</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">00</span> CST <span class="number">2018</span>, address=<span class="string">'北京修正'</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="其他CRUD"><a href="#其他CRUD" class="headerlink" title="其他CRUD"></a>其他CRUD</h3><p>这里简单的演示实验其他的CRUD操作。</p><h4 id="更新操作-1"><a href="#更新操作-1" class="headerlink" title="更新操作"></a>更新操作</h4><p>在UserDao中添加如下方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"update user set username = #&#123;userName&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在测试类中进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">45</span>);</span><br><span class="line">    user.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">    userDao.updateUser(user);</span><br><span class="line">    System.out.println(userDao.findAll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[User&#123;id=<span class="number">41</span>, userName=<span class="string">'老王'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>, address=<span class="string">'北京'</span>&#125;, User&#123;id=<span class="number">42</span>, userName=<span class="string">'小王'</span>, sex=<span class="string">'女'</span>, birthday=Fri Mar <span class="number">02</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37</span> CST <span class="number">2018</span>, address=<span class="string">'北京金燕龙'</span>&#125;, User&#123;id=<span class="number">45</span>, userName=<span class="string">'李四'</span>, sex=<span class="string">'男'</span>, birthday=Wed Mar <span class="number">07</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">26</span> CST <span class="number">2018</span>, address=<span class="string">'北京'</span>&#125;, User&#123;id=<span class="number">46</span>, userName=<span class="string">'超级玛丽'</span>, sex=<span class="string">'女'</span>, birthday=Thu Mar <span class="number">08</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">00</span> CST <span class="number">2018</span>, address=<span class="string">'北京修正'</span>&#125;]</span><br></pre></td></tr></table></figure><p>如果发现不能插入中文，则修改mybatis-config.xml中的dataSource中的url为</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>在UserDao中添加下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(username, sex, address, birthday) values(#&#123;userName&#125;, #&#123;sex&#125;, #&#123;address&#125;, #&#123;birthday&#125;)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在测试类中进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">"奥特曼"</span>);</span><br><span class="line">    user.setSex(<span class="string">"男"</span>);</span><br><span class="line">    user.setAddress(<span class="string">"M78"</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">    userDao.insertUser(user);</span><br><span class="line">    System.out.println(userDao.findAll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><p>在UserDao中添加下面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Delete</span>(<span class="string">"delete from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在测试类中进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.deleteUserById(<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">for</span> (User user: userDao.findAll()) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在注解中配置resultMap"><a href="#在注解中配置resultMap" class="headerlink" title="在注解中配置resultMap"></a>在注解中配置resultMap</h3><p>如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line"><span class="meta">@Results</span>(value = &#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"username"</span>, property = <span class="string">"userName"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"sex"</span>, property = <span class="string">"sex"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"birthday"</span>, property = <span class="string">"birthday"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"address"</span>, property = <span class="string">"address"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>如果直接将Results写在方法上，那就意味则如果还有方法需要些resultMap，那么就还需要在写一遍，我们希望就是只写一遍resultMap，然后通过id引用即可，我们给上面的Results添加id</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results</span>(id = <span class="string">"users"</span>, value = &#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"username"</span>, property = <span class="string">"userName"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"sex"</span>, property = <span class="string">"sex"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"birthday"</span>, property = <span class="string">"birthday"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"address"</span>, property = <span class="string">"address"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在需要resultMap的方法上添加如下的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results</span>(value = &#123;<span class="string">"users"</span>&#125;)</span><br></pre></td></tr></table></figure><p>或者简写为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results</span>(<span class="string">"users"</span>)</span><br></pre></td></tr></table></figure><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line"><span class="meta">@Results</span>(id = <span class="string">"accounts"</span>, value = &#123;</span><br><span class="line">        <span class="meta">@Result</span>(id = <span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"uid"</span>, property = <span class="string">"uid"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"money"</span>, property = <span class="string">"money"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"uid"</span>, property = <span class="string">"entity.User"</span>, one = <span class="meta">@One</span>(select = <span class="string">"dao.UserDao.findById"</span>, fetchType = FetchType.EAGER)),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Result中的one就是用来设置一对一查询的，其值是一个One注解，其中的select不用解释，与在xml中association设置的select相同功能</li><li>fetchType是用来设置是立即加载还是延迟加载的<ul><li>FetchType.EAGER：立即加载</li><li>FetchType.LAZY：延迟加载</li></ul></li></ul><blockquote><p>注意，如果要使用延迟加载，得先在mybatis-config.xml中开启延迟加载(方法同xml配置方式)。</p></blockquote><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line"><span class="meta">@Results</span>(value = &#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"username"</span>, property = <span class="string">"userName"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"sex"</span>, property = <span class="string">"sex"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"birthday"</span>, property = <span class="string">"birthday"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"address"</span>, property = <span class="string">"address"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(column = <span class="string">"id"</span>, property = <span class="string">"accounts"</span>, many = <span class="meta">@Many</span>(select = <span class="string">"dao.AccountDao.findByUid"</span>, fetchType = FetchType.LAZY))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将one换成了many，对应的Many注解里面的内容不用多加解释。</li></ul><h3 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h3><p>如何在注解中使用缓存，对于一级缓存来说，与xml相同，不用设置，默认是SESSION。</p><p>对于二级缓存，首先在mybatis-config.xml开启缓存，与在xml中相同。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在xml中，我们是在namespace中设置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是在注解中，我们在UserDao接口上添加@CacheNameSpace注解，设置其blocking属性为true，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span>(blocking = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就开启二级缓存了。</p>]]></content>
    
    <summary type="html">
    
      MyBatis入门
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Java/Web/"/>
    
    
      <category term="MyBatis" scheme="https://lastknightcoder.gitee.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>使用React搭建一个基于富文本编辑器的博客系统</title>
    <link href="https://lastknightcoder.gitee.io/%E4%BD%BF%E7%94%A8React%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lastknightcoder.gitee.io/%E4%BD%BF%E7%94%A8React%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-10T16:00:00.000Z</published>
    <updated>2020-02-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从0开始搭建一个基于富文本编辑器的博客系统，包括的内容有</p><ul><li><code>React</code>的基础知识</li><li>富文本编辑器组件<code>BraftEditor</code>的使用及扩展</li><li><code>React Hooks</code></li><li><code>Redux + React-Redux</code></li><li><code>antd</code>表单的介绍及使用</li><li>登录权限控制</li></ul><h1 id="项目前的准备"><a href="#项目前的准备" class="headerlink" title="项目前的准备"></a>项目前的准备</h1><p>首先需要下载<code>Node.js</code>和<code>npm</code>(下载<code>Node.js</code>自带<code>npm</code>)，下载完<code>Node.js</code>后，由于<code>npm</code>的速度较慢，可以考虑使用下面的命令下载<code>cnpm</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g</span><br></pre></td></tr></table></figure><blockquote><p><strong>npm是什么，为什么会需要npm：</strong></p><p>想要知道npm是什么，那就要先从共享代码说起，程序员自古以来就有社区文化，加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。</p><p>前端是怎么共享代码的呢?</p><p>在 GitHub 还没有兴起的年代，前端是通过网址来共享代码，比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用，GItHub 兴起之后，社区中也有人使用 GitHub 的下载功能。</p><p>当一个网站依赖的代码越来越多，程序员发现这是一件很麻烦的事情，比如你要下载BootStrap，你就必须下载jQuery，因为BootStrap依赖jQuery，所以你需要一个网站一个网站的去下代码。如果遇到依赖比较多的情况，这个库依赖另一个库，另一个库又依赖另一个库，如此当依赖关系十分复杂时，你根本不知道要下哪些库，这对程序员来说简直就是个灾难。</p><p>有些程序员就受不了了，一个程序员叫 Isaac Z. Schlueter(以下简称Isaaz)给出一个解决方案：用一个工具把这些代码集中到一起来管理吧!这个工具就是他用 JavaScript(运行在Node.js上)写的 npm，全称是 Node Package Manager。</p><p>NPM 的思路大概是这样的：</p><ol><li>买个服务器作为代码仓库(registry)，在里面放所有需要被共享的代码</li><li>发邮件通知 jQuery、Bootstrap、Underscore等作者使用npm publish 把代码提交到registry上，分别取名 jquery、bootstrap和underscore(注意大小写)</li><li>社区里的其他人如果想使用这些代码，就把jquery、bootstrap和underscore写到package.json里，然后运行 npm install，npm就会帮他们下载代码</li><li>下载完的代码出现在 node_modules 目录里，可以随意使用了。</li></ol><p>这些可以被使用的代码被叫做「包」(package)，这就是 NPM名字的由来：Node Package(包) Manager(管理器)。</p><p>但是npm叫别人这么干，别人不一定会这么干啊，所以npm是怎么火的呢?npm的发展是跟Node.js的发展相辅相成的。Node.js是由一个在德国工作的美国程序员Ryan Dahl写的。他写了Node.js，但是Node.js缺少一个包管理器，于是他和 npm的作者一拍即合、抱团取暖，最终Node.js内置了npm。</p><p>后来的事情大家都知道，Node.js火了。随着Node.js的火爆，大家开始用 npm来共享JS代码了，于是jQuery作者也将 jQuery发布到npm了。所以现在，你可以使用npm install jquery来下载jQuery代码。</p><p>现在用npm来分享代码已经成了前端的标配。</p></blockquote><p>接下来下载搭建<code>React</code>项目的脚手架<code>create-react-app</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install create-react-app -g</span><br></pre></td></tr></table></figure><blockquote><p><strong>什么是脚手架：</strong><br>随着前端工程化的概念越来越深入人心，脚手架的出现就是为减少重复性工作而引入的命令行工具，摆脱ctrl + c, ctrl + v，此话zenjiang? 现在新建一个前端项目，已经不是在html头部引入css，尾部引入js那么简单的事了，css都是采用Sass或则Less编写，在js中引入，然后动态构建注入到html中；除了学习基本的js，css语法和热门框架，还需要学习构建工具webpack，babel这些怎么配置，怎么起前端服务，怎么热更新；为了在编写过程中让编辑器帮我们查错以及更加规范，我们还需要引入ESlint；甚至，有些项目还需要引入单元测试(Jest)。对于一个刚入门的人来说，这无疑会让人望而却步。而前端脚手架的出现，就让事情简单化，一键命令，新建一个工程，再执行两个npm命令，跑起一个项目。在入门时，无需关注配置什么的，只需要开心的写代码；另外，对于很多系统，他们的页面相似度非常高，所以就可以基于一套模板来搭建，虽然是不同的人开发，但用脚手架来搭建，相同的项目结构与代码书写规范，是很利于项目的后期维护的；以上就是为什么脚手架存在的意义， 让项目从”搭建-开发-部署”更加快速以及规范。</p></blockquote><p>接着使用create-react-app搭建一个React项目，这里的项目名称就命名为blog</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create-react-app blog</span><br></pre></td></tr></table></figure><p>使用该命令会在本地生成一个文件夹blog，里面的内容如下</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200208002028.png"/></center><p>其中src就是我们开发的文件夹，其中index.js是入口文件，里面的内容为</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">'./serviceWorker'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you want your app to work offline and load faster, you can change</span></span><br><span class="line"><span class="comment">// unregister() to register() below. Note this comes with some pitfalls.</span></span><br><span class="line"><span class="comment">// Learn more about service workers: https://bit.ly/CRA-PWA</span></span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure><p>现在我们将里面的内容改为</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>然后npm start就可以看到下面的页面</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200208003524.png"/></center><p>这时可以将src下除index.js的文件全部都删掉了，因为没有用到他们。</p><h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2><p>可能现在你对上面的代码不太了解，特别是怎么在JavaScrpt里面写HTML</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>这里的HTML就是JSX，JSX的全称是JavaScript XML，指的就是JavaScript中的XML。</p><p>上面这行语句的作用是什么呢? React会解析这个JSX语句为一个虚拟DOM，而ReactDOM会将这个虚拟DOM转变为真正的DOM，然后塞到页面某个特定的元素上面，这里是塞到一个id为root(该DOM元素在public/index.html中)的DOM对象中,我们查看index.html中的内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 省略head中的内容和所有注释 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过ReactDOM渲染后的index.html的页面应该为为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 省略head中的内容和所有注释 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了验证这个想法，可以在刚才的页面中按下F12检查元素</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200208213722.png"/></center><p>所以页面显示出来的就是Hello React。</p><blockquote><p><strong>为什么需要虚拟DOM：</strong></p><p>原因很简单，那就是DOM很慢，我们先来看一下浏览器的渲染流程</p><ul><li>用HTML分析器，分析HTML元素，构建一颗DOM树</li><li>用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表</li><li>将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树</li><li>有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值</li><li>Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来</li></ul><p>当你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。</p><p>即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。</p><p>虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。</p></blockquote><p>我们知道React中的JSX会被解析为一个React对象(或者说JavaScript对象)，所以我们在写JSX的过程中，就可以把JSX看做是一个对象(记住JSX的本质就是对象，每当在JavaScript代码中看到这种JSX结构的时候，脑子里面就可以自动做转化，这样对你理解React.js的组件写法很有好处)。这就意味着JSX只能有一个根元素，如下面的写法是错误的</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>因为上面的代码并不能被解析为一个对象，正确的写法应该是</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>这样的JSX才会被解析为一个对象。</p><p>现在我们在来说一下文件开头的两行语句</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br></pre></td></tr></table></figure><p>在React中，我们使用import来导入npm下载的包，这里我们引入了React和ReactDOM，这里你可能有疑问，我们并没有使用npm下载react和react-dom，为什么能够引入，这是因为create-react-app为我们做了这件事情，打开package.json我们可以发现已经帮我们添加了react和react-dom</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200208211434.png"/></center><p>那么引入的React是做什么事情的呢? 首先在JavaScript中是不能写JSX的，在React中的JSX会被解析为JavaScript对象，就是通过React来做到的，而ReactDOM是将React渲染的JSX对象(有时我们也称之为组件)转变为真正的DOM对象并塞到某个特定的元素里面。所以记住只要你写React.js组件，都必须要引入React。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>这里十分推荐<a href="http://huziketang.mangojuice.top/books/react/" target="_blank" rel="noopener">React.js 小书</a>，里面将React的内容讲的十分的深入浅出，每读一遍都有新的收获。</p><p>组件是什么? 如果你搭过积木的话，那么里面的积木就是组件，我们使用积木搭建出一个东西，在React中我们使用组件来搭建一个页面。组件的作用就是复用，这里的复用指的不仅仅是页面的复用，还有逻辑和样式；除此以外，有的组件并不是用来展现页面的，而是用来加载数据的，然后将数据传给子组件，这样会使得处理数据的逻辑和展示数据的逻辑分开，职责分明，逻辑清晰，以及便于后期的维护。另外，有的组件是做权限的认证，以决定展示某些页面与否。总而言之，有许多不同的组件，组件根据功能或写法或有无状态等等可以进行分类，在后面将详细讨论。</p><p>按照组件的写法可以分为函数组件和类组件。</p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>我们写一个类组件HelloReact</p><iframe height="302" style="width: 100%;" scrolling="no" title="React类组件使用" src="https://codepen.io/lastknightcoder/embed/LYVEeEE?height=302&theme-id=default&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/LYVEeEE' target="_blank" rel="noopener">React类组件使用</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>使用类组件，里面必须有一个render函数，该方法是用来返回JSX代码。我们创建了一个HelloWorld组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloReact</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>))</span><br></pre></td></tr></table></figure><p>并且我们通过<code>&lt;HelloReact /&gt;</code>的方式使用了组件，此时的<code>&lt;HelloReact /&gt;</code>就相当于render函数的返回值</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;Hello React&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>但<code>&lt;HelloReact /&gt;</code>不仅仅是HTML，虽然在这个组件中，我们并没有加上JavaScript的逻辑和CSS样式，但是我们知道一个组件是包括这些的，下面我们为这个类添加样式和点击函数</p><iframe height="265" style="width: 100%;" scrolling="no" title="abOzEWb" src="https://codepen.io/lastknightcoder/embed/abOzEWb?height=265&theme-id=default&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/abOzEWb' target="_blank" rel="noopener">abOzEWb</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>两点说明：</p><ul><li>由于class在React中是关键字，所以类名要写成className</li><li>onClick={()=&gt; console.log(“click me”)}为div标签添加了点击事件，onClick={}并不是说onClick是一个对象，{}是React的插值语法，使用插值语法可以将组件的属性与变量(表达式)绑定起来，这样就不会写死，而是会根据变量取不同的值。这里就是将onClick这个React事件与{}里面的箭头函数绑定起来。<strong>在{}中的内容只能是JavaScript的表达式，不能是if，while等语句</strong></li></ul><blockquote><p><strong>React事件：</strong></p><p>使用原生的JS为DOM元素添加事件，主要有下面三种方法</p><ul><li>在HTML中直接事件绑定</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">"console.log('click')"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>直接绑定</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> divObj = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">&gt;divObj.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>对DOM对象进行事件监听处理,事件委托监听方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> divObj = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">&gt;divObj.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>至于这三种方法的优缺点与及什么时候使用，这里却不在讨论。那么React中的事件是如何绑定的呢?</p><p>在React中事件的绑定是直接写在JSX元素上的,不需要通过addEventListener事件委托的方式进行监听，写法上:</p><ul><li><p>在JSX元素上添加事件,通过on*EventType这种内联方式添加,命名采用小驼峰式(camelCase)的形式,而不是纯小写(原生HTML中对DOM元素绑定事件,事件类型是小写的),无需调用addEventListener进行事件监听,也无需考虑兼容性,React已经封装好了一些的事件类型属性(ps:onClick,onMouseMove,onChange,onFocus)等</p></li><li><p>使用JSX语法时,需要传入一个函数作为事件处理函数,而不是一个字符串,也就是props值应该是一个函数类型数据,事件函数方法外面得用一个双大括号包裹起来(也就是上面提到的插值语法)</p></li><li><p>on*EventType的事件类型属性,只能用作在普通的原生html标签上(例如:div,input,a,p等,例如:<code>&lt;div onClick={ 事件处理函数 }&gt;&lt;/div&gt;</code>),无法直接用在自定义组件标签上,也就是说下面这么写是没有作用的</p></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">HelloReact</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> console.log("click me")&#125;&gt;</span></span><br></pre></td></tr></table></figure><ul><li>不能通过返回false的方式阻止默认行为,必须显示使用preventDefault</li></ul><p>具体React事件有哪些，可以参照<a href="https://react-cn.github.io/react/docs/events.html" target="_blank" rel="noopener">事件系统|React</a>。</p></blockquote><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>组件最常用的作用就是用来展示数据，那么作为可复用的组件，不同人拿到这个组件所展示的数据也不会相同，那么数据从哪里来? 使用组件的人怎么将数据传给组件，而组件又怎么拿到数据。这就要用到props了。</p><p>假如有下面的组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayData</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;假设这里是要展示的数据&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这个组件的作用就是展示数据，现在我要用DisplayData组件，我怎么把数据传过去，如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;DisplayData data=<span class="string">"数据"</span> /&gt;</span><br></pre></td></tr></table></figure><p>我们通过给DisplayData组件加上一个data属性，值是”数据”，就可以将数据传给DisplayData，现在怎么拿到数据呢? 每一个组件都有props属性，它是一个对象，通过上面方法传递给组件的属性都会以键值对的形式添加到props对象中，所以在DisplayData组件中，我们就可以通过this.props.data拿到数据</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayData</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="keyword">this</span>.props.data&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><iframe height="265" style="width: 100%;" scrolling="no" title="React props父组件给子组件传递数据" src="https://codepen.io/lastknightcoder/embed/GRJgGvY?height=265&theme-id=default&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/GRJgGvY' target="_blank" rel="noopener">React props父组件给子组件传递数据</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>以上我们把DisplayData称之为子组件，而使用DisplayData的组件称之为父组件，上面演示了如何将数据从父组件传给子组件，现在我们考虑一下，如何将子组件的数据传递到父组件呢? 完全是有这个需要的，比如子组件是一个登录组件，我们需要将用户输入的用户名和密码交由父组件进行处理(为什么要交给父组件处理，在子组件中处理不可以吗?如果你在子组件里面处理了数据，那么这个组件就与具体的业务相关了，就不能够被复用了，所以数据处理的工作需要交由父组件来做)。</p><p>其实也很简单，我们给子组件传递一个回调函数，那么在子组件的某个时刻(比如子组件的值改变了或者说点击提交)时调用此回调函数并传入数据，这样我们就可以在父组件中拿到数据了</p><iframe height="620" style="width: 100%;" scrolling="no" title="React子组件向父组件传递数据" src="https://codepen.io/lastknightcoder/embed/eYNmKMB?height=620&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/eYNmKMB' target="_blank" rel="noopener">React子组件向父组件传递数据</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>上面的逻辑代码为当SonComponent中的input发生改变时(输入内容或删减内容等等)，会触发子组件中的handleValue回调函数(该回调函数bind了this，后面会进行解释)，在子组件的handleValue中，我们根据浏览器传入的event获得了input输入框的值，并且调用ParentComponent传入的handleValue回调函数将此值传入，这样就将子组件的数据传给了父组件，在父组件中，我们定义了这个回调函数接收这个值，并在控制台打印，你可以在上面的input中输入值并在控制台观察结果。</p><p><strong>JavaScript函数里面的this是什么：</strong></p><p>要想知道JavaScript函数里面的this是什么，就要知道函数调用的4种方式：</p><ul><li>定义在全局作用域中函数</li></ul><p>定义在全局作用域中的函数，根据是否是严格模式下，this的取值也不同，如果是在严格模式下，里面的this是undefined，如果是在非严格模式下，里面的this是window</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><ul><li>对象方法</li></ul><p>对象中方法中的this如果是对象.的形式调用的，那么对象方法中的this就是该对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.test(); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p>如果以某种角度看的话，第一种情况的非严格模式下是第二种情况的特例，我们知道在全局作用域下声明的变量和函数都会成为window对象的属性，当我们在全局作用域下声明一个test函数，就相当于在window对象中添加了一个test方法(在对象中的函数我们一般称为方法)，而调用test()方法就相当于window.test()，按照第二种情况，test中的this就是应该指向window</p><ul><li>作为构造函数被调用</li></ul><p>当我们new一个方法的时候，里面的this是一个空对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Dog(); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用call, apply, bind方法改变函数的上下文(this)</li></ul><p>上面三者都可以改变函数执行时内部this的指向，下面来看一个例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">funtion printName(firstName, lastName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.fullName)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接执行这个函数的话，那么this.fullName的结果就是undefined，因为window对象没有这个属性，但是如果有以下对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    fullName: <span class="string">"David"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将printName函数执行时内部的this指向obj</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">"firstName"</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">"lastName"</span></span><br><span class="line"><span class="comment">// 将printName内部this指向obj， 后面是printName需要的参数</span></span><br><span class="line">printName.apply(obj, firstName, lastName) </span><br><span class="line"><span class="comment">// 将printName内部this指向obj， 后面是printName需要的参数</span></span><br><span class="line">printName.call(obj, [firstName, lastName])</span><br></pre></td></tr></table></figure><p>这时this.fullName就是obj中的fullName了，因为apply和call方法改变了printName内的this指向。这里我们发现apply和call方法是极其的相似，除了传递参数时格式不一样；事实上也是如此，apply和call的功能是一样的。</p><p>说完apply和call，接下来讲一讲bind，bind与上面两者不同，上面改变函数内部的this指向时是立即执行这个函数的，而使用bind改变函数内部的this指向时，这个函数不会立即的执行，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">printName = printName.bind(obj)</span><br></pre></td></tr></table></figure><p>printNAme函数内部的this指向已经改变，当printName执行时，打印出的this.fullName就是obj里面的David。</p><p>了解完JavaScript中的this是什么，接下来就要解释</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Please Input"</span> onChange=&#123;<span class="keyword">this</span>.handleValue.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>中onChange={this.handleValue.bind(this)}，首先我们来看handleValue中的代码</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleValue(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.handleValue(event.target.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当input发生改变时便会执行这个函数，但是是谁执行这个函数呢? 是window，而React是运行在严格模式下的，所以这时的this就是undefined，所以我们拿不到我们想要的this，要使得我能拿到的使我们想拿到的this，就是改变函数执行时内部的this指向，考虑到这个函数是作为回调函数而不是立即执行，我们使用bind来绑定this。</p><p>机智的你已经发现，ParentComponent中的handleValue没有bind(this)，这是因为它在函数里面没有用到this啊，所以什么时候bind(this)是不是已经很清楚了呢!</p><p>到这里你有没有发现我们使用组件都是这样</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;HelloReact /&gt;</span><br></pre></td></tr></table></figure><p>居然不是一开一闭的格式，那想必你有疑问，可不可以这样使用</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;HelloReact&gt;&lt;<span class="regexp">/HelloReact&gt;</span></span><br></pre></td></tr></table></figure><p>答案是可以，那么问题来了? 二者又有什么不同? 使用后面的写法意味着可以在标签里面写子元素，如</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;HelloReact&gt;</span><br><span class="line">    &lt;div&gt;inner&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>HelloReact&gt;</span><br></pre></td></tr></table></figure><p>其实这也可以看做是一种传递数据的方式，标签里面的子元素会传给这个组件，传过去的数据会保存在props.children中，在HelloReact中可以通过this.props.children获得数据。</p><p>这两种写法都很常见，在写布局，路由，认证等组件时经常使用后面的写法，而在一些展示的组件中，通常只需要父组件传下来的数据，会使用前一种写法，当然这种情况下也可以使用第二种写法。</p><p>为了理解children的应用，我们来写简单的Layout组件。所谓的Layout，就是布局</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200209164423.png"/></center><p>我们简单的把页面上面三个部分，这就是一种布局，一个头部，一个侧边栏，一个内容区。很多时候我们发现一个网站的多个网页之间的布局是一样的，并且很有可能头部和侧边栏是相同，仅仅是内容区不同，作为一名优秀的程序员，当然要尽可能的抽离出这些重复的代码，我们把这个布局抽离为一个组件</p><iframe height="446" style="width: 100%;" scrolling="no" title="尝试Layout" src="https://codepen.io/lastknightcoder/embed/MWwYqEL?height=446&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/MWwYqEL' target="_blank" rel="noopener">尝试Layout</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>首先希望不要关注样式，因为那不是重点，关注Layout的结构。注意我们将{this.props.children}放在了类名为content的div中，所以如果我们将Content内容区组件放到Layout里面，Content组件就会被放在Layout的内容区，放置不同的Content组件，就会得到多个布局一样，内容不同的页面，这就做到了复用。</p><p>整个网站当然不可能只会有一种布局，很多时候我们会写多个布局的组件，明白了布局组件的作用，这些对你来说应当不难。</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>React中一个比较重要的思想就数据驱动视图，例如子组件根据props的内容进行展示，根据不同的props展示不同的内容，不同的props会展现不同的UI，所以可以认为是props决定了视图，每当props变化时，都会引起子组件的渲染，展现不同的视图，视图的改变完全在于数据，所以现在我们操作的重点不再是DOM，而是数据，我们通过操作数据来达到不同的UI效果。</p><p>但是仅仅靠props似乎是够的，因为props是只读的，它不能够更改。这意味着什么? 假设父组件传给子组件的props没有发生变化，那么子组件的视图就不会改变，因为数据没有改变。这意味着我们如何与这样一个组件进行交互呢?</p><p>这意味组件的内部需要数据来管理UI的变化，我们将组件内部的数据称之为state，state就是状态的意思。比如使用visible这个状态来控制某个对话框是否可见，用户通过改变visible这个状态从而影响组件UI的变化，每次state的变化都会引起组件UI的刷新，从而达到数据驱动视图的目的。从此，我们关心的再也不是DOM操作，而是props, state这些数据，我们操作这些数据来控制视图的更新。</p><p>定义一个合适的state，是正确创建组件的第一步。state必须能代表一个组件UI呈现的完整状态集，即组件的任何UI改变，都可以从state的变化中反映出来；同时，state还必须是代表一个组件UI呈现的最小状态集，即state中的所有状态都是用于反映组件UI的变化，没有任何多余的状态，也不需要通过其他状态计算而来的中间状态。</p><p>组件中用到的一个变量是不是应该作为组件state，可以通过下面的4条依据进行判断：</p><ul><li>这个变量是否是通过props从父组件中获取? 如果是，那么它不是一个状态。</li><li>这个变量是否在组件的整个<strong>生命周期</strong>(后面讲到)中都保持不变? 如果是，那么它不是一个状态。</li><li>这个变量是否可以通过其他状态(state)或者属性(props)计算得到?如果是，那么它不是一个状态。</li><li>这个变量是否在组件的render方法中使用? 如果不是，那么它不是一个状态(因为state是用来驱动视图的，如果这个变量没有在render方法中使用，意味着该状态的改变并不能使得视图发生变化)。这种情况下，这个变量更适合定义为组件的一个普通属性，例如组件中用到的定时器，就应该直接定义为this.timer，而不是this.state.timer。</li></ul><p>现在来写一个计数器，当点击按钮时页面上显示的数字+1，页面上的数字发生改变正是UI的改变，这个时候我们就要用state来管理页面上要展示的数据</p><iframe height="265" style="width: 100%;" scrolling="no" title="Counter演示state" src="https://codepen.io/lastknightcoder/embed/YzXPmjZ?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/YzXPmjZ' target="_blank" rel="noopener">Counter演示state</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>我们在constructor构造函数中初始化state为</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  number: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state为一个对象，其中的number属性正是我们要展现的数据，我们将它初始化为0。当我们点击按钮时，触发状态的改变</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">increment() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    number: ++<span class="keyword">this</span>.state.number</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，状态的改变不能使用this.state.number = ++this.state.number使状态发生改变，要使得状态发生改变，必须使用setState()方法使状态发生改变。</p><p>上面的例子进一步验证了数据驱动视图的思想，在计数器的例子中，我们没有手动的更改视图(操作DOM)，而是通过改变state来使得视图得到刷新，因为每次state的改变都会引起render()方法的调用，从而使得视图得以刷新。</p><p>请务必牢记，并不是组件中用到的所有变量都是组件的状态! 当存在多个组件共同依赖一个状态时，一般的做法是状态上移，将这个状态放到这几个组件的公共父组件中。</p><p>所谓状态上移是怎么回事呢? 考虑下面这么一个评论组件</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/comments2.png"/></center><p>CommentInput用来输入评论，当提交之后会在CommentList中新增一个CommentItem来显示新增的评论，很明显我们需要一个comments数组，当CommentInput提交评论时，将comment添加到comments数组中，CommentList拿到comments数组，comments中的元素会交给其中的CommentItem显示。而作为关键的comments数组，它是多个组件都会用到的，所以它应该作为state保存在公共的父组件中，即Comment组件中。这就是状态上移，将多个组件都会用到的数据上移到共同父组件的state中，当更新父组件的state的时，会使得传到子组件的props相应的更新，从而达到视图 更新的目的。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/comments4.png"/></center><h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><p>一个人从出生到死亡会经历一些人生节点，孩童、青年、中年、老年。而一个组件从创建到销毁也要经历特殊的节点，在这些节点中，我们可以做一些操作，每一个节点都对应一个函数，我们将它们称为生命周期函数。</p><p>那React有哪些生命周期函数，这些生命周期函数对应的节点是什么呢? 或者说这些生命周期函数在React从创建到销毁的哪一个过程会被执行呢? 这里我们将生命周期分为三个阶段：</p><ul><li>创建阶段</li><li>更新阶段</li><li>卸载阶段</li></ul><p>在每一个阶段都包含数个生命周期函数。</p><h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><h6 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h6><p>我们一般在构造函数中干两件事情：</p><ul><li>初始化状态</li><li>为事件处理函数绑定this</li></ul><blockquote><p><strong>注意：</strong> ES6子类的构造函数必须执行一次super()。React如果构造函数中要使用this.props，必须先执行super(props)。</p></blockquote><h6 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h6><p>当创建时、接收新的 props 时、setState时、forceUpdate时会执行这个方法。这是一个静态方法，参数nextProps是新接收的props，prevState是当前的state。返回值(对象)将用于更新state，如果不需要更新则需要返回null。</p><p>这个方法在建议尽量少用，只在必要的场景中使用，一般使用场景如下：</p><ul><li>无条件的根据props更新state</li><li>当props和state的不匹配情况更新state</li></ul><h6 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h6><p>这个方法已经不推荐使用。因为在未来异步渲染机制下，该方法可能会多次调用。它所行使的功能也可以由 componentDidMount() 和 constructor() 代替：</p><ul><li>之前有些人会把异步请求放在这个生命周期，其实大部分情况下都推荐把异步数据请求放在 componentDidMount() 中。</li><li>在服务端渲染时，通常使用 componentWillMount() 获取必要的同步数据，但是可以使用 constructor() 代替它。</li></ul><blockquote><p>有定义getDerivedStateFromProps时，会忽略componentWillMount()</p></blockquote><h6 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h6><p>每个类组件中，render() 唯一必须的方法。render() 正如其名，作为渲染用，可以返回下面几种类型：</p><ul><li>React 元素（React elements）</li><li>数组（Arrays）</li><li>片段（fragments）</li><li>插槽（Portals）</li><li>字符串或数字（String and numbers）</li><li>布尔值或 null（Booleans or null）</li></ul><p>里面不应该包含副作用，应该作为纯函数。<strong>不能使用 setState。</strong></p><h6 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h6><p>组件完成装载（已经插入 DOM 树）时，触发该方法。这个阶段已经获取到真实的 DOM。一般用于下面的场景：</p><ul><li>异步请求 ajax</li><li>添加事件绑定(注意在componentWillUnmount中取消，以免造成内存泄漏)</li></ul><h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><h6 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps()"></a>componentWillReceiveProps()</h6><p>这个方法在接收新的 props 时触发，即使 props 没有变化也会触发。一般用这个方法来判断 props 的前后变化来更新 state，如下面的例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.currentRow !== nextProps.currentRow) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        isScrollingDown:</span><br><span class="line">          nextProps.currentRow &gt; <span class="keyword">this</span>.props.currentRow,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将被弃用，推荐使用 getDerivedStateFromProps 代替。</p><h6 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps()"></a>static getDerivedStateFromProps()</h6><p>见创建阶段的描述</p><h6 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h6><p>在接收新的 props 或新的 state 时，在渲染前会触发该方法。该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。返回 false， 则不会触发后续的 componentWillUpdate()、render() 和 componentDidUpdate()（但是 state 变化还是可能引起子组件重新渲染）。</p><p>所以通常通过这个方法对 props 和 state 做比较，从而避免一些不必要的渲染。</p><h6 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate()"></a>componentWillUpdate()</h6><p>当接收到新的 props 或 state 时，在渲染前执行该方法。在以后异步渲染时，可能会出现某些组件暂缓更新，导致 componentWillUpdate 和 componentDidUpdate 之间的时间变长，这个过程中可能发生一些变化，比如用户行为导致 DOM 发生了新的变化，这时在 componentWillUpdate 获取的信息可能就不可靠了。这个方法将要弃用。</p><h6 id="render-1"><a href="#render-1" class="headerlink" title="render()"></a>render()</h6><p>见创建阶段的描述</p><h6 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a>getSnapshotBeforeUpdate()</h6><p>这个方法在 render() 之后，componentDidUpdate() 之前调用。两个参数 prevProps 表示更新前的 props，prevState 表示更新前的 state。返回值称为一个快照（snapshot），如果不需要 snapshot，则必须显示的返回 null —— 因为返回值将作为 componentDidUpdate() 的第三个参数使用。所以这个函数必须要配合 componentDidUpdate() 一起使用。</p><p>这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如：在 getSnapShotBeforeUpdate 中获取滚动位置，然后作为参数传给 componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。</p><p>下面是官方文档给出的例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, we've just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">    <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h6 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h6><p>这个方法是在更新完成之后调用，第三个参数 snapshot 就是 getSnapshotBeforeUpdate 的返回值。</p><p>正如前面所说，有 getSnapshotBeforeUpdate 时，必须要有 componentDidUpdate。所以这个方法的一个应用场景就是上面看到的例子，配合 getSnapshotBeforeUpdate 使用。</p><h5 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h5><p>componentWillUnmount()</p><p>在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如：</p><ul><li>取消定时器</li><li>取消事件绑定</li><li>取消网络请求</li></ul><p>上面三个阶段是正常的生命周期，但是如果发生了异常，就需要进行错误处理，所以React也提供了发生异常时的函数</p><h5 id="发生异常"><a href="#发生异常" class="headerlink" title="发生异常"></a>发生异常</h5><p>componentDidCatch(err, info)</p><p>任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。</p><p>错误边界不会捕获下面的错误：</p><ul><li>事件处理(Event handlers)(因为事件处理不发生在 React 渲染时，报错不影响渲染)</li><li>异步代码(Asynchronous code)(e.g. setTimeout or requestAnimationFrame callbacks)</li><li>服务端渲染(Server side rendering)</li><li>错误边界本身(而不是子组件)抛出的错误</li></ul><p>下面我们来看一张<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">生命周期函数图</a>来加深对上面描述的生命周期函数的理解</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200211010936.png"/></center><p>虽然React有做向下兼容，但是推荐尽量避免使用废弃的生命周期，而是拥抱未来，用新的生命周期替换它们。</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>现在我们用函数式组件写一个HelloReact组件</p><iframe height="265" style="width: 100%;" scrolling="no" title="函数式组件示例" src="https://codepen.io/lastknightcoder/embed/RwPPBPE?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/RwPPBPE' target="_blank" rel="noopener">函数式组件示例</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>其中函数式组件接收一个参数props，通我们在类组件中介绍的props相同。函数式组件与类组件不同的是，函数式组件没有state和生命周期函数，所以函数式组件又被称为无状态组件，从某种意义上说类组件具有更加强大的功能。</p><p>为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。其官方指出：在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</p><p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p><ul><li>组件不会被实例化，整体渲染性能得到提升</li></ul><p>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</p><ul><li>组件不能访问this对象</li></ul><p>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件</p><ul><li>组件无法访问生命周期的方法</li></ul><p>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</p><ul><li>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</li></ul><p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。</p><h2 id="组件分类"><a href="#组件分类" class="headerlink" title="组件分类"></a>组件分类</h2><p>组件按写法分可以分为类组件和函数式组件，在上面已经详细介绍过。按照组件有无状态又可以将组价分为有状态组件和无状态组件。按照组件的功能分又可以将组件分为容器组件和展示组件，又或者称为Smart组件和Dumb组件。这里主要介绍容器组件和展示组件。</p><p>展示组件：</p><ul><li>只关注看起来怎么样</li><li>内部可能包含有展示组件或容器组件，并且通常有DOM标签和样式</li><li>不用指明数据是如何加载或者变化的</li><li>只通过props接收数据和回调函数</li><li>一般写为函数式组件，除非它们需要状态、生命周期函数或者性能优化</li></ul><p>容器组件：</p><ul><li>只关注如何工作的</li><li>内部也许包含展示组件或容器组件，但一般不会有DOM标签除非一个包装的div，不可能会有样式</li><li>为展示组件或其他容器组件提供数据和回调函数</li><li>一般是有状态的，被认为是数据源</li><li>一般是从高阶组件生成的</li></ul><p>通过将组件分为这两种，可以有以下优点：</p><ul><li>关注点更好的分离</li><li>更好的复用性</li></ul><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件指的不是组件，而是一个函数，它可以增强组件，它接收一个组件，返回一个新组件，这个新组件是接收组件的加强版。假设有这样三个组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  componnetDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = localStorage.getItem(<span class="string">"data"</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      data</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  componnetDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = localStorage.getItem(<span class="string">"data"</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      data</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App3</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  componnetDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = localStorage.getItem(<span class="string">"data"</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      data</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察这三个组件，它们都有一个共同的特点，那就是它们在挂载后都要从localStorage中获取数据，可见这样的代码是重复了的，我们如果每次要从localStorage获取数据，都要写一遍这样的代码，那怎么可以让这样的逻辑复用呢? 这就是高阶组件的作用，考虑下面这样的一个函数</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataFromLocalStorage</span>(<span class="params">WrapComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NewComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    componentDidComponent() &#123;</span><br><span class="line">      <span class="keyword">const</span> data = localStorage.getItem(<span class="string">"data"</span>);</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        data</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NewComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收一个组件，返回一个新组件。这个新组件在挂载后会用localStorage读取数据，并注入到传入的组件的props.data中。而这个传入的组件会作为新组件render函数的返回值，所以当我们使用这个新组件时，与使用传入的组件一致，不过此时新组件的props中已经有了从localStorage读取的数据。我们可以将上面的三个组件都可以改造为</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  App1 = getDataFromLocalStorage(App1)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  App2 = getDataFromLocalStorage(App2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App3</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  App3 = getDataFromLocalStorage(App3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用高阶函数为三个组件的props.data中注入了数据，这样三个组件只要调用这个方法，就可以自动可以在props中获取到数据，从而达到了代码的复用。可能读到这里你还不能理解，没关系，多读几遍好好消化，或者写个几遍就习惯了。</p><h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>render props的目的同样也是进行代码的复用。再次考虑上面代码的复用，不过这次使用render props实现代码的复用</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDataFromLocalStorage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;<span class="attr">data</span>: <span class="literal">null</span>&#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(localStorage.getItem(<span class="string">"data"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;GetDataFromLocalStorage </span><br><span class="line">        render = &#123;(&#123;data&#125;) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>data<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;&#125; </span><br><span class="line">      /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细阅读上面的代码，想必还是比较容易读懂的。Render Props的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件。</p><h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React Redux"></a>React Redux</h1><p>假设有这么一棵组件树</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200215102614.png"/></center><p>Com4从App中获取数据，需要一层一层的传下来，有的中间组件可能只是用来传递数据用，同理，Com4向App传递数据，也要通过回调函数一层层往上传，再这样的情况下，代码实在是比较臃肿，不仅写出了很多不必要的代码，而且使得数据也比较难以理解。</p><p>假设有这么一个中央仓库，任何组件都可以直接存储和更改数据，而不需要一层层的传递</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200215103956.png"/></center><p>不管组件处于多深的层次，都可以从store中直接拿取数据。所以这个想法怎么做到呢?</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>首先来介绍React中你可能永远不会用到的特性context。我们在父组件中它下面的子组件通过context的方式提供数据，其中的任意子组件均可以通过context访问数据，这就使得context相当于中央仓库，那怎么用呢(为了演示方便，就写父子两层)?</p><iframe height="400" style="width: 100%;" scrolling="no" title="Context的使用" src="https://codepen.io/lastknightcoder/embed/JjdGQgL?height=675&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/JjdGQgL' target="_blank" rel="noopener">Context的使用</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>在上面用到了PropTypes，所以需要下载prop-types，使用npm下载</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install prop-types --save</span><br></pre></td></tr></table></figure><p>首先父组件提供context要声明提供的数据名称以及对应的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    data: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在getChildContext中返回数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getChildContext () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: <span class="string">"data"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子组件要使用父组件提供的数据，首先要声明要使用的数据是什么以及类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    data: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有这样才可以通过this.context获取想要的数据</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;Child中获取Context：&#123;<span class="keyword">this</span>.context.data&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>context 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。</p><p>但是这种机制对于前端应用状态管理来说是很有帮助的，因为毕竟很多状态都会在组件之间进行共享，context 会给我们带来很大的方便。一些第三方的前端应用状态管理的库（例如 Redux）就是充分地利用了这种机制给我们提供便利的状态管理服务。但我们一般不需要手动写 context，也不要用它，只需要用好这些第三方的应用状态管理库就行了。</p><h2 id="Redux-React-Redux"><a href="#Redux-React-Redux" class="headerlink" title="Redux + React Redux"></a>Redux + React Redux</h2><p>本来还想继续写Redux，React-Redux的，但是我发现<a href="http://huziketang.mangojuice.top/books/react/" target="_blank" rel="noopener">React.js 小书</a>写的实在是太好了，推荐仔细阅读其中的Redux和React-Redux的部分。</p><h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><p>使用React Hooks，使得在函数式组件可以有状态，也可以仿照生命周期函数，甚至可以替代React Redux。所谓的Hooks，就是指一些函数，通过这些函数可以在函数式组建中实现类组件的功能。</p><p>钩子函数一般是useXxx的形式，所有的钩子函数都只能写在函数式组件中。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>我们来看一下如何在函数式组件中使用state</p><iframe height="265" style="width: 100%;" scrolling="no" title="useState的使用" src="https://codepen.io/lastknightcoder/embed/WNvrVOo?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/WNvrVOo' target="_blank" rel="noopener">useState的使用</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>通过useState来创建一个状态，接收一个参数，这个参数就是状态的初始值，返回一个数组，数组包含两个元素，第一个元素就是状态，第二个元素是一个方法，该方法用来设置状态的，如上面</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中number就是状态，初始值为0，而setNumber是用来设置number的(二者的名字可以随便起，什么changeNumber随意)，每当我们点击+1按钮，都会将当前的number加一。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect主要是用来执行一些副作用的代码，比如拿数据</p><iframe height="265" style="width: 100%;" scrolling="no" title="useEffect" src="https://codepen.io/lastknightcoder/embed/poJgMar?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/poJgMar' target="_blank" rel="noopener">useEffect</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>useEffect接收两个参数，第一个参数是回调函数，第二个参数是一个数组，它会监视数组中的元素，当数组中的元素发生改变时，就会执行回调函数，所以当我们点击按钮改变data时，由于data发生改变，useEffect中的回调函数会被执行。如果希望是componentDidMount生命周期函数的特点，即只在组件挂载是执行一次，那么可以为第二个参数传入一个空数组。</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>useContext的作用正如在React Redux中介绍的Context中一样，可以使得子组件无论在什么深度都可以直接访问父组件提供的Context，这个给个例子大家就可以明白</p><iframe height="265" style="width: 100%;" scrolling="no" title="useContext的使用" src="https://codepen.io/lastknightcoder/embed/vYOLorB?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/vYOLorB' target="_blank" rel="noopener">useContext的使用</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>如何仔细阅读过React.js小书，那么想必你已经理解了reducer的作用，useReducer接收一个reducer和初始状态initState，返回state和dispatch，如下</p><iframe height="265" style="width: 100%;" scrolling="no" title="useReducer" src="https://codepen.io/lastknightcoder/embed/BaNjXOL?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/BaNjXOL' target="_blank" rel="noopener">useReducer</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><h2 id="结合useContext和useReducer"><a href="#结合useContext和useReducer" class="headerlink" title="结合useContext和useReducer"></a>结合useContext和useReducer</h2><p>我们可以将useContext和useReducer结合，来达到React-Redux的效果，具体就是将useReducer产生的state和dispatch作为Context传下去，如下</p><iframe height="959" style="width: 100%;" scrolling="no" title="useContext与useReducer结合" src="https://codepen.io/lastknightcoder/embed/BaNjXGQ?height=959&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/lastknightcoder/pen/BaNjXGQ' target="_blank" rel="noopener">useContext与useReducer结合</a> by LastKnightCoder  (<a href='https://codepen.io/lastknightcoder' target="_blank" rel="noopener">@lastknightcoder</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><h1 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h1><p>既然是搭建一个基于富文本编辑器的博客系统，那么就要用到富文本编辑器组件，这里我们选择<a href="https://braft.margox.cn/" target="_blank" rel="noopener">BraftEditor</a>。</p><p>使用npm安装到你的项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install braft-editor --save</span><br></pre></td></tr></table></figure><p>新建pages文件夹，并且在pages中新建文件夹RichText，在RichText中新建index.jsx，内容如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BraftEditor <span class="keyword">from</span> <span class="string">'braft-editor'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'braft-editor/dist/index.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RichText</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [editorState, setEditorState] = useState(BraftEditor.createEditorState(<span class="string">"&lt;p&gt;123&lt;/p&gt;"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleEditorChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleEditorSave = <span class="function">(<span class="params">editorState</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BraftEditor</span><br><span class="line">            value=&#123;editorState&#125;</span><br><span class="line">            onChange=&#123;handleEditorChange&#125;</span><br><span class="line">            onSave=&#123;handleEditorSave&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RichText</span><br></pre></td></tr></table></figure><p>我们在src下的index.js中引入该组件，并渲染到dom中</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> RichText <span class="keyword">from</span> <span class="string">'./pages/RichText'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">RichText</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>这时你使用yarn start或者npm start启动项目，在端口3000看到的页面应该是这样的</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214145449.png"/></center><p>现在我们来看BraftEditor组件接收的三个props，分别是</p><ul><li>value</li><li>onChange</li><li>onSave</li></ul><p>我们一个个来看。</p><p>首先看value，它是BraftEditor组件要显示的内容，它的值是一个editorState对象，我们可以通过BraftEditor.createEditorState()创建editorState对象，它接收html字符串或者一个raw对象(raw对象是它自定义的对象，一般我们保存富文本的内容就是保存raw对象)，也可以通过editorState实例转化为html字符串或者raw对象，如</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建edirorState对象</span></span><br><span class="line"><span class="keyword">const</span> editorState = BraftEditor.createEditor(<span class="string">"&lt;p&gt;123&lt;/p&gt;"</span>);</span><br><span class="line"><span class="keyword">const</span> htmlContent = editorState.toHTML();</span><br><span class="line"><span class="keyword">const</span> rawContent = editorState.toRAW();</span><br></pre></td></tr></table></figure><p>再者来看onChange，它是当BraftEditor发生改变时调用的回调函数，它会传入一个editorState对象，这个editorState对象代表的就是当前的文本内容。</p><p>最后看onSave，它是当按下Ctrl + S保存时会调用的方法，也会将代表当前文本内容的editorState传入。</p><p>我们来做一个简单的案例，当按下Ctrl + S时，将数据以raw对象的格式保存在localStorage中，当富文本加载时，从localStorage中读取数据</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BraftEditor <span class="keyword">from</span> <span class="string">'braft-editor'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'braft-editor/dist/index.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RichText</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [editorState, setEditorState] = useState(BraftEditor.createEditorState(<span class="literal">null</span>))</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rawContent = localStorage.getItem(<span class="string">"rawContent"</span>) || <span class="literal">null</span>;</span><br><span class="line">        setEditorState(BraftEditor.createEditorState(rawContent))</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleEditorChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleEditorSave = <span class="function">(<span class="params">editorState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rawContent = editorState.toRAW();</span><br><span class="line">        localStorage.setItem(<span class="string">"rawContent"</span>, rawContent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BraftEditor</span><br><span class="line">            value=&#123;editorState&#125;</span><br><span class="line">            onChange=&#123;handleEditorChange&#125;</span><br><span class="line">            onSave=&#123;handleEditorSave&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RichText</span><br></pre></td></tr></table></figure><p>这里就增加了两个地方，第一个是增加了useEffect，作用是当组件挂载后从localStorage中读取数据(既然从localStorage初始化，那么原来的”&lt;p&gt;123&lt;/p&gt;“就换为了null)，第二个是更改了handleEditorSave，当保存时将数据保存在localStorage中，上面的代码都很容易理解，不再解释。如果成功了的话，在富文本编辑器中输入并按Ctrl + S保存，然后刷新，数据会原样的重现。</p><h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><p>我们来看一下项目的每个页面的布局</p><p>Home</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214153650.png"/></center><p>Edit</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214153119.png"/></center><p>Display</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214153418.png"/></center><p>Login</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214153540.png"/></center><p>其中Home, Display, Edit都是下面这样的布局</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214154437.png" width="60%"/></center><p>而Login的布局是</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214154823.png" width="60%" /></center><p>所以我们抽离出布局组件，Home，Edit,Display三者的布局抽离为BasicLayout，而Login的布局抽离为LoginLayout组件，注意到他们的Heder都是相同的，所以我们把Header抽离为一个公共的组件。</p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>在src下新建components目录，在其中新建Header文件夹，在其中新建index.jsx和index.module.css。index.jsx的内容如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toEdit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> toHome = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;styles.header&#125;&gt;</span><br><span class="line">            &lt;div className=&#123;styles.nav&#125;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/home"</span> <span class="attr">onClick</span>=<span class="string">&#123;toHome&#125;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;li&gt;&lt;a href="/</span>edit<span class="string">" onClick=&#123;toEdit&#125;&gt;写博客&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;/ul&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div className=&#123;styles.desc&#125;&gt;</span></span><br><span class="line"><span class="string">                Coder</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Header</span></span><br></pre></td></tr></table></figure><p>index.module.css中的内容为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-family</span>: Consolas, <span class="string">"楷体"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#FFF</span> inset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.desc</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-family</span>: Consolas, <span class="string">"楷体"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容想必还是很容易理解的，其中Header中的两个a标签的点击事件均没有处理，这两个a标签是用于做路由跳转用的，等用到在回过头来补充。</p><h2 id="BasicLayout"><a href="#BasicLayout" class="headerlink" title="BasicLayout"></a>BasicLayout</h2><p>在src下新建layouts文件夹，在其中新建文件夹BasicLayout，在BasicLayout中新建index.jsx和index.module.css，其中index.jsx的内容为</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./../../components/Header'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BasicLayout</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;styles.box&#125;&gt;</span><br><span class="line">            &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Header /&gt;</span><br><span class="line">                &lt;div className=&#123;styles.main&#125;&gt;</span><br><span class="line">                    &lt;div className=&#123;styles.content&#125;&gt;</span><br><span class="line">                        &#123;children&#125;</span><br><span class="line">                    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;div className=&#123;styles.aside&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>div&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default BasicLayout</span></span><br></pre></td></tr></table></figure><p>其中index.module.css中的内容为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d8e2eb</span> <span class="built_in">url</span>(./../../assets/img/bg.jpg) no-repeat top center;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要用到背景图片，我们在src下新建assets文件夹，然后新建img，在其中放入背景图片，背景图片在这里</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214163456bg.jpg"/></center><p>接在src下新建common.css，以消除内外边距，设置字体</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Consolas, <span class="string">"楷体"</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在src/index.js中引用该布局看看效果</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RichText <span class="keyword">from</span> <span class="string">'./pages/RichText'</span>;</span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./layouts/BasicLayout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./common.css'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">BasicLayout</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">RichText</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">BasicLayout</span>&gt;</span></span>, </span><br><span class="line">                <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>如下：</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214171622.png"/></center><h2 id="LoginLayout"><a href="#LoginLayout" class="headerlink" title="LoginLayout"></a>LoginLayout</h2><p>在layouts下新建LoginLayout文件夹，在LoginLayout中新建index.jsx和index.module.css。有了BasicLayout的经验，代码的内容不必解释，直接上代码。index.jsx</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./../../components/Header'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginLayout</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;styles.box&#125;&gt;</span><br><span class="line">            &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Header /&gt;</span><br><span class="line">                &lt;div className=&#123;styles.main&#125;&gt;</span><br><span class="line">                    &#123;children&#125;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default LoginLayout</span></span><br></pre></td></tr></table></figure><p>index.module.css</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d8e2eb</span> <span class="built_in">url</span>(./../../assets/img/bg.jpg) no-repeat top center;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width </span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h1><p>为了使用路由，先下好react-router-dom</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install react-router-dom --save</span><br></pre></td></tr></table></figure><p>该blog项目总共有四个页面</p><ul><li>Home：页面主页</li><li>Display：阅读文章的页面</li><li>Edit：编辑文章的页面</li><li>Login：登录页面</li></ul><p>为了演示路由，在pages中分别新建Home, Display, Edit, Login四个文件夹，并在每个文件夹中新建index.jsx，同时在Edit文件夹了新建components文件夹，将RichText文件夹全部移入到这个文件夹中(因为RichText富文本编辑器属于编辑文章页面的一部分)，简单的在每个文件的index.jsx写下一些内容，具体的内容在后面添加。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./../../layouts/BasicLayout'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BasicLayout&gt;</span><br><span class="line">            Home</span><br><span class="line">        &lt;<span class="regexp">/BasicLayout&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Home)</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Display/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./../../layouts/BasicLayout'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Display</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BasicLayout&gt;</span><br><span class="line">            Display</span><br><span class="line">        &lt;<span class="regexp">/BasicLayout&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Display)</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Edit/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./../../layouts/BasicLayout'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> RichText <span class="keyword">from</span> <span class="string">'./components/RichText'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Edit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BasicLayout&gt;</span><br><span class="line">            &lt;RichText /&gt;</span><br><span class="line">        &lt;<span class="regexp">/BasicLayout&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Edit)</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Login/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> LoginLayout <span class="keyword">from</span> <span class="string">'./../../layouts/LoginLayout'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;LoginLayout&gt;</span><br><span class="line">            login</span><br><span class="line">        &lt;<span class="regexp">/LoginLayout&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Login)</span></span><br></pre></td></tr></table></figure><p>设计页面路由如下</p><table><thead><tr><th align="left">path</th><th align="left">component</th><th align="left">redirect</th></tr></thead><tbody><tr><td align="left">/home</td><td align="left">Home</td><td align="left"></td></tr><tr><td align="left">/display/:id</td><td align="left">Display</td><td align="left"></td></tr><tr><td align="left">/edit</td><td align="left">Edit</td><td align="left"></td></tr><tr><td align="left">/edit:id</td><td align="left">Edit</td><td align="left"></td></tr><tr><td align="left">/login</td><td align="left">Login</td><td align="left"></td></tr><tr><td align="left">/</td><td align="left"></td><td align="left">/home</td></tr></tbody></table><p>注意到Edit组件对应两个路径，因为编辑文章有两种情况，第一种是添加文章，这时是/edit路径，第二种是编辑文章，这时需要传入文章的id，所以这时是/edit/:id路径。</p><p>在src下新建文件夹config，在config新建routes.js，里面设置路由信息，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./../pages/Home/index'</span></span><br><span class="line"><span class="keyword">import</span> Display <span class="keyword">from</span> <span class="string">'./../pages/Display/index'</span></span><br><span class="line"><span class="keyword">import</span> Edit <span class="keyword">from</span> <span class="string">'./../pages/Edit/index'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./../pages/Login/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/login"</span>,</span><br><span class="line">        component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/home"</span>,</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/display/:id"</span>,</span><br><span class="line">        component: Display</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/edit"</span>,</span><br><span class="line">        component: Edit</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/edit/:id"</span>,</span><br><span class="line">        component: Edit</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/"</span>,</span><br><span class="line">        redirect: <span class="string">"/home"</span>,</span><br><span class="line">        exact: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在src下新建router.js，用来渲染路由，内容如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./config/routes'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Switch, BrowserRouter <span class="keyword">as</span> Router, Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createBrowserHistory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可能是Redirect 也可能是Route 所以使用RouteItem封装</span></span><br><span class="line"><span class="keyword">const</span> RouteItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; path, <span class="attr">component</span>: Component, redirect, key, exact &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;path&#125;</span> <span class="attr">to</span>=<span class="string">&#123;redirect&#125;</span> <span class="attr">key</span>=<span class="string">&#123;key&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Route</span><br><span class="line">            key=&#123;key&#125;</span><br><span class="line">            exact=&#123;exact&#125;</span><br><span class="line">            path=&#123;path&#125;</span><br><span class="line">            render=&#123;componentProps =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;Component &#123;...componentProps&#125; /&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &#123;<span class="comment">/* Switch 唯一匹配  */</span>&#125;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &#123;routes.map(<span class="function">(<span class="params">item, id</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> RouteItem(&#123; <span class="attr">key</span>: id, ...item &#125;)</span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Router&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>接着在src/index.js中渲染出来</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./common.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(router(), <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>接着启动项目(npm start或yarn start)，改变浏览的url(如localhost:3000/display)看看页面是否能成功跳转(我这里是没有问题的，如果你不能的话，回过头仔细看看吧)。</p><h1 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h1><h2 id="antd表单的使用"><a href="#antd表单的使用" class="headerlink" title="antd表单的使用"></a>antd表单的使用</h2><p>要使用antd，先下载antd</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install antd --save</span><br></pre></td></tr></table></figure><p>首先看一个表单的例子，在src下新建一个test文件夹，新建TextAntdForm.jsx，内容如下(先不管看得懂看不懂，后面解释)</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Form, Input, Button&#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextAntdForm</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;getFieldDecorator, validateFields&#125; = props.form</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        validateFields(<span class="function">(<span class="params">error, values</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">width</span>: <span class="string">"300px"</span>, <span class="attr">margin</span>: <span class="string">"100px auto"</span>, <span class="attr">fontFamily</span>: <span class="string">"Consolas, '楷体'"</span>&#125;&#125;&gt;</span><br><span class="line">            &lt;Form onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">                &lt;Form.Item label=<span class="string">"用户名"</span>&gt;</span><br><span class="line">                    &#123;getFieldDecorator(<span class="string">'title'</span>, &#123;</span><br><span class="line">                      rules: [&#123;</span><br><span class="line">                        required: <span class="literal">true</span>,</span><br><span class="line">                        message: <span class="string">'请输入用户名'</span>,</span><br><span class="line">                      &#125;],</span><br><span class="line">                    &#125;)(</span><br><span class="line">                      &lt;Input size=<span class="string">"large"</span> placeholder=<span class="string">"请输入用户名"</span>/&gt;</span><br><span class="line">                    )&#125;</span><br><span class="line">                &lt;<span class="regexp">/Form.Item&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Form.Item label="密码"&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;getFieldDecorator('password', &#123;</span></span><br><span class="line"><span class="regexp">                      rules: [&#123;</span></span><br><span class="line"><span class="regexp">                        required: true,</span></span><br><span class="line"><span class="regexp">                        message: '请输入密码',</span></span><br><span class="line"><span class="regexp">                      &#125;],</span></span><br><span class="line"><span class="regexp">                    &#125;)(</span></span><br><span class="line"><span class="regexp">                      &lt;Input.Password size="large" placeholder="请输入密码"/</span>&gt;</span><br><span class="line">                    )&#125;</span><br><span class="line">                &lt;<span class="regexp">/Form.Item&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                &lt;Form.Item&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Button size="large" type="primary" htmlType="submit"&gt;提交&lt;/</span>Button&gt;</span><br><span class="line">                &lt;<span class="regexp">/Form.Item&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Form&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Form.create()(TextAntdForm)</span></span><br></pre></td></tr></table></figure><p>修改src/index.js渲染该组件(记得引入antd/dits/antd.css，否则antd组件没有样式)</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import router from './router'</span></span><br><span class="line"><span class="keyword">import</span> TestAntdForm <span class="keyword">from</span> <span class="string">'./test/TestAntdForm'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./common.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(router(), document.getElementById("root"));</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">TestAntdForm</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214203708.png"/></center><p>现在来解释上面的代码，首先看最后一行</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Form.create()(TextAntdForm)</span><br></pre></td></tr></table></figure><p>还记得高阶组件吗，Form.create()就是一个高阶组件，他会向组件的props中注入form，form提供了一些API，这里使用了两个：</p><ul><li>getFieldDecorator：用于和表单进行双向绑定</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getFieldDecorator(<span class="string">'title'</span>, &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    message: <span class="string">'请输入用户名'</span>,</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;)(</span><br><span class="line">  &lt;Input size=<span class="string">"large"</span> placeholder=<span class="string">"请输入用户名"</span>/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面将Input与表单项进行了绑定，getFieldDecorator接收两个参数，第一个参数是id，根据它可以获取输入控件的值或者设置输入控件的值，是必填项；第二个参数是options，里面可以有很多属性，这里使用了rules，定义了校验的规则，required表示是否必填，message表示未填时显示的消息文字。</p><ul><li>validateFields：校验</li></ul><p>里面接受一个回调函数，回调函数接收两个参数，第一个参数为error，当不满足校验规则时error的值非空，第二个参数是values，会将绑定表单的值以对象的形式传给values，键就是在getFieldDecorator传入的id。</p><p>上面在提交表单后，会调用Form的onSubmit回调函数，在回调函数，我们对数据进行了校验，如果没有问题的话，我们可以将输入表单的键值对以对象的形式获取到values，并打印出来</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214205410.png"/></center><h2 id="页面数据"><a href="#页面数据" class="headerlink" title="页面数据"></a>页面数据</h2><p>我们将数据设置为一个数组datas，它的格式如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">datas = [</span><br><span class="line">  &#123;<span class="attr">title</span>: , <span class="attr">brief</span>: , <span class="attr">isTop</span>: , <span class="attr">content</span>: &#125;</span><br><span class="line">  &#123;<span class="attr">title</span>: , <span class="attr">brief</span>: , <span class="attr">isTop</span>: , <span class="attr">content</span>: &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Home组件根据datas展示数据，Edit和Display组件根据id和datas获取要展示的数据，由于多个组件都要用到数据，所以这里使用useContext和useReducer来分发数据。</p><p>在src下新建Provider.jsx，用来提供state和dispatch，内容如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useReducer&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Context = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tempDatas = state.datas</span><br><span class="line">    <span class="comment">// 按道理case后面跟的都是常量，我这里为了简单</span></span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'insertData'</span>:</span><br><span class="line">            tempDatas[tempDatas.length] = action.data;</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">datas</span>: tempDatas&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'updateData'</span>:</span><br><span class="line">            tempDatas[action.id] = action.data</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">datas</span>: tempDatas&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'deleteData'</span>:</span><br><span class="line">            tempDatas.splice(action.id, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">datas</span>: tempDatas&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'changeOperation'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">operation</span>: action.operation&#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    <span class="comment">// 随便写的数据用来实验 随后会删掉</span></span><br><span class="line">    datas: [&#123;<span class="attr">title</span>: <span class="string">'aaa'</span>, <span class="attr">isTop</span>: <span class="literal">true</span>, <span class="attr">brief</span>: <span class="string">'hahah'</span>&#125;, <span class="attr">content</span>: <span class="string">'&lt;p&gt;123&lt;/p&gt;'</span>],</span><br><span class="line">    <span class="comment">// 用来判断是添加文章还是编辑文章</span></span><br><span class="line">    operation: <span class="string">'ADD'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initState)</span><br><span class="line">    <span class="keyword">const</span> &#123;children&#125; = props</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Provider</span></span><br></pre></td></tr></table></figure><p>更改router.js，在最上面加上Provider</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Provider <span class="keyword">from</span> <span class="string">'./Provider'</span></span><br><span class="line"><span class="comment">// 上面没有变化，除了import Provider，故此省略</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Provider&gt;</span><br><span class="line">            &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">                &lt;Switch&gt;</span><br><span class="line">                    &#123;routes.map(<span class="function">(<span class="params">item, id</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> RouteItem(&#123; <span class="attr">key</span>: id, ...item, <span class="attr">history</span>: history &#125;)</span><br><span class="line">                    &#125;)&#125;</span><br><span class="line">                &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Router&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default router</span></span><br></pre></td></tr></table></figure><h2 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h2><p>观察Home页面</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214212726.png"/></center><p>发现Home是由这一个个Item组成，Item中的数据正是datas数组中每一个元素的内容，在Home中新建文件夹Item，并在Item中新建index.jsx和index.module.css。index.jsx:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Modal&#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;confirm&#125;  = Modal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Item</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">        data, </span><br><span class="line">        login, </span><br><span class="line">        handleDelete, </span><br><span class="line">        index, </span><br><span class="line">        handleToEdit, </span><br><span class="line">        handleToDisplay </span><br><span class="line">    &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toDisplay = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        handleToDisplay(index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toEdit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        handleToEdit(index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toDelete = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        confirm(&#123;</span><br><span class="line">            title: <span class="string">`你确定要删除<span class="subst">$&#123;data.title&#125;</span>`</span>,</span><br><span class="line">            content: <span class="string">'删除后内容不可恢复'</span>,</span><br><span class="line">            onOk() &#123;</span><br><span class="line">                handleDelete(index)</span><br><span class="line">            &#125;,</span><br><span class="line">            onCancel() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;styles.item&#125;&gt;</span><br><span class="line">            &lt;h2&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`/<span class="attr">display</span>/$&#123;<span class="attr">data.id</span>&#125;`&#125; <span class="attr">onClick</span>=<span class="string">&#123;toDisplay&#125;</span>&gt;</span>&#123;data.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;hr /</span>&gt;</span><br><span class="line">            &lt;div className=&#123;styles.abstract&#125;&gt;</span><br><span class="line">                &#123;data.brief&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className=&#123;styles.readmore&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;a href=&#123;`/</span>display/$&#123;data.id&#125;<span class="string">`&#125; onClick=&#123;toDisplay&#125;&gt;阅读更多&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &#123;/* 当登录失显示编辑本文和删除本文 */&#125;</span></span><br><span class="line"><span class="string">            &#123;login ? </span></span><br><span class="line"><span class="string">            &lt;div className=&#123;styles.edit&#125;&gt;</span></span><br><span class="line"><span class="string">                &lt;a href=&#123;`</span>/edit/$&#123;data.id&#125;<span class="string">`&#125; onClick=&#123;toEdit&#125;&gt;编辑本文&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt; : ""&#125; </span></span><br><span class="line"><span class="string">            &#123;login ? </span></span><br><span class="line"><span class="string">                &lt;div className=&#123;styles.delete&#125;&gt;</span></span><br><span class="line"><span class="string">                    &lt;a href="/delete" onClick=&#123;toDelete&#125;&gt;删除本文&lt;/a&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;: ""&#125;</span></span><br><span class="line"><span class="string">            &#123;/* 当isTop为1时显示置顶图标 */&#125;</span></span><br><span class="line"><span class="string">            &#123;data.isTop ? </span></span><br><span class="line"><span class="string">            &lt;div className=&#123;styles.isTop&#125;&gt;</span></span><br><span class="line"><span class="string">                &lt;svg viewBox="0 0 1024 1024"&gt;</span></span><br><span class="line"><span class="string">                    &lt;path d="M0 0h1024v1024z" fill="#7ED321"&gt;&lt;/path&gt;</span></span><br><span class="line"><span class="string">                    &lt;path d="M571.733333 157.866667l17.066667-12.8-83.2-83.2L552.533333 14.933333l183.466667 183.466667-46.933333 46.933333-81.066667-81.066666-17.066667 12.8 100.266667 100.266666-14.933333 14.933334-102.4-102.4c-6.4 4.266667-10.666667 8.533333-17.066667 10.666666l72.533333 72.533334-110.933333 110.933333 36.266667 36.266667-14.933334 14.933333L313.6 209.066667l14.933333-14.933334 36.266667 36.266667 110.933333-110.933333 61.866667 61.866666c6.4-4.266667 10.666667-8.533333 17.066667-10.666666l-96-96 14.933333-14.933334 98.133333 98.133334z m-72.533333 209.066666l17.066667-17.066666-117.333334-117.333334-17.066666 17.066667 117.333333 117.333333z m27.733333-29.866666l14.933334-14.933334L426.666667 204.8l-14.933334 14.933333 115.2 117.333334z m27.733334-27.733334l17.066666-14.933333-117.333333-117.333333-17.066667 14.933333 117.333334 117.333333z m27.733333-25.6l14.933333-14.933333L482.133333 149.333333l-14.933333 14.933334 115.2 119.466666z m10.666667-202.666666L554.666667 44.8l-21.333334 21.333333 38.4 38.4 21.333334-23.466666z m57.6 57.6l-40.533334-40.533334-21.333333 21.333334 40.533333 40.533333 21.333334-21.333333zM704 192l-38.4-38.4-21.333333 21.333333L682.666667 213.333333l21.333333-21.333333zM571.733333 471.466667l12.8-21.333334c8.533333 10.666667 17.066667 19.2 25.6 27.733334 6.4 6.4 12.8 6.4 21.333334-2.133334l172.8-172.8-38.4-38.4 17.066666-17.066666 87.466667 87.466666-17.066667 17.066667-29.866666-29.866667-177.066667 177.066667c-14.933333 14.933333-29.866667 14.933333-44.8 0l-29.866667-27.733333z m302.933334 21.333333l-44.8 44.8c-27.733333 25.6-55.466667 40.533333-83.2 44.8-27.733333 2.133333-59.733333-6.4-96-25.6l6.4-25.6c34.133333 19.2 64 27.733333 87.466666 25.6 23.466667-4.266667 46.933333-14.933333 68.266667-36.266667l44.8-44.8 17.066667 17.066667z m132.266666-21.333333l-17.066666 19.2-55.466667-55.466667c-10.666667 8.533333-19.2 17.066667-29.866667 23.466667l51.2 51.2-119.466666 119.466666-17.066667-17.066666 102.4-102.4-76.8-76.8-104.533333 100.266666-17.066667-17.066666 121.6-121.6 42.666667 42.666666c10.666667-6.4 19.2-14.933333 29.866666-23.466666L861.866667 362.666667l17.066666-17.066667 128 125.866667zM802.133333 682.666667h-25.6c2.133333-25.6 2.133333-55.466667-2.133333-89.6h23.466667c4.266667 34.133333 4.266667 64 4.266666 89.6z" fill="#FFFFFF"&gt;&lt;/path&gt;</span></span><br><span class="line"><span class="string">                &lt;/svg&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt; : ""&#125;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Item</span></span><br></pre></td></tr></table></figure><p>注意到Item为展示组件，只负责数据的展示，而不负责数据的处理、获取，Item的数据、数据的操作都是从props中获取的，这些操作都由Item的容器组件Home来完成。</p><p>我们会将login保存在sessionStorage，login是一个布尔值，保存了是否登录的信息，true表示登录，false表示未登录，根据是否登录，决定是否将删除和编辑的操作暴露出来。同时我们也将根据data的isTop是否为true来显示是否置顶的svg图样(该图样来自CSDN的置顶图样)。</p><p>index.module.css</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">6px</span> <span class="number">6px</span> <span class="number">#FFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#40759b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.abstract</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.readmore</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.edit</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">75px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.delete</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">140px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.isTop</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进入Home组件，修改Home/index.jsx如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./../../layouts/BasicLayout'</span></span><br><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">'./components/Item'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Context&#125; <span class="keyword">from</span> <span class="string">'./../../router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;history&#125; = props</span><br><span class="line">    <span class="comment">// 使用useContext获取Provider提供的数据</span></span><br><span class="line">    <span class="keyword">const</span> &#123;state, dispatch&#125; = useContext(Context);</span><br><span class="line">    <span class="keyword">const</span> login = sessionStorage.getItem(<span class="string">"login"</span>);</span><br><span class="line">    <span class="keyword">const</span> datas = state.datas;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleDelete = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: <span class="string">"deleteData"</span>, id&#125;);</span><br><span class="line">        message.success(<span class="string">'删除成功'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleToEdit = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: <span class="string">"changeOperation"</span>, <span class="attr">operation</span>: <span class="string">"EDIT"</span>&#125;)      </span><br><span class="line">        history.push(<span class="string">`/edit/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleToDisplay = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">        history.push(<span class="string">`display/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;BasicLayout&gt;</span><br><span class="line">                &#123;datas.map(<span class="function">(<span class="params">data, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span> </span></span></span><br><span class="line"><span class="xml">                        index=&#123;index&#125; </span></span><br><span class="line"><span class="xml">                        data=&#123;data&#125; </span></span><br><span class="line"><span class="xml">                        key=&#123;index&#125; </span></span><br><span class="line"><span class="xml">                        login=&#123;login&#125;</span></span><br><span class="line"><span class="xml">                        handleDelete=&#123;handleDelete&#125;</span></span><br><span class="line"><span class="xml">                        handleToEdit=&#123;handleToEdit&#125;</span></span><br><span class="line"><span class="xml">                        handleToDisplay=&#123;handleToDisplay&#125;</span></span><br><span class="line"><span class="xml">                        /&gt;</span></span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;<span class="regexp">/BasicLayout&gt;</span></span><br><span class="line"><span class="regexp">            </span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Home)</span><br></pre></td></tr></table></figure><p>现在启动项目(npm start)，观察到页面如下</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214224320.png"/></center><p>说明Home页面已经成功了(由于在sessionStorage中没有login，所以删除本文和编辑本文均显示不出来，当点击阅读更多时，会跳转到Display的页面)。</p><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><p>我们来观察Display的页面</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200214225458.png"/></center><p>发现Display页面有一个背景为白色的内容区和一个按钮，这个按钮根据是否有登录来决定是否暴露出来，所以我们在Display中新建一个components文件夹，在里面新建一个Content文件夹，在Content文件夹中新建index.jsx和index.module.css。首先Content是一个展示组件，所以它的数据全部都由Display提供，所有的数据操作也由Display传入回调函数进行处理。</p><p>index.jsx如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;login, htmlContent, handleToEdit&#125; = props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toEdit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleToEdit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div className=&#123;styles.display&#125;&gt;</span><br><span class="line">            &lt;div className=<span class="string">"braft-output-content"</span>  style=&#123;&#123;<span class="attr">minHeight</span>: <span class="string">"425px"</span>, <span class="attr">backgroundColor</span>: <span class="string">"#FFF"</span>, <span class="attr">padding</span>: <span class="string">"50px 25px"</span>, <span class="attr">fontSize</span>: <span class="string">"16px"</span>, <span class="attr">maxWidth</span>: <span class="string">"850px"</span>&#125;&#125; dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: htmlContent&#125;&#125; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &#123;login &amp;&amp; </span></span><br><span class="line"><span class="regexp">                &lt;div className=&#123;styles.edit&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Button type="primary" onClick=&#123;toEdit&#125;&gt;编辑文章&lt;/</span>Button&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Content</span><br></pre></td></tr></table></figure><p>想必上面的代码还是比较容易理解的，index.module.css的内容如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.display</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.display</span> <span class="selector-tag">ul</span>, <span class="selector-class">.display</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.edit</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Display中的内容如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./../../layouts/BasicLayout'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> Content <span class="keyword">from</span> <span class="string">'./components/Content'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Context&#125; <span class="keyword">from</span> <span class="string">'./../../Provider'</span></span><br><span class="line"><span class="keyword">import</span> BraftEditor <span class="keyword">from</span> <span class="string">'braft-editor'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Display</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;history&#125; = props</span><br><span class="line">    <span class="comment">// 获取传过来的id</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">Number</span>(history.location.pathname.split(<span class="string">"/"</span>)[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">const</span> &#123;state, dispatch&#125; = useContext(Context)</span><br><span class="line">    <span class="keyword">const</span> htmlContent = BraftEditor.createEditorState(state.datas[index].content).toHTML()</span><br><span class="line">    <span class="keyword">const</span> login = sessionStorage.getItem(<span class="string">"login"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleToEdit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: <span class="string">"changeOperation"</span>, <span class="attr">operation</span>: <span class="string">"EDIT"</span>&#125;);</span><br><span class="line">        history.push(<span class="string">`/edit/<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BasicLayout&gt;</span><br><span class="line">            &lt;Content</span><br><span class="line">                htmlContent=&#123;htmlContent&#125;</span><br><span class="line">                login = &#123;login&#125;</span><br><span class="line">                handleToEdit = &#123;handleToEdit&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        &lt;<span class="regexp">/BasicLayout&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Display)</span></span><br></pre></td></tr></table></figure><p>至此Display页面设计完毕。</p><h2 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h2><p>在写Edit页面之前，来改造一下RichText组件，我们要将RichText做成展示组件，所有的数据都由Edit提供，所有的数据处理也由Edit处理，修改如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> BraftEditor <span class="keyword">from</span> <span class="string">'braft-editor'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'braft-editor/dist/index.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RichText</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;value, onChange&#125; = props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleEditorChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> &#123;</span><br><span class="line">        onChange(editorState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;BraftEditor</span><br><span class="line">            value=&#123;value&#125;</span><br><span class="line">            onChange=&#123;handleEditorChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RichText</span><br></pre></td></tr></table></figure><p>现在我们来看一下Edit页面的结构</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200215000232.png"/></center><p>我们使用antd的表单来做成这件事情，在前面已经介绍过antd表单的使用，所以这里不多加介绍，直接上代码</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useEffect, useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> RichText <span class="keyword">from</span> <span class="string">'./components/RichText'</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Form, Input, Button, message, Checkbox &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">'./../../layouts/BasicLayout'</span></span><br><span class="line"><span class="keyword">import</span> BraftEditor <span class="keyword">from</span> <span class="string">'braft-editor'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Context&#125; <span class="keyword">from</span> <span class="string">'./../../Provider'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Edit</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;history&#125; = props</span><br><span class="line">  <span class="keyword">const</span> FormItem = Form.Item;</span><br><span class="line">  <span class="keyword">const</span> &#123; getFieldDecorator, validateFieldsAndScroll &#125; = props.form;</span><br><span class="line">  <span class="keyword">const</span> &#123;state, dispatch&#125; = useContext(Context)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当组件加载后 如果是编辑文章 根据id获取数据 然后显示 </span></span><br><span class="line">    <span class="comment">// 如果是添加操作，则不加载数据 直接显示空白内容</span></span><br><span class="line">    <span class="keyword">if</span>(state.operation === <span class="string">'EDIT'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="built_in">Number</span>(history.location.pathname.split(<span class="string">"/"</span>)[<span class="number">2</span>]) </span><br><span class="line">        <span class="keyword">const</span> data = state.datas[index]</span><br><span class="line">        <span class="comment">// setFieldsValue为表单设置内容</span></span><br><span class="line">        props.form.setFieldsValue(&#123;</span><br><span class="line">          ...data, </span><br><span class="line">          content: BraftEditor.createEditorState(data.content)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    </span><br><span class="line">    validateFieldsAndScroll(<span class="function">(<span class="params">err, values</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">        <span class="comment">// 如果是通过添加按钮进来的 那么拿到数据保存 然后跳转到home页面</span></span><br><span class="line">        <span class="keyword">if</span>(state.operation === <span class="string">'ADD'</span>) &#123;</span><br><span class="line">            dispatch(&#123;<span class="attr">type</span>: <span class="string">'insertData'</span>, <span class="attr">data</span>: &#123;</span><br><span class="line">                ...values,</span><br><span class="line">                content: values.content.toRAW()</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">            message.success(<span class="string">"添加成功"</span>);</span><br><span class="line">            history.push(<span class="string">"/home"</span>);</span><br><span class="line">            <span class="comment">//如果是编辑文章进来的，更新数据 然后跳转到home</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.operation === <span class="string">"EDIT"</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> id = <span class="built_in">Number</span>(history.location.pathname.split(<span class="string">"/"</span>)[<span class="number">2</span>]);</span><br><span class="line">            dispatch(&#123;<span class="attr">type</span>: <span class="string">"updateData"</span>, id, <span class="attr">data</span>: &#123;</span><br><span class="line">                ...values, </span><br><span class="line">                content: values.content.toRAW(),</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">            message.success(<span class="string">"更新成功"</span>);</span><br><span class="line">            history.push(<span class="string">"/home"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;BasicLayout&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Form onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">            &lt;FormItem labelAlign=<span class="string">"left"</span> label=<span class="string">"文章标题"</span>&gt;</span><br><span class="line">                &#123;getFieldDecorator(<span class="string">'title'</span>, &#123;</span><br><span class="line">                  rules: [&#123;</span><br><span class="line">                    required: <span class="literal">true</span>,</span><br><span class="line">                    message: <span class="string">'请输入标题'</span>,</span><br><span class="line">                  &#125;],</span><br><span class="line">                &#125;)(</span><br><span class="line">                  &lt;Input size=<span class="string">"large"</span> placeholder=<span class="string">"请输入标题"</span>/&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">              &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">            &lt;FormItem size="large" label="文章摘要"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;getFieldDecorator('brief', &#123;</span></span><br><span class="line"><span class="regexp">                  rules: [&#123;</span></span><br><span class="line"><span class="regexp">                    required: true,</span></span><br><span class="line"><span class="regexp">                    message: '请输入摘要',</span></span><br><span class="line"><span class="regexp">                  &#125;],</span></span><br><span class="line"><span class="regexp">                &#125;)(</span></span><br><span class="line"><span class="regexp">                  &lt;Input.TextArea style=&#123;&#123;fontSize: "16px"&#125;&#125; placeholder="请输入摘要"/</span>&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">              &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">            &lt;FormItem&gt;</span></span><br><span class="line"><span class="regexp">                &#123;getFieldDecorator('isTop', &#123;</span></span><br><span class="line"><span class="regexp">                  valuePropName: 'checked',</span></span><br><span class="line"><span class="regexp">                &#125;)(</span></span><br><span class="line"><span class="regexp">                  &lt;Checkbox&gt;</span></span><br><span class="line"><span class="regexp">                    是否置顶</span></span><br><span class="line"><span class="regexp">                  &lt;/</span>Checkbox&gt;,</span><br><span class="line">                )&#125;</span><br><span class="line">              &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">            &lt;FormItem label="文章正文"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;getFieldDecorator('content', &#123;</span></span><br><span class="line"><span class="regexp">                  validateTrigger: 'onBlur',</span></span><br><span class="line"><span class="regexp">                  rules: [&#123;</span></span><br><span class="line"><span class="regexp">                    required: true,</span></span><br><span class="line"><span class="regexp">                    message: "请输入正文"</span></span><br><span class="line"><span class="regexp">                  &#125;],</span></span><br><span class="line"><span class="regexp">                &#125;)(</span></span><br><span class="line"><span class="regexp">                  &lt;RichText /</span>&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">              &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">            &lt;FormItem&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Button size="large" type="primary" htmlType="submit"&gt;提交&lt;/</span>Button&gt;</span><br><span class="line">              &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>Form&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BasicLayout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Edit注入form</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Form.create()(Edit))</span><br></pre></td></tr></table></figure><p>上面的代码虽然有点长，但是都是比较容易理解的。注意，虽然我们没有为RichText传入value和onChange，但是由于RichText和表单项进行了双向绑定，所以表单会注入value和onChange。</p><h2 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h2><p>Login页面应该是最简单的，只要用我们在前面antd表单示例里面的表单就可以完成，所以直接上代码如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Form, Button, Input, message &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"><span class="keyword">import</span> LoginLayout <span class="keyword">from</span> <span class="string">'./../../layouts/LoginLayout'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; form, history &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FormItem = Form.Item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;getFieldDecorator, validateFields&#125; = form</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        validateFields(<span class="function">(<span class="params">err, values</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                <span class="keyword">if</span> (values.adminId === <span class="string">"123"</span> &amp;&amp; values.password === <span class="string">"123"</span>) &#123;</span><br><span class="line">                    sessionStorage.setItem(<span class="string">"login"</span>, <span class="literal">true</span>);</span><br><span class="line">                    message.success(<span class="string">"登录成功"</span>);</span><br><span class="line">                    history.push(<span class="string">"/home"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    message.error(<span class="string">"用户名或密码错误"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;LoginLayout&gt;</span><br><span class="line">          &lt;Form onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">            &lt;FormItem labelAlign=<span class="string">"left"</span> label=<span class="string">"用户名"</span>&gt;</span><br><span class="line">                &#123;getFieldDecorator(<span class="string">'adminId'</span>, &#123;</span><br><span class="line">                  rules: [&#123;</span><br><span class="line">                    required: <span class="literal">true</span>,</span><br><span class="line">                    message: <span class="string">'请输入用户名'</span>,</span><br><span class="line">                  &#125;],</span><br><span class="line">                &#125;)(</span><br><span class="line">                  &lt;Input size=<span class="string">"large"</span> placeholder=<span class="string">"请输入用户名"</span>/&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">            &lt;FormItem size="large" label="密码"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;getFieldDecorator('password', &#123;</span></span><br><span class="line"><span class="regexp">                  rules: [&#123;</span></span><br><span class="line"><span class="regexp">                    required: true,</span></span><br><span class="line"><span class="regexp">                    message: '请输入密码',</span></span><br><span class="line"><span class="regexp">                  &#125;],</span></span><br><span class="line"><span class="regexp">                &#125;)(</span></span><br><span class="line"><span class="regexp">                  &lt;Input.Password size="large" placeholder="请输入密码"/</span>&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">            </span></span><br><span class="line"><span class="regexp">            &lt;FormItem&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Button size="large" type="primary" htmlType="submit"&gt;提交&lt;/</span>Button&gt;</span><br><span class="line">            &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>Form&gt;</span><br><span class="line">        &lt;<span class="regexp">/LoginLayout&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Form.create()(Login))</span></span><br></pre></td></tr></table></figure><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>在这里还有一个小地方没有处理，那就是Header，里面的a标签的点击事件没有处理，并且我们希望在登录的情况下显示”写博客”，以及在登录的情况下显示”退出登录”，在未登录的情况下显示”登录”，所以修改Header如下(由于要用到history，所以要在Layout里给Header传入history，但是Layout也没有history，所以要在Home, Edit, Display, Login中给用到的Layout传入history，这里的代码就不贴出了，想必这样的事情对现在的你应该已经很简单了)</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Context&#125; <span class="keyword">from</span> <span class="string">'./../../Provider'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;history&#125; = props;</span><br><span class="line">    <span class="keyword">const</span> &#123;dispatch&#125; = useContext(Context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> login = sessionStorage.getItem(<span class="string">"login"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toEdit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: <span class="string">"changeOperation"</span>, <span class="attr">operation</span>: <span class="string">"ADD"</span>&#125;);</span><br><span class="line">        history.push(<span class="string">"/edit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> toHome = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        history.push(<span class="string">"/home"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> logout = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        sessionStorage.removeItem(<span class="string">"login"</span>);</span><br><span class="line">        history.push(<span class="string">"/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> login_ = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        history.push(<span class="string">"/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;styles.header&#125;&gt;</span><br><span class="line">            &lt;div className=&#123;styles.nav&#125;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/home"</span> <span class="attr">onClick</span>=<span class="string">&#123;toHome&#125;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;login &amp;&amp; &lt;li&gt;&lt;a href="/</span>edit<span class="string">" onClick=&#123;toEdit&#125;&gt;写博客&lt;/a&gt;&lt;/li&gt;&#125;</span></span><br><span class="line"><span class="string">                    &#123;login ? &lt;li&gt;&lt;a href="</span>/login<span class="string">" onClick=&#123;logout&#125;&gt;退出登录&lt;/a&gt;&lt;/li&gt; : &lt;li&gt;&lt;a href="</span>/login<span class="string">" onClick=&#123;login_&#125;&gt;登录&lt;/a&gt;&lt;/li&gt;&#125;</span></span><br><span class="line"><span class="string">                &lt;/ul&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div className=&#123;styles.desc&#125;&gt;</span></span><br><span class="line"><span class="string">                Coder</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Header</span></span><br></pre></td></tr></table></figure><p>接下来就是数据的持久化，我们希望将数据能够保存到localStorage，这样当页面刷新，关闭页面、浏览器,关机数据都能够保存。修改Provider.jsx</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useReducer&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Context = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saveData = <span class="function">(<span class="params">datas</span>) =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">"datas"</span>,<span class="built_in">JSON</span>.stringify(datas) || [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果datas没有内容，则为空数组，因为后面用到datas.map，放止报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"datas"</span>)) || []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tempDatas = state.datas</span><br><span class="line">    <span class="comment">// 每次对数据进行操作后都保存数据</span></span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'insertData'</span>:</span><br><span class="line">            tempDatas[tempDatas.length] = action.data;</span><br><span class="line">            saveData(tempDatas)</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">datas</span>: tempDatas&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'updateData'</span>:</span><br><span class="line">            tempDatas[action.id] = action.data</span><br><span class="line">            saveData(tempDatas)</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">datas</span>: tempDatas&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'deleteData'</span>:</span><br><span class="line">            tempDatas.splice(action.id, <span class="number">1</span>)</span><br><span class="line">            saveData(tempDatas)</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">datas</span>: tempDatas&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'changeOperation'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, <span class="attr">operation</span>: action.operation&#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    <span class="comment">// 初始化从localStorage中读取数据</span></span><br><span class="line">    datas: loadData(),</span><br><span class="line">    operation: <span class="string">'ADD'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initState)</span><br><span class="line">    <span class="keyword">const</span> &#123;children&#125; = props</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Provider</span></span><br></pre></td></tr></table></figure><h1 id="登录权限控制"><a href="#登录权限控制" class="headerlink" title="登录权限控制"></a>登录权限控制</h1><p>如果用户没有登录的话，是没有权利访问某些页面的，比如编辑页面，它不能够添加文章，也不能够编辑文章(虽然我们在未登录的情况下没有暴露这样的途径，如Display页面未登录没有编辑文章的按钮，Header未登录没有写文章的连接，但是可以通过url直接访问)，所以我们要做一些权限控制。</p><p>所以在访问路由时，我们要做权限的检查，修改router.js中的RouteItem方法，不能直接的返回Route，而是要给Route加一层验证，以决定是否返回，如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Auth <span class="keyword">from</span> <span class="string">'./components/Auth'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> RouteItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; path, <span class="attr">component</span>: Component, redirect, key, exact &#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;path&#125;</span> <span class="attr">to</span>=<span class="string">&#123;redirect&#125;</span> <span class="attr">key</span>=<span class="string">&#123;key&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Route</span><br><span class="line">            key=&#123;key&#125;</span><br><span class="line">            exact=&#123;exact&#125;</span><br><span class="line">            path=&#123;path&#125;</span><br><span class="line">            render=&#123;componentProps =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="comment">// 对Component加以验证</span></span><br><span class="line">                    &lt;Auth history=&#123;history&#125;&gt;</span><br><span class="line">                        &lt;Component &#123;...componentProps&#125; /&gt;</span><br><span class="line">                    &lt;<span class="regexp">/Auth&gt;</span></span><br><span class="line"><span class="regexp">                )</span></span><br><span class="line"><span class="regexp">            &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Auth组件正是用来做权限控制的，在src/components下新建Auth文件夹，并在其中新建index.jsx，如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Auth</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;children, history&#125; = props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> login = sessionStorage.getItem(<span class="string">"login"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Edit页面不能直接访问 需要登录</span></span><br><span class="line">    <span class="keyword">if</span> (children.type.WrappedComponent.name !== <span class="string">"Edit"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> children</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (login) &#123;</span><br><span class="line">            <span class="keyword">return</span> children</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        history.replace(<span class="string">"/login"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Auth</span><br></pre></td></tr></table></figure><p>验证的逻辑也是十分的简单，如果不是Edit组件，则可以访问直接返回，如果是，则进一步判断是否登录，如果登录，则可以访问，否则来到登录页面。</p><p>至此，整个项目的工作已经大致完成了，可能有的地方还需要美化，比如富文本编辑器的代码美化，或者将数据保存在后台服务器等等。这一路走来可能你会感到有点不轻松，那么恭喜你，你获得了进步，如果你十分的轻松，那么这个项目对你来说还是有点容易。不过不管怎么样，希望你能够完全靠自己做一遍，也许你跟着我一路走来十分的顺利，这是因为一些坑我给你跳过去了，说实话，在我第一次做时，遇到到许许多多的坑，有很多不明白的点，有的地方明明十分的简单，可是我能卡几个小时甚至一两天，虽然辛苦，但是收获十分的巨大。所以我希望你能够独立的完成，去遇到一些坑，然后去找解决办法，在这个过程你会收获巨大，索性你已经完成了这个项目，所以对于这个项目要做出什么样的效果以及功能已经有了把握，所以在做一遍会简单很多，总之，加油。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/24357770" target="_blank" rel="noopener">npm是干什么的?</a></li><li><a href="https://segmentfault.com/a/1190000016915868" target="_blank" rel="noopener">前端脚手架，听起来玄乎，实际呢?</a></li><li><a href="https://juejin.im/entry/5b1496656fb9a01e28621ef0" target="_blank" rel="noopener">虚拟DOM介绍</a></li><li><a href="http://huziketang.mangojuice.top/books/react/" target="_blank" rel="noopener">React.js 小书</a></li><li><a href="https://juejin.im/post/5d613dfcf265da03a53a41dc" target="_blank" rel="noopener">React中的事件处理</a></li><li><a href="https://www.jianshu.com/p/c6257cbef1b1" target="_blank" rel="noopener">深入理解React组件状态(State)</a></li><li><a href="https://juejin.im/entry/5ba3013fe51d453eb93d53e5" target="_blank" rel="noopener">重新认识生命周期函数</a></li><li><a href="https://segmentfault.com/a/1190000020353236" target="_blank" rel="noopener">React中类组件和函数式组件</a></li><li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.kuvqndiqq" target="_blank" rel="noopener">Presentational and Container Components</a></li><li><a href="https://juejin.im/post/5a3087746fb9a0450c4963a5" target="_blank" rel="noopener">使用Render Props吧</a></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Hook</a></li><li><a href="https://braft.margox.cn/" target="_blank" rel="noopener">BraftEditor</a></li></ul>]]></content>
    
    <summary type="html">
    
      介绍了从零搭建一个基于富文本编辑器的博客系统
    
    </summary>
    
    
      <category term="React" scheme="https://lastknightcoder.gitee.io/categories/React/"/>
    
    
      <category term="React antd React-Hooks" scheme="https://lastknightcoder.gitee.io/tags/React-antd-React-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 新特性</title>
    <link href="https://lastknightcoder.gitee.io/CSS3/"/>
    <id>https://lastknightcoder.gitee.io/CSS3/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2019-12-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3新特性样式"><a href="#CSS3新特性样式" class="headerlink" title="CSS3新特性样式"></a>CSS3新特性样式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h4><p>我们知道盒子的大小有三部分组成：border, padding, content，当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的，它有三个可选值</p><a id="more"></a><ul><li>border-box</li><li>padding-box</li><li>content-box</li></ul><p>其中意思不必解释就可以明白。如果不进行设置的话，默认是padding-box，即以padding的左上角为原点。</p><h4 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h4><p>该属性是用来设置背景(背景图片、背景颜色)延伸的范围，有4个值可选</p><ul><li>border-box：背景延伸至边框外沿(但是在边框下层)</li><li>padding-box：背景延伸至内边距(padding)外沿,不会绘制到边框处</li><li>content-box：背景被裁剪至内容区(content box)外沿</li><li>text：背景被裁剪成文字的前景色</li></ul><p>具体可以参考网站<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip" target="_blank" rel="noopener">background-clip</a>，这里演示一下上面的效果</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS301.gif"></center><h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>background-size用以设置背景图片大小。单张图片的背景大小可以使用以下三种方法中的一种来规定：</p><ul><li>使用关键词 contain</li><li>使用关键词 cover</li><li>设定宽度和高度值</li></ul><p>设定指定的宽度和高度值想必不用多加介绍。contain和cover会等比例的缩放图片，以使得图片能够最大的被完整包含或者最小的覆盖背景区。</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS302.gif"></center><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS303.gif"></center><p>如果背景区(由background-origin决定)的宽高比和图片的宽高比是一样的，那么cover和contain的结果是一样的，会完全的覆盖背景区并完整的显示。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><h4 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h4><p>使用border-radius可以设置边框为圆角的，border-radius的值就是圆角边框的半径。</p><center><img src="https://img-blog.csdnimg.cn/20190121192025792.png"></center><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">border-radius</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">pink</span>;</span><br></pre></td></tr></table></figure><center><img src="https://img-blog.csdnimg.cn/20190121192340237.png"></center><p>与padding一样，取不同个数的值，代表设置不同地方的圆角半径，如</p><table><thead><tr><th>取值个数</th><th>设置</th></tr></thead><tbody><tr><td>1个，如border-radius: 20px</td><td>设置四个角的圆角半径都为20px</td></tr><tr><td>2个，如border-radius: 10px 20px</td><td>设置左上角和右下角这条对角线为10px,另一条对角线为20px</td></tr><tr><td>3个，如border-radius: 10px 20px 30px</td><td>设置左上角为10px,右上角和左下角这条对角线为20px,右下角为30px</td></tr><tr><td>4个，如border-radius: 5px 10px 15px 20px</td><td>从左上角开始设置，按顺时针来，即左上角为5px,右上角为10px, …</td></tr></tbody></table><p>由第一张图，我们发现半径也分为水平半径和垂直半径，这两个也可以分别设置，用<code>/</code>分开当做两组，第一个用来设置水平半径，第二个设置垂直半径，如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 120<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br><span class="line">border-radius: 50px / 60px; </span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">pink</span>;</span><br></pre></td></tr></table></figure><p>我们设置四个角的水平半径为50px,四个角的水平半径为60px,得到效果如下</p><center><img src="https://img-blog.csdnimg.cn/20190121193308161.png"></center><p>如果不分开设置，则默认水平半径和垂直半径是相同的。</p><p>如果想要更加详细的了解，这里推荐一篇阮一峰的网络日志<a href="http://www.ruanyifeng.com/blog/2010/12/detailed_explanation_of_css3_rounded_corners.html" target="_blank" rel="noopener">CSS3圆角边框</a>。</p><h4 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h4><p>找到一篇写的很好的博文<a href="https://aotu.io/notes/2016/11/02/border-image/index.html" target="_blank" rel="noopener">border-image的正确用法</a>，所以这里就不自己写了。</p><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><h4 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h4><p>为了知道什么是盒子阴影，观看如下效果</p><center><img src="https://img-blog.csdnimg.cn/20190123143605852.gif"></center><p>这里选取了小米的做法，由于设置阴影的颜色比较淡，所以可能比较难看出来。</p><p>用以设置盒子阴影的属性是box-shadow,它的值比较多，需要设置的值如下，</p><ul><li>水平阴影 </li><li>垂直阴影 </li><li>模糊距离(虚实) </li><li>阴影尺寸(影子大小)  </li><li>阴影颜色  </li><li>内/外阴影(这个我也不懂，不做介绍)</li></ul><p>其中水平阴影h-shadow和垂直阴影v-shadow是必须设置的。</p><p>为了观看设置这些值的效果，我们首先创建一个盒子</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#CCC</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><center><img src="https://img-blog.csdnimg.cn/20190123152039866.png"></center><p>为盒子添加阴影</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: 1<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br></pre></td></tr></table></figure><p>水平阴影大小的影响(正值，阴影向右移动，负值，阴影向左移动)</p><center><img src="https://img-blog.csdnimg.cn/20190123153228640.gif"></center><p>垂直阴影大小的影响(正值，阴影向下移动，负值，阴影向上移动)</p><center><img src="https://img-blog.csdnimg.cn/20190123153439339.gif"></center><p>模糊距离大小的影响</p><center><img src="https://img-blog.csdnimg.cn/20190123153534212.gif"></center><p>阴影尺寸大小的影响</p><center><img src="https://img-blog.csdnimg.cn/20190123153544203.gif"></center><h4 id="文本阴影"><a href="#文本阴影" class="headerlink" title="文本阴影"></a>文本阴影</h4><p>使用text-shadow来设置文本阴影。使用与box-shadow差不多，具体可以参照<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow" target="_blank" rel="noopener">text-shadow</a>。</p><h2 id="CSS3选择器"><a href="#CSS3选择器" class="headerlink" title="CSS3选择器"></a>CSS3选择器</h2><p>CSS3新增了许多的选择器，为我们选择元素提供了更加灵活的选择。</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul><li>[attr]：选择包含attr属性的标签</li><li>[attr=value]：选择attr属性值为value的标签</li><li>[attr^=value]：选择attr属性值以value开头的标签</li><li>[attr*=value]：选择attr属性值包含value的标签</li><li>[attr$=value]：选择attr属性值以value的标签</li></ul><p>如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class]</span> &#123;</span><br><span class="line">    <span class="comment">/* 会选择包含class属性的div标签 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class=<span class="string">"active"</span>]</span> &#123;</span><br><span class="line">    <span class="comment">/* 会选择class属性值为active的div标签 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class^=<span class="string">"header"</span>]</span> &#123;</span><br><span class="line">    <span class="comment">/* 会选择class属性以header开头的div标签 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><ul><li>E:first-child</li><li>E:last-child</li><li>E:nth-child(n)</li><li>E:nth-last-child(n)</li><li>E:first-of-type</li><li>E:last-of-type</li><li>E:nth-of-type(n)</li><li>E:nth-last-of-type(n)</li></ul><p>上面的选择器是比较常见的结构伪类选择器，下面具体讲解其表达的意思。</p><p>E:first-child指的是，选择E，这个E满足的条件是：它是其父元素第一个子元素。听起来有点绕，来看一个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="comment">/* 它会选择span，条件是这个span必须是它父元素的第一个子元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于第一个div里面的span是其父元素(第一个div)的第一个子元素，所以第一个div里面的span会被选中。而第二个div里面的span不是其父元素(第二个div)的第一个子元素，所以这个span不会被选中。</p><p>E:last-child的与E:first-child相似，不过第一个改为最后一个。</p><p>E:nth-child(n)指的是选择E，E需要满足条件，是其父元素的第n个元素(n是从1开始的)，E:first-child就相当于是E:nth-child(1)。E:nth-child(n)中这个”n”除了可以是具体的数字以外，还可以是odd和even，表示选择所有的E，这些E是其父元素的第奇数或第偶数个。除此之外”n”还可以是表达式，如2n+1, 3n(n从1开始)。</p><p>而E:nth-last-child(n)则是倒着数的，用法同E:nth-child(n)相似，这里不多介绍。</p><p>E:first-of-type与E:first-child不同，其意思是选择器父元素下的第一个E元素。还是以上面两个div为例</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:first-of-type</span> &#123;</span><br><span class="line">    <span class="comment">/* 选择span父元素下的第一个span元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候两个span都可以被选择到，first-of-type相当于只是将E的父元素所包含的E全部抽离出来，然后进行选择。现在我们将div包含的span全部抽离出来，相当于</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后选择第一个span，所以这两个span都可以被选择到。其余的first-last-type, nth-of-type(n), nth-last-of-type同上面介绍的last-child, …相似，其不同之处在fitst-child与first-of-type处已详细阐述。</p><h2 id="CSS3颜色渐变"><a href="#CSS3颜色渐变" class="headerlink" title="CSS3颜色渐变"></a>CSS3颜色渐变</h2><p>颜色渐变是指在两个颜色之间平稳的过渡。以往我们如果希望有颜色渐变的效果，会在绘图工具(如PS)设计出希望的效果，然后作为图片来实现这种效果。现在通过浏览器可以渲染而成，这样可以减少下载的时间和带宽的使用，以及在放大时看起来效果更好，因为这是浏览器自动生成的。</p><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>线性渐变指的是颜色在一条线上平稳的变化，为了实现线性渐变，我们要规定线的方向，起点颜色和终止颜色。它的语法为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">direction</span>, <span class="selector-tag">color-stop1</span>, <span class="selector-tag">color-stop2</span>, ...);</span><br></pre></td></tr></table></figure><p>如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">            background-image: linear-gradient(to right, red, green);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果为</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS04.png"></center><p>其中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br></pre></td></tr></table></figure><p>其中第一个参数<code>to right</code>是用来设置方向的，设置方向的值有</p><ul><li>to right：从左往右</li><li>to left：从右往左</li><li>to top：从下往上</li><li>to bottom：从上往下，默认值</li><li>to right bottom：从左上角往右下角</li><li>… …</li></ul><p>除了可以设置这些值之外，还可以设置角度，如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">linear-gradient</span>(0<span class="selector-tag">deg</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br></pre></td></tr></table></figure><p>其中角度所代表的的方向如下所示</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS05.jpg" width="70%" title="图片来自于菜鸟教程"></center><p>即<code>0deg</code>代表的方向是从下往上。</p><p>除此之外，除了设置起点颜色和终点颜色之外，还可以在之间设置多个颜色节点，如下面设置了一个彩虹渐变色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">orange</span>, <span class="selector-tag">yellow</span>, <span class="selector-tag">green</span>, <span class="selector-tag">blue</span>, <span class="selector-tag">indigo</span>, <span class="selector-tag">violet</span>);</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS06.png"></center><p>除此之外，还可以在颜色后面加上数值或者百分比，如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">blue</span> 10%, <span class="selector-tag">violet</span>);</span><br></pre></td></tr></table></figure><p><code>blue 10%</code>表示<code>blue</code>颜色节点在该线性方向<code>10%</code>的位置，所以从<code>0%-10%</code>是红色到蓝色的渐变，<code>10%-100%</code>是蓝色到紫色的渐变。</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS07.png"></center><p>接下来介绍渐变的最后一个特性：渐变重复。看下面一个例子</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置为23%而没有设置为能被100%整除的数 就是想看一下这种情况是怎么处理的 */</span></span><br><span class="line"><span class="selector-tag">repeating-linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>,<span class="selector-tag">yellow</span> 23%);</span><br></pre></td></tr></table></figure><p>上面的意思是从<code>0%-23%</code>实现红色到黄色的渐变，然后重复直至<code>100%</code>。</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS08.png"></center><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>径向渐变是指以某点为圆心，向外进行颜色渐变。所以为了实现径向渐变，我们要规定圆心的位置和起点颜色和终点颜色。径向渐变的语法为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">shape</span> <span class="selector-tag">size</span> <span class="selector-tag">at</span> <span class="selector-tag">position</span>, <span class="selector-tag">start-color</span>, ..., <span class="selector-tag">last-color</span>);</span><br></pre></td></tr></table></figure><p>其中shape为渐变的形状，有两种取值</p><ul><li>circle(圆形)</li><li>ellipse(椭圆, 默认值)</li></ul><p>size是指<code>100%</code>所代表的的长度，有四种取值</p><ul><li>closest-side(离最近的边的距离)</li><li>farthest-side(离最远的边的距离)</li><li>cloest-corner(离最近的角的距离)</li><li>farthest-corber(离最远的角的距离，默认值)</li></ul><p>position是指圆心的位置，默认为<code>center</code>，即中心位置，也可以通过<code>at 100px 100px</code>形式进行设置，左上角的坐标的为(0px, 0px)。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="comment">/* 设置size大小为离最近的边的距离 */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">repeating-radial-gradient</span>(circle closest-side at <span class="number">200px</span> <span class="number">100px</span>, red, red <span class="number">10%</span>,green <span class="number">12.5%</span>, green <span class="number">25%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS09.png"></center><p>可见离最近的边有4个完整的重复。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置size大小为离最远的边的距离 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">repeating-radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">farthest-side</span> <span class="selector-tag">at</span> 200<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>, <span class="selector-tag">red</span>, <span class="selector-tag">red</span> 10%,<span class="selector-tag">green</span> 12<span class="selector-class">.5</span>%, <span class="selector-tag">green</span> 25%)</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS10.png"></center><p>可见离最远的边有4个完整的重复。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*为了使最远的角和最近的角的距离不同 position不能设置在中心 */</span></span><br><span class="line"><span class="comment">/* 设置size大小为离最近的角的距离 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">repeating-radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">closest-corner</span> <span class="selector-tag">at</span> 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>, <span class="selector-tag">red</span>, <span class="selector-tag">red</span> 10%,<span class="selector-tag">green</span> 12<span class="selector-class">.5</span>%, <span class="selector-tag">green</span> 25%)</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS11.png"></center><p>可见离最近的角有4个完整的重复。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置size大小为离最远的角的距离 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">repeating-radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">farthest-corner</span> <span class="selector-tag">at</span> 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>, <span class="selector-tag">red</span>, <span class="selector-tag">red</span> 10%,<span class="selector-tag">green</span> 12<span class="selector-class">.5</span>%, <span class="selector-tag">green</span> 25%)</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS12.png"></center><p>可见离最远的角有4个完整的重复。</p><h2 id="CSS3-2D变换"><a href="#CSS3-2D变换" class="headerlink" title="CSS3 2D变换"></a>CSS3 2D变换</h2><p>CSS3 2D变换包括对元素进行移动、缩放、转动、拉长或拉伸。</p><ul><li><p>translate()：对元素进行进行移动</p><ul><li>translate(100px)：对元素向x正方向移动100px(负值向负方向移动)</li><li>translate(100px, 100px)：对元素向x, y正方向方向移动100px</li></ul></li><li><p>scale()：对元素进行缩放</p><ul><li>scale(n)：对元素进行缩放，传入的参数大于1，进行放大，小于1，进行缩小</li><li>scale(x, y)：第一个参数对宽度进行缩放，第二个值对高度进行缩放</li></ul></li><li><p>rotate()：围绕中心旋转，正值顺时针，负值逆时针</p><ul><li><p>transform-origin：可以改变旋转的中心，如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 围绕左上角进行旋转 */</span></span><br><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 围绕中心旋转 为默认值 */</span></span><br><span class="line"><span class="selector-tag">transform-origin</span>: 50% 50%;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>skew()：对元素进行倾斜</p><ul><li>skew(angle)：向x轴负方向倾斜angle(负值沿正方向)</li><li>skew(anglex, angley)：第一个参数对x方向，第二个参数对y方向</li></ul></li></ul><p>除了可以使用上述属性进行设置，还可以使用translateX(), translateY()等进行设置。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        div &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 为每个div设置颜色 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">            background-color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box3</span> &#123;</span></span><br><span class="line">            background-color: chocolate;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box4</span> &#123;</span></span><br><span class="line">            background-color: darkcyan;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 为每个盒子设置不同的2D变换效果 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            transform: translateX(100px);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box3</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            transform: rotate(-30deg);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box4</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            transform: skew(30deg);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS313.gif"></center><h2 id="CSS3-3D"><a href="#CSS3-3D" class="headerlink" title="CSS3 3D"></a>CSS3 3D</h2><p>3D变换的操作同2D相同，只是多了一个对Z轴的操作，如translateZ()，而rotate也分为rotateX(), rotateY(), rotateZ()，分别表示绕着X轴，Y轴，Z轴旋转。2D变换的rotate()其实就相当于rotateZ()。</p><h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>首先我们来看一个例子</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">600px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS314.gif"></center><p>当我们把鼠标放在盒子上时，盒子向右移动了600px，但是这个过程是在瞬间完成的，十分的突兀，我们希望是缓慢由一个转态转变到另一个状态的，这种效果又叫做过渡，这时就需要用到transition属性了。</p><p>为某个元素添加过渡效果，必须规定两项内容：</p><ul><li>transition-property：指定要添加效果的CSS属性</li></ul><p>例如上面就要为transform添加过渡效果，所以就可以写为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 值可以为all 表示为所有的属性添加过渡效果 默认值为all*/</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">transform</span>;</span><br></pre></td></tr></table></figure><ul><li>transition-duration：添加过渡的总时间</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认值为0s */</span></span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>; <span class="comment">/* 单位可以为s */</span></span><br><span class="line"><span class="selector-tag">transition-duration</span>: 100<span class="selector-tag">ms</span>; <span class="comment">/* 单位也可以为ms */</span></span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS315.gif"></center><p>除了上面必须设置的两个属性，还可以设置下面的属性</p><ul><li>transition-timing-function：时间函数，设置过渡的变化速度<ul><li>ease：开始和结束慢，中间快，默认值。</li><li>linear：匀速。</li><li>ease-in：开始慢。</li><li>ease-out：结束慢。</li><li>ease-in-out：和ease类似，但比ease幅度大。</li></ul></li></ul><p>除了可以设置以上关键字，还可以设置steps()函数，语法如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">steps</span>(&lt;<span class="selector-tag">integer</span>&gt;<span class="selector-attr">[,start | end]</span>?)</span><br></pre></td></tr></table></figure><p>第一个参数传入一个整数值，steps步进函数将过渡时间划分成大小相等的时间时隔来运行，这个整数值就是分成的份数。第二个值是可选的，默认值为end。如果是start，则不保留开始值，如果是end，则保留开始值。</p><p>这里给出一个利用steps()函数做动画效果的<a href="https://cssanimation.rocks/twitter-fave/" target="_blank" rel="noopener">例子</a>。</p><ul><li>transition-delay：延时时间，默认值为0s</li></ul><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>与transition一样，animation也有很多的属性</p><ul><li>animation-name：动画名称</li><li>animation-duration：动画持续时间</li><li>animation-timing-function：动画时间函数</li><li>animation-delay：动画延迟时间</li><li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</li><li>animation-direction：动画执行方向</li><li>animation-paly-state：动画播放状态</li><li>animation-fill-mode：动画填充模式</li></ul><p>过渡是指在两个状态之间，而动画则是指在多个状态之间变化，这些状态我们称之为关键帧，因此动画又称之为关键帧动画。使用动画首先要创建关键帧，然后使用animation-name去调用该动画，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">           animation-name: move;</span><br><span class="line">           animation-duration: 1s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">       <span class="comment">/* 创建一个关键帧动画 动画名为move */</span></span></span><br><span class="line"><span class="css">       <span class="comment">/* 调用时使用animation-name: move调用 */</span></span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> move &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/* 第一个状态 0% 时的状态 可以使用from代替 */</span></span></span><br><span class="line"><span class="css">            <span class="comment">/* 这里的百分比是指 总时间 * 百分比 得到的某个时刻的状态*/</span></span></span><br><span class="line">            0% &#123;</span><br><span class="line">                transform: translateX(0px);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            50% &#123;</span><br><span class="line">                transform: translateX(100px);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="comment">/* 100% 可以使用 to 代替 */</span></span></span><br><span class="line">            100% &#123;</span><br><span class="line">                transform: translateY(100px);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS316.gif"></center><p>我们还可以设置动画的执行次数，修改上面的样式为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">animation-name</span>: move;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="comment">/* 播放次数默认值为 1 */</span></span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS317.gif"></center><p>我们发现动画执行完毕后，盒子突然就回到了原位置，这个过程有点突兀，我们希望这个过程也是慢慢过渡的，那么我们可以设置animation-direction，animation-direction有四种取值</p><ul><li>normal：默认值，正常播放</li><li>reverse：反向播放</li><li>alternate：如果动画次数在两次或两次以上，那么第偶数次为反向播放，就可以达到回到原位置时也有过渡的效果。若动画只播放一次，则和正向播放一样。</li><li>alternate-reverse：若动画只播放一次，则和反向播放一样。若播放两次以上，偶数次效果为正向播放</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">   <span class="attribute">animation-name</span>: move;</span><br><span class="line">   <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">   <span class="attribute">animation-iteration-count</span>: <span class="number">2</span>;</span><br><span class="line">   <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS318.gif"></center><p>animation-play-state用来设置动画的播放状态，有两种取值</p><ul><li>running：默认值，动画运行</li><li>paused：动画暂停</li></ul><p>将样式修改为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">animation-name</span>: move;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">    <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="comment">/* 当鼠标放上去时 动画暂停 */</span></span><br><span class="line">   <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS319.gif"></center><p>animation-fill-mode用来定义动画开始帧之前和结束帧之后的动作，有以下四种取值</p><ul><li>none：默认值。动画结束后，元素移动到初始状态(不一定0%的状态，是元素自身的属性值)</li><li>forwards：元素停在动画结束时的位置(不一定是100%的位置，有可能反向运动)</li><li>backwards：在animation-delay的时间内，元素立刻移动到动画开始时(不一定是0%，有可能反向运动)的位置。若元素无animation-delay时，与none的效果相同</li><li>both：同时具有forwards和backwards</li></ul><p>修改样式如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">   <span class="attribute">animation-name</span>: move;</span><br><span class="line">   <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">   <span class="comment">/* 动画结束后，停留在动画结束的位置 */</span></span><br><span class="line">   <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS320.gif"></center><h2 id="CSS3-flex布局"><a href="#CSS3-flex布局" class="headerlink" title="CSS3 flex布局"></a>CSS3 flex布局</h2><p>当一个父元素被设置为display:flex时，它就是弹性布局，子元素的float、clear和vertical-align属性将失效。此时我们把父元素称之为container(容器)，把子元素称之为item(项目)。当父元素被设置为弹性布局后，对子元素有什么影响? 先来感受一下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">            display: flex;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background-color: crimson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="comment">/* 这个是为了演示方便 样式不重要 不必细看 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.item</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">           width: 50%;</span><br><span class="line">           height: 50%;</span><br><span class="line">           position: absolute;</span><br><span class="line"><span class="css">           <span class="comment">/* 下面三行语句是为了设置居中对齐 */</span></span></span><br><span class="line">           top: 50%;</span><br><span class="line">           left: 50%;</span><br><span class="line">           transform: translate(-50%, -50%);</span><br><span class="line">           background-color: brown;</span><br><span class="line"><span class="css">           <span class="comment">/* 圆角边框 */</span></span></span><br><span class="line">           border-radius: 50%;</span><br><span class="line"><span class="css">           <span class="comment">/* 下面两行设置文字居中对齐 */</span></span></span><br><span class="line">           text-align: center;</span><br><span class="line">           line-height: 50px;</span><br><span class="line"><span class="css">           <span class="comment">/* 设置字体样式 */</span></span></span><br><span class="line">           font-size: 30px;</span><br><span class="line">           font-weight: 700;</span><br><span class="line">           color: white;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS330.png"></center><p>当父元素设置为flex布局后，其子元素item会在父元素container的主轴上排列。</p><p>这里又牵涉到新的概念，主轴(main axis)，flex容器的主轴默认为X轴，即从左向右，既然有主轴，那么就会有侧轴(cross axis)，默认的侧轴为Y轴，即从上往下。</p><h3 id="container上的属性"><a href="#container上的属性" class="headerlink" title="container上的属性"></a>container上的属性</h3><p>直观的感受了一下flex的效果，现在我们来看看flex要设置哪些属性，首先设置在container的flex属性有</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p>下面来一一介绍。</p><p>flex-direction是用来设置主轴的，它有以下四个值可选</p><ul><li>row：默认值，主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><p>现在我们分别修改container里面的样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row-reverse</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS331.png"></center><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">column</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS323.png"></center><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">column-reverse</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS324.png"></center><p>为了演示flex-wrap，我们添加9个item(此时flex-direction为默认值row，除非特别声明，否则我们在演示其一个flex属性时，会将其他flex属性设置为默认值)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果为</p><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS332.png"></center><p>我们发现9个item排成了一排，没有换行。为了使得item能够换行，我们需要设置flex-wrap，它有三个值可选</p><ul><li>nowrap：默认值，不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS333.png"></center><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap-reverse</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS334.png"></center><p>flex-flow是flex-direction和flex-wrap两个属性的简写，默认值为row wrap</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><p>justify-content是用来设置item在container在主轴上的对齐方式的，具体对齐方式与轴的方向有关,下面假设主轴为从左到右(row)。有下面几种值可选</p><ul><li>flex-start：左对齐</li><li>flex-end：右对齐</li><li>center：居中对齐</li><li>space-between：两端对齐，项目之间间隔相等</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p>这里演示一下space-between和space-around</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-between</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS328.png"></center><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-around</span>;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS329.png"></center><p>align-items定义了在侧轴上的对齐方式(以从上往下的侧轴为例)</p><ul><li>first-start：往上对齐</li><li>first-end：往下对齐</li><li>center：居中对齐</li><li>baseline：item的第一行文字的基线对齐。</li><li>stretch：默认值，如果没有设置height或者height设置为auto，将占满整个容器的高度</li></ul><p>这里演示一下stretch，不设置height</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: crimson;</span><br><span class="line">    <span class="attribute">align-items</span>: stretch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="comment">/* height: 100px; */</span></span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 修改line-height为200px使文字居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS335.png"></center><p>align-content，当我们设置flex-wrap为wrap或者wrap-reverse时，item会占据多行，这个属性是用来设置占据多行item在侧轴上的对齐方式，如果没有多行，这个属性无效。有下列值可选(以侧轴为从上往下为例)</p><ul><li>first-start：往上对齐</li><li>first-end：往下对齐</li><li>center：居中对齐</li><li>stretch：默认值，轴线占据整个侧轴</li><li>space-between：两端对齐，轴线之间平均分布</li><li>space-around</li></ul><h3 id="item上的属性"><a href="#item上的属性" class="headerlink" title="item上的属性"></a>item上的属性</h3><p>下面6个属性是设置在item上的</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>self-align</li></ul><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0，现在设置第2个item的order为1</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2)</span>&#123;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS336.png"></center><p>如果存在剩余空间，那么flex-grow可以用来设置item占据剩余空间的份数(这会导致item增大)，默认值为0，意味着即使有剩余空间，也不增大，现在设置各自的flex-grow</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="comment">/* 第一个item占 1 / (1 + 2 + 1) = 1/4 的剩余间 */</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="comment">/* 第二个item占 2/4 的剩余空间*/</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="comment">/* 第三个item占 1/4 的剩余空间 */</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS337.png"></center><p>flex-shrink与flex-grow相反，当空间不足时，item缩小的以使得所有item被包含在container中。默认值是1，即每个item会等比例缩小</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS338.png"></center><p>可见第一个、第二个和最后一个缩小的更多。</p><p>flex-basis的含义是item在被放进container之前的大小。也就是item理想或假设的大小。默认值为auto，如果不设置这个值，并且主轴是row的话，那么flex-basis就是width的大小，如果主轴是column的话，那么flex-basis就是height的大小，如果width或height也没有设置的话，flex-basis是content的大小。item的宽度是最终的flex-basis，最佳的方法是只使用flex-basis而不是width或height属性。</p><p>但是flex-basis不能保证其大小! 一旦将items放入flex容器中，flex-basis的值就无法保证了。这是因为有flex-grow和flex-shrink，可能会被放大或者缩小item的大小。</p><p>除此之外，flex-basis还受到min-width, max-width, min-height, max-height的约束。具体见<a href="https://gedd.ski/post/the-difference-between-width-and-flex-basis/" target="_blank" rel="noopener">The Difference Between Width and Flex Basis</a>这篇文章，有着十分详细的阐述，绝对让你物超所值。</p><p>slef-align属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">    <span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/CSS339.png"></center>]]></content>
    
    <summary type="html">
    
      讲解CSS3的新特性 几乎包括了各个方面
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="CSS" scheme="https://lastknightcoder.gitee.io/categories/Web/CSS/"/>
    
    
      <category term="CSS3" scheme="https://lastknightcoder.gitee.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>HTML5超详细了解</title>
    <link href="https://lastknightcoder.gitee.io/HTML5%E5%85%A5%E9%97%A8/"/>
    <id>https://lastknightcoder.gitee.io/HTML5%E5%85%A5%E9%97%A8/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2019-12-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5属于上一代HTML的新迭代语言，设计HTML5最主要的目的是为了在移动设备上支持多媒体，例如：video标签和audio及canvas标记。</p><h2 id="HTML5中语义化标签"><a href="#HTML5中语义化标签" class="headerlink" title="HTML5中语义化标签"></a>HTML5中语义化标签</h2><p>在HTML5中新增了很多的语义标签，如</p><ul><li>header</li><li>footer</li><li>nav</li><li>article</li><li>aside</li><li>section</li><li>… …</li></ul><p>比如以前我们使用以下方式来布局</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以替换为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML5可以让很多更语义化的结构化代码标签代替大量无意义的div标签</p><ol><li>这种语义化的特性提升了网页的质量和语义</li><li>减少了以前用于CSS 调用的<code>class</code>和<code>id</code>属性</li></ol><p>并且对搜索引擎的友好，新的结构标签带来的是网页布局的改变及提升对搜索引擎的友好。</p><p>但是现在碰到一个问题，由于这些具有语义的标签是HTML5新增的，这就意味着在IE8及以下版本的IE浏览器中不支持，如下面的样式在IE8中就不能够正常的显示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        header &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            height: 400px;</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 解决办法：</p><ol><li>在script中创建语义标签header，并且将header的display设置为block</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        header &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            height: 400px;</span><br><span class="line">            width: 100%;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.createElement(<span class="string">"header"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用1的方法，意味着对每个语义标签都要创建元素，这样未免比较麻烦，更好的办法是使用插件，引入html5shiv.js文件，该插件的实质还是创建了语义元素</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        header &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            height: 400px;</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"html5shiv.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>上面的方法还有需要改进的地方，比如在谷歌浏览器中完全支持HTML5，这就意味着在渲染HTML网页时不需要下载html5shiv.js文件，但是上面的方法是在任何的浏览器中都会下载的，所以再次改进如下</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lte IE 8]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="html5shiv.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码只有IE浏览器才会识别，意思是如果IE浏览器的版本是IE8及以下的版本，才会下载这个js文件，在其他浏览器中会认为这时注释，自动忽略。</p><h2 id="video和audio"><a href="#video和audio" class="headerlink" title="video和audio"></a>video和audio</h2><p>在浏览器中插入视频和音频文件，以往是使用flash来实现，但是在移动端使用flash就会比较慢，HTML5给了两个新的标签，用来插入视频和音频文件。二者的使用相似，现以video为例介绍该标签的属性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>src</td><td>值为视频文件的路径</td></tr><tr><td>controls</td><td>显示控制台</td></tr><tr><td>autoplay</td><td>自动播放</td></tr><tr><td>loop</td><td>循环播放</td></tr><tr><td>… …</td><td>… …</td></tr></tbody></table><p>还有一些属性没有介绍，以上是较为常用的，剩余的请参考网站<a href="https://www.w3school.com.cn/html5/html_5_video.asp" target="_blank" rel="noopener">HTML5视频</a>。这里给出一个实例</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"resources/video.mp4"</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个需要注意的是，目前只支持三种格式的视频</p><ul><li>Ogg</li><li>MPEG 4(mp4)</li><li>WebM </li></ul><p>并且不同的浏览器支持的程度也不一样，具体的可以参考上面的链接。那么这个时候怎么办? 我们不能这么写</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test.mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test.ogg"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test.WebM"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然我们的本意是：如果支持.mp4，那么就使用.mp4，否则如果支持.ogg，则用.ogg，以此类推。但是上面的效果是出现3个video，而不是一个，这个时候的解决办法是使用source标签，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test.mp4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test.ogg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test.WebM"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候达到的效果就是我们想要的。</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML5在表单这里也做了很多的改进，比如新增了一些属性以进行表单验证(以往这些工作我们都是使用JavaScript进行正则表达式的验证)，以及新的标签和方法。</p><h3 id="智能表单控件"><a href="#智能表单控件" class="headerlink" title="智能表单控件"></a>智能表单控件</h3><ul><li>emial</li><li>url</li><li>number</li><li>range</li><li>color</li><li>date</li><li>month</li><li>week</li><li>time</li></ul><p>首先用法如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    url: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    number: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    range: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    color: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    date: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    week: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"week"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    time: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"time"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html501.png"/></center><p>当<code>type</code>设置为<code>emial</code>时，如果输入的不是电子邮箱，当点击提交按钮时，不能提交成功，并给出提示信息</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html502.png"/></center><p>当<code>type</code>设置为<code>url</code>时，如果输入的不是<code>url</code>地址，那么当点击提交按钮时，也不能提交成功，并给出提示信息</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html503.png"/></center><p>正确的<code>url</code>地址应该以<code>http</code>或者<code>https</code>开头，如<code>http://www.baidu.com</code>。</p><p>当<code>type</code>设置为<code>number</code>时，这时在控件里面只能输入数字，当你按其他键时没有反应，可以自行实验看看效果。</p><p>当<code>type</code>设置为<code>color</code>时，点击<code>color</code>后的颜色，会出现拾色器，可以选择颜色，如下</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html504.png"/></center><p>设置<code>type</code>设置为<code>date, week, time</code>时，显示的是各种格式的时间，这里不多加解释想必可以明白。</p><h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><h4 id="form表单的属性"><a href="#form表单的属性" class="headerlink" title="form表单的属性"></a>form表单的属性</h4><ol><li>autocomplete</li></ol><p>直译过来就是自动完成，当我们提交表单后，表单会记录我们提交的内容，当我们再次填写时，它会给出我们已经提交过的内容作为提示信息。有时这种情况下可能会造成信息的泄漏，不安全，我们可以将<code>autocomplete</code>设置为<code>off</code>，这时就不会出现上面的情况。默认情况下<code>autocomplete</code>为<code>on</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>novadilate</li></ol><p>上面我们提到，当我们使用智能表单控件时，如果不能满足格式的要求，如<code>email</code>，则不能提交成功，当表单添加<code>novadilate</code>属性时，那么这时即使所填写的格式不满足要求，那么也可以提交成功。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span>  <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="input的属性"><a href="#input的属性" class="headerlink" title="input的属性"></a>input的属性</h4><ol><li>autofocus</li></ol><p>自动获得焦点，我们先来看一个淘宝的案例</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html505.gif"/></center><p>当我们进入淘宝，搜索框会自动的获得焦点，用户可以直接输入，不需要用鼠标先点击搜索框获得焦点才能输入。input添加autofocus的属性即可有这种效果。</p><ol start="2"><li>form</li></ol><p>先来看这么一个结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"two"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以知道当提交form表单时，只会提交表单域里面的表单，表单域外的表单不会提交，所以当我们提交时，只会有<code>one</code>的数据才会提交</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html506.png"/></center><p>但是如果希望当提交时，<code>two</code>的数据也能进行提交(别奇怪，真的有这种需求)，这个时候就需要用到<code>form</code>属性了</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"data"</span> <span class="attr">action</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"two"</span> <span class="attr">form</span>=<span class="string">"data"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>form</code>属性的值为<code>form</code>表单的<code>id</code>值。这时再次进行提交</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html507.png"/></center><p>这时<code>two</code>的数据也得到了提交。</p><ol start="3"><li>list</li></ol><p><code>list</code>属性要配合HTML5新添加的表单标签<code>&lt;datalist&gt;</code>使用，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">list</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"One"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Two"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Three"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>list</code>属性的值为<code>datalist</code>标签的<code>id</code>值。当我们在<code>text</code>中输入时，会有<code>datalist</code>中<code>option</code>值的提示</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html508.png"/></center><ol start="4"><li>multiple</li></ol><p><code>multiple</code>可以实现多选的效果，比如选择多个文件，假设有下面的<code>input</code>标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html509.gif"/></center><p>这时只能选择一个文件，为了选择多个文件，我们为<code>input</code>标签添加<code>multiple</code>属性</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html510.gif"/></center><p>这时就可以选择多个文件了。</p><ol start="5"><li>placeholder</li></ol><p>使用placeholder作为提示信息，假设有如下标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入信息"</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html511.gif"/></center><p>当我们输入文字时，提示信息会消失，当我们将文字消失时，文字又会出现。</p><ol start="6"><li>required</li></ol><p>当<code>input</code>使用该属性时，表示该<code>input</code>控件是必填项，否则无法提交，具体可以自己试验一下，这里就不演示了。</p><h2 id="HTML5-API"><a href="#HTML5-API" class="headerlink" title="HTML5 API"></a>HTML5 API</h2><h3 id="获取DOM元素"><a href="#获取DOM元素" class="headerlink" title="获取DOM元素"></a>获取DOM元素</h3><p>假设有如下的<code>html</code>结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们要改变<code>span</code>的样式(通过JS)，我们我们一般要为<code>span</code>标签添加<code>id</code>属性或者<code>class</code>属性，这样才能获取要对应的<code>DOM</code>元素，HTML5新增了两个方法</p><ul><li>querySelector()：只能选择一个元素</li><li>querySelectorAll()：可以选择所有符合条件的元素</li></ul><p>可以向其中传入选择器(任何CSS支持的选择器)，从而来选择<code>DOM</code>元素，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用子代选择器选择span元素</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"li&gt;span"</span>).style.color = <span class="string">"red"</span>;</span><br></pre></td></tr></table></figure><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><p>有时候我们需要为某个标签添加或者移除类样式，HTML5为我们提供了API接口</p><ul><li>classList.add()：为<code>DOM</code>元素添加指定的类样式</li><li>classList.remove()：为<code>DOM</code>元素移除指定的类样式</li><li>classList.toggle()：切换，意思即如果<code>DOM</code>元素有这个类样式，则移除这个类样式，如果没有这个类样式，这添加这个类样式</li><li>classList.contains()：判断该<code>DOM</code>元素是否包含这个类样式，包含则返回<code>true</code>，否则返回<code>false</code>。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.active</span> &#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: darkred;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"add"</span>&gt;</span>添加类名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"remove"</span>&gt;</span>移除类名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"toggle"</span>&gt;</span>切换类名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"contains"</span>&gt;</span>是否包含类名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">".add"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).classList.add(<span class="string">"active"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">".remove"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).classList.remove(<span class="string">"active"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">".toggle"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).classList.toggle(<span class="string">"active"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">".contains"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).classList.contains(<span class="string">"active"</span>));</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html512.gif"/></center><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>HTML5规定自定义属性需要以<code>data-</code>开头，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面自定义了一个叫<code>test</code>的属性，我们可以通过<code>DOM</code>元素的<code>dataset</code>来访问或者修改自定义属性的值，有两种方式</p><ul><li>dataset.属性名</li><li>dataset[“属性名”]</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).dataset.test);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).dataset[<span class="string">"test"</span>] = <span class="string">"two"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果属性名之间使用<code>-</code>之间连接，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test-name</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么使用<code>dataset</code>访问或修改时要使用驼峰命名法获取，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).dataset.testName);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).dataset[<span class="string">"testName"</span>] = <span class="string">"two"</span>;</span><br></pre></td></tr></table></figure><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p><code>FileReader</code>是用来读取上传的文件的，它有3个读取的方法</p><ul><li>readAsText()：读取文本文件，返回文本字符串(utf-8)</li><li>readAsBinaryString()：读取任意文件，返回二进制文件</li><li>readAsDataURL()：读取任意文件，得到包含一个data:URL格式的字符串(base64编码)，以表示所读取文件的内容</li></ul><p>上面三个方法读取的内容都会放在FileReader对象的result属性中。</p><p>现在演示一个案例，选择上传的图片，在上传之后希望有预览的效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"800"</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//获得input DOM元素</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> input = <span class="built_in">document</span>.querySelector(<span class="string">"input"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//获得img DOM元素</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> image = <span class="built_in">document</span>.querySelector(<span class="string">"img"</span>);</span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="comment">//当input发生改变时即有文件上传时触发该事件</span></span></span><br><span class="line"><span class="actionscript">        input.onchange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//获得上传的文件对象</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> file = input.files[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//获得FileReader对象</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//使用FileReader读取该图片，得到一个base64格式的编码</span></span></span><br><span class="line">            reader.readAsDataURL(file);</span><br><span class="line">            </span><br><span class="line"><span class="actionscript">            <span class="comment">//reader读取完毕后触发该事件</span></span></span><br><span class="line"><span class="actionscript">            reader.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//将读取到的base64编码格式的URL赋值给img标签的src属性</span></span></span><br><span class="line">                image.src = reader.result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html513.gif"/></center><p>上面的代码中，我们用到了<code>FileReader</code>对象的<code>onload</code>事件，这里列出<code>FileReader</code>提供的事件</p><ul><li>onabort：中断时触发</li><li>onerror：出错时触发</li><li>onload：文件读取成功完成时触发</li><li>onloadend：读取完成触发，无论成功或失败</li><li>onloadstart：读取开始时触发</li><li>onprogress：在读取过程中持续触发</li></ul><h3 id="获取网络状态"><a href="#获取网络状态" class="headerlink" title="获取网络状态"></a>获取网络状态</h3><p>HTML5提供了有关网络状态的API，使用<code>window.navigator.onLine</code>可以获取当前的网络状态，返回一个布尔值。除此之外，还提供了两个网络事件</p><ul><li>ononline()：连上网络的时候触发</li><li>onoffline()：断开网络的时候触发</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.ononline = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"online"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onoffline = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"offline"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html514.gif"/></center><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以<code>document.cookie</code>来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案，使用<code>sessionStorage</code>和<code>localStorage</code>存储数据。</p><p><code>sessionStorage</code>的大小大约为5M左右，它的生命周期为当前页面，即当关闭当前页面时，存储在本地的数据会被清除。并且不同页面之间的<code>sessionStorage</code>是独立的，不能互相访问。<code>sessionStorage</code>的方法有</p><ul><li>setItem(key, value)：存储键值对</li><li>getItem(key)：根据key获取对应的value</li><li>removeItem(key)：删除key所对应的键值对</li><li>clear()：清除<code>sessionStorage</code>本地缓存</li></ul><p><code>localStorage</code>的大小为20M左右，它的生命周期为当前浏览器。关闭浏览器不会清除数据，数据存储在硬盘上，只能手动清除。<code>localStorage</code>的方法同<code>sessionStorage</code>。</p>]]></content>
    
    <summary type="html">
    
      讲解HTML5的新增内容，包括语义化标签，表单新属性，和新增的API
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="HTML" scheme="https://lastknightcoder.gitee.io/categories/Web/HTML/"/>
    
    
      <category term="HTML5" scheme="https://lastknightcoder.gitee.io/tags/HTML5/"/>
    
      <category term="基础知识" scheme="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Maven安装及配置</title>
    <link href="https://lastknightcoder.gitee.io/Maven%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>https://lastknightcoder.gitee.io/Maven%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven</a></li></ol><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven01.png"><ol start="2"><li>解压文件夹</li></ol><p>将下载好的压缩包解压到一个不含中文路径的目录下，如我的解压路径为<code>G:\apache-maven-3.6.2</code>，解压后的文件目录应如下所示</p><a id="more"></a><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven02.png"><ol start="3"><li>配置环境变量</li></ol><p>新建环境变量MAVEN_HOME，内容为Maven的解压目录</p><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven03.png"><p>编辑Path变量，内容如下</p><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven04.png"><ol start="4"><li>配置setting.xml</li></ol><p>打开解压目录下的conf/setting.xml，设置本地仓库的路径</p><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven05.png"><ol start="5"><li>配置IDEA</li></ol><p>打开IDEA并打开setting，搜索maven如下所示</p><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven06.png"><ol start="6"><li>新建Maven项目</li></ol><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven07.png"><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven08.png"><p>标准的Maven目录结构应该是这样的</p><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven10.png"><p>在添加依赖包的坐标后，记得进行Update</p><img src="https://raw.githubusercontent.com/LastKnightCoder/img/master/Maven09.png">]]></content>
    
    <summary type="html">
    
      记录第一次安装Maven的过程，以便以后参考
    
    </summary>
    
    
      <category term="软件安装及配置" scheme="https://lastknightcoder.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="Maven" scheme="https://lastknightcoder.gitee.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="https://lastknightcoder.gitee.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://lastknightcoder.gitee.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2019-10-01T16:00:00.000Z</published>
    <updated>2019-10-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期在学习排序算法，决定将自己的学习过程记录下来，一是为了自己能够方便的复习，另一个是将这个知识分享给大家。我将使用Java语言实现下列排序算法</p><ul><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li><li>堆排序</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了对实现的算法进行测试，我们准备一个工具类Helper，里面包括我们由于测试算法正确与否的方法以及性能测试的代码，包括交换数组中的两个元素(这个操作在排序时经常用到，所以抽象出一个方法)，还有产生一个指定容量和范围的随机数组，还有判断数组是否有序的函数以及性能测试的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换arr[i]和arr[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//产生一个范围在rangeL-rangeR，容量为n的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR) &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(rangeR - rangeL + <span class="number">1</span>) + rangeL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断数组是否有序(从小到大)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试排序需要的时间 需要传入一个函数接口Sort</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">testTime</span><span class="params">(<span class="keyword">int</span>[] arr, Sort sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        sort.sort(arr);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中testTime需要传入一个函数式接口Sort，该接口定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在调用该方法时，只要将我们的排序算法的方法引用传入即可。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>为了描述的精确性，我们把数组分为两部分，一部分是已经排好序的区域，一部分是未排序的区域</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort01.png"/></center><p>选择排序的策略就是在未排序的区域找出最小元素的位置，然后将它交换到未排序区域的最前方，然后已排序区域向前扩大一位，然后接着上面策略，直至未排序的区域为空，排序结束。下面以一个例子进行说明，我们默认蓝色区域代表已排序区域，白色区域代表未排序区域</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort02.png"/></center><p>代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Helper.swap(arr,minIndex,i);</span><br><span class="line">            minIndex = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对100000个数进行排序</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">        <span class="comment">//产生随机数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Helper.generateArray(n, <span class="number">0</span>, n);</span><br><span class="line">        <span class="comment">//传入排序算法的引用，得到排序所需时间</span></span><br><span class="line">        <span class="keyword">double</span> time = Helper.testTime(arr,SelectionSort::sort);</span><br><span class="line">        <span class="comment">//确定算法是否排好序</span></span><br><span class="line">        System.out.println(<span class="string">"isSorted: "</span> + Helper.isSorted(arr));</span><br><span class="line">        <span class="comment">//打印排序所需时间</span></span><br><span class="line">        System.out.println(time + <span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">7.319637673</span>s</span><br></pre></td></tr></table></figure><p>可见算法已经排好序，并且选择排序对100000个数据排序所需的时间为7.32s左右。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序就像是你在打斗地主，当你摸牌时你对牌的排序。向上面一样，我们将数组分为已排序的部分和未排序的部分，以排序的部分就是你已经排好序的牌，现在你又摸到了一张牌，那么你是不是会将这张牌与排好序的牌进行比较，插入到合适的位置，然后继续摸下一张牌，然后又进行插入排序，直到牌已经摸完了(未排序的部分为空)，那么你就已经拍好序了，下面看一个例子</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort03.png"/></center><p>代码为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//i = 1开始，因为默认第一张牌是排好序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//如果后面比前面小，进行交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    Helper.swap(arr,j - <span class="number">1</span>, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果后面比前面大，结束交换</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Helper.generateArray(n, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">double</span> time = Helper.testTime(arr,InsertSort::sort);</span><br><span class="line">        System.out.println(<span class="string">"isSorted: "</span> + Helper.isSorted(arr));</span><br><span class="line">        System.out.println(time + <span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">8.863959818</span>s</span><br></pre></td></tr></table></figure><p>这表明插入排序对100000个数据排序所需的时间为8.86s左右。它的速度比选择排序还要慢一些，这时因为插入排序中含有大量的交换操作，如果我们将上面的交换操作替换为赋值操作</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort06.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[i]; <span class="comment">//保存要插入的元素</span></span><br><span class="line">        <span class="keyword">int</span> j; <span class="comment">//记录要插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; e) &#123;</span><br><span class="line">                <span class="comment">//向后移动</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时需要的时间为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">2.293106947</span>s</span><br></pre></td></tr></table></figure><p>并且对于近乎有序的数组，插入排序的速度非常的快，甚至比后面要介绍的O(NlogN)的速度还要快。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是对插入排序的改进。既然是改进，那么我们就要知道插入排序有什么问题：如果有一个很小的数在数组的后方，那么这个数就会进行很长时间的交换才能插入到合适的位置，这明显是一个比较慢的过程</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort04.png"/></center><p>而希尔排序将解决这一个问题，希尔排序首先将数组分组，比如</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort05.png"/></center><p>上面的示例中，我们从每隔3个一组到每隔2个一组最后每隔1个一组，我们把上面的”3,2,1”称之为增幅序列h，不同的递增序列对算法的性能也有影响，有很多的论文研究了不同的递增序列，但都无法证明某个递增序列是最好的，下面的程序考虑使用”1, 4, 13, …”这个递增序列(h = 1, h = 3 * h + 1)，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 1 4 13 40 121 ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// h = 1的时候就是对整个数组进行插入排序</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//每隔h个元素(将数组分成了h组)进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; h - <span class="number">1</span>; j -= h) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j - h] &gt; arr[j]) &#123;</span><br><span class="line">                        Helper.swap(arr, j, j-h);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = Helper.generateArray(n, <span class="number">0</span>, n);</span><br><span class="line">            time += Helper.testTime(arr, ShellSort::sort);</span><br><span class="line">            System.out.println(<span class="string">"isSorted: "</span> + Helper.isSorted(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        time = time / m;</span><br><span class="line">        System.out.println(time + <span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">0.0292856418</span>s</span><br></pre></td></tr></table></figure><p>希尔排序10次平均所需的时间只有0.03s，与选择排序和插入排序不是一个等级上的。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><p>归并排序的思想是将数组一分为二，然后对左、右两边的数组进行排序，然后将左右两边的已经有序数组进行融合成一个有序的数组，而左右两边的排序问题也可以按照上面的思想进行，直到数组只剩下一个元素，我们认为已经是有序的了，然后向上进行融合</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort10.png"/></center><p>下面的代码简要的简述了上面的过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mergeSort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个元素，可认为是有序的了</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对左右两边进行排序</span></span><br><span class="line">        mergeSort(arr,left,mid);</span><br><span class="line">        mergeSort(arr,mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//融合左右两边的数组</span></span><br><span class="line">        merge(arr,left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的关键是如何融合左右两个有序的数组为一个有序的数组，来看下面这个例子</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort11.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要融合的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左右数组的首部</span></span><br><span class="line">    <span class="keyword">int</span> p1 = left;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//要融合数组的首部</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果两个数组都没有遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果p2遍历完毕了，将p1中剩下的元素复制到融合的数组中</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将融合的数组按序赋值给我们要排序的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">        arr[j] = help[j - left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下10次平均所需时间为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">0.0334043239</span>s</span><br></pre></td></tr></table></figure><p>归并排序是O(NlogN)级别的算法，比选择排序和插入排序要快很多。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>上面我们在对左右两个数组排好序之后，直接进行了merge操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mergeSort(arr,left,mid);</span><br><span class="line">mergeSort(arr,mid + <span class="number">1</span>, right);</span><br><span class="line">merge(arr,left,right);</span><br></pre></td></tr></table></figure><p>但是如果考虑到如下情况</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort12.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mergeSort(arr,left,mid);</span><br><span class="line">mergeSort(arr,mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">    merge(arr,left,right);</span><br></pre></td></tr></table></figure><p>我们还可以进行优化，在上面我们提到，插入排序在数组近乎有序的情况下排序的速度非常的快，所以我们可以考虑当数组被划分到小于一定的规模(当数组小于一定规模时，近乎有序的概率很大)时我们不在向下划分，而是转而用插入排序，所以我们在Helper中添加一个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[i]; <span class="comment">//保存要插入的元素</span></span><br><span class="line">        <span class="keyword">int</span> j; <span class="comment">//记录要插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; l; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; e) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法与插入排序的算法很相似，不过规定了对什么范围的数组进行排序，所以归并排序的算法可以修改如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当数组小于15时，使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; <span class="number">15</span>) &#123;</span><br><span class="line">        Helper.insertSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr,left,mid);</span><br><span class="line">    mergeSort(arr,mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">        merge(arr,left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试10次平均所需时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">0.028484280499999997</span>s</span><br></pre></td></tr></table></figure><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>我们在上面使用的归并排序是自顶向下使用递归来完成的，但是我们不一定要自顶向下的完成这个排序过程，而是可以自底向上进行排序，首先将底层的序拍好，然后进行merge一路向上完成排序</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort13.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每轮2*sz个元素，为什么不直接sz = 2, 因为我们后面传入mid是要/2，所以这里的粒度就为sz</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt;= arr.length; sz += sz) &#123;</span><br><span class="line">        <span class="comment">//mid &lt;= arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; arr.length; i += (sz + sz)) &#123;</span><br><span class="line">            <span class="comment">//小数组使用插入排序</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * sz &lt; <span class="number">15</span>) &#123;</span><br><span class="line">                Helper.insertSort(arr,i, i + sz + sz - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有当右边最小比左边最大还大时才需要merge</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i + sz -<span class="number">1</span>] &gt; arr[Math.min(i + sz, arr.length - <span class="number">1</span>)]) <span class="comment">//防止越界</span></span><br><span class="line">                merge(arr, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, arr.length - <span class="number">1</span>)); <span class="comment">//防止越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = left;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">        arr[j] = help[j - left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能发现这次的merge需要自己传入mid值，而不是自己计算。可以思考一下为什么? 现在我们测试一下自底向上排序所需要的时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">0.031012182500000006</span>s</span><br></pre></td></tr></table></figure><p>自底向上的排序会比自顶向下的排序慢，但是自底向上的排序有一个非常重要的特点，它没有利用数组随机访问的特点，即数组通过下标对元素访问(插入排序中有，但是你可以不优化这里)，这意味着我们可以对链表使用自底向上的排序。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>在看快速排序算法前我们先来看一个问题，给定一个数，要求数组左边的数都小于等于这个数，数组右边的数都大于这个数，请问这个算法怎么写。首先我们将数组标记为小于等于区和大于区，并用less和more标记区域的范围，所有index &lt;= less的元素都小于指定数，所有index &gt;= more的都大于指定数，下图将讲解具体的算法</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort14.png"/></center><p>上面的过程我们称为partition，对应的代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = L;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt;= e) &#123;</span><br><span class="line">            <span class="comment">//如果当前元素小于指定元素 less和cur向前移动</span></span><br><span class="line">            less++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; e) &#123;</span><br><span class="line">            Helper.swap(arr,--more,cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回两个数组的分界处</span></span><br><span class="line">    <span class="keyword">return</span> less;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么快速排序的思想就是选定一个数(一般我们选择要排序范围内的最后一个数arr[R])，要求左边的数比这个数小(或等于)，右边的数比这个数大。然后又接着对左右两边的数进行上述的分割(partition)，直至分割后的数组只剩下一个元素，可认为是有序的，这时数组就是有序的了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当数组较小时，使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &lt; <span class="number">15</span>) &#123;</span><br><span class="line">            Helper.insertSort(arr, l, r);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">            quickSort(arr, l, p);</span><br><span class="line">            quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = L;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &lt;= arr[R]) &#123;</span><br><span class="line">                less++;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; arr[R]) &#123;</span><br><span class="line">                Helper.swap(arr,--more,cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> less;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试此时10次平均所需的时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">0.023240137399999996</span>s</span><br></pre></td></tr></table></figure><h3 id="随机快排"><a href="#随机快排" class="headerlink" title="随机快排"></a>随机快排</h3><p>但是此时有一个问题，如果此时数组是近乎有序的，那么我们根据最后一个元素划分元素会划分出左右两边的数组失衡</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort15.png"/></center><p>所以我们不能选择最后一个元素，而是选择一个随机的元素，我们只要在上面的程序中加入下面的一行代码即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="comment">//随机一个下标和最后一个元素交换</span></span><br><span class="line">    Helper.swap(arr, (<span class="keyword">int</span>)Math.random() * (r - l + <span class="number">1</span>) + l, r); <span class="comment">// 随机快排</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">    quickSort(arr, l, p);</span><br><span class="line">    quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三路快排"><a href="#三路快排" class="headerlink" title="三路快排"></a>三路快排</h3><p>这时需要考虑这么一种情况，如果数组中有十分多的重复元素，那么就会有元素重复的子数组，这时应该就不应该排序了，但是我们的算法还是会把数组继续切分为更小的数组进行排序，这就有很大的改进潜力。所以我们考虑我们的partition算法不再划分为两部分，而是划分为三部分，小于，等于和大于三个区域</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/imgsort16.png"/></center><p>所以我们修改上面的排序算法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">15</span>) &#123;</span><br><span class="line">        Helper.insertSort(arr, l, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        Helper.swap(arr, (<span class="keyword">int</span>)Math.random() * (r - l + <span class="number">1</span>) + l, r); <span class="comment">// 随机快排</span></span><br><span class="line">        <span class="comment">//p得到的是等于区的范围</span></span><br><span class="line">        <span class="keyword">int</span>[] p = partition(arr,l,r);</span><br><span class="line">        <span class="comment">//对等于区不用排序</span></span><br><span class="line">        quickSort(arr,l,p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr,p[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = R;</span><br><span class="line">    <span class="keyword">int</span> cur = L;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; arr[R]) &#123;</span><br><span class="line">            <span class="comment">//与less的前一个元素进行交换 并且less和cur向前移动</span></span><br><span class="line">            Helper.swap(arr,++less,cur++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; arr[R]) &#123;</span><br><span class="line">            <span class="comment">//与more的后一个元素进行交换 并且more向后移动，并且cur和less都不移动</span></span><br><span class="line">            Helper.swap(arr,--more,cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果等于，将cur向前移动即可</span></span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后将最后一个元素与more位置的元素进行交换</span></span><br><span class="line">    Helper.swap(arr,R,more);</span><br><span class="line">    <span class="comment">//返回等于区的左右下标</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆的有关知识可以参考<a href="https://lastknightcoder.gitee.io//%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--Java%E6%8F%8F%E8%BF%B0/">数据结构–Java描述</a>中优先队列与堆的内容，如果你已经仔细的阅读了话，相比你已经熟悉了堆的性质了，那么下面就直接上代码了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数组变成堆结构</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            heapInsert(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Helper.swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">            heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index-<span class="number">1</span>)/<span class="number">2</span>]) &#123;</span><br><span class="line">            Helper.swap(arr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123;</span><br><span class="line">            <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//假设左更大</span></span><br><span class="line">            <span class="keyword">int</span> larger = left;</span><br><span class="line">            <span class="comment">//如果右比左大 改变larger为右</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[left]) &#123;</span><br><span class="line">                larger = right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果父比左右子节点都大，说明还是堆，直接退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (arr[larger] &lt; arr[index]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不是，那么就和比较大的交换交换</span></span><br><span class="line">            Helper.swap(arr,larger,index);</span><br><span class="line">            index = larger;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = Helper.generateArray(n, <span class="number">0</span>, n);</span><br><span class="line">            time += Helper.testTime(arr, HeapSort::sort);</span><br><span class="line">            System.out.println(<span class="string">"isSorted: "</span> + Helper.isSorted(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        time = time / m;</span><br><span class="line">        System.out.println(time + <span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试10次平均所需时间为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSorted: <span class="keyword">true</span></span><br><span class="line"><span class="number">0.060118443099999995</span>s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      讲解常见的排序算法，并用Java实现
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://lastknightcoder.gitee.io/categories/Algorithms/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="排序" scheme="https://lastknightcoder.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--Java描述</title>
    <link href="https://lastknightcoder.gitee.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--Java%E6%8F%8F%E8%BF%B0/"/>
    <id>https://lastknightcoder.gitee.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--Java%E6%8F%8F%E8%BF%B0/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-09-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是为了记录自己在学习数据结构时的笔记，会对常见的数据结构做基本的介绍以及使用Java语言进行实现。包括</p><ul><li>动态数组</li><li>栈</li><li>队列</li><li>链表</li><li>二分搜索树</li><li>优先队列和堆</li><li>线段树</li><li><code>Trie</code></li><li>并查集</li><li><code>AVL</code> 树</li><li>红黑树</li><li>哈希表</li></ul><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>数组是一种根据下标操作的数据结构，它的查询速度很快，但是它有缺点，那就是数组的容量一旦在创建时确定，就不能进行更改，所以为了克服这一缺点，我们实现一个自己的数组，并除此以外，还会实现一些方法，包括以下</p><ul><li><code>add(int index, E e)</code><ul><li>向指定 index 添加元素 e</li></ul></li><li><code>get(int index)</code><ul><li>获得指定 index 的元素</li></ul></li><li><code>remove(int index)</code><ul><li>删除指定 index 的元素并返回该元素</li></ul></li><li><code>set(int index, E e)</code><ul><li>更改 index 处的元素为 e</li></ul></li><li><code>getSize()</code><ul><li>返回数组中元素的个数</li></ul></li><li><code>contains(E e)</code><ul><li>查询数组是否包含元素 e</li></ul></li><li><code>isEmpty()</code><ul><li>查看数组是否为空(是否有元素)</li></ul></li><li><code>find(E e)</code><ul><li>返回数组中元素 e 第一次出现的 index，若没有元素 e，则返回 -1</li></ul></li></ul><p>新建一个 Array 类，它含有两个私有成员变量</p><ul><li><code>E[] data</code><ul><li>用以保存数据</li></ul></li><li><code>int size</code><ul><li>用以记录数组中元素的个数</li></ul></li></ul><p>除此以外还有两个构造方法</p><ul><li><code>Array(int capacity)</code><ul><li>设定数组的容量</li></ul></li><li><code>Array()</code><ul><li>容量默认为 10</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来实现上面提到的方法。</p><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>首先来实现 <code>getSize()</code> 方法，这个是返回数组元素的个数的，我们直接返回 <code>size</code> 即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isEmpty()</code> 是为了查看数组中是否还有元素，如果 <code>size</code> 为 0 的话说明数组为空，所以我们返回 <code>size == 0</code> 即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来实现 <code>add(int index, E e)</code> 方法，该方法的实现是将 <code>index</code> 后面的元素都向后移动一位，然后在 <code>index</code> 处插入元素 <code>e</code></p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr01.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对inex进行验证 如果不符合规范则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将元素向后移动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">        data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在index处插入元素e</span></span><br><span class="line">    data[index] = e;</span><br><span class="line">    <span class="comment">//数组中元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个方法，我们可以很快的实现 <code>addFirst(E e)</code> 和 <code>addLast(E e)</code> 方法，这两个方法一个是在数组头添加元素，一个是在数组的末尾添加一个元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在index = size处添加元素 即在数组末尾添加一个元素</span></span><br><span class="line">    add(size,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在index = 0处添加一个元素 即在数组头添加一个元素</span></span><br><span class="line">    add(<span class="number">0</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来实现 <code>remove(int index)</code> 方法，该方法是删除 <code>index</code> 处的元素，并将该元素返回，以添加的操作相反，删除是将后面的元素向前移动，覆盖掉 <code>index</code> 处的元素即可删除</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr02.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得index处的元素用以返回</span></span><br><span class="line">    E e = data[index];</span><br><span class="line">    <span class="comment">//将元素从后向前移一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组中元素个数-1</span></span><br><span class="line">    size --;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，根据这个方法我们可以快速的实现 <code>removeLast()</code> 和 <code>removeFirst()</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以添加一个删除指定元素的方法 <code>removeElement(E e)</code>，我们会遍历数组，如果发现有元素等于该元素，那么删除该元素并退出方法，所以这个方法只删除第一个元素 <code>e</code>，并不是数组所有的元素 <code>e</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//如果找到等于该元素的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e.equals(data[i])) &#123;</span><br><span class="line">            <span class="comment">//删除该元素</span></span><br><span class="line">            remove(i);</span><br><span class="line">            <span class="comment">//退出方法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现 <code>contains(E e)</code> 方法，这个方法的思路同删除指定元素相似，遍历数组，如果找到元素与指定元素相同，那么返回 <code>true</code>，如果遍历完数组还没有找到与之相等的元素，那么返回 <code>false</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//如果找到元素，那么返回true</span></span><br><span class="line">        <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历完所有数组没有找到，那么返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find(E e)</code> 方法的实现也是遍历数组，如果找到了元素，那么返回下标，如果遍历完数组都没有找到，那么返回 <code>-1</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//找到元素则返回下标</span></span><br><span class="line">        <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历完数组都没有找到，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现 <code>get(int index)</code> 和 <code>set(int index, E e)</code>，这两个方法的实现及其简单，直接上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    data[index] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以根据 <code>get</code> 方法实现 <code>getLast()</code>和 <code>getFirst()</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经实现了 <code>API</code> 中提到的所有的方法，但是我们还是没有解决数组容量固定的问题，为了解决这个问题，我们需要实现一个 <code>resize(int newCapacity)</code>，它的作用是改变数组的容量大小，这样当数组的容量不足时，我们调用该方法就可以将数组进行扩容，或者当数组中有大量空间空闲时，我们可以缩小数组的容量，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新容量的数组</span></span><br><span class="line">    E[] temp = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    <span class="comment">//将数组中的数据全部放入新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        temp[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变数组指针指向</span></span><br><span class="line">    data = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们改变 <code>add(int index, E e)和remove(int index)</code> 方法，我们会在添加元素和删除元素时检查数组的容量，以便对数组进行扩容或者缩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果数组容量满了 那么将数组的容量扩为原来的两倍</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">        resize(data.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">        data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    E e = data[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    <span class="comment">//如果数组中的元素个数为数组容量的1/4，那么容量变为原来的1/2</span></span><br><span class="line">    <span class="comment">//思考一下为什么是1/4 提示：复杂度震荡</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length/<span class="number">4</span>) &#123;</span><br><span class="line">        resize(data.length/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便的打印 <code>Array</code> 类，我们重写 <code>toString()</code> 方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    str.append(<span class="string">"size "</span> + size);</span><br><span class="line">    str.append(<span class="string">" capacity "</span> + data.length);</span><br><span class="line">    str.append(<span class="string">"\n["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">            str.append(data[i].toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.append(data[i].toString() + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们已经完全实现了 <code>Array</code>，它的容量没有限制，并且提供了很多的方法供用户调用，我们将使用该类来实现其它的基本的数据结构。下面贴出完整的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(size,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">0</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize(data.length * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">            data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(size -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        E e = data[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            data[i] = data[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        size --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == data.length/<span class="number">4</span>) &#123;</span><br><span class="line">            resize(data.length/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.equals(data[i])) &#123;</span><br><span class="line">                remove(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        E[] temp = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            temp[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        str.append(<span class="string">"size "</span> + size);</span><br><span class="line">        str.append(<span class="string">" capacity "</span> + data.length);</span><br><span class="line">        str.append(<span class="string">"\n["</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                str.append(data[i].toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.append(data[i].toString() + <span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str.append(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种先进后出的结构，比如你放书会把书放在最上面，最先放的书在最下面，而你拿书却是从最上面拿，最后放的最先拿到，栈正是怎么一种结构，我们规定最上面的位置叫做栈顶，我们向栈中添加元素是添加到栈顶，向栈中取出元素是从栈顶取出的，我们先来定义一个 <code>Stack</code> 接口，里面规定了一个栈包含的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//向栈中压入一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//将栈顶元素弹出</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得栈中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将使用上面实现的 <code>Array</code> 来实现一个 <code>ArrayStack</code>，我们把数组的最后位置定义为栈顶</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        data.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">"Stack: "</span>);</span><br><span class="line">        res.append(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.getSize(); i++) &#123;</span><br><span class="line">            res.append(data.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != data.getSize()-<span class="number">1</span>) &#123;</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">"] top"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码极其的简单，只要仔细的阅读就可以完全的理解，这里不多做解释。</p><p>下面介绍一个有关于栈的题目，此题来自于<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">LeetCode第20题</a></p><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p></blockquote><p>这道题的解题思路是，如果遇到左括号<code>&#39;(&#39;, &#39;[&#39;, &#39;{&#39;</code>，那么将左括号压入栈中，如果遇到右括号，那么将栈顶的左括号弹出，判断两个括号是否匹配，如果不匹配返回 <code>fasle</code>，如果匹配进行下一轮，最后如果字符串遍历完毕，如果栈为空说明匹配成功，如果栈不为空，所以左边的括号多匹配失败，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个空栈</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">//如果是左括号，则压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是右括号 先判断栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获得栈顶的左括号</span></span><br><span class="line">                <span class="keyword">char</span> charTop = stack.pop();</span><br><span class="line">                <span class="comment">//下面三种皆为不匹配的情况</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; charTop != <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">']'</span> &amp;&amp; charTop != <span class="string">'['</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'&#125;'</span> &amp;&amp; charTop != <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里不能直接返回true 要根据栈是否为空决定返回值</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出的结构，假设你在排队，那么最先排队的人最先得到服务。我们只能从队尾添加元素，从队首取出元素。老规矩，我们首先规定一下队列 <code>Queue</code> 的 <code>API</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//向队列中添加一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//从队列中取出一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得队首的元素</span></span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取队列中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组队列"><a href="#数组队列" class="headerlink" title="数组队列"></a>数组队列</h3><p> 现在我们将使用动态数组 <code>Array</code> 类来实现队列，实现的逻辑也十分的简单，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">"Queue: "</span>);</span><br><span class="line">        res.append(<span class="string">"front ["</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.getSize(); i++) &#123;</span><br><span class="line">            res.append(array.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != array.getSize()-<span class="number">1</span>) &#123;</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">"] tail"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面我们的 <code>dequeue</code> 操作是调用了动态数组的 <code>removeFirst</code> 操作，这个操作需要遍历整个数组将元素向前移动，所以该操作是 <code>O(n)</code> 的。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面队列的 <code>dequeue</code> 操作是 <code>O(n)</code> 级别的，这是因为上面会将数组整体向前移一位，但是如果我们不这么做，而是增加一个变量 <code>front</code> 来记录队首的位置，这样我们只要将 <code>front</code> 向前移一位即可，这样的操作就是 <code>O(1)</code> 级别的</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr03.png"/></center><p>这样做的同时，我们发现，如果当 <code>tail</code> 来到数组的末尾，按道理应该将数组进行扩容，但是 <code>front</code> 前面还有空间</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr04.png"/></center><p>这个时候我们应当将 <code>tail</code> 移动到数组头去</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr05.png"/></center><p>这时 <code>tail</code> 的计算公式不再是简单的 <code>tail = tail + 1</code>，而是 <code>tail = (tail + 1) % data.length</code>，如果不理解这个式子，就想象一下时钟，11 点向前一步就是 12 点，也可以称为是 0 点，这个时候时钟的计算公式为 <code>(11 + 1) % 12</code>。因为这种循环的特性，我们把这种实现方式称为循环队列。这次我们实现队列不在使用上面的动态数组，有了上面实现栈和队列的经验，想必可以容易理解下面的代码(在关键的步骤给予注释)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="comment">//队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//底层实现的数组</span></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认容量为10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断数组是不是满了，如果是那么就进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * data.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向队尾添加元素</span></span><br><span class="line">        data[tail] = e;</span><br><span class="line">        <span class="comment">//tail向后移动 不是简单的+1 上面已有解释</span></span><br><span class="line">        tail = (tail +<span class="number">1</span>) % data.length;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组伸缩操作，已接触过</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        E[] temp = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//这里我们将队列的头对应到新数组的开头</span></span><br><span class="line">            temp[i] = data[(front + i)%data.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新记录front和tail的位置</span></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        tail = size;</span><br><span class="line">        data = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果队列为空，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得出队的元素</span></span><br><span class="line">        E e = data[front];</span><br><span class="line">        data[front] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//front向前移动(带循环)</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % data.length;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩容操作，不做解释</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.append(<span class="string">"Queue: size "</span> + size);</span><br><span class="line">        str.append(<span class="string">" capacity "</span> + data.length);</span><br><span class="line">        str.append(<span class="string">"\nfront ["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                str.append(data[(front + i) % data.length].toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.append(data[(front + i) % data.length].toString() + <span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(<span class="string">"] tail"</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们得到的 <code>dequeue</code> 操作就是 <code>O(1)</code> 的了(严格的讲均摊复杂度为 <code>O(1)</code>，因为里面 <code>resize()</code> 复杂度是 <code>O(n)</code> 的)。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种非常重要的线性数据结构，我们在实现栈和队列时使用的是动态数组实现的，这个动态数组是针对用户而言是动态的，实际上底层是静态的，是通过 <code>resize()</code> 操作去解决容量问题的。而链表则是一种真正的动态数据结构，它是这么一种数据结构，我们把数据存储在一个节点(Node)中，一个节点一般包含两部分的内容，一个是存储的数据，一个是它要指向的下一个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个节点指向一个节点，所以最后看起来就像是一个链，我们把这种数据结构称为链表</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr06.png"/></center><p>最后一个节点的下一个节点为 <code>NULL</code>，表示后面没有节点了。它是一个真正的动态的数据结构，不需要处理容量的问题。但是它也有缺点，它没有数组那样快的查询能力，它要查询某个节点的数据，只能通过头结点一直寻找下来(后面我们将看到)，所以它的查询速度比数组慢。</p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><p>现在我们将实现这么一个结构，首先设计好节点类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//我们将Node设置为LinkedList的私有内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要想向链表中添加(或其他操作)元素，不可避免的要遍历链表(因为链表不能通过索引访问，只能通过前面的节点找到后面的节点)，而要遍历链表，我们就要将链表的头存储起来，这样才能遍历链表，我们将链表的头称为 <code>head</code></p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr07.png"/></center><p>同时我们使用变量 <code>size</code> 来记录链表中元素的个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//为了节省篇幅，Node类不再展示，下同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//链表中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们实现两个简单的方法 <code>getSize()</code> 和 <code>isEmpty()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="向链表头添加元素"><a href="#向链表头添加元素" class="headerlink" title="向链表头添加元素"></a>向链表头添加元素</h5><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr08.png"/></center><p>首先将要插入的新节点指向 <code>head</code>，然后将 <code>head</code> 设置为新节点，实现如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//体会一下这条语句的意思</span></span><br><span class="line">    head = <span class="keyword">new</span> Node(e,head);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在链表的中间添加一个元素"><a href="#在链表的中间添加一个元素" class="headerlink" title="在链表的中间添加一个元素"></a>在链表的中间添加一个元素</h5><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr09.png"/></center><p>比如现在往节点 1 后面插入一个元素，首先将新节点指向节点 2，然后节点 1 指向新节点，实现如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是头结点需要单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prev代表要插入位置的前一个节点</span></span><br><span class="line">    Node prev = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="向链表的尾部添加一个元素"><a href="#向链表的尾部添加一个元素" class="headerlink" title="向链表的尾部添加一个元素"></a>向链表的尾部添加一个元素</h5><p>直接复用上面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h4><p>我们在向链表中添加元素时，因为 <code>head</code> 前面没有节点，所以我们在添加元素时会对 <code>head</code> 进行单独的处理，为了不使 <code>head</code> 具有特殊性，我们在链表的最头部添加一个虚拟头结点，里面不存储元素，它的存在是为了使得操作链表方便</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr10.png"/></center><p>现在我们修改上面的 <code>head</code> 为 <code>dummyHead</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟结点</span></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里修改了</span></span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接调用add方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">0</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不需要对head进行单独的处理了</span></span><br><span class="line">        <span class="comment">//index - 1修改为了index</span></span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获得某个索引的值"><a href="#获得某个索引的值" class="headerlink" title="获得某个索引的值"></a>获得某个索引的值</h4><p>实现的思路同 <code>add</code> 很像，不过这里我们找的不是前一个节点，而是当前的节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cur代表当前节点</span></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (E) cur.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这个方法，我们可以很快的实现 <code>getFirst()</code> 和 <code>getLast()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新某个索引的值"><a href="#更新某个索引的值" class="headerlink" title="更新某个索引的值"></a>更新某个索引的值</h4><p>实现的思路完全是同 <code>get()</code> 方法，直接上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.e = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找链表是否存在元素e"><a href="#查找链表是否存在元素e" class="headerlink" title="查找链表是否存在元素e"></a>查找链表是否存在元素e</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从当前节点开始，一直遍历到最后一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node cur = dummyHead.next; cur != <span class="keyword">null</span>; cur = cur.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.e.equals(e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表中的元素"><a href="#删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素</h4><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr11.png"/></center><p>上图已详细说明了操作的步骤，这里直接贴上代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得要删除节点的前一个节点</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//图示的操作</span></span><br><span class="line">    Node delNode = prev.next;</span><br><span class="line">    prev.next = delNode.next;</span><br><span class="line">    delNode.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> (E) delNode.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的方法，可以很快的实现 <code>removeFirst()</code> 和 <code>removeLast()</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    </span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="comment">//你可以使用上面的for循环</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(<span class="string">"NULL"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">0</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (E) cur.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node cur = dummyHead.next; cur != <span class="keyword">null</span>; cur = cur.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.e.equals(e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node delNode = prev.next;</span><br><span class="line">        prev.next = delNode.next;</span><br><span class="line">        delNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (E) delNode.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">"NULL"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用链表实现栈"><a href="#使用链表实现栈" class="headerlink" title="使用链表实现栈"></a>使用链表实现栈</h3><p>由于链表的 <code>addFirst()</code> 和 <code>removeFirst()</code> 的操作都是 <code>O(1)</code>，所以我们使用链表头作为栈顶，具体的实现逻辑如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkedList.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">"Stack: top "</span>);</span><br><span class="line">        res.append(linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用链表实现队列"><a href="#使用链表实现队列" class="headerlink" title="使用链表实现队列"></a>使用链表实现队列</h3><p>我们之前使用数组实现队列，由于它的 <code>dequeue</code> 操作是 <code>O(n)</code> 级别的，所以我们使用 <code>front</code> 来标记队首，使用循环队列设计，同样的在链表中从链表尾部删除或增加元素都是 <code>O(n)</code> 级别的，为了解决这一个问题，我们决定在链表的尾部增加一个 <code>tail</code> 变量来标记，从而使得在尾部增加元素是 <code>O(1)</code> 级别的</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr12.png"/></center><p>另外考虑在尾部删除一个元素是 <code>O(1)</code> 的吗? 答案是不是。因为我们删除一个节点需要知道该节点的前一个节点，而知道 <code>tail</code> 节点是无法知道 <code>tail</code> 的前一个节点的，我们还是要遍历。所以我们在 <code>head</code> 端删除元素，在 <code>tail</code> 端添加元素，并且由于只涉及到头部和尾部的操作，所以我们也不需要添加虚拟头结点了</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr13.png"/></center><p>下面就是实现的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//队列为空时，tail和head都为null 添加元素后二者都指向第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">new</span> Node(e);</span><br><span class="line">            head = tail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> Node(e);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node delNode = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        delNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">//如果队列为空了，此时tail指向的是delNode，此时应该让tail为null</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) delNode.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (E) head.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        res.append(<span class="string">"Queue: front "</span>);</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">"NULL tail"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>什么是树结构</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr16.png"/></center><p>当你把上面的图倒过来看，就像是一棵树，所以我们把这种结构称为是树结构。那为什么要使用树结构，因为树结构在生活中很常见，如文件夹的组织方式，又或者如公司职能的组织方式，这些都是树结构的例子。为什么会使用树结构呢? 原因就是因为高效。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>同链表一样，它也是一种动态的数据结构，链表中的节点是指向一个节点，而二叉树是指向两个节点，我们把这两个节点称为左子树和右子树，又或者称为左孩子和右孩子。如下图表示的就是二叉树</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr16.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根节点<ul><li>最顶部的那个节点，如上图中 28 就是根节点</li><li>二叉树具有唯一的一个根节点</li></ul></li><li>叶子节点<ul><li>没有孩子的节点，如上图的最后一行都是叶子节点</li></ul></li><li>二叉树的每个节点最多有两个孩子，最多有一个父亲</li></ul><p>那是什么是二分搜索树，首先二分搜索树是二叉树，它满足这样的特点，对于每个节点</p><ul><li>大于左子树所有节点的值</li><li>小于右子树所有节点的值</li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr16.png"/></center><p>可以验算，上面的这棵树满足二分搜索树的性质，所以这棵树是二分搜索树。下面我们来实现二分搜索树中节点有关代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//树中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h4><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr17x.png"/></center><p>上图想必已经将添加元素的规则说的很详细了，所以这里直接上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add(root, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.left = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.right = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        add(node.left, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        add(node.right, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的代码还可以改进，因为我们在 <code>add(E e)</code> 中对 <code>root</code> 为根节点进行了单独的考虑，其实可以不再这里考虑，因为通过上面的规则知道，当一个节点为 <code>null</code> 时，不管它是根节点还是左右孩子，新加入的节点都将取代这个 <code>null</code> 节点</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr18.png"/></center><p>所以我们优化上面的代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里返回的Node所指的语义是node所代表的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果比根节点小，对左子树进行更新</span></span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果比根节点大，对右子树进行更新</span></span><br><span class="line">        node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等于的话什么都不做</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>对于某个数据结构的遍历就是将该数据结构中所有的元素都访问一遍，分为三类</p><ul><li>前序遍历<ul><li>父节点在访问左子树之前访问</li></ul></li><li>中序遍历<ul><li>父节点在访问左子树之后，在访问右子树之前访问</li></ul></li><li>后序遍历<ul><li>父节点在访问右子树之后访问</li></ul></li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr19.png"/></center><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先访问父节点</span></span><br><span class="line">    System.out.println(node);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历的结果是元素从小到大排序。</p><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的一个应用是内存释放，我们必须先把左右孩子的内存释放完才能释放该节点的内存。</p><h5 id="前序遍历的非递归实现"><a href="#前序遍历的非递归实现" class="headerlink" title="前序遍历的非递归实现"></a>前序遍历的非递归实现</h5><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr20.png"/></center><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非递归写法</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的Stack是上面自己写的Stack</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node top = stack.pop();</span><br><span class="line">        System.out.println(top);</span><br><span class="line">        <span class="keyword">if</span> (top.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(top.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(top.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr21.png"/></center><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">    queue.enqueue(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node front = queue.dequeue();</span><br><span class="line">        System.out.println(front);</span><br><span class="line">        <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.enqueue(front.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.enqueue(front.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>在二分搜索树中删除一个节点是比较复杂的，我们首先从最简单的情况开始，删除二分搜索树中的最小值和最大值，首先是如何找到最大值和最小值</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr22.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到了之后如何删除呢</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr23.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E ret = minimum();</span><br><span class="line">    root = removeMin(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E ret = maximum();</span><br><span class="line">    root = removeMax(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.right = removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在讲解如何删除二分搜搜数中的任意一个节点</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr24.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = remove(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);<span class="comment">//为什么这条语句必须在前面???</span></span><br><span class="line">            successor.left = node.left;</span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//size--; 在removeMin中已经维护size了</span></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = remove(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = remove(node.right, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说的是取右子树中的最小值，你也可以考虑取左子树中的最大值，道理都是一样的。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//树中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = add(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里返回语义指的的是node所代表的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果比根节点小，对左子树进行更新</span></span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果比根节点大，对右子树进行更新</span></span><br><span class="line">            node.right = add(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等于的话什么都不做</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非递归写法</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node top = stack.pop();</span><br><span class="line">            System.out.println(top);</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node front = queue.dequeue();</span><br><span class="line">            System.out.println(front);</span><br><span class="line">            <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.enqueue(front.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.enqueue(front.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E ret = minimum();</span><br><span class="line">        root = removeMin(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E ret = maximum();</span><br><span class="line">        root = removeMax(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.right = removeMax(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = remove(root, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node successor = minimum(node.right);</span><br><span class="line">                successor.right = removeMin(node.right);<span class="comment">//为什么这条语句必须在前面???</span></span><br><span class="line">                successor.left = node.left;</span><br><span class="line">                node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//size--; 在removeMin中已经维护size了</span></span><br><span class="line">                <span class="keyword">return</span> successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = remove(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = remove(node.right, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列和堆"><a href="#优先队列和堆" class="headerlink" title="优先队列和堆"></a>优先队列和堆</h2><p>普通队列：先进先出，就像是我们在银行办业务或者是在超市买东西，但是考虑在医院，有病人有突发情况，这个时候容不得他去排队挂号了，这时他的优先级是比较高的，所以他需要得到优先的处理，像这种队列中的元素具有优先级的队列，我们把它称之为优先队列。在游戏中我们也会设置优先攻击血量最低的怪或者距离最近的怪，这时候血量和距离就成为了判断优先级的标准；在操作系统的任务调度，我们为程序分配 CPU，内存等等资源，并不是先到先得的，也是根据程序的优先级来进行分配的。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr25.png"/></center><h3 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h3><p>这里的堆指的是二叉堆，它满足以下的性质</p><ul><li>二叉堆是一棵完全二叉树<ul><li>把元素顺序排列成树的形状</li></ul></li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr26.png"/></center><ul><li>堆中某个节点的值总是不大于其父亲节点的值(最大堆，相应也可以定义最小堆)</li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr27.png"/></center><p>如果我们使用数组去实现堆</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr28.png"/></center><p>上面的序号表示的是在数组中的下标，我们发现如果父节点的下标为 <code>i</code>，那么左孩子的下标就为 <code>2i + 1</code>，右孩子的下标为 <code>2i + 2</code>，所以可以很快的根据父节点的下标得到左右孩子的下标，如果知道左右孩子的下标 <code>i</code>，那么 <code>(i - 1)/2</code> 就可以得到父节点的下标(整数除法，小数部分会被舍去)。这个结论可以使用数学归纳法进行证明，但不是这里的重点，所以不多做阐述。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据左右孩子的下标获得父亲节点的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据父节点的下标获得左孩子的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据父节点的下标获得右孩子的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><h4 id="向堆中添加元素"><a href="#向堆中添加元素" class="headerlink" title="向堆中添加元素"></a>向堆中添加元素</h4><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr29.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size() || j &lt; <span class="number">0</span> || j &gt;= size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    E temp = data.get(i);</span><br><span class="line">    data.set(i, data.get(j));</span><br><span class="line">    data.set(j, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    data.addLast(e);</span><br><span class="line">    siftUp(data.getSize() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index不是根节点(根节点不要上浮了) 并且孩子比父亲大</span></span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span> &amp;&amp; data.get(index).compareTo(data.get(parent(index))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(index, parent(index));</span><br><span class="line">        index = parent(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向堆中取出最大元素"><a href="#向堆中取出最大元素" class="headerlink" title="向堆中取出最大元素"></a>向堆中取出最大元素</h4><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr30.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">findMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"堆为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E ret = findMax();</span><br><span class="line">    swap(<span class="number">0</span>,data.getSize() - <span class="number">1</span>);</span><br><span class="line">    data.removeLast();</span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有孩子时，下沉结束</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = leftChild(index);</span><br><span class="line">        <span class="keyword">int</span> rightIndex = rightChild(index);</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; size()) &#123;</span><br><span class="line">            max = data.get(max).compareTo(data.get(rightIndex)) &gt; <span class="number">0</span> ? max : rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大孩子比父节点小时，下沉结束</span></span><br><span class="line">        <span class="keyword">if</span> (data.get(max).compareTo(data.get(index)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(max,index);</span><br><span class="line">        index = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p><code>replace</code> 操作指的是从堆中取出元素，并向堆中添加一个元素，实现的方法为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr31.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出堆中的最大元素，并添加一个新元素e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    E ret = findMax();</span><br><span class="line">    data.set(<span class="number">0</span>,e);</span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h4><p><code>heapify</code> 是指将任意一个数组整理成堆的形状，</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr32.png"/></center><p>我们把这个方法做成一个构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">    data = <span class="keyword">new</span> Array&lt;&gt;(arr.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        data.addLast(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = parent(data.getSize() -<span class="number">1</span>); i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(arr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            data.addLast(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = parent(data.getSize() -<span class="number">1</span>); i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据左右孩子的下标获得父亲节点的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据父节点的下标获得左孩子的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据父节点的下标获得右孩子的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size() || j &lt; <span class="number">0</span> || j &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        E temp = data.get(i);</span><br><span class="line">        data.set(i, data.get(j));</span><br><span class="line">        data.set(j, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        data.addLast(e);</span><br><span class="line">        siftUp(data.getSize() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//index不是根节点(根节点不要上浮了) 并且孩子比父亲大</span></span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">0</span> &amp;&amp; data.get(index).compareTo(data.get(parent(index))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(index, parent(index));</span><br><span class="line">            index = parent(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">findMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"堆为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E ret = findMax();</span><br><span class="line">        swap(<span class="number">0</span>,data.getSize() - <span class="number">1</span>);</span><br><span class="line">        data.removeLast();</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没有孩子时，下沉结束</span></span><br><span class="line">        <span class="keyword">while</span> (leftChild(index) &lt; size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = leftChild(index);</span><br><span class="line">            <span class="keyword">int</span> rightIndex = rightChild(index);</span><br><span class="line">            <span class="keyword">if</span> (rightIndex &lt; size()) &#123;</span><br><span class="line">                max = data.get(max).compareTo(data.get(rightIndex)) &gt; <span class="number">0</span> ? max : rightIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最大孩子比父节点小时，下沉结束</span></span><br><span class="line">            <span class="keyword">if</span> (data.get(max).compareTo(data.get(index)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(max,index);</span><br><span class="line">            index = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出堆中的最大元素，并添加一个新元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        E ret = findMax();</span><br><span class="line"></span><br><span class="line">        data.set(<span class="number">0</span>,e);</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于堆的优先队列"><a href="#基于堆的优先队列" class="headerlink" title="基于堆的优先队列"></a>基于堆的优先队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        maxHeap.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.findMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>对于有一类的问题，我们主要关心的是线段(区间)，比如说查询一个区间 <code>[i, j]</code> 内的最大值，最小值等等。假设你有一个网站，你想查询某年(或某年以后)的用户访问量，消费最多的用户等等，这些都是在某个区间内进行查询，一般线段树的区间是固定的，不包含删除和添加的操作，只有查询和更新的操作</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr33.png"/></center><h3 id="线段树的表示"><a href="#线段树的表示" class="headerlink" title="线段树的表示"></a>线段树的表示</h3><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr34.png"/></center><p>现在如果假设有n个元素，用数组存储的话，需要多少空间呢</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr35.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] tree;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            data[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree = (E[]) <span class="keyword">new</span> Object[<span class="number">4</span> * data.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= data.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="创建线段树"><a href="#创建线段树" class="headerlink" title="创建线段树"></a>创建线段树</h4><p>下面就要根据数组来创建一棵线段树，我们的方法先创建下面的子线段树，然后由这些子线段树合并成大的线段树，以此类推</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr36.png"/></center><p>在合并左右子树的过程中，我们不能写死合并的过程，具体怎么合并应该由业务决定，由用户去决定如何合并，所以合并的过程我们写一个接口，具体的实现由用户去实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merger</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">merge</span><span class="params">(E a, E b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在构造方法中添加创建线段树的过程(为了创建线段树，增加了一个辅助方法)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Merger&lt;E&gt; merger;</span><br><span class="line"><span class="comment">//merger由用户传入 用户决定如何合并</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr, Merger&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.merger = merger;</span><br><span class="line">    </span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        data[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree = (E[]) <span class="keyword">new</span> Object[<span class="number">4</span> * data.length];</span><br><span class="line">    <span class="comment">//构造线段树 创建根节点为0，范围为[0,data.length - 1]的线段树</span></span><br><span class="line">    buildSegmentTree(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在treeIndex创建一棵[l,r]的线段树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[treeIndex] = data[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//l != r 那么就要创建子树的线段树</span></span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//(l +r) / 2中l + r可能会大于int表示的范围从而溢出</span></span><br><span class="line">    buildSegmentTree(leftTreeIndex, l, mid);</span><br><span class="line">    buildSegmentTree(rightTreeIndex, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//融合的方法由用户传入</span></span><br><span class="line">    tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便我们打印出线段树，我们实现一个 <code>toString()</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.append(tree[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.append(<span class="string">"null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != tree.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr37.png"/></center><p>实现代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queryL &lt; <span class="number">0</span> || queryL &gt;= data.length</span><br><span class="line">            || queryR &lt; <span class="number">0</span> || queryR &gt;= data.length</span><br><span class="line">            || queryL &gt; queryR) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, queryL, queryR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == queryL &amp;&amp; r == queryR) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (queryL &gt;= mid + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(rightChildIndex, mid+<span class="number">1</span>, r, queryL, queryR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryR &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(leftChildIndex, l, mid, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line">    E leftResult = query(leftChildIndex, l, mid, queryL, mid);</span><br><span class="line">    E rightResult = query(rightChildIndex, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, queryR);</span><br><span class="line">    <span class="keyword">return</span> merger.merge(leftResult, rightResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= data.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, index, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[treeIndex] = e;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mid + <span class="number">1</span>) &#123;</span><br><span class="line">        set(rightChildIndex, mid+<span class="number">1</span>, r, index, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set(leftChildIndex, l, mid, index, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree[treeIndex] = merger.merge(tree[leftChildIndex], tree[rightChildIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] tree;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> Merger&lt;E&gt; merger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr, Merger&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            data[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree = (E[]) <span class="keyword">new</span> Object[<span class="number">4</span> * data.length];</span><br><span class="line">        buildSegmentTree(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在treeIndex创建一棵[l,r]的线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[treeIndex] = data[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//(l +r) / 2中l + r可能会大于int表示的范围从而溢出</span></span><br><span class="line">        buildSegmentTree(leftTreeIndex, l, mid);</span><br><span class="line">        buildSegmentTree(rightTreeIndex, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queryL &lt; <span class="number">0</span> || queryL &gt;= data.length</span><br><span class="line">                || queryR &lt; <span class="number">0</span> || queryR &gt;= data.length</span><br><span class="line">                || queryL &gt; queryR) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == queryL &amp;&amp; r == queryR) &#123;</span><br><span class="line">            <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queryL &gt;= mid + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> query(rightChildIndex, mid+<span class="number">1</span>, r, queryL, queryR);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryR &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> query(leftChildIndex, l, mid, queryL, queryR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        E leftResult = query(leftChildIndex, l, mid, queryL, mid);</span><br><span class="line">        E rightResult = query(rightChildIndex, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, queryR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merger.merge(leftResult, rightResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= data.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, index, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[treeIndex] = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftChildIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightChildIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= mid + <span class="number">1</span>) &#123;</span><br><span class="line">            set(rightChildIndex, mid+<span class="number">1</span>, r, index, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set(leftChildIndex, l, mid, index, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftChildIndex], tree[rightChildIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= data.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.append(tree[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(<span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != tree.length - <span class="number">1</span>) &#123;</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p><code>Trie</code> 树又称为字典树、前缀树。如果我们使用一般树结构去查询一个数据集里的单词，它的复杂度是 <code>O(log n)</code>，但是如果我们使用 <code>Trie</code> 去查询单词的话，查询的复杂度只与单词的长度有关，与数据的规模无关。比如对于一个 $2^{20}$ 规模的数据集，我们去查一个单词 <code>&quot;word&quot;</code>，一般树的复杂度为 <code>O(20)</code>，而 <code>Trie</code> 树的复杂度为 <code>O(4)</code>，其中 4 是单词的长度，所以 <code>Trie</code> 树是一种很高效的查询字符串的树结构。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr38.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    Node next[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样考虑忽略了大小写，并且没有考虑一些特殊的字符，如 <code>@</code> 等符号或标点符号。所以我们每个节点不再是静态的指向 26 个节点，而是动态的指向若干个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    Map&lt;Character,Node&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们通过某个字符来到一个节点，可以通过 <code>Map</code>已经知道了，所以我们不必存储这个字符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Node&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr39.png"/></center><p>另外通过叶子节点是无法区别单词的结尾的，因为有的单词可能为某个单词的前缀，如 <code>&quot;pan&quot;</code> 为 <code>&quot;panda&quot;</code> 的前缀，所以我们要增加一个变量 <code>isWord</code> 来表示是否是单词的结尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> TreeMap&lt;Character,Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="添加单词"><a href="#添加单词" class="headerlink" title="添加单词"></a>添加单词</h4><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr40.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">        <span class="comment">//判断是否有指向这个字符的节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有则新建一个节点</span></span><br><span class="line">            cur.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移动到这个节点</span></span><br><span class="line">        cur = cur.next.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历完毕，判断这个节点是否被标记为单词的结尾 如果没有则标记并且维护size++</span></span><br><span class="line">    <span class="keyword">if</span> (!cur.isWord) &#123;</span><br><span class="line">        cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询单词"><a href="#查询单词" class="headerlink" title="查询单词"></a>查询单词</h4><p>查询单词的逻辑与添加单词的逻辑高度重复，如果在查询过程中遇到没有指向该字符的节点，则直接返回 <code>false</code>，如果遍历完毕都没有发生上面的情况，则判断该节点是否被标记为单词的结尾，如果没有则返回 <code>false</code>，否则返回 <code>true</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cur.isWord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前缀搜索"><a href="#前缀搜索" class="headerlink" title="前缀搜索"></a>前缀搜索</h4><p>查询是否包含某个前缀，与 <code>contains()</code> 方法几乎一样，不过最后不用判断是否是单词结尾，直接返回 <code>true</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单字符匹配"><a href="#简单字符匹配" class="headerlink" title="简单字符匹配"></a>简单字符匹配</h3><p>对于字符串中的字符 <code>.</code> 规定它可以匹配任意的字符，那么这样的一个匹配算法如何写，如果我们遇到的字符不是 <code>.</code> 的话，逻辑和上面一样，如果遇到的是<code>.</code>的话，我们就要去搜索该节点中所有的分叉(子树)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> match(root, word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Node node, String word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line">    <span class="comment">//如果不是.</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="comment">//没有指向该字符的节点 返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则继续匹配</span></span><br><span class="line">            <span class="keyword">return</span> match(node.next.get(c), word, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果是. 去该节点的所有分叉中搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> nextChar : node.next.keySet()) &#123;</span><br><span class="line">            <span class="comment">//如果有任一个分叉匹配到了，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (match(node.next.get(nextChar), word, index + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明上面的没有一个匹配成功了，返回fasle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全部代码-1"><a href="#全部代码-1" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> TreeMap&lt;Character,Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur.isWord) &#123;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Node node, String word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isWord;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> match(node.next.get(c), word, index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> nextChar : node.next.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (match(node.next.get(nextChar), word, index + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明上面的没有一个匹配成功了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>我们之前遇到的树结构都是由父亲指向孩子，但是并查集不一样，它是由孩子指向父亲的一种结构，并查集结构可以非常高效的回答连接问题(Connectivity Problem)，它可以很快的判断网络中节点的连接状态。并查集主要支持两个动作</p><ul><li><code>union(p, q)</code><ul><li>将元素 <code>p, q</code> 连接起来</li></ul></li><li><code>isConnected(p, q)</code><ul><li>判断元素 <code>p, q</code> 是否是连接的，即是否所属一个集合</li></ul></li></ul><p>这里先给出并查集的接口，后面我们将实现多个版本的并查集</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h3><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr41.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一版的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时id全部为0，相当于在一个集合中 一开始应该全部不在一个集合中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到元素p所属的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= id.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (find(p) == find(q)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == find(p)) &#123;</span><br><span class="line">                id[i] = find(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h3><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr42.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二版的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind2</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind2</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= parent.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index != parent[index]) &#123;</span><br><span class="line">            index = parent[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[pRoot] = parent[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h3><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr43.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三版的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind3</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//记录根节点的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind3</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= parent.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index != parent[index]) &#123;</span><br><span class="line">            index = parent[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt;= rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = parent[qRoot];</span><br><span class="line">            <span class="comment">//只要在两个数的高度相等的时候 树的高度才会增加</span></span><br><span class="line">            <span class="keyword">if</span> (rank[pRoot] == rank[qRoot]) &#123;</span><br><span class="line">                rank[qRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = parent[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr44.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第四版的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind4</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind4</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= parent.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index != parent[index]) &#123;</span><br><span class="line">            <span class="comment">//只添加了这一行代码</span></span><br><span class="line">            parent[index] = parent[parent[index]];</span><br><span class="line">            index = parent[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时rank不代表高度 因为在路径压缩时没有维护rank</span></span><br><span class="line">        <span class="comment">//但是整体上rank还是能够表示大小关系的</span></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt;= rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = parent[qRoot];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rank[pRoot] == rank[qRoot]) &#123;</span><br><span class="line">                rank[qRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = parent[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr45.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第五版的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind5</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind5</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= parent.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改了这里</span></span><br><span class="line">        <span class="keyword">if</span> (index != parent[index]) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt;= rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = parent[qRoot];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rank[pRoot] == rank[qRoot]) &#123;</span><br><span class="line">                rank[qRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = parent[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五版的效率不一定比第四版的好，因为第四版最后也可能做到”扁平化”，并且第五版的递归操作比较耗时。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="概念及实现"><a href="#概念及实现" class="headerlink" title="概念及实现"></a>概念及实现</h3><p>我们在研究二分搜索树时发现，如果我们将数据顺序添加进树中时，它有会退化成一棵链表，即所有的元素都添加到一个孩子上，这样树结构的优势就体现不出来，为了不使左右孩子的高度相差太大，我们需要对树进行调整，使树达到平衡，成为一棵平衡二叉树，<code>AVL</code> 就是一种经典的平衡二叉树</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr46.png"/></center><p>在 <code>AVL</code> 中，我们定义的平衡二叉树为，对于任意一个节点，左子树和右子树的高度相差不能超过 1。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr47.png"/></center><p>我们为每一个节点标注好高度值，计算方法为取左右子树高度较高的高度，然后 +1</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr48.png"/></center><p>然后我们还有记录节点左右子树的高度差，我们称之为平衡因子(规定用左子树的高度-右子树的高度)</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr49.png"/></center><p>由于我们只是在添加元素和删除元素时对树进行调整，其余的代码同二分搜索树是相同的，所以就不贴出所有的代码，只给出不同的代码，首先我们需要在 <code>Node</code> 类中添加一个 <code>height</code> 变量来记录高度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="comment">//高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        left = <span class="keyword">null</span>;</span><br><span class="line">        right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//高度初始为1</span></span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增加一个获得某节点高度的函数和平衡因子的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些因素，我们一般需要在添加元素时进行维护，重新计算高度和平衡因子，从而进行调整</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(balanceFactor) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们后面的内容主要是如何调整，后面所以只给出如何调整的代码，在学如何调整之前，我们来写两个辅助函数来判断这棵树是不是二分搜索树和 <code>AVL</code> 树，因为如果我们的代码有问题的话，有可能破坏二分搜索树的性质，这样有利于我们检查，那怎么检查一棵树是不是二分搜索树，我们根据二分搜索树的性质，它的中序遍历的结果是从小到大的特性，我们重写中序遍历为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;E&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inOrder(root, arrayList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayList.get(i-<span class="number">1</span>).compareTo(arrayList.get(i)) &gt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node, ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inOrder(node.left, arrayList);</span><br><span class="line">    arrayList.add(node.e);</span><br><span class="line">    inOrder(node.right, arrayList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们判断这棵树是不是平衡二叉树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断某个节点是不是平衡</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(balanceFactor) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(node.left) &amp;&amp; isBalanced(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对不平衡的四种情形进行讨论，并给出调整方法</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr50.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对节点y进行向右旋转操作，返回旋转后新的根节点x</span></span><br><span class="line"><span class="comment">//        y                              x</span></span><br><span class="line"><span class="comment">//       / \                           /   \</span></span><br><span class="line"><span class="comment">//      x   T4     向右旋转 (y)        z     y</span></span><br><span class="line"><span class="comment">//     / \       - - - - - - - -&gt;    / \   / \</span></span><br><span class="line"><span class="comment">//    z   T3                       T1  T2 T3 T4</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">// T1   T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    Node x = y.left;</span><br><span class="line">    Node T3 = x.right;</span><br><span class="line">    x.right = y;</span><br><span class="line">    y.left = T3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新x和y的高度值 先更新y的，因为y是x的右孩子，x的更新取决于y</span></span><br><span class="line">    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对节点y进行向左旋转操作，返回旋转后新的根节点x</span></span><br><span class="line"><span class="comment">//    y                             x</span></span><br><span class="line"><span class="comment">//  /  \                          /   \</span></span><br><span class="line"><span class="comment">// T4   x      向左旋转 (y)       y     z</span></span><br><span class="line"><span class="comment">//     / \   - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment">//   T3  z                     T4 T3 T1 T2</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     T1 T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    Node x = y.right;</span><br><span class="line">    Node T3 = x.left;</span><br><span class="line">    x.left = y;</span><br><span class="line">    y.right = T3;</span><br><span class="line">    </span><br><span class="line">    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">    <span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = leftRotate(node.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = rightRotate(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = remove(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node retNode;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            retNode = leftNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            retNode = rightNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            <span class="comment">////由于removeMin没有维持balance，所以我们复用remove</span></span><br><span class="line">            successor.right = remove(node.right,successor.e);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            retNode = successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = remove(node.left, e);</span><br><span class="line">        retNode = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = remove(node.right, e);</span><br><span class="line">        retNode = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则retNode.height会有空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (retNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(retNode);</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        retNode.left = leftRotate(retNode.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        retNode.right = rightRotate(retNode.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            height = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//树中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;E&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, arrayList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(i-<span class="number">1</span>).compareTo(arrayList.get(i)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node, ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(node.left, arrayList);</span><br><span class="line">        arrayList.add(node.e);</span><br><span class="line">        inOrder(node.right, arrayList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断某个节点是不是平衡</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(balanceFactor) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(node.left) &amp;&amp; isBalanced(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">        Node x = y.left;</span><br><span class="line">        Node T3 = x.right;</span><br><span class="line">        x.right = y;</span><br><span class="line">        y.left = T3;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新x和y的高度值 先更新y的，因为y是x的右孩子，x的更新取决于y</span></span><br><span class="line">        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">        Node x = y.right;</span><br><span class="line">        Node T3 = x.left;</span><br><span class="line">        x.left = y;</span><br><span class="line">        y.right = T3;</span><br><span class="line"></span><br><span class="line">        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = add(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = add(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = remove(root, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node retNode;</span><br><span class="line">        <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">                retNode = leftNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">                retNode = rightNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node successor = minimum(node.right);</span><br><span class="line">                successor.right = remove(node.right,successor.e);<span class="comment">//由于removeMin没有维持balance，所以我们用remove</span></span><br><span class="line">                successor.left = node.left;</span><br><span class="line">                node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//size--; 在removeMin中已经维护size了</span></span><br><span class="line">                retNode = successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = remove(node.left, e);</span><br><span class="line">            retNode = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = remove(node.right, e);</span><br><span class="line">            retNode = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则retNode.height会有空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (retNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(retNode);</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            retNode.left = leftRotate(retNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retNode.right = rightRotate(retNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树的节点它可以有一个元素，也可以有两个元素，它也满足二分搜索树的性质</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr51.png"/></center><p>我们把含有两个孩子的节点称为 2 节点，含有 3 个孩子的节点称为 3 节点</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr52.png"/></center><p><code>2-3</code> 树是一种绝对平衡的树，所谓绝对平衡的树指的是从根节点到任意一个叶子节点，所经过的节点是都是相同的。那么 <code>2-3</code> 树是怎么做到的呢? </p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr53.png"/></center><h3 id="红黑树与2-3树的等价性"><a href="#红黑树与2-3树的等价性" class="headerlink" title="红黑树与2-3树的等价性"></a>红黑树与2-3树的等价性</h3><p>由于我们一般每个节点都是表示一个数据的，<code>2-3</code> 树有点难以实现，所以有人发明一种树叫做红黑树，它可以说是 <code>2-3</code> 树的等价，那么它树如何等价的呢?</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr54.png"/></center><p>上图想必很清楚的描述了等价的过程</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr55.png"/></center><p>现在我们来实现一下上面描述的红黑树，大部分的代码都是和二分搜索树是重合的，只是在添加时有调整，另外这里我们不牵涉到从红黑树中删除元素，因为太复杂了(其实是我不会)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//规定红色为true 黑色为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//我们在2-3树中添加节点时 永远是和别的节点融合 所以默认为红色</span></span><br><span class="line">            color = RED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedBlackTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = add(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点node的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = add(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><p>在了解了红黑树与 <code>2-3</code> 等价以后，我们来看红黑树满足哪些性质</p><ul><li>每个节点或者是红色的，或者的是黑色的</li><li>根节点是黑色的</li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr56.png"/></center><ul><li>每一个叶子节点(最后的空节点是黑色的)<ul><li>因为红色节点只存在于 3 节点中，而所有的叶子节点都是 2 节点</li></ul></li><li>如果一个节点是红色的，那么它的所有孩子节点都是黑色的</li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr57.png"/></center><ul><li>从任意一个节点到黑色节点，经过的黑色节点是一样的<ul><li>因为 <code>2-3</code> 树到所有叶子节点的距离都是一样的，而经过的节点，不管是 2 节点还是 3 节点，都包括一个黑色节点，所以经过的黑色节点是一样的</li></ul></li></ul><h3 id="向红黑树中添加元素"><a href="#向红黑树中添加元素" class="headerlink" title="向红黑树中添加元素"></a>向红黑树中添加元素</h3><p>因为根节点是黑色的，所以我们在添加完元素后需要将根节点变为黑色</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = add(root, e);</span><br><span class="line">    </span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加元素到红黑树中时，可能会破坏红黑树的规则，这时就需要红黑树进行自我调整，我们就来看一下添加过程会碰到的所有情形，以及处理方法</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr58.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   node                     x</span></span><br><span class="line"><span class="comment">//  /   \     左旋转         /  \</span></span><br><span class="line"><span class="comment">// T1   x   ---------&gt;   node   T3</span></span><br><span class="line"><span class="comment">//     / \              /   \</span></span><br><span class="line"><span class="comment">//    T2 T3            T1   T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Node x = node.right;</span><br><span class="line">    <span class="comment">// 左旋转</span></span><br><span class="line">    node.right = x.left;</span><br><span class="line">    x.left = node;</span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr63.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    node.left.color = BLACK;</span><br><span class="line">    node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr64.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     node                   x</span></span><br><span class="line"><span class="comment">//    /   \     右旋转       /  \</span></span><br><span class="line"><span class="comment">//   x    T2   -------&gt;   y   node</span></span><br><span class="line"><span class="comment">//  / \                       /  \</span></span><br><span class="line"><span class="comment">// y  T1                     T1  T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Node x = node.left;</span><br><span class="line">    <span class="comment">// 右旋转</span></span><br><span class="line">    node.left = x.right;</span><br><span class="line">    x.right = node;</span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr65.png"/></center><p>对上面的情况进行总结</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr62.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">        node = leftRotate(node);</span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">        node = rightRotate(node);</span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">        flipColors(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//规定红色为true 黑色为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//我们在2-3树中添加节点时 永远是和别的节点融合 所以默认为红色</span></span><br><span class="line">            color = RED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedBlackTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   node                     x</span></span><br><span class="line">    <span class="comment">//  /   \     左旋转         /  \</span></span><br><span class="line">    <span class="comment">// T1   x   ---------&gt;   node   T3</span></span><br><span class="line">    <span class="comment">//     / \              /   \</span></span><br><span class="line">    <span class="comment">//    T2 T3            T1   T2</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node x = node.right;</span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//     node                   x</span></span><br><span class="line">    <span class="comment">//    /   \     右旋转       /  \</span></span><br><span class="line">    <span class="comment">//   x    T2   -------&gt;   y   node</span></span><br><span class="line">    <span class="comment">//  / \                       /  \</span></span><br><span class="line">    <span class="comment">// y  T1                     T1  T2</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node x = node.left;</span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = add(root, e);</span><br><span class="line"></span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = add(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>我们通过将我们要查找的某种数据类型转化为一个索引 <code>index</code>，然后通过索引去数组中查找，这时它的复杂度就是 <code>O(1)</code> 级别的。而将某个数据类型转化为索引的函数我们就称为是哈希函数，比如说将 26 个小写字母转化为索引，我们可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = ch - <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><p>这样就建立起了一一对应的关系，但是并不是所有的对应关系都是一一对应的，因为数组的容量是有限的，而输入的范围可能是无穷的，所以很有可能不同的键对应着同一个索引，比如说键是字符串，因为字符串的组合方式是非常的多，可以看做是无穷的，我们不可能去开辟一个无穷的空间去与这些字符串一一对应，所以不同的字符串生成的索引很有可能会有冲突，我们称这种情况为哈希冲突。由于上面讲到的哈希冲突，所以我们要设计好哈希函数(<code>hashCode()</code>)使得发生哈希冲突的可能性小，即使哈希函数产生的哈希值均匀的分布在数组中。</p><h3 id="哈希函数的设计"><a href="#哈希函数的设计" class="headerlink" title="哈希函数的设计"></a>哈希函数的设计</h3><p>哈希函数应该满足上面提到的：哈希函数产生的哈希值均匀的分布在数组中。数据的类型五花八门，对于特殊的领域有特殊领域的哈希函数的设计方式，甚至还有专门的论文，说这么多就是想说哈希函数的设计十分的复杂，在这里我们只提最简单的一种，哈希函数的设计应该满足</p><ul><li>一致性<ul><li>如果 <code>a == b</code>，那么 <code>hashCode(a) == hashCode(b)</code></li></ul></li><li>高效性<ul><li>计算迅速</li></ul></li><li>均匀性<ul><li>输出尽可能均匀</li></ul></li></ul><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr66.png"/></center><p>由于 <code>Java</code> 中基本数据类型和字符串类型有默认的 <code>hashCode()</code> 计算，所以我们就用 <code>Java</code> 自带的 <code>hashCode</code> 计算基本数据类型和字符串的哈希值，而对于引用类型 <code>Java</code> 是根据地址计算的哈希值，所以可能会出现问题，需要我们自己自定义规则，比如对于一个 <code>Student</code> 类，我们规定学号以及姓名相同(不区分大小写)就是同一个学生，所以根据一致性原则，它们应该产生相同的哈希值，但是由于 <code>Java</code> 默认是根据地址产生哈希值，由于二者的地址是不同的，所以产生的哈希值有极大的概率是不同的，所以我们需要自己创建哈希函数。</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>现在我们来演示往哈希表中添加元素的步骤</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr67.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//数组中存储的是TreeMap这种查找表</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K, V&gt;[] hashTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        hashTable = <span class="keyword">new</span> TreeMap[M];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashTable.length; i++) &#123;</span><br><span class="line">            hashTable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到在数组中的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//与0x7fffffff是为了消除负数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;K, V&gt; map = hashTable[hash(key)];</span><br><span class="line">        <span class="comment">//先查看已经是否有这个键了</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//有则更新</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有则进行添加，并维护size</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V ret = <span class="keyword">null</span>;</span><br><span class="line">        TreeMap&lt;K, V&gt; map = hashTable[hash(key)];</span><br><span class="line">        <span class="comment">//如果包含键则删除，没有返回null</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            ret = map.remove(key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;K, V&gt; map = hashTable[hash(key)];</span><br><span class="line">        <span class="comment">//没有该键抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"键不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        map.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接得到相应的TreeMap，然后去查，TreeMap有检查步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashTable[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/datastr68.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> upperTol = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> lowerTol = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initCapacity = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组中存储的是TreeMap这种查找表</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K, V&gt;[] hashTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只显示改变的内容</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        hashTable = <span class="keyword">new</span> TreeMap[initCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= upperTol * M) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * M);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; M * lowerTol &amp;&amp; M / <span class="number">2</span> &gt;= initCapacity) &#123;</span><br><span class="line">            resize(M / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newM)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt;[] newHashTable = <span class="keyword">new</span> TreeMap[newM];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面要更新M，但是还需要旧M遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> oldM = M;</span><br><span class="line">        <span class="comment">//由于后面要重新计算下标，所以这里要更新M</span></span><br><span class="line">        M = newM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldM; i++) &#123;</span><br><span class="line">            TreeMap&lt;K, V&gt; map = hashTable[i];</span><br><span class="line">            <span class="keyword">for</span> (K key: map.keySet()) &#123;</span><br><span class="line">                <span class="comment">//重新计算下标并赋值</span></span><br><span class="line">                newHashTable[hash(key)].put(key, map.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashTable = newHashTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现每次我们都扩容为 <code>2 \* M</code>，这时 <code>M</code> 就不是一个素数了，为了解决这一个问题，我们准备一个素数表，让 <code>M</code> 取素数表中的值，每次扩容 <code>M</code> 在素数表中的索引 <code>+1</code>，缩容 <code>-1</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//素数表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] capacity = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> upperTol = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> lowerTol = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> capacityIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组中存储的是TreeMap这种查找表</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K, V&gt;[] hashTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = capacity[capacityIndex];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        hashTable = <span class="keyword">new</span> TreeMap[M];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashTable.length; i++) &#123;</span><br><span class="line">            hashTable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= upperTol * M &amp;&amp; capacityIndex + <span class="number">1</span> &lt; size) &#123;</span><br><span class="line">            capacityIndex++;</span><br><span class="line">            resize(capacity[capacityIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; M * lowerTol &amp;&amp; capacityIndex - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            capacityIndex--;</span><br><span class="line">            resize(capacity[capacityIndex]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] capacity = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> upperTol = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> lowerTol = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> capacityIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组中存储的是TreeMap这种查找表</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K, V&gt;[] hashTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = capacity[capacityIndex];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        hashTable = <span class="keyword">new</span> TreeMap[M];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashTable.length; i++) &#123;</span><br><span class="line">            hashTable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到在数组中的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//与0x7fffffff是为了消除负数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;K, V&gt; map = hashTable[hash(key)];</span><br><span class="line">        <span class="comment">//先查看已经是否有这个键了</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//有则更新</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有则进行添加，并维护size</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= upperTol * M &amp;&amp; capacityIndex + <span class="number">1</span> &lt; capacity.length) &#123;</span><br><span class="line">            capacityIndex++;</span><br><span class="line">            resize(capacity[capacityIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V ret = <span class="keyword">null</span>;</span><br><span class="line">        TreeMap&lt;K, V&gt; map = hashTable[hash(key)];</span><br><span class="line">        <span class="comment">//如果包含键则删除，没有返回null</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            ret = map.remove(key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; M * lowerTol &amp;&amp; capacityIndex - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            capacityIndex--;</span><br><span class="line">            resize(capacity[capacityIndex]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;K, V&gt; map = hashTable[hash(key)];</span><br><span class="line">        <span class="comment">//没有该键抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"键不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接得到相应的TreeMap，然后去查，TreeMap有检查步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashTable[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newM)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt;[] newHashTable = <span class="keyword">new</span> TreeMap[newM];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面要更新M，但是还需要旧M遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> oldM = M;</span><br><span class="line">        <span class="comment">//由于后面要重新计算下标，所以这里要更新M</span></span><br><span class="line">        M = newM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldM; i++) &#123;</span><br><span class="line">            TreeMap&lt;K, V&gt; map = hashTable[i];</span><br><span class="line">            <span class="keyword">for</span> (K key: map.keySet()) &#123;</span><br><span class="line">                <span class="comment">//重新计算下标并赋值</span></span><br><span class="line">                newHashTable[hash(key)].put(key, map.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashTable = newHashTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://coding.imooc.com/class/chapter/207.html" target="_blank" rel="noopener">玩转数据结构</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章是为了记录自己在学习数据结构时的笔记，会对常见的数据结构做基本的介绍以及使用Java语言进行实现。包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态数组&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;二分搜索树&lt;/li&gt;
&lt;li&gt;优先队列
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://lastknightcoder.gitee.io/categories/Algorithms/"/>
    
    
      <category term="算法" scheme="https://lastknightcoder.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://lastknightcoder.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="https://lastknightcoder.gitee.io/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lastknightcoder.gitee.io/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-09-13T16:00:00.000Z</published>
    <updated>2019-09-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是记录我学习 <code>MySQL</code> 时的一些笔记，不成体系，仅为以后快速学习准备，由于记录的是从零学习 <code>MySQL</code> 的笔记，所以笔记的内容是十分的基础的，基本上是以用为主，不牵涉到具体的原理性问题。</p><h2 id="MySQL基本概念"><a href="#MySQL基本概念" class="headerlink" title="MySQL基本概念"></a>MySQL基本概念</h2><p>我们使用Java编写程序，一般数据都是存储在内存中的，一旦程序终止或断电，那么数据就会丢失，所以我们需要将数据存储到本地文件中，我们一般存储到数据库中，而 <code>MySQL</code> 正是这么一款数据库。</p><p>安装 <code>MySQL</code> 很简单，直接使用搜索引擎搜索 <code>MySQL</code>，进入官网进行安装，<code>MySQL</code> 是开源的软件。目前企业使用的是5.5-5.7的版本，选择进行下载即可。若要卸载 <code>MySQL</code>，在手动卸载 <code>MySQL</code> 后，还要删除 <code>C:\ProgramData\MySQL</code> 这个文件夹，否则重新安装时不能成功。</p><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>在命令行中输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>然后会提示你输入密码</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql01.png" /></center><p>输入的密码以密文的形式显示，以保证安全。当然你也可以直接在 <code>-p</code> 后面输入密码，不过这样并不安全。</p><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><p><code>SQL</code> 语句按功能分为</p><ul><li><code>DDL</code>：操作数据库，表</li><li><code>DML</code>：增、删、改数据</li><li><code>DQL</code>：查询数据</li><li><code>DLL</code>：与授权有关</li></ul><p>在 <code>MySQL</code> 中不区分大小写，不过关键字一般会大写，而数据库名和表名一般小写，<code>SQL</code>语句需要以<code>;</code>结尾，否则会一直等待输入。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>MySQL</code> 的注释为 <code>--</code> 后面需要接一个空格，否则会报错，另一种注释为 <code>#</code>，这是 <code>MySQL</code> 独有的，后面不需要加空格</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; <span class="comment">-- 显示所有的数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; <span class="comment">#显示所有的数据库</span></span><br></pre></td></tr></table></figure><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>这里来介绍操作数据库和表的 <code>SQL</code> 语句，这些操作一般就是 <code>C(Create), R(Retrieve), U(Update), D(Delete)</code>。</p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>首先介绍查询数据库的语句，连接上 <code>MySQL</code> 后，在命令行中输入(这里关键字没有大写)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><p>这个语句的作用是显示出所有的数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.31 sec)</span><br></pre></td></tr></table></figure><p>下面这条语句的作用是显示出某数据库所用的字符集</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> world;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">----------+------------------------------------------------------------------+</span></span><br><span class="line">| Database | <span class="keyword">Create</span> <span class="keyword">Database</span>                                                  |</span><br><span class="line">+<span class="comment">----------+------------------------------------------------------------------+</span></span><br><span class="line">| world    | <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`world`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span> |</span><br><span class="line">+<span class="comment">----------+------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure><p>可见 <code>world</code> 数据库所用的字符集为 <code>latin1</code>。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建数据库的语句为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br></pre></td></tr></table></figure><p>如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1; <span class="comment">-- 创建一个名为db1的数据库</span></span><br></pre></td></tr></table></figure><p>如果数据库已经存在，那么会发生错误，例如再次执行上面的命令 <code>create database db1;</code> 会发生如下错误</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1007 (HY000): Can't <span class="keyword">create</span> <span class="keyword">database</span> <span class="string">'db1'</span>; database exists</span><br></pre></td></tr></table></figure><p>这个时候我们可以使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> db1; <span class="comment">-- 如果db1不存在，那么创建db1，否则什么也不做</span></span><br></pre></td></tr></table></figure><p>我们还可以在创建数据库时指定字符集，如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2 <span class="built_in">character</span> <span class="keyword">set</span> gbk;</span><br></pre></td></tr></table></figure><p>使用 <code>show create database db2;</code> 查看字符集</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">----------+-------------------------------------------------------------+</span></span><br><span class="line">| Database | <span class="keyword">Create</span> <span class="keyword">Database</span>                                             |</span><br><span class="line">+<span class="comment">----------+-------------------------------------------------------------+</span></span><br><span class="line">| db2      | <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`db2`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET gbk */</span> |</span><br><span class="line">+<span class="comment">----------+-------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>我们可以通过下面的命令修改数据库的字符集</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure><p>例如修改 <code>db2</code> 数据库为 <code>utf8</code> 编码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> db2 <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>我们可以使用 <code>drop</code> 命令删除数据库，例如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db2;</span><br></pre></td></tr></table></figure><p>使用 <code>show databases;</code> 查看数据库，发现 <code>db2</code> 已经被删除了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| information_schema |</span><br><span class="line">| db1                |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><p>如果数据库不存在，那么会报错，比如在删除一次 <code>db2</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1008 (HY000): Can't <span class="keyword">drop</span> <span class="keyword">database</span> <span class="string">'db2'</span>; database doesn't exist</span><br></pre></td></tr></table></figure><p>这个时候我们可以使用下面的语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> db2; <span class="comment">-- 如果db2存在则删除db2，否则什么也不做</span></span><br></pre></td></tr></table></figure><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><p>通过 <code>select database();</code> 命令可以查看我们正在使用哪一个数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| database() |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| NULL       |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>因为我们没有使用数据库，所以这里显示的是 <code>NULL</code>，可以通过 <code>use 数据库名;</code>来使用数据库，比如使用 <code>db1</code> 数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> db1;</span><br></pre></td></tr></table></figure><p>再次执行 <code>select database();</code> 输出为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| database() |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| db1        |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>可以使用 <code>show tables</code> 查询某数据库中所有的表，例如现在我们使用 <code>world</code> 数据库，然后查询其中所有的表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> world;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| Tables_in_world |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| city            |</span><br><span class="line">| country         |</span><br><span class="line">| countrylanguage |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure><p>我们还可以使用 <code>desc 表名;</code> 来查询某表的结构，我们来查询 <code>city</code> 表的结构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc city;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+----------+------+-----+---------+----------------+</span></span><br><span class="line">| Field       | Type     | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------------+----------+------+-----+---------+----------------+</span></span><br><span class="line">| ID          | int(11)  | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| Name        | char(35) | NO   |     |         |                |</span><br><span class="line">| CountryCode | char(3)  | NO   | MUL |         |                |</span><br><span class="line">| District    | char(20) | NO   |     |         |                |</span><br><span class="line">| Population  | int(11)  | NO   |     | 0       |                |</span><br><span class="line">+<span class="comment">-------------+----------+------+-----+---------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.65</span> sec)</span><br></pre></td></tr></table></figure><p>使用 <code>show create table 表名;</code> 查看表的字符集。</p><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>创建表的语法为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(列名<span class="number">1</span> 数据类型<span class="number">1</span>, ..., 列名n 数据类型n);</span><br></pre></td></tr></table></figure><p>MySQL 中常用的数据类型有</p><ul><li><code>int</code><ul><li>整数类型</li></ul></li><li><code>double</code><ul><li>浮点数类型，接收两个参数，如 <code>double(5,2)</code>，5 代表数字的总长度，2 代表小数点后的位数</li></ul></li><li><code>date</code><ul><li>日期类型，格式为 <code>yy-MM-dd</code></li></ul></li><li><code>datetime</code><ul><li>日期类型，格式为<code>yy-MM-dd HH:mm:ss</code></li></ul></li><li><code>timestamp</code><ul><li>时间戳，格式为<code>yy-MM-dd HH:mm:ss</code>，当不赋值或赋值为NULL时，自动使用当前的时间作为值</li></ul></li><li><code>varchar</code><ul><li>字符串类型，接收一个参数表示字符串的最大长度，如 <code>varchar(20)</code></li></ul></li></ul><p>现在我们在 db1 中创建一个 student 表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> db1; <span class="comment">-- 使用数据库db1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>), age <span class="built_in">int</span>, score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>), insert_time <span class="built_in">timestamp</span>); <span class="comment">-- 创建表student 里面包括name age score insert_time 等列</span></span><br><span class="line">desc student; <span class="comment">-- 查看student表的结构</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+-------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| Field       | Type        | Null | Key | Default           | Extra                       |</span><br><span class="line">+<span class="comment">-------------+-------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| name        | varchar(10) | YES  |     | NULL              |                             |</span><br><span class="line">| age         | int(11)     | YES  |     | NULL              |                             |</span><br><span class="line">| score       | double(4,1) | YES  |     | NULL              |                             |</span><br><span class="line">| insert_time | timestamp   | NO   |     | CURRENT_TIMESTAMP | on <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span> |</span><br><span class="line">+<span class="comment">-------------+-------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>同删除数据库一样，有两种用法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure><p>这里不多做解释。</p><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><ul><li>重命名表名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure><ul><li>修改表的字符集</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure><ul><li>添加一列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br></pre></td></tr></table></figure><ul><li>修改列名及其类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure><ul><li>修改列的数据类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 新数据类型;</span><br></pre></td></tr></table></figure><ul><li>删除列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p><code>DML</code> 是与修改数据有关的 <code>sql</code> 语句。修改数据主要包括的是增删改数据。为了查看修改数据的效果，这里介绍一个查询数据的命令</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>现在创建一个 <code>student</code> 的表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>), <span class="comment">-- 名字长度最大10个字符</span></span><br><span class="line">    age <span class="built_in">int</span>, <span class="comment">-- 年龄</span></span><br><span class="line">    math_score <span class="keyword">double</span>(<span class="number">3</span>,<span class="number">1</span>), <span class="comment">-- 数学成绩</span></span><br><span class="line">    english_score <span class="keyword">double</span>(<span class="number">3</span>,<span class="number">1</span>), <span class="comment">-- 英语成绩</span></span><br><span class="line">    insert_time <span class="built_in">timestamp</span>  <span class="comment">-- 数据加入的时间</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC student; <span class="comment">-- 查看表的结构</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql02.png" /></center><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>向表中添加数据的写法为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>, ..., 列名n) <span class="keyword">values</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ..., 值n); <span class="comment">-- 列名和值要一一对应</span></span><br></pre></td></tr></table></figure><p>例如向表中添加数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (<span class="keyword">name</span>, age, math_score, english_score) <span class="keyword">VALUES</span> (<span class="string">'dilireba'</span>, <span class="number">27</span>, <span class="number">60</span>, <span class="number">70</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (<span class="keyword">name</span>, age, math_score, english_score) <span class="keyword">VALUES</span> (<span class="string">'gulinazha'</span>, <span class="number">28</span>, <span class="number">62</span>, <span class="number">68</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>SELECT * FROM student;</code> 得到数据为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql03.png" /></center><p>注意：</p><ul><li>列名和值名要一一对应</li><li>如果表名后不定义列名，则默认为给所有列添加，如<ul><li><code>INSERT INTO student VALUES (&#39;dilireba&#39;, 27, 60, 70);</code></li></ul></li><li>除了数字类型，其他类型要用引号(<code>&#39;</code>)括起来</li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据的格式为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]; <span class="comment">-- 删除满足条件的行</span></span><br></pre></td></tr></table></figure><p>其中 <code>[]</code> 代表的是里面的内容可省略，如果不加条件的话，默认为删除表中的所有数据，现在我们删除上例中 <code>age &gt; 27</code> 的行，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt; <span class="number">27</span>;</span><br></pre></td></tr></table></figure><p>得到的结果为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql04.png" /></center><p>如果要删除表中的所有数据的话，不推荐使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>因为它会将表中的数据一行一行的删除，效率较慢，推荐使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><p>它会直接删除这个表，然后创建一个空表，这个表的名字和结构与删除的表相同，从效果上就相当于是删除了表中所有的数据，但是它的效率比 <code>delete from 表名;</code> 快。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据的语法为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名<span class="number">1</span> = 值<span class="number">1</span>, ..., 列名n = 值n [<span class="keyword">where</span> 条件]; <span class="comment">-- 当符合条件时，更新值</span></span><br></pre></td></tr></table></figure><p>如何省略条件，那么会修改所有的行，如现在我要更新，如何符合条件 <code>age = 27</code>，那么将 <code>age</code> 修改为 <code>28</code>，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">set</span> age = <span class="number">28</span> <span class="keyword">WHERE</span> age = <span class="number">27</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql05.png" /></center><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>查询数据的基本语法为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    字段列表</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    表名列表</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    分组字段</span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">    分组后的条件限定</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">    排序</span><br><span class="line"><span class="keyword">LIMIT</span> </span><br><span class="line">    分页限定</span><br></pre></td></tr></table></figure><p>下面会详细的讲解其中各个关键字的意思。创建一个 <code>student</code> 表如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,  <span class="comment">--  编号</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="comment">--  姓名</span></span><br><span class="line">    age <span class="built_in">int</span>, <span class="comment">--  年龄</span></span><br><span class="line">    sex <span class="built_in">varchar</span>(<span class="number">5</span>),  <span class="comment">--  性别</span></span><br><span class="line">    address <span class="built_in">varchar</span>(<span class="number">100</span>),  <span class="comment">--  地址</span></span><br><span class="line">    math <span class="built_in">int</span>, <span class="comment">--  数学</span></span><br><span class="line">    english <span class="built_in">int</span> <span class="comment">--  英语</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>向其中插入以下数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(<span class="keyword">id</span>,<span class="keyword">name</span>,age,sex,address,math,english) <span class="keyword">VALUES</span> </span><br><span class="line">       (<span class="number">1</span>,<span class="string">'马云'</span>,<span class="number">55</span>,<span class="string">'男'</span>, <span class="string">'杭州 '</span>,<span class="number">66</span>,<span class="number">78</span>),</span><br><span class="line">       (<span class="number">2</span>,<span class="string">'马化腾 '</span>,<span class="number">45</span>,<span class="string">'女 '</span>,<span class="string">'深圳 '</span>,<span class="number">98</span>,<span class="number">87</span>),</span><br><span class="line">       (<span class="number">3</span>,<span class="string">'马景涛 '</span>,<span class="number">55</span>,<span class="string">'男 '</span>,<span class="string">'香港 '</span>,<span class="number">56</span>,<span class="number">77</span>),</span><br><span class="line">       (<span class="number">4</span>,<span class="string">'柳岩'</span>,<span class="number">20</span>,<span class="string">'女 '</span>,<span class="string">'湖南 '</span>,<span class="number">76</span>,<span class="number">65</span>),</span><br><span class="line">       (<span class="number">5</span>,<span class="string">'柳青 '</span>,<span class="number">20</span>,<span class="string">'男 '</span>,<span class="string">'湖南 '</span>,<span class="number">86</span>,<span class="literal">NULL</span>),</span><br><span class="line">       (<span class="number">6</span>,<span class="string">'刘德华 '</span>,<span class="number">57</span>,<span class="string">'男 '</span>,<span class="string">'香港'</span>,<span class="number">99</span>, <span class="number">99</span>),</span><br><span class="line">       (<span class="number">7</span>,<span class="string">'马德'</span>,<span class="number">22</span>,<span class="string">'女'</span>,<span class="string">'香港'</span>,<span class="number">99</span>,<span class="number">99</span>),</span><br><span class="line">       (<span class="number">8</span>,<span class="string">'德玛西亚'</span>,<span class="number">18</span>,<span class="string">'男'</span>,<span class="string">'南京'</span>,<span class="number">56</span>,<span class="number">65</span>);</span><br></pre></td></tr></table></figure><p>如果提示</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Incorrect string value: '\xE9\xA9\xAC\xE4\xBA\x91' for column 'name' at row 1</span><br></pre></td></tr></table></figure><p>那么就是因为字符编码的问题，这时可以修改 <code>name,address,sex</code> 的字符集为 <code>utf8</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">change</span> <span class="keyword">name</span> <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">change</span> address address <span class="built_in">char</span>(<span class="number">100</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">change</span> sex sex <span class="built_in">char</span>(<span class="number">5</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql06.png" /></center><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><h4 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, age </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student; <span class="comment">-- 查询name和age字段</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql07.png" /></center><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>查询 <code>address</code> 字段时，发现有相同的，如”香港”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">address </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql08.png" /></center><p>如果希望重复出现的只出现一次，那么可以使用 <code>DISTINCT</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> </span><br><span class="line">address </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql09.png" /></center><h4 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h4><p>现在要计算它们的数学成绩和英语成绩的和</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, math, english, math+english </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student; <span class="comment">-- 为了看出是谁的总分，这里加上一个name字段</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql10.png" /></center><p>我们发现第 5 行的结果为 <code>null</code>，这是因为 <code>null</code>+ 其它数得到的结果都是 <code>null</code>，但是这里我们应该把 <code>null</code> 当做 0 处理 ，这样加出来的就是总分，而不是 <code>null</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, math, english, math+<span class="keyword">ifnull</span>(english,<span class="number">0</span>) </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student;</span><br></pre></td></tr></table></figure><p>这里使用了 <code>ifnull(english,0)</code>，如果 <code>english</code> 的值是 <code>null</code>，那么就替换为 0，所以我们得到的结果为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql11.png" /></center><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><p>我们注意到上面的最后一列的列名为 <code>math+ifnull(english,0)</code>，这个列名没有什么意义，我们应该为它起个别名，如 <code>score</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, math, english, math+<span class="keyword">ifnull</span>(english,<span class="number">0</span>) <span class="keyword">AS</span> score </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql12.png" /></center><p>其中 <code>AS</code> 作为一个起别名的作用，<code>AS</code> 其实可以省略，使用空格替代即可，如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, math, english, math+<span class="keyword">ifnull</span>(english,<span class="number">0</span>) score </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student;</span><br></pre></td></tr></table></figure><p>该句得到的结果与上面的相同</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql12.png" /></center><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>我们使用 <code>WHERE</code> 来指明条件查询，比如我要查询年龄在 20 岁以上的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,age </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">age &gt; <span class="number">20</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql13.png" /></center><p>可见 <code>WHERE</code> 后面跟的是一个逻辑值，既然是逻辑值就可以使用与或非运算</p><ul><li><code>AND</code></li><li><code>OR</code></li><li><code>NOT</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,age </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">age &gt; <span class="number">20</span> <span class="keyword">AND</span> age &lt; <span class="number">50</span>; <span class="comment">-- 年龄在20-50之间的</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql14.png" /></center><p>我们可以使用 <code>BETWEEN ... AND ...</code> 来简化上面的操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,age </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">50</span>; <span class="comment">-- 在20-50之间，包括20和50</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql15.png" /></center><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,age </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">age = <span class="number">18</span> <span class="keyword">OR</span> age = <span class="number">20</span> <span class="keyword">OR</span> age = <span class="number">25</span>; <span class="comment">-- 查询年龄为18或20或25的</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql16.png" /></center><p>我们可以使用 <code>IN</code> 达到相同的效果</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,age </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">age <span class="keyword">IN</span> (<span class="number">18</span>,<span class="number">20</span>,<span class="number">25</span>); <span class="comment">-- 查询年龄为18或20或25的</span></span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>使用 <code>ORDER BY</code> 来对查询结果进行排序，后面跟要排序的字段，默认对字段进行升序排序。</p><ul><li><code>ASC</code>：升序</li><li><code>DESC</code>：降序</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,math </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">math; <span class="comment">-- 默认为升序</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql17.png" /></center><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,math </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">math <span class="keyword">DESC</span>; <span class="comment">-- 降序</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql18.png" /></center><p><code>ORDER BY</code> 可以对多个字段进行排序，先对前面的字段进行排序，如果前面的字段相同，在根据后面的字段排序，比如按照数学和英语成绩排名，优先按数学成绩来，如果数学成绩相同则按英语成绩来</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,math,english </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">math <span class="keyword">DESC</span>, english <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql19.png" /></center><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>使用 <code>LIKE</code> 进行模糊查询，比如记不住全称，这时可以使用模糊查询，比如想查询姓马的，在查询之前要介绍占位符</p><ul><li><code>_</code>：表示单个任意字符</li><li><code>%</code>：表示多个任意字符</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span> </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"><span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'马%'</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql20.png" /></center><p>如果我想查询名字中带有”德”字的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span> </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"><span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%德%'</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql21.png" /></center><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数将一列作为整体，进行纵向计算。聚合函数有</p><ul><li><code>count</code>：统计个数，不包括 <code>NULL</code>。</li><li><code>max</code>：计算最大值</li><li><code>min</code>：计算最小值</li><li><code>sum</code>：计算总和</li><li><code>avg</code>：计算平均值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(math) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">max</span>(math) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">min</span>(math) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(math) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">avg</span>(math) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>使用 <code>GROUP BY</code> 进行分组查询，比如我想男生和女生的数学平均分，那么可以使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">     sex,<span class="keyword">avg</span>(math) <span class="keyword">avg</span>  <span class="comment">-- avg是别名</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">     student </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">     sex;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql22.png" /></center><p>如果我想对分数在 70 以上的人计算平均分，并且统计人数，可以这么写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">     sex,<span class="keyword">avg</span>(math) <span class="keyword">avg</span>, <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">count</span> <span class="comment">-- avg和count是别名</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">     student </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">     math &gt; <span class="number">70</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">     sex;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql23.png" /></center><p>如果分组后的还要进行筛选，那么可以使用 <code>HAVING</code>，比如这里我要筛选分组后人数大于 2 的才进行统计</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">       sex,<span class="keyword">avg</span>(math) <span class="keyword">avg</span>, <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">count</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">     student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">      math &gt; <span class="number">70</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">         sex</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">id</span>) &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql24.png" /></center><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>当我们查询数据时，如果我们一页只能显示几行数据，我们就要进行分页查询，使用 <code>LIMIT</code>，后面跟两个数，第一个数代表查询的起始位置，从 0 开始，第二个代表一页显示的行数，如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">       *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">    <span class="number">0</span>,<span class="number">3</span>; <span class="comment">-- 查询中0开始的3行数据</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql25.png" /></center><p>如果我们要查询第二页，可以怎么写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">       *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">    <span class="number">3</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql26.png" /></center><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>所谓约束就是对数据产生限制，比如说某列不能为空(NULL)，有或者说某列的数据不能重复。约束一般包括下面四种约束</p><ul><li>非空约束(not null)</li><li>唯一约束(unique)</li><li>主键约束(primary key)</li><li>外键约束(foreign key)</li></ul><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>所谓的非空约束指的就是该列不能有 <code>NULL</code> 值，下面介绍如何创建非空约束，分为两种情况，一种是在创建表示添加非空约束，一种是在创建表之后添加非空约束</p><ol><li>创建表示添加非空约束</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>); <span class="comment">-- 为name添加非空约束 name不能为NULL</span></span><br></pre></td></tr></table></figure><p>如果此时为 name 赋值为 <code>NULL</code>，那么这条语句将会报错</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">0</span>,<span class="literal">NULL</span>); <span class="comment">-- 为name赋值为NULL 将会报错</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Column 'name' cannot be null</span><br></pre></td></tr></table></figure><ol start="2"><li>在创建表后添加非空约束</li></ol><p>如现在给 id 也添加非空约束，应当这么写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>; <span class="comment">-- 为id添加非空约束</span></span><br></pre></td></tr></table></figure><ol start="3"><li>删除非空约束</li></ol><p>删除的办法与添加的语法差不多，如现在我又要删除 id 的非空约束，应当这么写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>; <span class="comment">-- 删除id的非空约束</span></span><br></pre></td></tr></table></figure><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>唯一约束指的是该列的值不能相同，关键字为 <code>unique</code>。</p><ol><li>创建表时如何添加唯一约束</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)); <span class="comment">-- 为name添加非空约束 name不能为NULL</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建表后添加唯一约束</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>删除唯一约束</li></ol><p>删除唯一约束的语法与删除非空约束的语法不同，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>主键约束<code>(primary key)</code>是上面两个的总和，即该列既不能为 <code>NULL</code>，也不能相同。一张表只能有一个字段为主键。</p><ol><li>创建表时添加主键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表后添加主键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>删除主键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span> ; <span class="comment">-- 因为主键只有一个，不必指明是哪个字段</span></span><br></pre></td></tr></table></figure><p>下面介绍一个小知识点，主键自动增长，当我们添加数据时，如果我们设置了主键增长并且没有为主键赋值，那么主键的值会相较于上一条数据主键的值增长，设置主键自动增长的语法为(假设设置(了) id 为主键)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT, <span class="comment">-- 创建表时添加</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) ); </span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span> AUTO_INCREMENT; <span class="comment">-- 创建表后添加 id已经设置为主键了</span></span><br></pre></td></tr></table></figure><p>删除主键增长的方法为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>; <span class="comment">-- 这样是不会删除主键的，只会删除主键自动增长</span></span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>假设有这么一张表</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql27.png" /></center><p>观察研发部门和部门地点，发现数据冗余很严重，并且在后续添加数据中添加的也是这么一对一对的，很麻烦并且有在添加数据可能会出错，所以我们可以把这张表拆成两张表，如下</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql30.png" /></center><p>现在问题是怎么将这两张表联系起来，答案就是外键约束。那么什么是外键，从表(被别人约束的表)中与主表(用来约束别人的表)主键对应的那一列，如：员工表中的 dep_id。</p><ol><li>新建表时增加外键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名)</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表后添加外键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span>] [外键约束名称] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (外键字段名) <span class="keyword">REFERENCES</span>  主表(主</span><br><span class="line">键字段名);</span><br></pre></td></tr></table></figure><p>比如我在创建 employee 表时添加外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="built_in">INT</span>,</span><br><span class="line">    dep_id <span class="built_in">INT</span>,  <span class="comment">--  外键对应主表的主键</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> emp_depid_fk <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dep_id) <span class="keyword">REFERENCES</span> department(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>employee 表已经存在的情况下添加外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> emp_depid_fk <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dep_id) <span class="keyword">REFERENCES</span> department(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>删除外键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--  删除 employee 表的 emp_depid_fk 外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> emp_depid_fk;</span><br></pre></td></tr></table></figure><p>这个时候又会出现新的问题，比如我改变主表中 id=1 为 id=5，但是这时是不会成功的，因为如果改了，从表中的 dep_id 便没有对应的值，这个时候就需要级联操作(在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作)。</p><ul><li><code>ON UPDATE CASCADE</code> <ul><li>级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键<br>列也自动同步更新</li></ul></li><li><code>ON DELETE CASCADE</code><ul><li>级联删除</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    dep_id <span class="built_in">int</span>,  <span class="comment">--  外键对应主表的主键</span></span><br><span class="line">    <span class="comment">--  创建外键约束</span></span><br><span class="line">    <span class="keyword">constraint</span> emp_depid_fk <span class="keyword">foreign</span> <span class="keyword">key</span> (dep_id) <span class="keyword">references</span> department(<span class="keyword">id</span>) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span> <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p>设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p><p>目前关系数据库有六种范式 ： 第一范式(1NF) 、第二范式(2NF) 、第三范式(3NF) 、巴斯-科德范式(BCNF) 、第四范式(4NF)和第五范式(5NF，又称完美范式) 。满足最低要求的范式是第一范式(1NF) 。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF) ，其余范式以次类推。一般说来，数据库只需满足第三范式(3NF)就行了。</p><p>为了理解三大范式，我们首先来看这么一张表</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql31.png" /></center><p>我们首先来看第一范式的概念：数据库表的每一列都是不可分割的原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。上面的那个表不满足第一范式，因为系的那一列被拆成了两列，我们将它拆分成不同的列</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql32.png" /></center><p>它现在满足第一范式的要求了，接下来看第二范式的概念：在1NF的基础上，非码属性必须完全依赖于码。为了理解这句话的意思，先看下面几个概念：</p><ol><li>函数依赖：<code>A=&gt;B</code>，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值。则称 B 依赖于 A <ul><li>例如：学号<code>=&gt;</code>姓名。(学号，课程名称) <code>--&gt;</code> 分数</li></ul></li><li>完全函数依赖：<code>A=&gt;B</code>， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。<ul><li>例如：(学号，课程名称) <code>=&gt;</code> 分数</li></ul></li><li>部分函数依赖：<code>A=&gt;B</code>， 如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可。<ul><li>例如：(学号，课程名称) <code>--&gt;</code> 姓名，只依靠学号</li></ul></li><li>传递函数依赖：<code>A=&gt;B</code>, <code>B=&gt;C</code> . 如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A<ul><li>例如：学号 <code>=&gt;</code> 系名，系名 <code>=&gt;</code> 系主任</li></ul></li><li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<ul><li>例如：该表中码为：(学号，课程名称)</li><li>主属性：码属性组中的所有属性</li><li>非主属性：除过码属性组的属性</li></ul></li></ol><p>其实 2NF 就是在 1NF 基础上消除非主属性对主码的部分函数依赖，上表中的码为(学号，课程名称)，只有分数完全依赖该码组，所以我们拆分表如下，</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql33.png" /></center><p>第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖)，在学生表中存在学号 <code>=&gt;</code> 系名 <code>=&gt;</code> 系主任的传递依赖，所以再次拆分表</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql34.png" /></center><p>三大范式小结</p><ul><li>1NF: 原子性，表中每列不可再拆分。</li><li>2NF: 不产生局部依赖，一张表只描述一件事情</li><li>3NF: 不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其它列间接依赖于主键。 </li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询顾名思义就是同时查询多张表，假设有下面这么两张表(第一张是职员(emp)表，第二张是部门(dept)表)</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql35.png" /><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql36.png" /></center><p>现在我们同时查询这两张表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    emp, dept;</span><br></pre></td></tr></table></figure><p>我们将得到下面这么一张表</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql37.png" /></center><p>这张表的结果是两张表一一组合得到的，得到的结果也叫做笛卡尔积，我们可以看到很有的信息都是错误的，我们的目的就是去除这些无用的信息。</p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>用左边表的记录去匹配右边表的记录，如果符合条件的则显示。内连接分为</p><ul><li>隐式内连接<ul><li>使用 <code>WHERE</code> 条件指定</li></ul></li><li>显示内连接<ul><li>使用 <code>INNER JOIN ... ON</code> 语句</li></ul></li></ul><p>比如现在我要在上面的笛卡尔积中筛选出 emp 表外键 dept_id 等于主表主键 id 的，那么分别使用隐式内连接和显式外连接的写法为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#隐式写法</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    emp, dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    emp.dept_id = dept.id;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#显式写法</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>为了演示外连接，在上面的部门表中新加入一个销售部</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql38.png" /></center><p>外连接分为</p><ul><li>左外连接</li><li>右外连接</li></ul><p>两者只要掌握一种即可，因为用另一种时，将二表的顺序交换即可。那什么是左外连接，就是在内连接的基础上，以左表为基准，显示左表的所有内容，如果右表没有对应的内容，那么显示为 <code>NULL</code>，现在我们进行一次内连接查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp e <span class="keyword">ON</span> e.dept_id = dept.id; <span class="comment"># e是emp的别名</span></span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql39.png" /></center><p>现在我们进行一次左外连接查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp e <span class="keyword">ON</span> dept.id = e.dept_id;</span><br></pre></td></tr></table></figure><p>因为左外连接查询是以左表(dept)为基准，左表的内容会全部显示出来，即销售部会被查询出来，而对应的员工表没有对应的元素，所以会显示空</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql40.png" /></center><p>而右外连接与左外连接相反，是以右表为基准，现在如果我们将二表的位置交换，并且使用右外连接查询，得到的结果与上面的会是相同的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql41.png" /></center><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>所谓的子查询是指将查询得到的结果作为另一个查询语句的条件，比如我想查出薪资最高员工的信息，那么思路如下</p><ul><li>查出最高的薪资是多少</li><li>匹配谁的薪资为最高薪资</li></ul><p>那么第一步查出的最高薪资就作为了第二步进行匹配的条件</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp t1 <span class="keyword">WHERE</span> t1.salary = (<span class="keyword">SELECT</span> <span class="keyword">max</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql42.png" /></center><p>子查询得到的结果有多种，例如</p><ul><li>单行单列</li><li>单列多行</li><li>多行多列的值(表)</li></ul><p>当结果是单个列的值的时候，肯定在 <code>WHERE</code> 后面作为条件，父查询使用比较运算符，如：<code>&gt; 、&lt;、&lt;&gt;、 =</code> 等。现在我要查询小于平均薪资的人有哪些，那么可以这么写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp t1 <span class="keyword">WHERE</span> t1.salary &lt; (<span class="keyword">SELECT</span> <span class="keyword">avg</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql43.png" /></center><p>子查询结果是单列多行，结果集类似于一个数组，父查询使用 IN 运算符。查询工资大于5000的员工，来自于哪些部门</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t1.name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">     dept t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    t1.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> emp.dept_id <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.salary &gt; <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql44.png" /></center><p>子查询结果只要是多列，肯定在FROM后面作为表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 查询字段 <span class="keyword">FROM</span> （子查询）表别名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p>子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段。查询出2011年以后入职的员工信息，包括部门名称 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> db1.emp t1 <span class="keyword">WHERE</span> t1.join_date &gt; <span class="string">"2011-1-1"</span>) t3, dept d</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    d.id = t3.dept_id;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>所谓事务是指一系列的操作，这些操作要么同时成功，要么同时失败。比如转账，不能我这里转账成功，你那么收不到钱，那么钱就这么消失了? 如果事务执行成功了，那么就提交，如果有一条失败了，那么就需要进行回滚(即回到之前的状态)。与事务有关的三条语句为</p><ul><li><code>start transaction</code><ul><li>开启事务</li></ul></li><li><code>commit</code><ul><li>提交事务</li><li>可手动提交，也可设置为自动提交</li></ul></li><li><code>roll back</code><ul><li>回滚事务</li><li>当事务执行失败时自动自动，也可手动执行</li></ul></li></ul><p>假设有这么一张表，里面存储的是用户名和余额信息</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql45.png" /></center><p>现在张三要向李四转账 500 块，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 张三账号-500 </span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">500</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'张三'</span>; </span><br><span class="line"><span class="comment">-- 李四账号+500 </span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance + <span class="number">500</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'李四'</span>;</span><br></pre></td></tr></table></figure><p>如果我们不开启事务的话，那么当张三转了 500 块时，这时服务器崩溃了，李四没有收到钱，但是钱还是少了，这种情况是不能发生的，我们应当开启一个事务，这两个操作要么同时成功，要么同时失败。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>; <span class="comment">-- 开启一个事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 张三账号-500</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">500</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'张三'</span>;</span><br><span class="line"><span class="comment">-- 李四账号+500</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance + <span class="number">500</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'李四'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure><p>开启事务后，所有的操作都在临时日志文件中，<code>commit</code> 操作是将临时日志中的内容写到数据库的存储引擎中，所以在提交事务之前，是不会对数据库中的内容进行修改的。而 <code>rollback</code> 则是清空临时日志文件，之前没有进行提交的内容全部清除。</p><p>事务的步骤可以简述为下面几步</p><ul><li>客户端连接数据库服务器，创建连接时创建此用户临时日志文件 </li><li>开启事务以后，所有的操作都会先写入到临时日志文件中 </li><li>所有的查询操作从表中查询，但会经过日志文件加工后才返回 </li><li>如果事务提交则将日志文件中的数据写到表中，否则清空日志文件</li></ul><p>事务的提交分为自动提交和手动提交，在 <code>MySQL</code> 命令行的默认设置下，事务都是自动提交的，即执行 <code>SQL</code> 语句后就会马上执行 <code>COMMIT</code> 操作。因此要显式地开启一个事务务须使用命令 <code>BEGIN</code> 或 <code>START TRANSACTION</code>，或者执行命令 <code>SET AUTOCOMMIT=0</code>，用来禁止使用当前会话的自动提交。</p><ul><li><strong>SET AUTOCOMMIT=0</strong> <ul><li>禁止自动提交</li></ul></li><li><strong>SET AUTOCOMMIT=1</strong> <ul><li>开启自动提交</li></ul></li></ul><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>事务的四大特性 ACID</p><ul><li>原子性(Atomicity)<ul><li>每个事务都是一个整体，不可再拆分，事务中所有的 <code>SQL</code> 语句要么都执行成功， 要么都失败。</li></ul></li><li>一致性(Consistency)<ul><li>事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前 2 个人的 总金额是 2000，转账后 2 个人总金额也是 2000 </li></ul></li><li>隔离性(Isolation)<ul><li>事务与事务之间不应该相互影响，执行时保持隔离的状态。 </li></ul></li><li>持久性(Durability)<ul><li>一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 </li></ul></li></ul><p>这篇文章<a href="https://zhuanlan.zhihu.com/p/60723043" target="_blank" rel="noopener">MySQL事务：ACID特性的实现原理总结分析</a>详细讲解了 MySQL 的事务，所以在这里我不多做介绍，因为讲的没人家好。</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务在操作时的理想状态是所有的事务之间保持隔离，互不影响。但是因为并发操作，多个用户同时访问同一个数据时，可能引发并发访问的问题，如</p><ul><li>脏读 <ul><li>一个事务读取到了另一个事务中尚未提交的数据</li><li>比如李四向张三转了 500 块，但是没有提交，这时张三读取数据，发现已经到账 500 块，跟李四说到账了，这时李四进行 <code>roll back</code></li></ul></li><li>不可重复读 <ul><li>一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这是事务 <code>update</code> 时引发的问题</li><li>两次查询输出的结果不同，到底哪次是对的? 不知道以哪次为准。 有的时候这不是一个问题，当然是后面的为准。但是我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和发短信给客 户，结果在一个事务中针对不同的输出目的地进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作 人员就不知道以哪个为准了。 </li><li>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据</li></ul></li><li>幻读<ul><li>一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致的，这是 <code>insert</code> 或 <code>delete</code> 时引发的问题</li><li>幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从 “1” 修改为 “2” 的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 “1” 并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。</li><li>幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体(比如数据的个数)。</li></ul></li></ul><p>MySQL数据库有四种隔离级别 </p><ul><li><code>read uncommitted</code><ul><li>上面三种问题都有可能发生</li></ul></li><li><code>read committed</code><ul><li>不可能发生脏读，因为只有读到已提交的数据</li></ul></li><li><code>repeatable read</code><ul><li>可能发生幻读</li><li>这时 MySQL 的默认隔离级别</li></ul></li><li><code>serializable</code><ul><li>所有的问题都不会发生</li></ul></li></ul><p>上面的级别最低，下面的级别最高，隔离级别越高，性能越差，安全性越高。在 MySQL 数据库中设置事务的隔离级别</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> [glogal | <span class="keyword">session</span>] <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称;</span><br><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">'隔离级别名称'</span>;</span><br></pre></td></tr></table></figure><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>我们现在默认使用的都是 root 用户：超级管理员，拥有全部的权限。但是一个公司里面的数据库服务器上面可能同时运行着很多个项目的数据库。所以我们应该可以根据不同的项目建立不同的用户，分配不同的权限来管理和维护数据库。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'密码'</span>;</span><br></pre></td></tr></table></figure><ul><li>‘用户名’ <ul><li>将创建的用户名 </li></ul></li><li>‘主机名’ <ul><li>指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以 从任意远程主机登陆，可以使用通配符% </li></ul></li><li>该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建 user1 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'user1'</span>@<span class="string">'localhost'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123'</span>; </span><br><span class="line"><span class="comment">#创建 user2 用户可以在任何电脑上登录 mysql 服务器，密码为 123 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'user2'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123'</span>;</span><br></pre></td></tr></table></figure><p>创建的用户名都在 mysql 数据库中的 user 表中可以查看到，密码经过了加密。 </p><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限 <span class="number">1</span>, 权限 <span class="number">2.</span>.. <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br></pre></td></tr></table></figure><ul><li><code>GRANT…ON…TO</code> <ul><li>授权关键字 </li></ul></li><li>权限<ul><li>授予用户的权限，如 <code>CREATE、ALTER、SELECT、INSERT、UPDATE</code> 等。如果要授 予所有的权限则使用 <code>ALL</code> </li></ul></li><li>数据库名.表名 <ul><li>该用户可以操作哪个数据库的哪些表。如果要授予该用户对所有数据库和表的相应操作 权限则可用 * 表示，如 *.* </li></ul></li><li>‘用户名‘@’主机名’ <ul><li>给哪个用户授权</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给 user1 用户分配对 test 这个数据库操作的权限：创建表，修改表，插入记录，更新记录，查询 </span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span>,<span class="keyword">alter</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">select</span> <span class="keyword">on</span> test.* <span class="keyword">to</span> <span class="string">'user1'</span>@<span class="string">'localhost'</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">#给 user2 用户分配所有权限，对所有数据库的所有表  </span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'user2'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><h3 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span>  权限 <span class="number">1</span>, 权限 <span class="number">2.</span>.. <span class="keyword">ON</span> 数据库.表名 <span class="keyword">from</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br></pre></td></tr></table></figure><ul><li><code>REVOKE…ON…FROM</code><ul><li>撤销授权的关键字 </li></ul></li><li>权限 <ul><li>用户的权限，如 <code>CREATE、ALTER、SELECT、INSERT、UPDATE</code> 等，所有的权限则使用 <code>ALL</code> </li></ul></li><li>数据库名.表名 <ul><li>对哪些数据库的哪些表，如果要取消该用户对所有数据库和表的操作权限则可用*表 示，如*.* </li></ul></li><li>‘用户名‘@’主机名’ <ul><li>给哪个用户撤销  </li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#撤销 user1 用户对 test 数据库所有表的操作的权限 </span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> test.* <span class="keyword">from</span> <span class="string">'user1'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'root'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br></pre></td></tr></table></figure><h3 id="修改管理员密码"><a href="#修改管理员密码" class="headerlink" title="修改管理员密码"></a>修改管理员密码</h3><p>如果忘了原来的管理员密码</p><ol><li><code>cmd --&gt; net stop mysql</code> 停止 mysql 服务<ul><li>需要管理员运行该 cmd</li></ul></li><li>使用无验证方式启动 mysql 服务：<code>mysqld --skip-grant-tables</code></li><li>打开新的 cmd 窗口,直接输入 mysql 命令，敲回车。就可以登录成功</li><li><code>use mysql;</code></li><li><code>update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;</code></li><li>关闭两个窗口</li><li>打开任务管理器，手动结束 mysqld.exe 的进程</li><li>启动 mysql 服务</li><li>使用新密码登录。</li></ol><p>如果记得原来的密码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p password 新密码 <span class="comment">#需要在未登陆 MySQL 的情况下操作，新密码不需要加上引号。</span></span><br></pre></td></tr></table></figure><h3 id="修改普通用户密码"><a href="#修改普通用户密码" class="headerlink" title="修改普通用户密码"></a>修改普通用户密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span> = <span class="keyword">password</span>(<span class="string">'新密码'</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/whu-2017/p/9293083.html" target="_blank" rel="noopener">数据库隔离级别，每个级别会引发什么问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/60723043" target="_blank" rel="noopener">MySQL事务：ACID特性的实现原理总结分析</a></li><li><a href="https://www.cnblogs.com/bypp/p/8618382.html" target="_blank" rel="noopener">MySQL数据查询之多表查询</a></li><li><a href="https://blog.csdn.net/ch717828/article/details/41357431" target="_blank" rel="noopener">MySQL插入中文错误</a></li></ul>]]></content>
    
    <summary type="html">
    
      MySQL数据库入门
    
    </summary>
    
    
      <category term="MySQL" scheme="https://lastknightcoder.gitee.io/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="https://lastknightcoder.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://lastknightcoder.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java Web笔记</title>
    <link href="https://lastknightcoder.gitee.io/JavaWeb/"/>
    <id>https://lastknightcoder.gitee.io/JavaWeb/</id>
    <published>2019-08-19T16:00:00.000Z</published>
    <updated>2019-08-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Web服务器软件"><a href="#Web服务器软件" class="headerlink" title="Web服务器软件"></a>Web服务器软件</h3><ul><li>服务器：安装了服务器软件的计算机</li><li>服务器软件：接收用户请求，处理请求，做出响应</li><li>Web服务器软件：用户通过浏览器进行访问我们部署的项目<ul><li>webLogic：oracle公司，大型JavaEE服务器，收费，支持所有的JavaEE规范</li><li>webSphere：IBM公司，大型JavaEE服务器，收费，支持所有的JavaEE规范</li><li>JBOSS：JBOSS公司，大型JavaEE服务器，收费，支持所有的JavaEE规范</li><li>Tomcat：Apache基金组织，中小型JavaEE服务器，仅仅支持少量的JavaEE规范，开源的，免费的</li></ul></li></ul><h3 id="下载、安装、卸载"><a href="#下载、安装、卸载" class="headerlink" title="下载、安装、卸载"></a>下载、安装、卸载</h3><p>下载：tomcat.apache.org(Tomcat 8)</p><p>安装：解压压缩包即可(路径不要含中文)</p><p>卸载：删除文件夹</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">bin             可执行文件</span><br><span class="line">conf            配置文件</span><br><span class="line"><span class="class"><span class="keyword">lib</span>             依赖<span class="title">jar</span>包</span></span><br><span class="line">logs            日志文件</span><br><span class="line">temp            临时文件</span><br><span class="line">webapps         存放web项目的</span><br><span class="line">work            运行时数据</span><br><span class="line">LICENSE</span><br><span class="line">NOTICE</span><br><span class="line">RELEASE-NOTES</span><br><span class="line">RUNNING.txt</span><br></pre></td></tr></table></figure><p>启动</p><ol><li>双击bin/startup.bat</li><li>访问：127.0.0.1:8080，有页面说明访问成功(127.0.0.1可写为localhost)</li></ol><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/1571488794890.png"/></center><p>启动遇到的问题</p><ol><li><p>黑窗口一闪而过</p><ul><li><p>原因：没有配置JAVA_HOME</p><ol><li><p>在环境变量中新建JAVA_HOME，值为jdk的路径，不包括bin目录</p></li><li><p>然后将PATH中的…/bin(jdk的路径)改为%JAVA_HOME%/bin</p></li></ol></li></ul></li><li><p>启动报错</p><ul><li><p>原因：端口被占用，两种方法</p><ol><li><p>找到占用8080端口的进程杀死</p></li><li><p>修改自身的端口号</p><ul><li><p>conf/server.xml文件</p></li><li><p>修改port</p></li><li><p>一般会将tomcat的默认端口号修改为80(浏览器默认端口号)</p></li></ul></li></ol></li></ul></li></ol><p>关闭</p><ol><li>正常关闭<ul><li>shutdown.bat</li><li>Ctrl + C</li></ul></li><li>强制关闭</li></ol><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><ol><li>直接将项目(这里假设为hello)放到webapps文件夹中即可<ul><li>*/hello：项目的访问路径，虚拟路径</li><li>简化部署：打包为war包，将war包复制到webapps下，war包会自动解压缩</li><li>缺点：必须拷贝到webapps中</li></ul></li><li>config/server.xml</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"项目路径"</span> <span class="attr">path</span>=<span class="string">"虚拟路径"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>缺点：不安全，弄坏配置文件</li></ul><ol start="3"><li>/conf/Catalina/localhost<ol><li>创建一个文件xxx.xml(任意名称)</li><li>编写&lt;Context docBase=”项目路径” /&gt;</li><li>虚拟目录就是xml文件的名称</li></ol></li></ol><p>Java动态项目的目录结构</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">根目录</span><br><span class="line">WEB-INF</span><br><span class="line">web.xml：web项目的核心配置文件</span><br><span class="line">classes：放置字节码文件的目录</span><br><span class="line"><span class="class"><span class="keyword">lib</span>：放置依赖的<span class="title">jar</span>包</span></span><br></pre></td></tr></table></figure><h3 id="Tomcat集成到IDEA中"><a href="#Tomcat集成到IDEA中" class="headerlink" title="Tomcat集成到IDEA中"></a>Tomcat集成到IDEA中</h3><p>Run –&gt; Edit Configurations -&gt; Defaults -&gt; Tomcat Server -&gt; Local -&gt; Configure -&gt; Tomcat安装目录</p><h2 id="Servlet-server-applet"><a href="#Servlet-server-applet" class="headerlink" title="Servlet(server applet)"></a>Servlet(server applet)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat)识别的规则。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li>创建JavaEE项目</li><li>定义一个类实现Servlet接口</li><li>实现接口中的抽象方法</li><li>配置Servlet</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo01</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//只写了这一行</span></span><br><span class="line">        System.out.println(<span class="string">"Hello Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Servlet(web.xml)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Servlet配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>web.ServletDemo01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Servlet执行原理"><a href="#Servlet执行原理" class="headerlink" title="Servlet执行原理"></a>Servlet执行原理</h3><ol><li>解析URL请求路径，获取Servlet的资源路径</li><li>查找web.xml中是否有对应的&lt;url-pattern&gt;标签内容</li><li>查找&lt;servlet-class&gt;全类名</li><li>tomcat将字节码文件加载进内存，并且创建其名称</li><li>调用其方法</li></ol><h3 id="Servlet生命周期方法"><a href="#Servlet生命周期方法" class="headerlink" title="Servlet生命周期方法"></a>Servlet生命周期方法</h3><p>init</p><ul><li>在Servlet创建时执行，只会执行一次</li><li>默认情况第一次被访问时创建Servlet<ul><li>配置&lt;servlet&gt;下的&lt;load-on-startup&gt;可修改Servlet创建时机<ul><li>负数，第一次被访问时创建</li><li>0或正数，服务器启动时创建</li></ul></li></ul></li><li>Servlet是单例的<ul><li>多个用户同时访问时，可能存在线程安全问题</li><li>解决：尽量不要在Servlet中定义成员变量，定义了成员变量，也不要进行赋值</li></ul></li></ul><p>service</p><ul><li>提供服务的方法，每一次Servlet访问时执行</li></ul><p>destroy</p><ul><li>Servlet被杀死时被执行(服务器被正常关闭时)</li><li>在Servlet被销毁之前执行</li></ul><p>getServletConfig(了解)</p><ul><li>获取Servlet的配置对象</li></ul><p>getServletInfo(了解)</p><ul><li>获取Servlet的信息(版本、作者…)</li></ul><h3 id="Servlet3-0注解配置"><a href="#Servlet3-0注解配置" class="headerlink" title="Servlet3.0注解配置"></a>Servlet3.0注解配置</h3><p>Servlet3.0</p><ul><li>支持注解配置</li></ul><ol><li>创建JavaEE项目，勾选servlet3.0以上版本，可以不勾选web.xml</li><li>定义类实现Servlet接口，实现方法</li><li>在类上使用@WebServlet注解</li></ol><p>@WebServlet(“资源路径”)</p><h3 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h3><p>Servlet –&gt; GenericServlet –&gt; HttpServlet</p><ul><li>GenericServlet：将Servlet接口除service()外进行了空实现，只对service()进行了抽象</li><li>HttpServlet：对http协议封装，简化操作<ul><li>doGet()</li><li>doPost()</li></ul></li></ul><h3 id="Servlet-url-pattern配置"><a href="#Servlet-url-pattern配置" class="headerlink" title="Servlet url_pattern配置"></a>Servlet url_pattern配置</h3><p>可以定义多个访问路径：@WebServlet({“/d4”,”/dd4”,”/ddd4”})</p><ol><li>/xxx</li><li>/xxx/xxx(目录结构)<ul><li>/xxx/*(*是通配符，优先级较低)</li></ul></li><li>*.do(*表示任意，.do代表后缀名，如/demo4.do)</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>规定请求消息和响应消息的格式。</p><p>特点：</p><ol><li>基于TCP/IP的高级协议</li><li>默认端口号：80</li><li>基于请求响应模型，一次请求对应一次响应</li><li>无状态的：每次请求相互独立</li></ol><p>历史版本：</p><ul><li>1.0：每一次请求响应会建立新的连接</li><li>1.1：复用连接</li></ul><h3 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h3><ol><li>请求行</li><li>请求头</li><li>请求空行</li><li>请求体</li></ol><p>请求方式(七种，只介绍常见两种)：</p><ul><li>GET：<ul><li>参数在请求行中，在url后</li><li>请求的url长度有限制</li><li>不太安全</li></ul></li><li>POST<ul><li>参数在请求体中</li><li>请求的url长度没有限制</li><li>相对安全</li></ul></li></ul><p>请求头：</p><ul><li>Host：主机</li><li>User-Agent：使用的浏览器版本信息</li><li>Accept：可以接受什么格式</li><li>Accept-Language：可接受的语言</li><li>Referer：告诉服务器我从哪里来，作用<ol><li>防盗链</li><li>统计信息</li></ol></li><li>Connection：keep-alive(连接不会断开，可复用)</li></ul><p>请求正文：</p><ul><li>封装POST请求消息的请求参数的</li></ul><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>Request和Response原理：</p><ol><li>tomcat根据url创建对应的Servlet对象</li><li>tomcat服务器会创建request和response对象，request对象中封装的是请求消息数据</li><li>tomcat将request和response传递给service方法，并调用service方法</li><li>程序员通过request对象获取请求消息数据，通过response对象设置响应数据</li><li>服务器在做出响应之前，会用response对象中拿程序员设置的响应消息数据</li></ol><p>Request继承结构：</p><p>ServletRequest(接口) –&gt; HttpServletRequest(接口) –&gt; RequestFacade(类，Tomcat编写)</p><h4 id="获取请求消息数据"><a href="#获取请求消息数据" class="headerlink" title="获取请求消息数据"></a>获取请求消息数据</h4><ol><li>获取请求行</li></ol><p>格式：GET 虚拟路径/Servlet路径?参数 HTTP/1.1</p><ul><li><p>获取请求方式：getMethod</p></li><li><p><strong>获取虚拟目录：getContextPath</strong></p></li><li><p>获取Servlet路径：getServletPath</p></li><li><p>获取请求参数：getQueryString</p></li><li><p><strong>获取URI：getURI</strong></p></li><li><p>获取URL：getURL</p></li><li><p>获得协议及版本：getProtocol</p></li><li><p>获取客户机的IP地址：getRemoteAddr</p></li></ul><blockquote><p>URL &lt; URI</p></blockquote><ol start="2"><li>获取请求头</li></ol><ul><li>通过请求头的名称获取请求头的值：<strong>getHeader(String name)</strong></li><li>获取所有的请求头名称：Enumeration&lt;String&gt; getHeaderNames()</li></ul><ol start="3"><li>获取请求体<ol><li>获取流数据<ol><li>字符流：BufferedReader getReader()</li><li>字节流：ServletInputStream getInputStream()</li></ol></li><li>再从流对象中</li></ol></li></ol><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ul><li>获取请求方法通用方式(get和post都可以)<ol><li><strong>String getParameter(String name)</strong>：根据参数名称获取参数值</li><li>String[] getParameterValues(String name)：根据参数名称获取参数值的数组(多用于复选框)</li><li>Enumeration getParameterNames()：获取所有请求的参数名称</li><li><strong>Map&lt;String, String[]&gt; getParameterMap</strong>：获取所有参数的Map集合</li></ol></li></ul><blockquote><p>中文乱码问题：</p><p>get：tomcat 8已经解决</p><p>post：设置流的编码</p><ul><li>resquest.setCharacterEncoding(“utf-8”)</li></ul></blockquote><ul><li><p>请求转发：一种在服务器内部的资源跳转的方式</p><ol><li>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</li><li>使用RequestDispatcher进行转发：forward(ServletRequest request, ServletResponse response)</li></ol><blockquote><p>特点：</p><ol><li>浏览器地址栏路径没有发生变化</li><li>只能转发到当前服务器内部资源中</li><li>转发是一次请求</li></ol></blockquote></li><li><p>共享数据</p><ul><li>域对象：一个有作用范围的对象，可以在范围内共享对象</li><li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li><li>方法<ol><li>setAttribute(String name, Obkect obj)：存储数据</li><li>Object getAttribute(String name)：通过键获取值</li><li>void removeAttribute(String name)：删除键值对</li></ol></li></ul></li><li><p>获取ServletContext</p><ul><li>ServletContext getServletContext()</li></ul></li></ul><blockquote><p>开发步骤：</p><ol><li>创建项目，导入html，配置文件，jar包</li><li>创建数据库环境，User表</li><li>创建实体类User</li><li>创建UserDao，操作数据库中User表的类</li></ol></blockquote><h4 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h4><p>简化数据封装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String String[]) map = req.getParameterMap();</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.populate(loginUser, map);</span><br></pre></td></tr></table></figure><h3 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h3><ol><li>响应行</li><li>响应头</li><li>响应空行</li><li>响应体</li></ol><p>响应行：</p><ol><li><p>协议以及版本：HTTP/1.1</p></li><li><p>响应状态码：200</p><ul><li><p>1xx：服务器接客户端消息但是没有接收完成，一段时间后服务器向客户端询问是否还有数据发送</p></li><li><p>2xx：成功。</p><ul><li>200</li></ul></li><li><p>3xx：重定向。</p><ul><li><p>302(重定向)</p></li><li><p>304(访问缓存)</p></li></ul></li><li><p>4xx：客户端错误。</p><ul><li><p>404(请求路径没有对应的资源)</p></li><li><p>405(请求方式没有对应的doXxx方法)</p></li></ul></li><li><p>5xx：服务器端错误。</p><ul><li>500(服务器内部出现异常)</li></ul></li></ul></li><li><p>状态码的描述：OK</p></li></ol><p>响应头：</p><ol><li>格式<ul><li>名称：值</li></ul></li><li>常见响应头<ul><li>Content-Type：服务器告诉客户端响应体数据格式以及编码格式</li><li>Content-disposotion：服务器告诉客户端以什么格式打开我的响应体<ul><li>in-line：默认值，在当前页面打开</li><li>attachment：以附件形式打开(文件下载)</li></ul></li></ul></li></ol><p>响应体：</p><ul><li>真实传输的数据</li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>功能：设置响应消息的</p><ol><li>设置响应行<ul><li>设置状态码：setStatus(int sc)</li></ul></li><li>设置响应头：<ul><li>setHeader(String name, String value)</li></ul></li><li>设置响应体<ol><li>获取输出流<ol><li>字符输出流：PrintWriter getWriter()</li><li>字节输出流：ServletOutputStream getOutputStream()</li></ol></li><li>使用输出流，将数据输出到客户端浏览器</li></ol></li></ol><blockquote><p>重定向：</p><ol><li>设置状态码302</li><li>设置响应头location</li></ol><p>简单重定向方法：</p><ul><li>sendRedirect(String url)</li></ul><p>重定向的特点：</p><ol><li>地址栏发生变化</li><li>可以访问其他站点(服务器)的资源</li><li>两次请求(不可用Request域对象共享数据)</li></ol></blockquote><blockquote><p>路径写法：</p><ul><li>相对路径：当前资源与访问资源的路径关系(./index.html = index.html)</li><li>绝对路径：(/responseDemo2)<ul><li>给客户端浏览器使用(a标签，表单，重定向等)：需要加虚拟目录(项目访问路径)<ul><li>req.getContextPath：动态获取虚拟目录</li></ul></li><li>给服务器端使用：不需要加虚拟目录(如转发)</li></ul></li></ul></blockquote><blockquote><p>输出字符/字节：</p><ul><li>乱码问题：浏览器默认以GBK解码(与操作系统有关，Windows在中文环境下是GBK)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">"content-type"</span>, <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="comment">//简便写法</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>验证码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> width = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//设置图片的宽高和类型</span></span><br><span class="line">BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//美化图片</span></span><br><span class="line"><span class="comment">//获取画图对象</span></span><br><span class="line">Graphics g = image.getGraphics();</span><br><span class="line"><span class="comment">//设置背景色</span></span><br><span class="line">g.setColor(Color.PINK);</span><br><span class="line">g.fileRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置边框色以及绘制</span></span><br><span class="line">g.setColor(Color.BLUE);</span><br><span class="line">g.drawRect(<span class="number">0</span>,<span class="number">0</span> width - <span class="number">1</span>, height - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取随机字符并绘制</span></span><br><span class="line">String str = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>;</span><br><span class="line">Random ran = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">    index = ran.nextInt(str.length());</span><br><span class="line">    <span class="keyword">char</span> ch = str.charAt(index);</span><br><span class="line">    g.drawString(ch+<span class="string">""</span>, <span class="number">20</span>*i, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置干扰线</span></span><br><span class="line">g.setColor(Color.GREEN);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = ran.nextInt(width);</span><br><span class="line">    <span class="keyword">int</span> x2 = ran.nextInt(width);</span><br><span class="line">    <span class="keyword">int</span> y1 = ran.nextInt(height);</span><br><span class="line">    <span class="keyword">int</span> y2 = ran.nextIne(height);</span><br><span class="line">    g.drawLine(x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制到浏览器中</span></span><br><span class="line">ImageIO.writer(image, <span class="string">"jpg"</span>, response.getOutputStream());</span><br></pre></td></tr></table></figure></blockquote><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>概念：代表整个Web应用，可以和程序的容器来通信。</p><p>获取：</p><ol><li>request对象获取：request.getServletContext()</li><li>HttpServlet的方法：this.getServletContext()</li></ol><p>功能：</p><ol><li><p>获取MIME类型</p><ul><li><p>MIME：互联网通信过程中定义的一种文件数据类型</p><ul><li>格式：大类型/小类型(text/html image/jpeg)</li></ul></li><li><p>String getMimeType(String file)</p><ul><li><pre><code class="java">String fileName = <span class="string">"a.jpg"</span>;String mimeType = servletContext.getMimeType(fileName);&lt;!--￼<span class="number">8</span>--&gt;</code></pre></li></ul></li></ul></li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote><p>会话：</p><ul><li><p>概念：一次会话(浏览器第一次发生请求，直到一方断开)包含多次请求和响应</p></li><li><p>功能：一次会话的多次请求间共享数据</p></li><li><p>方式：</p><ol><li>客户端：Cookie</li><li>服务器：Session</li></ol></li></ul></blockquote><p>将数据保存到客户端，使用步骤：</p><ol><li>创建Cookie对象，绑定数据<ul><li>new Cookie(String name, String value)</li></ul></li><li>发送Cookie对象<ul><li>response.addCookie(Cookie cookie)</li></ul></li><li>获取Cookie,得到数据<ul><li>Cookie[] request.getCookies()</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"msg"</span>, <span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        response.addCookie(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieDemo2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                String value = cookie.getValue();</span><br><span class="line">                System.out.println(name + <span class="string">": "</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理：</p><p>response发送响应头：set-cookie:msg=hello</p><p>request发送请求头：Cookie:mas=hello</p><p>细节：</p><ol><li>一次可不可以发送多个Cookie<ul><li>可以</li></ul></li><li>Cookie能在浏览器中保存多长的时间<ul><li>默认：浏览器关闭时Cookie数据被销毁</li><li>持久化存储：<ul><li>cookie.setMaxAge(int seconds)<ul><li>正数：将Cookie数据写到硬盘的文件中，数值表示存活时间</li><li>负数：默认值</li><li>0：删除Cookie信息</li></ul></li></ul></li></ul></li><li>Cookie能不能存中文<ul><li>Tomcat 8之前不能直接存储中文信息，Tomcat 8之后可以</li></ul></li><li>Cookie共享问题<ul><li>一个Tomcat服务器部署了多个web项目，在这些项目中cookie能不能共享<ul><li>默认不能共享</li><li>setPath(String path)：设置Cookie的获取范围，默认情况设置当前的虚拟目录</li></ul></li><li>不同的Tomcat服务器间Cookie共享问题<ul><li>setDomain(String path)：如果一级域名相同，那么多个服务器之间Cookie可以共享</li></ul></li></ul></li></ol><p>特点：</p><ol><li><p>Cookie存储数据在浏览器</p></li><li><p>浏览器对于单个Cookie的大小有限制(4KB)，数目也有限制(20个)</p></li></ol><p>作用：</p><ul><li>一般用于存在少量不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ul><p>案例：记住上一次登录时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieTest"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie: cookies) &#123;</span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"lastTime"</span>.equals(name)) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    String time = cookie.getValue();</span><br><span class="line">                    time = URLDecoder.decode(time, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">                    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy:MM:dd HH:mm:ss"</span>);</span><br><span class="line">                    String str_date = sdf.format(date);</span><br><span class="line">                    str_date = URLEncoder.encode(str_date, <span class="string">"utf-8"</span>);</span><br><span class="line">                    cookie.setValue(str_date);</span><br><span class="line">                    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">                    response.getWriter().write(<span class="string">"lastTime: "</span> + time);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">            Date date = <span class="keyword">new</span> Date();</span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy:MM:dd HH:mm:ss"</span>);</span><br><span class="line">            String str_date = sdf.format(date);</span><br><span class="line">            str_date = URLEncoder.encode(str_date, <span class="string">"utf-8"</span>);</span><br><span class="line">            Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>, str_date);</span><br><span class="line">            cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">            response.getWriter().write(<span class="string">"欢迎首次访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>概念：服务器端会话技术，用以保存一次请求的数据，相关类为HttpSession</p><ul><li>HttpSession session = request.getSession();</li></ul><p>方法(Session是域对象)：</p><ul><li>setAttribute</li><li>getAttribute</li><li>removeAttribute</li></ul><p>原理：Session的实现是依赖于Cookie的</p><p>细节：</p><ol><li><p>客户端关闭，服务器不关闭获取的Session是同一个吗</p><ul><li><p>不是</p></li><li><pre><code class="java"><span class="comment">//如果希望是同一个，可以这么写</span>Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>, session.getId());c.setMaxAge(<span class="number">60</span> * <span class="number">60</span>);response.addCookie(c);&lt;!--￼<span class="number">12</span>--&gt;</code></pre></li></ul></li></ol><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>概念：JavaServer Pages Tag Library</p><p>作用：简化和替换JSP页面上的Java代码</p><p>使用步骤：</p><ol><li>导入jar包</li><li>引入标签库：taglib指令(&lt;%@ taglib %&gt;)</li><li>使用标签</li></ol><p>常用标签：</p><ol><li><p>if</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">""</span>&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure></li><li><p>choose</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=""&gt;&lt;/c:when&gt;</span><br><span class="line">    ... ...</span><br><span class="line">    &lt;c:otherwise&gt;&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure></li><li><p>forEach</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">""</span> end=<span class="string">""</span> <span class="keyword">var</span>=<span class="string">""</span> step=<span class="string">""</span>&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"str"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">    $&#123;s.index&#125;</span><br><span class="line">    $&#123;s.count&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>作用：</p><ul><li>一般用于完成通用的操作，如登录验证、统一编码处理，敏感字符过滤</li></ul><p>入门：</p><ol><li>定义类实现接口Filter</li><li>实现方法</li><li>配置拦截路径</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"... ..."</span>);</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>web.FilterDemo<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生命周期：</p><ul><li>init</li><li>doFilter</li><li>destroy</li></ul><p>过滤器配置：</p><ol><li><p>拦截路径配置</p><ol><li>具体路径：/index.jsp</li><li>目录拦截：/user/*</li><li>后缀名拦截：*.jsp</li><li>拦截所有资源：/*</li></ol></li><li><p>拦截方式配置：资源被访问的方式</p><ol><li><p>注解配置：设置dispatcherTypes属性</p><ol><li>REQUEST：默认值，浏览器直接请求资源</li><li>FORWORD：转发访问资源</li><li>INCLUDE：包含访问资源</li><li>ERROR：错误跳转资源</li><li>ASYNC：异步访问资源</li></ol></li><li><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>过滤器链的配置</p><ol><li>如果有两个过滤器<ul><li>Filter1 –&gt; Filter2 –&gt; 资源执行 –&gt; Filter2 –&gt; Filter1</li></ul></li><li>执行顺序问题<ol><li>注解配置：按照类名的字符串比较规则进行比较，最小的先则执行<ul><li>AFilter &lt; BFilter(AFilter先执行)</li></ul></li><li>web.xml配置：谁定义在上面，谁先执行</li></ol></li></ol></li></ol><blockquote><p>代理：</p><ul><li>概念<ul><li>真实对象</li><li>代理对象</li><li>代理模式：代理对象代理真实对象，达到增强真实对象功能的目的</li></ul></li><li>实现方式<ul><li>静态代理：有一个类文件描述代理模式</li><li>动态代理：在内存中形成代理类<ol><li>代理对象和真实对象实现相同的接口</li><li>代理对象：Proxy.newProxyInstance()<ol><li>第一个参数：类加载器</li><li>第二个参数：接口数组</li><li>第三个参数：处理器<ul><li>invoke<ul><li>proxy</li><li>method：代理对象调用的方法，被封装为对象</li><li>args：代理对象调用方法时，传递的实际对象</li></ul></li></ul></li></ol></li><li>使用代理对象调用方法</li></ol></li></ul></li></ul></blockquote><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>事件监听机制</p><ul><li>事件源</li><li>监听器</li><li>注册监听</li></ul><p>ServletContextLinstener：监听ServletContext对象的创建和监听</p><ul><li>contextDestroyed(ServletXontextEvent sec)</li><li>contextImitialized(ServletContextEvent sec)</li></ul><p>步骤：</p><ol><li>定义一个类，实现ServletContextLinstener接口</li><li>实现方法</li><li>配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerDemo</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器启动自动被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器正常关闭后被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有关Java Web的简略笔记，包括Tomcat Servlet JSP Cookie Session等等
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Java/Web/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="https://lastknightcoder.gitee.io/JDBC/"/>
    <id>https://lastknightcoder.gitee.io/JDBC/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识JDBC"><a href="#初识JDBC" class="headerlink" title="初识JDBC"></a>初识JDBC</h2><p>如果我们要使用<code>Java</code>来操作数据库，由于数据库的种类繁多，并且<code>sql</code>语句并不完全相同，总而言之不同的数据库千差万别，这是不是意味着我们要对不同的数据库写不同的程序，这样的话对程序员的要求有点高，并且学习的成本也很大，所以我们要定义一套规范，要求对所有的数据库程序员只要写相同的程序就可以了。就相当于插座，我们定义好插座的标准，那么所有的商家必须按我的标准来，否则就不能使用插座。同理，在Java中定义好数据库的接口，定义接口中的方法有什么作用，而具体的实现细节则有数据库的厂商进行编写，程序员只要调用接口里面的方法就可以了。这里给出一个摘至维基百科的定义</p><blockquote><p>Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is a Java-based data access technology used for Java database connectivity.</p></blockquote><p>所以使用<code>JDBC</code>的好处便显而易见</p><ul><li>程序员如果要开发访问数据库的程序，只需要会调用<code>JDBC</code>接口中的方法即可，不用关注类是如何实现的</li><li>使用同一套<code>Java</code>代码，进行少量的修改就可以访问其他<code>JDBC</code>支持的数据库 </li></ul><p>我们使用<code>Java</code>操作数据库，会使用到数据库的驱动，由各大数据库厂商提供，需要额外去下载，里面是对<code>JDBC</code>接口实现的类，导入驱动jar包的具体的步骤如下</p><ul><li>在项目中新建一个<code>libs</code>文件夹</li><li>将<code>jar</code>包复制到这个文件夹中</li><li>选中这个<code>jar</code>包，右击找到<code>&quot;Add as Library&quot;</code></li></ul><p>上面是导入<code>jar</code>包的通用步骤，后面会经常导入<code>jar</code>包，所以需要熟记。</p><h3 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h3><p>使用<code>Java</code>操作数据库一般包括下面几步</p><ul><li>注册驱动</li><li>获得连接数据库的对象</li><li>获得执行<code>sql</code>语句的对象</li><li>执行<code>sql</code>语句</li><li>释放资源(断开连接)</li></ul><p>程序如下(具体类后面解释)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db1"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建sql语句</span></span><br><span class="line">        String sql = <span class="string">"update account set balance = 2000 where id = 1"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建执行sql语句的对象</span></span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        <span class="comment">//执行sql语句</span></span><br><span class="line">        statement.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p>下面就详细介绍<code>JDBC</code>的核心类(接口)以及它们的功能</p><ul><li><code>DriverManager</code>：驱动管理对象，功能如下<ul><li>注册驱动：告诉程序该使用哪一个数据库驱动<code>jar</code>包<ul><li><code>mysql5</code>之后可以省略注册驱动的步骤，即不需要写<code>Class.forName()</code></li></ul></li><li>获取数据库连接<ul><li><code>static Connection getConnection(String url, String user, String password)</code><ul><li><code>url</code>：连接的路径<ul><li>格式：<code>jdbc:mysql://ip地址(域名):端口号/数据库名称?参数=参数值</code><ul><li>例子：<code>jdbc:mysql://localhost:3306/db1</code></li><li>如果<code>ip</code>地址为本机地址且端口号为<code>3306</code>，则上面可省略<code>ip</code>地址和端口号，简写为：<code>jdbc:mysql:///db1</code></li></ul></li><li>如果出现乱码问题，可以指定参数<code>?characterEncoding=utf8</code></li></ul></li><li><code>user</code>：用户名</li><li><code>password</code>：密码</li></ul></li></ul></li></ul></li><li><code>Connection</code>：数据库连接对象，相当于是在Java程序与数据库之间建立了一条通道，功能如下<ul><li>获取执行<code>sql</code>的对象<ul><li><code>Statement createStatement()</code></li><li><code>PreparedStatement prepareStatement(String sql)</code></li></ul></li><li>管理事务<ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code>，传入<code>false</code>即开启事务</li><li>提交事务：<code>commit()</code></li><li>回滚事务：<code>rollback()</code></li></ul></li></ul></li><li><code>Statement</code>：执行<code>sql</code>的对象，含有如下方法<ul><li><code>boolean execute(String sql)</code>：可以执行任意的<code>sql</code>语句，不常用，了解即可</li><li><code>int executeUpdate(String sql)</code><ul><li>执行<code>DML(insert、update、delete)</code>语句、<code>DDL(create，alter、drop)</code>语句</li><li>返回值：影响的行数，可以通过这个影响的行数判断<code>DML</code>语句是否执行成功 返回值<code>&gt;0</code>的则执行成功，反之，则失败。</li></ul></li><li><code>ResultSet executeQuery(String sql)</code>：执行<code>DQL(select)</code>语句</li></ul></li><li><code>ResultSet</code>：结果集对象，封装查询结果，数据库通过通道返回的结果<ul><li><code>boolean next()</code><ul><li>判断游标所指向的行是否为空</li></ul></li><li><code>getXxx()</code><ul><li><code>getXxx(int columnIndex)</code><ul><li>根据列数来获得数据</li></ul></li><li><code>getXxx(int columnLabel)</code><ul><li>根据列名称获得数据</li></ul></li></ul></li></ul></li></ul><p>这里给出一个使用<code>ResultSet</code>的例子，比如我们要去查询<code>account</code>表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///db1"</span>, <span class="string">"user"</span>, <span class="string">"root"</span>);</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        </span><br><span class="line">        String sql = <span class="string">"select * from account"</span>;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将查询到的数据打印出来</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="comment">//根据列名查询数据</span></span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">            String name = resultSet.getString(<span class="string">"name"</span>);</span><br><span class="line">            <span class="keyword">double</span> balance = resultSet.getDouble(<span class="string">"balance"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(id + <span class="string">"---"</span> + name + <span class="string">"---"</span> + balance);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC工具类"><a href="#JDBC工具类" class="headerlink" title="JDBC工具类"></a>JDBC工具类</h3><p>其实上面的代码并不是十分的规范，因为资源的释放可能不能释放成功，因为前面发生异常就可以导致后面的程序执行不到，这样资源无法释放，就会导致内存越用越少(内存泄漏)，所以我们应当将资源释放的代码写到<code>finally</code>代码块中，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义在try代码块外是为了在finally中能够访问</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///db1"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            statement = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"update account set balance = 2000 where id = 1"</span>;</span><br><span class="line">            statement.executeUpdate(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们发现代码十分的冗长(特别是资源释放的部分)，并且每次写代码都会重复这些，再者程序所连接的数据库是写死的，如果需要改变的话还需要改动程序，我们可以将这些信息写在一个<code>jdbc.properties</code>的配置文件中，如果有改动直接改动配置文件即可</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span>=jdbc:mysql:///db1</span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">password</span>=root</span><br><span class="line"><span class="attr">driver</span>=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>将上面的这些操作抽离出来，写一个<code>JDBC</code>的工具类，在工具类中读取配置文件，以及抽离出一些方法，这样不用每次都写这么长的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取jdbc.properties中的内容 获得url user password driver等信息</span></span><br><span class="line">    <span class="comment">//因为只需要读取一次，所以写在static代码块中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            ClassLoader classLoader = JDBCUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">            URL res = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            String path = res.getPath();</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">            url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">"driver"</span>);</span><br><span class="line"></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stam != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stam.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stam, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复用上面的代码</span></span><br><span class="line">        close(conn, stam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户登录练习"><a href="#用户登录练习" class="headerlink" title="用户登录练习"></a>用户登录练习</h3><p>我们来写一个方法来判断用户输入的用户名和密码是否正确，思路就是根据用户输入的用户名和密码去数据库中查询，如果返回的<code>ResultSet</code>有内容，那么就确定输入正确，否则失败。假设有下面这么一个表(<code>user</code>)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| id   | user     | password |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">|    1 | zhangsan | 123      |</span><br><span class="line">|    2 | lisi     | 345      |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br></pre></td></tr></table></figure><p>下面是检查用户名和密码的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        statement = conn.createStatement();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拼接user和password未一个sql语句</span></span><br><span class="line">        String sql = <span class="string">"select * from user where user = '"</span> + user + <span class="string">"' and password = '"</span> +  password + <span class="string">"'"</span>;</span><br><span class="line">        resultSet = statement.executeQuery(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果返回有数据则返回true 否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> resultSet.next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.close(conn, statement, resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面在<code>main</code>方法中写测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用户输入用户名和密码</span></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">    String user = scanner.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">    String password = scanner.nextLine();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> flag = login(user, password);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来试验一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">lisi</span><br><span class="line">请输入密码：</span><br><span class="line"><span class="number">234</span></span><br><span class="line">用户名或密码错误</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">zhangsan</span><br><span class="line">请输入密码：</span><br><span class="line"><span class="number">123</span></span><br><span class="line">登录成功</span><br></pre></td></tr></table></figure><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p><code>PreparedStatement</code>的作用同<code>Statement</code>，也是用来执行<code>sql</code>命令的，但是已经有了<code>Statement</code>，为什么还需要<code>PreparedStatement</code>呢? 那就要知道<code>Statement</code>存在什么问题，我们来看上面的用户登录程序，如果我们登录时这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">daad</span><br><span class="line">请输入密码：</span><br><span class="line">a<span class="string">' or '</span>a<span class="string">' = '</span>a</span><br><span class="line">登录成功</span><br></pre></td></tr></table></figure><p>得到的结果居然登录成功了，因为<code>sql</code>语句被拼接成了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where user &#x3D; &#39;daad&#39; and password &#x3D; &#39;a&#39; or &#39;a&#39; &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure><p>最后的<code>or ‘a’ = ‘a’</code>得到的永远是true，所以总是可以得到返回结果，所以自然会显示登录成功，这种情况叫做<code>SQL</code>注入。<code>PreparedStatement</code>正是为了解决这一个问题的，上面出现问题是因为我们的<code>sql</code>语句是拼接而成的，所以才会出现问题，<code>PreparedStatement</code>采取的办法是首先使用<code>?</code>占据位置(占位符)，然后对<code>?</code>所占据的位置进行赋值，赋值的方法为</p><ul><li><code>setXxx()</code>：接收两个参数<ul><li>第一个参数表示为第几个占位符赋值，从<code>1</code>开始</li><li>第二个参数是值</li></ul></li></ul><p>所以我们将上面的登录代码修改如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">//使用?作为占位符</span></span><br><span class="line">        String sql = <span class="string">"select * from user where user = ? and password = ?"</span>;</span><br><span class="line">        <span class="comment">//创建PreparedStatement对象</span></span><br><span class="line">        preparedStatement = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//为占位符赋值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, user);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, password);</span><br><span class="line">        <span class="comment">//不需要传入sql</span></span><br><span class="line">        resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">//如果返回有数据则返回true 否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> resultSet.next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.close(conn, preparedStatement, resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时还是使用与上面相同的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">dadd</span><br><span class="line">请输入密码：</span><br><span class="line">a or <span class="string">'a'</span> = <span class="string">'a'</span></span><br><span class="line">用户名或密码错误</span><br></pre></td></tr></table></figure><p>在实际中我们一般使用<code>PreparedStatement</code>，因为它不仅可以防止<code>SQL</code>注入，并且效率更高。</p><h2 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h2><p>事务就是一组<code>sql</code>操作，这一组<code>sql</code>操作要么同时成功，要么同时失败。比如转账，一方钱的支出与另一方钱的到账必须同时成功或者同时失败，没有这里钱转出去了，另一方却没有到账的情况。有关事务一般包含下面三个操作</p><ul><li>开启事务<ul><li><code>setAutoCommit(false)</code></li><li>开启事务后，直至提交，执行的<code>sql</code>语句不会在数据库中生效，而是会写在日志中，只有提交后才会将根据日志修改数据库中的数据</li><li>默认是自动提交的，即每次执行一次<code>sql</code>命令都会更改数据库中的内容，我们将自动提交关闭就相当于是开启了事务</li></ul></li><li>提交事务<ul><li><code>commit()</code></li></ul></li><li>回滚事务<ul><li><code>rollback()</code></li><li>事务执行失败，这时我们就要回到执行事务前的状态，这时会把日志中的内容清空</li><li>一般在<code>catch</code>代码块中进行回滚操作</li></ul></li></ul><p>假设有下面这么一个表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | NAME | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | 张三 |    2000 |</span><br><span class="line">|  2 | 李四 |    1000 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure><p>现在张三要给李四转500块钱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//转账的金额</span></span><br><span class="line">        <span class="keyword">double</span> money = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">            String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line"></span><br><span class="line">            preparedStatement1 = connection.prepareStatement(sql1);</span><br><span class="line">            preparedStatement1.setDouble(<span class="number">1</span>, money);</span><br><span class="line">            preparedStatement1.setInt(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            preparedStatement2 = connection.prepareStatement(sql2);</span><br><span class="line">            preparedStatement2.setDouble(<span class="number">1</span>, money);</span><br><span class="line">            preparedStatement2.setInt(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            preparedStatement1.executeUpdate();</span><br><span class="line">            preparedStatement2.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(connection, preparedStatement1);</span><br><span class="line">            <span class="comment">//因为connection已经关闭了，所以传入null</span></span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, preparedStatement2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的程序然后再次查表得</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | NAME | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  <span class="number">1</span> | 张三 |    <span class="number">1500</span> |</span><br><span class="line">|  <span class="number">2</span> | 李四 |    <span class="number">1500</span> |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure><p>但是如果我们在执行张三支出500块后手动添加一个异常，这时李四则不会收到500块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">preparedStatement1.executeUpdate();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> / <span class="number">0</span>;</span><br><span class="line">preparedStatement2.executeUpdate();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | NAME | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | 张三 |    1000 |</span><br><span class="line">|  2 | 李四 |    1500 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure><p>张三的钱减少了500块，但是李四却没有收到。这就是问题，所以我们要开启事务，并且在<code>catch</code>代码块中进行回滚</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> money = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            </span><br><span class="line">            String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">            String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line"></span><br><span class="line">            preparedStatement1 = connection.prepareStatement(sql1);</span><br><span class="line">            preparedStatement1.setDouble(<span class="number">1</span>, money);</span><br><span class="line">            preparedStatement1.setInt(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            preparedStatement2 = connection.prepareStatement(sql2);</span><br><span class="line">            preparedStatement2.setDouble(<span class="number">1</span>, money);</span><br><span class="line">            preparedStatement2.setInt(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            preparedStatement1.executeUpdate();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span> / <span class="number">0</span>;</span><br><span class="line">            preparedStatement2.executeUpdate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//回滚事务</span></span><br><span class="line">                    connection.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(connection, preparedStatement1);</span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, preparedStatement2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次再次执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | NAME | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | 张三 |    1000 |</span><br><span class="line">|  2 | 李四 |    1500 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure><p>虽然还是发生了异常，但是张三和李四并没有发生上面一方转出一方没有到账的情况，而是转账失败。</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>每次我们使用完连接对象后都会将该对象销毁，然后下次需要连接对象时又需要重新创建。如果考虑到有频繁的操作数据库的操作，每次创建销毁的开销是很大的，所以就有了数据库连接池，里面有很多的连接对象，当我们需要时就从里面拿，用完之后不是销毁，而是将对象归还给连接池，这样做能够有效的提升程序的性能。Java定义了一个<code>DataSource</code>接口，我们可以通过该接口的<code>getConnection()</code>方法获取一个连接，并且可以通过<code>close()</code>方法归还这个连接(前提是这个连接是从连接池中获得的)。<code>DataSource</code>接口的实现我们不需要关心，我们只要知道如何使用即可，我们学习如何使用两种数据库连接池技术</p><ul><li><code>C3P0</code></li><li><code>Druid</code>：阿里巴巴提供，目前最好的数据库连接池之一</li></ul><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p><code>C3P0</code>的使用步骤</p><ol><li>导入<code>jar</code>包<ul><li><code>c3p0-0.9.5.2.jar</code></li><li><code>mchange-commons-java-0.2.12.jar</code></li></ul></li><li>定义配置文件<ul><li>只能为<code>c3p0-config.xml</code>或<code>c3p0.properties</code>，配置文件需放在<code>src</code>目录下</li></ul></li><li>使用实现类<code>ComboPooledDataSource</code>获得连接池对象</li></ol><p>下面给出配置文件<code>c3p0-config.xml</code>的内容</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql:///db1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--初始连接对象数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--最大连接对象数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--最大等待时间 3s--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面给出一个使用的示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//获得连接池对象</span></span><br><span class="line">        DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p><code>Druid</code>的使用步骤</p><ol><li>导入<code>jar</code>包<ul><li><code>druid-1.0.9.jar</code></li></ul></li><li>定义配置文件<ul><li><code>.properties</code>文件</li><li>可以放置在任何的地方</li></ul></li><li>使用工厂方法<code>DruidDataSourceFactory.createDataSource()</code>获得连接池<ul><li>需要传入一个<code>Properties</code>对象(配置文件)</li></ul></li></ol><p>下面给出<code>druid.properties</code>的内容</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">url</span>=jdbc:mysql:///db1</span><br><span class="line"><span class="attr">username</span>=root</span><br><span class="line"><span class="attr">password</span>=root</span><br><span class="line"><span class="attr">initialSize</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="number">3000</span></span><br></pre></td></tr></table></figure><p>想必上面的各参数的含义不必解释，那么就给出一个使用<code>Druid</code>的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//得到配置文件的输入流对象</span></span><br><span class="line">        InputStream is = Demo06.class.getClassLoader().getResourceAsStream("druid.properties");</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>我们发现每次使用连接池时会有很多重复的操作，同上面我们应该写一个工具类<code>JDBCUtils</code>将一些操作抽离出来，<code>JDBCUtils</code>类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件 初始化连接池对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stam != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stam.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stam, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复用上面的代码</span></span><br><span class="line">        close(conn, stam);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回连接池对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><p><code>Spring</code>对<code>JDBC</code>进行了简单的封装，提供了一个<code>JdbcTemplate</code>对象来简化<code>JDBC</code>的开发，使用步骤为</p><ol><li>导入<code>jar</code>包<ul><li><code>spring-beans-5.0.0.RELEASE.jar</code></li><li><code>spring-core-5.0.0.RELEASE.jar</code></li><li><code>spring-jdbc-5.0.0.RELEASE.jar</code></li><li><code>spring-tx-5.0.0.RELEASE.jar</code></li><li><code>commons-logging-1.2.jar</code></li></ul></li><li>创建<code>JdbcTemplate</code>对象<ul><li><code>new JdbcTemplate(ds)</code>：<code>ds</code>为数据库连接池对象</li></ul></li><li>使用<code>JdbcTemplate</code>对象的方法对数据库进行操作<ul><li><code>update()</code>：执行<code>DML</code>语句<ul><li>第一个参数为<code>sql</code>语句</li><li>第二个参数为可变参数，是占位符<code>?</code>所对应的值</li></ul></li><li><code>queryForMap()</code>：将结果封装为<code>Map</code>对象<ul><li>只能查询一行数据，将结果封装为<code>Map</code>对象</li><li>将列名最为<code>Key</code>，将字段值作为<code>Value</code></li></ul></li><li><code>queryForList()</code>：将结果封装为<code>List</code>对象<ul><li>查询多行数据，每一行数据封装为一个<code>Map</code>对象，这些<code>Map</code>对象会被添加到一个<code>List</code>集合中返回</li></ul></li><li><code>queryForObject()</code>：将结果封装为对象<ul><li>用以查询一些聚合函数</li></ul></li><li><code>query()</code>：将结果封装为<code>JavaBean</code>对象</li></ul></li></ol><p>下面就来做一个简单的演示，假设<code>db1</code>数据库中有一张表<code>account</code>其中内容如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | NAME | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | 张三 |    1000 |</span><br><span class="line">|  2 | 李四 |    1000 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现在我们使用<code>update</code>命令修改张三的<code>balance</code>为2000</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Junit单元测试 方法可以单独执行 不需要写在main方法中</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update account set balance = 2000 where id = ?"</span>;</span><br><span class="line">        template.update(sql, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次查询<code>account</code>表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | NAME | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | 张三 |    2000 |</span><br><span class="line">|  2 | 李四 |    1000 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure><h3 id="queryForMap"><a href="#queryForMap" class="headerlink" title="queryForMap"></a>queryForMap</h3><p>查询张三所在行<code>(id = 1)</code>，得到一个<code>Map</code>对象，我们将其打印出来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from account where id = ?"</span>;</span><br><span class="line">    Map map = template.queryForMap(sql, <span class="number">1</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;id=<span class="number">1</span>, NAME=张三, balance=<span class="number">2000.0</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="queryForList"><a href="#queryForList" class="headerlink" title="queryForList"></a>queryForList</h3><p>如果我们需要查询多条数据怎么办，这个时候就使用<code>queryForList</code>，它会将每条数据封装为<code>Map</code>集合，然后将这些<code>Map</code>集合添加到<code>List</code>集合中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from account"</span>;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; mapList = template.queryForList(sql);</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String, Object&gt; map: mapList) &#123;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;id=<span class="number">1</span>, NAME=张三, balance=<span class="number">2000.0</span>&#125;</span><br><span class="line">&#123;id=<span class="number">2</span>, NAME=李四, balance=<span class="number">1000.0</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>更多的时候我们希望将得到的结果封装为一个对象，现在我们新建一个类<code>Account</code>如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(Double balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", balance="</span> + balance +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们希望将获得结果封装为一个个<code>Account</code>对象，这时我们就需要使用<code>query()</code>方法了，<code>query</code>方法的第一个参数是<code>sql</code>语句，第二个参数是<code>RowMapper&lt;&gt;</code>的实现类，这个类我们可以自己实现，也可以使用<code>Spring</code>提供好的实现类，我们就使用<code>Spring</code>提供好的实现类<code>BeanPropertyRowMapper&lt;&gt;</code>，我们只要将<code>Account</code>的<code>class</code>属性传递进去即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from account"</span>;</span><br><span class="line">    List&lt;Account&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="keyword">for</span> (Account account : list) &#123;</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Account&#123;id=<span class="number">1</span>, name=<span class="string">'张三'</span>, balance=<span class="number">2000.0</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">2</span>, name=<span class="string">'李四'</span>, balance=<span class="number">1000.0</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="queryForObject"><a href="#queryForObject" class="headerlink" title="queryForObject"></a>queryForObject</h3><p>现在我们来查询<code>account</code>表中右多少条数据，我们使用聚合函数<code>count()</code>，得到的结果是一个<code>long</code>类型的数字，我们使用<code>queryForObject()</code>查询，接收两个参数，第一个参数是<code>sql</code>命令，第二个参数是返回类型的<code>class</code>属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select count(id) from account"</span>;</span><br><span class="line">    Long num = template.queryForObject(sql, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有关于JDBC的基本知识，需要mysql的基础
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="数据库" scheme="https://lastknightcoder.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="JDBC" scheme="https://lastknightcoder.gitee.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://lastknightcoder.gitee.io/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://lastknightcoder.gitee.io/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在之前就有接触过注解，比如@Override，它可以帮我们检查是否重写了方法，如果没有，它在编译阶段就会报错。注解一般有下面三个功能</p><ul><li>编译检查<ul><li>比如@Override</li></ul></li><li>代码分析<ul><li>读取注解的属性，然后使用反射技术进行分析</li></ul></li><li>编写文档<ul><li>比如javadoc</li></ul></li></ul><h2 id="系统自定的注解"><a href="#系统自定的注解" class="headerlink" title="系统自定的注解"></a>系统自定的注解</h2><p>下面介绍三个系统自定义的注解</p><ul><li>@Override<ul><li>检查方法是否是重写父类的方法</li></ul></li><li>@Deprecated<ul><li>将该注解标记的内容显示为已过时</li></ul></li><li>@SuppressWarnings(“all”)<ul><li>压制所有的警告</li></ul></li></ul><p>如果有一个方法被@Deprecated修饰了，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show ..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用时会这样</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java44.png"/></center><p>代表这个方法已经过时了，但是你想调用还是可以调用的。</p><p>在我们写代码时，经常会弹出一些警告，如</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java45.png"/></center><p>我们可以使用@SuppressWarnings(“all”)表示压制所有的警告</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java46.png"/></center><p>这时类里面所有的警告都压制了。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>要定义一个注解，首先我们看它的格式是什么</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实注解本质是一个接口，所以我们可以在里面定义抽象方法，这些抽象方法我们又把它叫做属性，这些抽象方法的返回值只能是下面这些类型</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul><p>下面定义了一个MyAnno的注解，里面有两个属性，name和age</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元注解暂时不必关注</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们使用MyAnno</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnno</span>(name=<span class="string">"小明"</span>,age=<span class="number">18</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show ..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解时，要为属性赋值，否则会报错，并且格式为属性名=值的形式，我们可以在MyAnno中设定默认值，这样在使用注解时就可以不赋值，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "小明"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br></pre></td></tr></table></figure><p>现在我们在使用时可以不赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnno</span>()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show ..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果注解里面只有一个属性，并且属性名为value，那么在使用注解时可以省略value直接赋值，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用时直接赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnno</span>(<span class="number">12</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show ..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的赋值为属性名 = {}的形式，如果里面只有一个值，那么花括号可以省略。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解就是描述注解的注解，这里只介绍两个</p><ul><li>@Target()<ul><li>表示注解能作用的位置，比如作用在类上</li><li>它有一个value属性，类型是ElementType枚举类型</li><li>我们一般使用TYPE, FIELD, METHOD分别表示能够作用在类、成员变量、方法上</li></ul></li><li>@RETENTION()<ul><li>表示注解被保留的阶段</li><li>它也有一个value属性，类型是RetentionPolicy枚举类型</li><li>我们一般使用RetentionPolicy.RUNTIME表示保留到运行时</li></ul></li></ul><h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p>在反射那里根据配置文件来创建一个类的对象，并且调用方法，现在我们将根据注解的属性来创建一个类的对象和调用相应的方法，现在有以下注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建类使用该注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnno</span>(className = <span class="string">"Animal"</span>, methodName = <span class="string">"eat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnno</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取该类的Class对象</span></span><br><span class="line">        Class&lt;TestAnno&gt; cla = TestAnno<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//获取注解 会在内存中生成一个该注解的子类实现对象</span></span><br><span class="line">        MyAnno an = cla.getAnnotation(MyAnno<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法会将属性值返回</span></span><br><span class="line">        String className = an.className();</span><br><span class="line">        String methodName = an.methodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据类名获取Class对象</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//使用无参构造方法创建对象</span></span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat ...</span><br></pre></td></tr></table></figure><p>这时我们只要改变注解的属性值，就可以创建任意类的对象，并且调用相应的方法。</p>]]></content>
    
    <summary type="html">
    
      讲解Java注解的基本知识及其使用
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="注解" scheme="https://lastknightcoder.gitee.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java异常</title>
    <link href="https://lastknightcoder.gitee.io/Java%E5%BC%82%E5%B8%B8/"/>
    <id>https://lastknightcoder.gitee.io/Java%E5%BC%82%E5%B8%B8/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的异常就是不正常，我们在之前很多地方有碰到异常，比如对象向下转型时有碰到ClassCastException。所有的异常都继承自Exception类。Exception下面有一个重要的的子类叫做RuntimeException。</p><p>异常分为编译期异常和运行时异常，如Exception就是编译期异常，而RuntimeException是运行时异常，如果在方法中抛出了一个编译期异常，那么必须处理该异常，继续向上抛出或者就地处理，而对于运行异常可以选择不处理，那么就会默认交给JVM处理。</p><h2 id="处理异常的过程"><a href="#处理异常的过程" class="headerlink" title="处理异常的过程"></a>处理异常的过程</h2><p>首先JVM检测到了异常，这时JVM会创建一个异常对象，该对象包含发生错误的内容、原因和位置。如果在发生异常处的方法内没有异常处理逻辑，那么JVM会把该异常抛给这个方法的调用者，如果该调用者也没有异常处理逻辑，那么就会一直向上抛出，直到遇到main方法，如果main方法也没有异常处理逻辑，那么这时异常就会抛给JVM，JVM会打印红色字体至控制台，并且终止Java程序的运行。</p><p>与异常有关的关键字有五个，分别为throw, throws, try, catch, finally。下面介绍这五个关键字的作用。</p><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>throw关键字用于在方法中抛出一个异常，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"除0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用是a/b，在检测到b=0时，我们抛出了一个异常，并给出提示信息”除0”。现在我们在main方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(divide(<span class="number">5</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>由于我们没有对异常进行处理，所以程序会进行终结并在控制台打印出信息：</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java32.png"/></center><p><strong>注意：</strong></p><ul><li><code>throw</code>必须写在方法的内部</li><li><code>new</code>的必须是<code>Exception</code>或其子类</li></ul><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>throws的作用是声明异常，或者说叫把异常抛给调用者，我们知道，编译期异常是必须要进行处理，那么处理的办法有两种，一种就是把继续向上抛出，另一种就是使用try-catch进行处理。而throws就是将异常继续抛出，现在我们将上面的ArithmeticException改为Exception，由于Exception为编译期异常，必须进行处理，否则编译不通过</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java33.png"/></center><p>由图片可以知道，由于我们没有对该异常处理，所以编译没有通过，我们这里的处理办法就是继续抛出</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java34.png"/></center><p>我们通过throws关键字抛出异常了，但是我们发现在main方法处又出现了问题，这是因为main方法没有处理divide()方法可能抛出的异常，因为divide()抛出的异常为编译期异常，必须进行处理，这里我们继续向上抛出，如下</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java35.png"/></center><p>这时代码就不会报错了。</p><p><strong>注意：</strong></p><ul><li>使用<code>throws</code>时可以抛出多个异常，异常与异常之间使用逗号隔开</li><li>如果抛出的多个异常具有父子类关系，那么抛出父类异常就可以了</li></ul><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>虽然我们通过throws可以向上抛出异常，但是如果不进行处理的话，最终还是会抛出给JVM，而JVM的处理方法就是打印异常信息然后终止程序。我们应该在异常发生时进行捕获，这个时候就不会将异常最终抛给JVM，程序就不会终止，而是会继续的执行下去。进行捕获的代码就是try-catch。具体格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;接收异常的变量&#125; &#123;</span><br><span class="line">    <span class="comment">//对异常进行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们重写上面的那个方法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//可能发生异常的代码</span></span><br><span class="line">            System.out.println(divide(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="comment">//这里对异常的处理只是将异常打印出来</span></span><br><span class="line">            <span class="comment">//处理异常后并不会终止程序，所以后面的代码还是可以执行</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"除0"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ArithmeticException: 除<span class="number">0</span></span><br><span class="line">后续代码</span><br></pre></td></tr></table></figure><p>可见后面的代码执行了。</p><p>Throwable(它是Exception的父类)中有三个处理异常的方法</p><ul><li>getMessage<ul><li>打印简短信息</li></ul></li><li>toString<ul><li>就是上面的直接打印对象</li></ul></li><li>printStackTrace<ul><li>JVM向控制台输出的信息就是调用这个方法，该方法打印的信息很全</li></ul></li></ul><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>其实在try-catch后面还可以跟一个finally块，我们知道如果没有发生异常的话，catch里面的代码块是不会执行的，而finally里的代码块，无论是是否抛出异常，都一定会执行的，所以finally里面的代码多用来释放资源的。我们来看一个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(divide(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"finally代码块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时是会抛出异常的，输出的结果为</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java36.png"/></center><p>可见finally里面的代码执行了，现在修改上面的代码为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(divide(<span class="number">5</span>,<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"finally代码块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时是不会抛出异常的，所以catch代码块里面的程序不会被执行，但是finally里面的代码始终会被执行，执行的结果为</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java37.png"/></center><p><strong>注意：</strong></p><ul><li>由于finally里面的代码一定是会执行的，所以要避免在finally里面写return语句，否则返回的一直是finally里面的结果。</li></ul><h2 id="多异常捕获"><a href="#多异常捕获" class="headerlink" title="多异常捕获"></a>多异常捕获</h2><h3 id="多次捕获，多次处理"><a href="#多次捕获，多次处理" class="headerlink" title="多次捕获，多次处理"></a>多次捕获，多次处理</h3><p>即使用多个try-catch语句块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常<span class="number">1</span> e) &#123;</span><br><span class="line">    <span class="comment">//处理异常1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常<span class="number">2</span> e) &#123;</span><br><span class="line">    <span class="comment">//处理异常2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="一次捕获，多次处理"><a href="#一次捕获，多次处理" class="headerlink" title="一次捕获，多次处理"></a>一次捕获，多次处理</h3><p>即一个try匹配多个catch</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常<span class="number">1</span> e) &#123;</span><br><span class="line">    <span class="comment">//处理异常1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常<span class="number">2</span> e) &#123;</span><br><span class="line">    <span class="comment">//处理异常2</span></span><br><span class="line">&#125; ...</span><br></pre></td></tr></table></figure><p>如果在try中发生了异常，那么首先会判断这个异常能不能被异常1接收，如果能那么就在第一个catch中进行处理，如果不能，那么就判断能不能被异常2接收，以此类推。</p><p>这里需要注意的点是，父类异常必须子类异常后面。假设父类异常写在前面，如果发生了子类异常，根据多态，父类能够接收这个异常，所以写在后面的子类异常永远接受=收不到这个异常，就相当于是死代码了。</p><h3 id="一次捕获，一次处理"><a href="#一次捕获，一次处理" class="headerlink" title="一次捕获，一次处理"></a>一次捕获，一次处理</h3><p>就是在catch中使用Exception变量接收异常，因为所有的异常都是Exception的子类，所以可以接收所有的异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子类注意事项"><a href="#子类注意事项" class="headerlink" title="子类注意事项"></a>子类注意事项</h2><p>如果父类方法抛出多个异常，子类重写了该方法，那么子类方法有三种方案</p><ul><li>抛出相同异常</li><li>抛出父类异常的子类</li><li>不抛出异常</li></ul><p>如果父类的方法没有抛出异常，那么子类重写的方法也不能抛出异常。该子类产生的异常只能try-catch捕获处理，不能使用throws抛出。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>自定义的异常必须继承一个异常类。如果继承的是Exception，那么该异常就是编译期异常，如果继承的是RuntimeException，那么就是运行时异常。下面简单的演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="comment">//一个空参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//一个带异常信息的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        divide(<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//继承至RuntimeException，是运行时异常，可以不进行处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"除0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java38.png"/></center>]]></content>
    
    <summary type="html">
    
      Java异常的简单介绍
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="异常" scheme="https://lastknightcoder.gitee.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java文件操作</title>
    <link href="https://lastknightcoder.gitee.io/Java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://lastknightcoder.gitee.io/Java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>File类代表的是文件或者文件夹(目录)，将目录和文件抽象为一个类。File提供了很多方法用来操作文件夹或者文件。下面具体介绍该类。</p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>File类有四个成员变量</p><ul><li>pathSeparator</li><li>pathSeparatorChar<ul><li>这两个保存的路径分隔符</li><li>Windows下为<code>;</code>，Linux下为<code>:</code></li></ul></li><li>separator</li><li>separatorChar<ul><li>这两个保存的是文件名称分隔符</li><li>Windows下为<code>\</code>反斜杠，Linux下为<code>/</code>正斜杠</li></ul></li></ul><p>下面看这个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(File.pathSeparator);</span><br><span class="line">        System.out.println(File.pathSeparatorChar);</span><br><span class="line"></span><br><span class="line">        System.out.println(File.separator);</span><br><span class="line">        System.out.println(File.separatorChar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">;</span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="File-String-pathname"><a href="#File-String-pathname" class="headerlink" title="File(String pathname)"></a>File(String pathname)</h4><ul><li>传入一个字符串类型，这个字符串为第一个路径名</li><li>传入的路径可以是绝对路径，也可以是相对路径</li><li>传入的路径可以存在，也可以不存在</li><li>可以是文件结尾，也可以是文件夹结尾<code>\</code></li></ul><p>下面来看看该方法的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">"G:\\JavaProject\\FirstProject"</span>); <span class="comment">//绝对路径写法</span></span><br><span class="line">System.out.println(file1);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"SecondProject"</span>); <span class="comment">//相对路径写法</span></span><br><span class="line">System.out.println(file2);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G:\JavaProject\FirstProject</span><br><span class="line">SecondProject</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>由于<code>\</code>代表的是转义，所以要写两个<code>\\</code></li><li>可见File类重写了toString()方法</li></ul><h4 id="File-String-parent-String-child"><a href="#File-String-parent-String-child" class="headerlink" title="File(String parent,String child)"></a>File(String parent,String child)</h4><ul><li>该构造方法需要传入两个参数，一个为父级目录的路径，一个为子级目录的路径</li><li>该种构造方法相比上面的要灵活一点</li></ul><p>下面示例使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String parent = <span class="string">"C:\\JavaProject\\"</span>;</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent,<span class="string">"FirstProject"</span>);</span><br><span class="line">System.out.println(file3);</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parent,<span class="string">"SecondProject"</span>);</span><br><span class="line">System.out.println(file4);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\JavaProject\FirstProject</span><br><span class="line">C:\JavaProject\SecondProject</span><br></pre></td></tr></table></figure><h4 id="File-File-parent-String-child"><a href="#File-File-parent-String-child" class="headerlink" title="File(File parent, String child)"></a>File(File parent, String child)</h4><ul><li>同上个构造方法，传入也是父级和子级的路径，不过传入的父级路径是一个File对象</li><li>这样可以调用File类的方法，更加灵活</li></ul><p>下面示例使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File parent = <span class="keyword">new</span> File(<span class="string">"C:\\JavaProject"</span>);</span><br><span class="line">File file5 = <span class="keyword">new</span> File(parent,<span class="string">"FirstProject"</span>);</span><br><span class="line">System.out.println(file5);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\JavaProject\FirstProject</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>按照功能不同分为了三类</p><ul><li>获取功能</li><li>判断功能</li><li>创建删除</li></ul><h4 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h4><p>与获取功能有关的方法有四个</p><ul><li>getAbsolutePath()<ul><li>获得文件或文件夹的绝对路径</li><li>不论在构造方法中传入的是绝对路径还是相对路径，获得都是绝对路径</li></ul></li><li>getPath()<ul><li>在构造方法中传入的是什么，返回的就是什么</li><li>toString()调用的就是这个方法</li></ul></li><li>getName()<ul><li>获得文件或文件夹的名称，即路径的结尾部分</li></ul></li><li>length()<ul><li>获得文件的长度，以字节为单位</li><li>如果该文件不存在，那么返回0</li></ul></li></ul><p>下面示例这四个方法的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"src\\Dog.java"</span>); <span class="comment">//传入的相对路径，获得是src目录下的Dog.java文件</span></span><br><span class="line">        <span class="comment">//打印绝对路径</span></span><br><span class="line">        System.out.println(file.getAbsolutePath()); <span class="comment">//G:\JavaProject\SecondProject\src\Dog.java</span></span><br><span class="line">        <span class="comment">//打印路径，传入什么打印什么</span></span><br><span class="line">        System.out.println(file.getPath()); <span class="comment">//src\Dog.java</span></span><br><span class="line">        <span class="comment">//获得文件的名称</span></span><br><span class="line">        System.out.println(file.getName()); <span class="comment">//Dog.java</span></span><br><span class="line">        <span class="comment">//获得文件的大小</span></span><br><span class="line">        System.out.println(file.length()); <span class="comment">//353</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h4><p>与判断功能有关的方法有三个</p><ul><li>exists()<ul><li>判断传入构造方法的路径是否存在</li></ul></li><li>isDirectory()<ul><li>判断是不是目录(文件夹)</li><li>如果路径不存在，无论是否为目录(文件夹)，返回false</li></ul></li><li>isFile()<ul><li>判断是否为文件</li><li>如果路径不存在，无论是否为文件，返回false</li></ul></li></ul><p>下面进行示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src\\Dog.java"</span>); <span class="comment">//传入的相对路径，获得是src目录下的Dog.java文件</span></span><br><span class="line"><span class="comment">//判断该路径是否存在</span></span><br><span class="line">System.out.println(file.exists()); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//是否为文件夹</span></span><br><span class="line">System.out.println(file.isDirectory()); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//是否为文件</span></span><br><span class="line">System.out.println(file.isFile()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h4><p>与创建和删除有关的方法有四个</p><ul><li>createNewFile()<ul><li>如果该文件不存在，则创建该文件，如果存在则不创建</li><li>返回布尔值，创建返回true</li><li>不能创建目录，所以该文件所在目录必须存在，否则会抛出异常</li></ul></li><li>delete()<ul><li>删除该类代表的文件或文件夹，直接从硬盘删除，不走文件夹，要小心</li><li>删除成功返回true</li></ul></li><li>makdir()<ul><li>创建由此File类代表的目录，只能创建单级目录</li></ul></li><li>makdirs()<ul><li>创建由此File类代表的目录，包括必需但不存在的父级目录</li></ul></li></ul><p>下面演示使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//D:\\目录下没有1.txt</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">"D:\\1.txt"</span>);</span><br><span class="line">        <span class="comment">//createNewFile使用了throws抛出异常，需要处理，我们在main中直接抛出即可</span></span><br><span class="line">        System.out.println(file1.createNewFile()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//D:\\下没有新建文件夹</span></span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\新建文件夹"</span>);</span><br><span class="line">        <span class="comment">//创建这个文件夹</span></span><br><span class="line">        System.out.println(file2.mkdir());  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        File file3 = <span class="keyword">new</span> File(<span class="string">"D:\\abc\\def"</span>); </span><br><span class="line">        <span class="comment">//创建多级目录</span></span><br><span class="line">        System.out.println(file3.mkdir()); <span class="comment">//不能创建 mkdir只能创建单级目录 false</span></span><br><span class="line">        System.out.println(file3.mkdirs()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面创建的文件及文件夹全部删除</span></span><br><span class="line">        System.out.println(file1.delete()); <span class="comment">//true</span></span><br><span class="line">        System.out.println(file2.delete()); <span class="comment">//true</span></span><br><span class="line">        System.out.println(file3.delete()); <span class="comment">//true abc这个文件夹还在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>为了遍历目录，有两个方法</p><ul><li>list()<ul><li>返回一个字符串数组，这些字符串是文件名或文件夹名</li></ul></li><li>listFiles()<ul><li>返回时的File类对象数组</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>上面两个方法，如果目录不存在或者不是目录，那么会抛出空指针异常</li><li>隐藏文件和文件夹也能获取到</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"G:\\JavaProject\\SecondProject\\src"</span>);</span><br><span class="line">String[] filename = file.list();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filename.length; i++) &#123;</span><br><span class="line">    System.out.println(filename[i]);</span><br><span class="line">&#125;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File file4 : files) &#123;</span><br><span class="line">    System.out.println(file4.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line">Dog.java</span><br><span class="line">Doudizhu.java</span><br><span class="line">GenericsDemo.java</span><br><span class="line">JustForFun.java</span><br><span class="line">MyException.java</span><br><span class="line">MyThread.java</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归就是在函数里面调用自己。</p><ul><li>递归必须要用终止条件，否则会不断的调用自己，造成栈内存溢出</li><li>递归的次数也不能太多，否则也会造成栈内存溢出</li><li>构造方法</li></ul><p>下面做几个小的练习来熟悉递归。</p><h3 id="递归练习"><a href="#递归练习" class="headerlink" title="递归练习"></a>递归练习</h3><p>第一个练习是根据函数接收的参数$n$，来计算$1 + 2  … + n$，因为我们是从递归的角度看，所以应当这么看<br>$$<br>sum(n) = \begin{cases}1, &amp;if ,, n =1 \\<br>n + sum(n - 1), &amp;if ,,n &gt; 1 \end{cases}<br>$$</p><p>所以程序我们应该这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里没有考虑输入为负数时的处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中调用该方法测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = sum(<span class="number">100</span>);</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><p>可见程序是正确的。</p><p>第二个练习是计算阶乘，思路同上面完全是一样的<br>$$<br>fac(n) = \begin{cases}1, &amp;if ,, n =0 \\<br>n * fac(n - 1), &amp;if ,,n &gt; 1 \end{cases}<br>$$</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中调用测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = fac(<span class="number">5</span>);</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><h3 id="文件夹遍历"><a href="#文件夹遍历" class="headerlink" title="文件夹遍历"></a>文件夹遍历</h3><p>下面使用递归来实现文件夹的遍历，我们getFile()文件来进行文件夹的遍历，它接收一个File对象作为参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file1 : files) &#123;</span><br><span class="line">        System.out.println(file1.getName());</span><br><span class="line">        <span class="comment">//如果是文件夹的，就遍历该文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (file1.isDirectory()) &#123;</span><br><span class="line">            getFile(file1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在D盘下新建了一个Test文件夹，它的目录结构如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test</span><br><span class="line">a</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">b</span><br><span class="line">c.txt</span><br><span class="line">d.txt</span><br></pre></td></tr></table></figure><p>我们在main方法中遍历该文件夹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getFile(<span class="keyword">new</span> File(<span class="string">"D:\\Test"</span>));</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">b</span><br><span class="line">c.txt</span><br><span class="line">d.txt</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>listFiles其实还可以接收一个叫做过滤器的参数。这个过滤器是一个接口，分为有FileFilter和FilenameFilter两个接口，这两个接口里面都只有一个方法accept()，listFiles会调用这个方法，将它获得的路径传入该方法中，如果得到的结果为true，那么就保留这个路径在最终返回的数组中，如果返回的是false，那么就不要这个路径。可见这样就起到了文件过滤的作用，而过滤什么样的文件，需要什么样的文件，完全由accept()方法决定，所以这也是它们为什么叫做过滤器的原因。</p><h3 id="FileFilter"><a href="#FileFilter" class="headerlink" title="FileFilter"></a>FileFilter</h3><p>下面来介绍FileFilter，FileFilter里面的accept(File pathname)接收一个参数，这个参数就是路径名，listFiles()会将它获得的路径传入accept()，accept()进行过滤，以决定要什么样的路径。下面我们做一个示范，打印出一个图片文件夹里面以.png结尾的图片</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入的是图片文件夹的路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPNG</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为接口里面只要一个方法，所以这里使用Lambda表达式</span></span><br><span class="line">    File[] files = file.listFiles(pathname -&gt; &#123;</span><br><span class="line">        <span class="comment">//判断是不是以.png结尾</span></span><br><span class="line">        <span class="keyword">boolean</span> b = pathname.getName().endsWith(<span class="string">".png"</span>);</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="comment">//如果是以.png结尾，则加入到files数组中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//打印files数组，查看结果是否正确</span></span><br><span class="line">    <span class="keyword">for</span> (File fi : files) &#123;</span><br><span class="line">        System.out.println(fi.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在main方法调用测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printPNG(<span class="keyword">new</span> File(<span class="string">"D:\\images"</span>));</span><br></pre></td></tr></table></figure><p>打印输出为</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java39.png"/></center><p>可见只有.png结尾的图片才被放入了files数组中。</p><h3 id="FilenameFilter"><a href="#FilenameFilter" class="headerlink" title="FilenameFilter"></a>FilenameFilter</h3><p>它的accept(File dir, String name)接收两个参数，其余的与FileFilter相同，下面就同样的功能演示其代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPNGAgain</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    File[] files = file.listFiles(((dir, name) -&gt; &#123;</span><br><span class="line">        <span class="comment">//根据dir和name创建一个File对象</span></span><br><span class="line">        <span class="comment">//后面的代码完全同上面一样</span></span><br><span class="line">        File newFile = <span class="keyword">new</span> File(dir,name);</span><br><span class="line">        <span class="keyword">boolean</span> b = newFile.getName().endsWith(<span class="string">".png"</span>);</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">for</span> (File fi : files) &#123;</span><br><span class="line">        System.out.println(fi.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printPNGAgain(<span class="keyword">new</span> File(<span class="string">"D:\\images"</span>));</span><br></pre></td></tr></table></figure><p>输出同上面一模一样</p><center>     <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java39.png"/></center><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>下面介绍两个类用来从文件中读取数据和写入数据到文件的类。不管是读取数据还是写入数据，都是以字节为单位的。</p><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>该类可以将内存中的数据写入到文件中。OutputStream类是一个抽象类，我们可以使用它的子类FileOutputStram，它的构造方法中传入的参数可以是一个File对象，也可以是一个代表路径的字符串。它里面主要有以下方法</p><ul><li>write(byte b)<ul><li>写入一个字节到文件中</li></ul></li><li>write(byte[] bytes)<ul><li>将一个字节数组写入到文件中</li><li>如果传入的byte是一个负数，那么该数与其后面的那个字节组成一个中文</li></ul></li><li>write(byte[] bytes, int off, int len)<ul><li>写入字节数组索引从off开始，长度为len字节的数据</li></ul></li><li>close()<ul><li>关闭流</li></ul></li></ul><p>下面示例其使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有a.txt，会创建一个a.txt新文件</span></span><br><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>)); <span class="comment">//可以传入"a.txt"字符串</span></span><br><span class="line">fos.write(<span class="number">97</span>); <span class="comment">//写入a</span></span><br><span class="line"><span class="comment">//\r\n代表 回车换行</span></span><br><span class="line">fos.write(<span class="string">"\r\n"</span>.getBytes()); <span class="comment">//String类的getBytes()方法可以得到一个byte数组</span></span><br><span class="line">fos.write(<span class="string">"abc"</span>.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>上面的程序是会把原来文件里面的内容情空，然后将数据写入了，如果想向文件中追加数据的话，那么就要在构造方法的第二个参数传入true，代表是追加。如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>), <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>与OutputStream相对的，该类的作用是读取文件中的内容，一般我们使用的是其子类FileInputStream，构造方法同OutputStream，包含的方法有</p><ul><li>read()<ul><li>读取一个字节并返回，如果读到了文件的末尾，那么返回-1，我们可以通过返回的是否是-1来判断是否已经读到了文件的末尾</li></ul></li><li>read(byte[] bytes)<ul><li>读取bytes大小的字节，返回的是读取的有效位数</li><li>假如文件有5个字节，我用长度为6的字节数组去读取，那么返回的就是5</li><li>如果已经读到了文件的末尾，不是返回0，而是返回-1。</li></ul></li><li>close()<ul><li>关闭流</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>)); <span class="comment">//可以传入"a.txt"字符串</span></span><br><span class="line"><span class="keyword">int</span> len = fis.read(); <span class="comment">//读取一个字符，读取的虽然是byte，但是返回时会被提升为int，所以用用int接收</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><p>综合读取数据和写入数据，我们通过这两个流复制一个文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"copy.jpg"</span>));</span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"a.jpg"</span>));</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">//用来读取数据的数组，也是写数据的数组</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 判断是否读取完毕</span></span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fos.write(bytes,<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先关闭写的流，因为写完了，说明肯定读完了</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字节流是一个字节一个字节读取的，但是对于中文，如果使用GBK编码的话由2个字节组成，如果使用UTF-8编码的话由3个字节组成。所以如果一个字节进行读取的话就得不到想要的字符。那么这里就需要引入一个新的流来读取字符，以字符为单位进行读取。</p><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>Reader就相当于是InputStream，它的作用就是从文件中读取数据到内存，不过不同的是，Reader读取的最小单位为字符，它的构造方法与InputStream一样，包含的方法也一样，不过参数有所不同，不在是字节，而是字符。Reader也是一个抽象类，我们在这里常使用它的子类FileReader。我们在本目录下新建一个文件b.txt，在里面写入你好，使用UTF-8编码(不要使用GBK)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"b.txt"</span>); <span class="comment">//也可以传入一个File对象</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((c = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">你</span><br><span class="line">好</span><br></pre></td></tr></table></figure><p>FileReader其实也有新建一个字节流去读取数据，不过中间有一个将字节转为字符的过程，转换默认是按照UTF-8的方式解码的，所以如果你在Windows下直接新建文件，默认是GBK的，这样读取就会是乱码，可以直接在IDEA中新建文件，默认为UTF-8编码。</p><p>如果我们读取得到了一个字符数组，我们可以使用String类的构造方法</p><ul><li>String(char[] value)</li><li>String(char [] value, int off, int len)</li></ul><p>将字符数组转化为字符串，方便处理。</p><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p>Writer就是向文件中写入一个字符，同OutputStream不同，Writer有一个特有的方法</p><ul><li>flush()<ul><li>该方法的作用是将缓存区里的内容写入到文件中</li></ul></li></ul><p>这是怎么回事，其实Writer的底层是创建一个了字节流写数据的，我们直接写入字符不是直接写在文件中，而是写在缓冲区中，然后缓冲区中的内容转化为字节写入文件中。在调用close()，在关闭流之前，会把缓冲区中的内容写到文件中，如果既没有调用flush()也没有调用close()，那么写入的数据不会写入文件中。</p><p>还有一个方法是</p><ul><li>write(String str [, int off, int len])<ul><li>可以直接写入字符串，不用写字符数组那么麻烦了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有c.txt，那么会新建一个</span></span><br><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c.txt"</span>);  <span class="comment">//也可以传入一个File对象</span></span><br><span class="line"><span class="comment">//写入的默认是utf-8编码</span></span><br><span class="line">writer.write(<span class="string">"你好啊"</span>);</span><br><span class="line"><span class="comment">//如果不调用close()，那么c.txt里面什么都没有</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>同OutputStream一样，这里的write也是覆盖重写，如果想要只是追加数据的话，在构造方法的第二个参数传入true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c.txt"</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="Properties属性集"><a href="#Properties属性集" class="headerlink" title="Properties属性集"></a>Properties属性集</h2><p>Properties是继承至HashTable的一个集合。它是与IO流关联起来的，通过load()和store()方法可以读取特定格式的文件数据，和将Properties集合中的数据写入到文件中。</p><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>下面介绍将Properties中的数据写入到文件中。首先介绍如何向Properties集合中添加数据</p><ul><li>setProperty(String key, String value)</li></ul><p>Properties集合中的键和值都是String类型的。store()分为两种，一种是字节流，传入的是OutputStream对象，一种是字符流，传入的是Writer对象</p><ul><li>store(OutputStream in, String comment)</li><li>store(Writer writer, String comment)</li></ul><p>第二个参数String comment是注释，写入文件会写在第一行，并且以#开头，一般我们传入一个空字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"18"</span>);</span><br><span class="line">properties.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"17"</span>);</span><br><span class="line">properties.store(<span class="keyword">new</span> FileWriter(<span class="string">"properties.txt"</span>), <span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>properties.txt文件里面的内容为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line">#Fri Aug 09 11:28:20 CST 2019</span><br><span class="line">古力娜扎=<span class="number">18</span></span><br><span class="line">迪丽热巴=<span class="number">17</span></span><br></pre></td></tr></table></figure><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>在介绍load()之前，说明一下如何获取Properties中的元素</p><ul><li>getProperty(String key)<ul><li>通过键获取值，相当于Map中的get()</li></ul></li><li>stringPropertiesName()<ul><li>相当于Map中的 keySet()，返回一个Set集合，泛型为String</li></ul></li></ul><p>下面介绍load()方法，load()就是读取指定格式的文件，比如，指定格式如下两种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">古力娜扎=<span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">古力娜扎 <span class="number">18</span></span><br></pre></td></tr></table></figure><p>中间的分隔符可以使用=或者空格，如果碰到以#开头的，则不会读取，我们来读取刚刚写的properties.txt文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">properties.load(<span class="keyword">new</span> FileReader(<span class="string">"properties.txt"</span>));</span><br><span class="line">Set&lt;String&gt; propertiesName = properties.stringPropertyNames();</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String name : propertiesName) &#123;</span><br><span class="line">    System.out.println(name+<span class="string">"="</span>+properties.getProperty(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">古力娜扎=<span class="number">18</span></span><br><span class="line">迪丽热巴=<span class="number">17</span></span><br></pre></td></tr></table></figure><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>之前我们使用过字节流InputStream和OutputStream进行过文件复制的练习，但是其实我们可以发现，使用这两个流的速度很慢，所以这里就引入了缓冲流BufferedInputStream和BufferedOutPutStream，还有BufferedReader和BufferedWriter。为了感受字节流和缓冲流的差异，我们这次来复制一个1MB的文件。</p><h3 id="字节流复制"><a href="#字节流复制" class="headerlink" title="字节流复制"></a>字节流复制</h3><p>首先使用字节流，一个字节一个字节的读取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"file.pdf"</span>);</span><br><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.pdf"</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fos.write(len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时"</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">共耗时<span class="number">11738</span>毫秒</span><br></pre></td></tr></table></figure><p>现在还是使用字节流，不过一次读取1KB</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"G:\\JavaProject\\ThirdProject\\src\\file.pdf"</span>);</span><br><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.pdf"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//存储读取的有效位数</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">//读取1KB</span></span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">共耗时<span class="number">203</span>毫秒</span><br></pre></td></tr></table></figure><h3 id="缓冲流复制"><a href="#缓冲流复制" class="headerlink" title="缓冲流复制"></a>缓冲流复制</h3><p>这次使用缓冲流，先一个字节一个字节的读取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">BufferedInputStream buffis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"file.pdf"</span>));</span><br><span class="line">BufferedOutputStream buffos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.pdf"</span>));</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = buffis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    buffos.write(len);</span><br><span class="line">&#125;</span><br><span class="line">buffos.close();</span><br><span class="line">buffis.close();</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时"</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">共耗时<span class="number">94</span>毫秒</span><br></pre></td></tr></table></figure><p>这次一次读取一1KB</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">BufferedInputStream buffis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"file.pdf"</span>));</span><br><span class="line">BufferedOutputStream buffos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.pdf"</span>));</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = buffis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    buffos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">buffos.close();</span><br><span class="line">buffis.close();</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时"</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">共耗时<span class="number">16</span>毫秒</span><br></pre></td></tr></table></figure><p>下面我来做一个表格总结一下速度</p><table><thead><tr><th></th><th>缓冲流(ms)</th><th>字节流(ms)</th></tr></thead><tbody><tr><td>1MB</td><td>94</td><td>11738</td></tr><tr><td>1KB</td><td>16</td><td>203</td></tr></tbody></table><p>从这些数据看，就知道缓冲流的速度比字节流的快很多。</p><h3 id="缓冲流的一些特有方法"><a href="#缓冲流的一些特有方法" class="headerlink" title="缓冲流的一些特有方法"></a>缓冲流的一些特有方法</h3><p>缓冲流提供了几个特有的方法，如BufferedOutputStream和BufferedReader中有一个方法为</p><ul><li>readline()<ul><li>一次读取一行数据，读到的数据不包括换行符</li><li>如果读到了末尾，那么返回null</li></ul></li></ul><p>BufferedInputStream和BufferedWriter也提供了一个方法叫做</p><ul><li>newline()<ul><li>作用是换行，可以根据不同的操作系统进行换行</li><li>之前我们写的<code>\r\n</code>只适用于Windows系统</li></ul></li></ul><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>我们在使用字符流时，只能读取UTF-8格式的文件，写出的数据的格式也是UTF-8的，现在假设我要读取一个GBK的文件，里面有中文”你好”，看看会发生什么。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"text.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><p>发现读取的只是乱码</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java40.png"/></center><p>这是因为FileReader是按照UTF-8的格式读取的，但是文件的格式却是GBK，编码不一样，那么解码当然会出问题。所以就有了转换流的出现，有两个类是做这件事情的，分别是InputStreamReader和OutputStreamWriter，它们的构造方法是</p><ul><li>InputStreamReader(InputStream in, String charset)</li><li>OutputStreamWriter(OutputStream out, String charset)</li></ul><p>第二个参数就是用来指定字符集的，如果不指定字符集的话，就默认为UTF-8。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path = <span class="string">"text.txt"</span>;</span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path), <span class="string">"gbk"</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) len);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">你好</span><br></pre></td></tr></table></figure><p>下面做一个小的练习，将一个GBK格式的文件转换为一个UTF-8格式的文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path = <span class="string">"text.txt"</span>;</span><br><span class="line"><span class="comment">//也可写成GBK</span></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path), <span class="string">"gbk"</span>); </span><br><span class="line"><span class="comment">//不指定字符集的话，默认为UTF-8(utf-8)</span></span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    writer.write(len);</span><br><span class="line">&#125;</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><h2 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h2><p>如果我们想将对象保存在硬盘中怎么办? 因为一旦断电，内存中的对象就会全部的消失。这个时候就需要序列流将对象保存在文件中，对应也有相应的序列流读取文件得到一个对象。</p><ul><li>ObjectOutputStream<ul><li>将文件写到文件中的类</li><li>writeObject(Object o)<ul><li>该方法将对象写到文件中</li></ul></li></ul></li><li>ObjectInputStream<ul><li>从文件中读取对象的类</li><li>readObject()<ul><li>将文件中的对象读取出来，返回一个Object对象</li></ul></li></ul></li></ul><p>下面介绍使用及注意事项。首先创建一个Person类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> IOProject</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在测试类中创建一个对象，并使用ObjectOutputStream类的对象将这个对象写到文件中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person"</span>));</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">oos.writeObject(p);</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure><p>这时抛出了一个异常</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java41.png"/></center><p>这时因为Person没有实现Serializable接口，这里谈第一个注意事项</p><ul><li>只有实现了Serializable接口才能将其对象序列化和反序列化</li><li>Serilaizable是一个标志性接口，所谓的标志性指的是只起一个标志的作用，Serializable接口里面什么都没有，我们不需要实现任何的方法</li></ul><p>现在将Person实现Serializable接口然后执行上面的程序就不会有问题了。</p><p>下面使用ObjectInputStream读取刚刚序列化的对象，这个过程叫做反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person"</span>));</span><br><span class="line">Object o = ois.readObject();</span><br><span class="line">System.out.println(o);</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;age=<span class="number">18</span>, name=<span class="string">'迪丽热巴'</span>&#125;</span><br></pre></td></tr></table></figure><p>说明我们读取成功了。</p><p>下面添加几个注意事项</p><ul><li>static修饰的静态变量不能进行序列化</li><li>被transient修饰的成员变量也不能进行序列化</li><li>如果对象序列化后，修改了类文件，那么不能被序列化</li></ul><p>现在我们修改Person类中的age使用transient修饰，进行序列化和反序列化操作，得到的结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;age=<span class="number">0</span>, name=<span class="string">'迪丽热巴'</span>&#125;</span><br></pre></td></tr></table></figure><p>age = 0并不等于18，说明age没有被序列化到文件中。</p><p>现在我们将Person类的对象序列化，然后修改Person类，接着在反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread "main" java.io.InvalidClassException: IOProject.Person; local class incompatible: stream classdesc serialVersionUID = -774581383406272369, local class serialVersionUID = -4004215360553243182</span><br><span class="line">at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">699</span>)</span><br><span class="line">at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1885</span>)</span><br><span class="line">at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1751</span>)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2042</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1573</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">431</span>)</span><br><span class="line">at IOProject.TestSerial.main(TestSerial.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>抛出了一个异常InvalidClassException，这是因为它们的serialVersionUID对不上。serialVersionUID是根据类文件自动计算的，当我们修改类文件时，serialVersionUID发生了改变，当我们反序列化时会比较serialVersionUID，由于这时它们的serialVersionUID不同，所以抛出了这个异常。我们可以在类里面为这个变量赋一个固定的值，这样serialVersionUID就不会发送改变，但是赋值也是有要求的</p><ul><li>必须使用final static long修饰</li></ul><p>我们在Person类中加入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>然后执行上面的操作，发现没有问题。输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;age=<span class="number">18</span>, name=<span class="string">'迪丽热巴'</span>&#125; <span class="comment">//这里age没有使用transient修饰</span></span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>PrintStream是一个有关于打印流的类，我们一直使用的System.out其中的out就是一个PrintStream对象，下面是其在System类中的定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>打印流有以下的特点</p><ul><li>它只负责数据的输出</li><li>永不抛出IOExecption</li><li>它继承了OutputStream类</li><li>它有自己的特有方法，如print(), println()，这两个方法可以打印出任意的数据类型</li><li>当它调用OutputStream类的方法write()时，打印数据时会查编码表，如write(97)会打印出a，但是print(),println()方法输入什么，打印出什么，如print(97)打印出97。</li></ul><p>下面简单介绍使用，首先看PrintStream的构造方法</p><ul><li>PrintStream(File file)</li><li>PrintStream(OutputStream out)</li><li>PrintStream(String filename)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream printStream = <span class="keyword">new</span> PrintStream(<span class="string">"a.txt"</span>);</span><br><span class="line">printStream.write(<span class="number">97</span>);</span><br><span class="line">printStream.println(<span class="number">97</span>);</span><br><span class="line">printStream.println(<span class="number">22.2</span>);</span><br><span class="line">printStream.println(<span class="keyword">true</span>);</span><br><span class="line">printStream.println(<span class="string">'a'</span>);</span><br><span class="line">printStream.println(<span class="string">"abc"</span>);</span><br><span class="line">printStream.close();</span><br></pre></td></tr></table></figure><p>打开a.txt文件，里面的内容为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a97</span><br><span class="line"><span class="number">22.2</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">a</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>System类有一个方法setOut(PrintStream out)，可以用来改变System.out的指向，这样打印出的内容不会在控制台显示，而是会在文件中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream printStream = <span class="keyword">new</span> PrintStream(<span class="string">"a.txt"</span>);</span><br><span class="line">System.setOut(printStream);</span><br><span class="line">System.out.println(<span class="string">"怎么了，你累了，说好的幸福呢？"</span>);</span><br></pre></td></tr></table></figure><p>运行程序发现控制台没有任何的输出</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java42.png"/></center><p>而在a.txt中出现了打印的语句。</p>]]></content>
    
    <summary type="html">
    
      Java文件操作的简单介绍
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="文件" scheme="https://lastknightcoder.gitee.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="File" scheme="https://lastknightcoder.gitee.io/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="https://lastknightcoder.gitee.io/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://lastknightcoder.gitee.io/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程主要是客户端与服务器之间的交互，与客户端有关的类是Socket，与服务器有关的类是ServerSocket。客户端与服务器之间的通信主要是通过字节流实现的，客户端Socket含有方法</p><ul><li>getInputStream()</li><li>getOutputStream()</li></ul><p>来获得流，而服务器通过accept()监听请求的客户端，该方法返回一个Socket类对象，这个对象就是访问的客户端，服务器通过这个Socket获得流，通过该流与客户端通信。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>客户端Socket类的构造方法为</p><ul><li>Socket(String host, int port)<ul><li>第一个参数为域名地址或者IP地址</li><li>第二个参数为端口号</li></ul></li></ul><p>服务器端ServerSocket的构造方法为</p><ul><li>ServerSocket(int port)<ul><li>这个参数为端口号</li></ul></li></ul><h2 id="客户端与服务器之间的简单通信"><a href="#客户端与服务器之间的简单通信" class="headerlink" title="客户端与服务器之间的简单通信"></a>客户端与服务器之间的简单通信</h2><p>下面写一个简单的示例来进行客户端与服务器的通信。</p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端对象socket 服务器IP地址为127.0.0.1，代表本机 端口号为8888</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//获得输出流以便向服务器发送信息</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//向服务器发送信息</span></span><br><span class="line">        os.write(<span class="string">"这里是客户端"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得输入流，以接收服务器返回的信息</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//读取服务器返回的信息并打印</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个服务器对象</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//通过accept()方法获得客户端对象</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//通过客户端对象获得输入流，已读取客户端发送的消息</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//读取客户端发送的消息并打印</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过客户端对象获得输出流，以便发送消息给客户端</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"收到了，谢谢"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行服务器端的程序，然后运行客户端的程序，服务器的输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里是客户端</span><br></pre></td></tr></table></figure><p>客户端的输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">收到了，谢谢</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>将本地的文件传输到服务器，其实原理就是文件的复制，之前我们写过，不过现在是使用网络流来实现，下面是代码，说明都在代码的注释中。</p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientUpload</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流读取要上传的文件</span></span><br><span class="line">        InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"upload.pdf"</span>);</span><br><span class="line">        <span class="comment">//创建客户端对象</span></span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读取文件，并将文件通过socket的输出流传给服务器</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        OutputStream os = client.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于read不会将最后读取到-1发送，那么服务器就得不到-1，就不会终止</span></span><br><span class="line">        <span class="comment">//就会进入死循环，所以下面的代码是写入终止符，你可以把下面这行代码去掉，看看会发生什么</span></span><br><span class="line">        client.shutdownOutput();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得输入流以便获得服务器的返回信息</span></span><br><span class="line">        InputStream is = client.getInputStream();</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerUpload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获得输出流，将上传的文件写到服务器的硬盘中</span></span><br><span class="line">        OutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"uploadServer.pdf"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得输入流读取客户端发送的数据</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//读到-1才会终止，所以客户端最后要发一个终止符-1，否则会不断循环</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向客户端返回数据"已经上传完成"</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"已经上传完成"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      基础的网络编程的知识
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="网络编程" scheme="https://lastknightcoder.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://lastknightcoder.gitee.io/Java%E5%8F%8D%E5%B0%84/"/>
    <id>https://lastknightcoder.gitee.io/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>反射是框架设计的灵魂，通过反射我们可以在程序运行时读取配置文件动态的创建一个类，也可以通过读取注解来达到我们想到的功能。与反射有关的类是Class类。</p><a id="more"></a><h3 id="Class类对象的获取方法"><a href="#Class类对象的获取方法" class="headerlink" title="Class类对象的获取方法"></a>Class类对象的获取方法</h3><p>Class类对象的获取方法有三种</p><ul><li>Class.forName(String name)<ul><li>参数是类的全类名(包名+类名)，可以获得该类的Class对象</li></ul></li><li>类名.class<ul><li>通过类的静态属性class可以获取Class对象</li></ul></li><li>对象.getClass()<ul><li>通过对象的getClass()方法可以获取Class对象</li></ul></li></ul><p>假设一个Animal类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat "</span> + string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sleep ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要通过上面的三种方法获取该类的Class对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过全类名获取Class对象</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"Animal"</span>);</span><br><span class="line"><span class="comment">//通过类的静态属性class获取Class对象</span></span><br><span class="line">Class cls2 = Animal<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//通过对象的getClass()获取静态对象</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">Class cls3 = animal.getClass();</span><br></pre></td></tr></table></figure><p>另外需要注意的是，通过上面三种方法获取的Class对象是同一个对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cls1 == cls2); <span class="comment">//true</span></span><br><span class="line">System.out.println(cls1 == cls3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="Class类的常见成员方法"><a href="#Class类的常见成员方法" class="headerlink" title="Class类的常见成员方法"></a>Class类的常见成员方法</h3><h4 id="与成员变量有关的方法"><a href="#与成员变量有关的方法" class="headerlink" title="与成员变量有关的方法"></a>与成员变量有关的方法</h4><ul><li>getFields()<ul><li>获取public修饰的所有成员变量，返回一个Field[]</li></ul></li><li>getField(String name)<ul><li>获取指定名称被public修饰的成员变量</li></ul></li><li>getDeclaredFields()<ul><li>同getFields()，不过任意修饰符修饰的都可以获取</li></ul></li><li>getDeclaredField(String name)<ul><li>同getField(String name)，不过任意修饰符修饰的都可以获取</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields1 = cls1.getFields();</span><br><span class="line"><span class="comment">//public java.lang.String Animal.name</span></span><br><span class="line"><span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">Field[] fields2 = cls1.getDeclaredFields();</span><br><span class="line"><span class="comment">//public java.lang.String Animal.name</span></span><br><span class="line"><span class="comment">//private int Animal.age</span></span><br><span class="line"><span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">Field field1 = cls1.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//private int Animal.age</span></span><br><span class="line">System.out.println(field1);</span><br></pre></td></tr></table></figure><p>可以通过set(Object obj, Object value)方法对指定的对象设定值，也可以通过get(Object obj)方法来获取值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field field2 = cls1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">field2.set(animal,<span class="string">"Dog"</span>);</span><br><span class="line">System.out.println(animal.name); <span class="comment">//Dog</span></span><br><span class="line">System.out.println(field2.get(animal)); <span class="comment">//Dog</span></span><br></pre></td></tr></table></figure><p>如果我们要对age进行赋值，因为age变量是private修饰的，是不能在类外面直接访问的，我们可以调用setAccessible(true)方法，来忽略访问修饰符的安全检查(暴力反射)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field field1 = cls1.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(animal,<span class="number">10</span>);</span><br><span class="line">System.out.println(field1.get(animal)); <span class="comment">//10</span></span><br><span class="line"><span class="comment">//System.out.println(animal.age); //会报错，不能这么访问</span></span><br></pre></td></tr></table></figure><h4 id="与构造方法有关的方法"><a href="#与构造方法有关的方法" class="headerlink" title="与构造方法有关的方法"></a>与构造方法有关的方法</h4><ul><li>getConstructors()<ul><li>得到由public修饰的所有构造方法</li></ul></li><li>getConstructor()<ul><li>获取指定参数的构造函数，如<ul><li>getConstructor()：获取无参构造函数</li><li>getConstructor(String.class, int.class)：获得第一个参数类型为String类型和第二个参数类型为int类型的构造方法</li></ul></li></ul></li><li>cls1.getDeclaredConstructors()<ul><li>参照Field</li></ul></li><li>cls1.getDeclaredConstructor()<ul><li>参照Field</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得无参的构造方法</span></span><br><span class="line">Constructor cons1 = cls1.getConstructor();</span><br><span class="line">Stream.of(cons1).forEach(System.out::println); <span class="comment">//public Animal()</span></span><br><span class="line"><span class="comment">//获得参数类型分别为String类型和int类型的构造方法</span></span><br><span class="line">Constructor cons2 = cls1.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Stream.of(cons1).forEach(System.out::println); <span class="comment">//public Animal()</span></span><br></pre></td></tr></table></figure><p>现在获得了构造方法，那么构造方法的作用就是创造对象，我们可以通过Contructor对象的的newInstance()方法创建一个对象，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//newInstance方法返回的是一个Object对象</span></span><br><span class="line">Animal animal1 = (Animal) cons1.newInstance();</span><br><span class="line">Animal animal2 = (Animal) cons2.newInstance(<span class="string">"Cat"</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(animal1);</span><br><span class="line">System.out.println(animal2);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal&#123;name=<span class="string">'null'</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Animal&#123;name=<span class="string">'Cat'</span>, age=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>如果想创建一个无参的对象，可以直接通过Class对象的newInsatance()方法创建，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal3 = (Animal) cls1.newInstance();</span><br></pre></td></tr></table></figure><h4 id="与成员方法有关的方法"><a href="#与成员方法有关的方法" class="headerlink" title="与成员方法有关的方法"></a>与成员方法有关的方法</h4><ul><li>getMethods<ul><li>获取所有public修饰的方法</li></ul></li><li>getMethod()<ul><li>通过方法名和参数类型(区别重载的方法)获取public修饰的指定方法</li></ul></li><li>getDeclaredMethods<ul><li>忽略修饰符</li></ul></li><li>getDeclaredMethod<ul><li>忽略修饰符</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取不带参数的eat方法</span></span><br><span class="line">Method eat1 = cls1.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"><span class="comment">//获取带一个参数类型为String的eat方法</span></span><br><span class="line">Method eat2 = cls1.getMethod(<span class="string">"eat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//获取private修饰的sleep方法</span></span><br><span class="line">Method sleep = cls1.getDeclaredMethod(<span class="string">"sleep"</span>);</span><br></pre></td></tr></table></figure><p>获取到了方法，那么接下来就是怎么使用的问题，我们可以使用invoke()方法来执行方法，需要传入相应的对象和需要的参数，如果方法不需要参数，那么可以不传，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat1.invoke(animal);</span><br><span class="line"><span class="comment">//需要传入参数</span></span><br><span class="line">eat2.invoke(animal,<span class="string">"饭"</span>);</span><br><span class="line"><span class="comment">//因为sleep是private修饰的，要执行就要执行下面这一步</span></span><br><span class="line">sleep.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">sleep.invoke(animal);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat ...</span><br><span class="line">eat 饭</span><br><span class="line">sleep ...</span><br></pre></td></tr></table></figure><p>我们还可以通过getName()方法获得方法名，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(eat1.getName()); <span class="comment">//eat</span></span><br></pre></td></tr></table></figure><p>我们可以通过Class对象的getName()方法获得该类的全类名(包名+类名)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cls1.getName()); <span class="comment">//Animal</span></span><br></pre></td></tr></table></figure><h3 id="使用反射读取配置文件动态创建任意的对象"><a href="#使用反射读取配置文件动态创建任意的对象" class="headerlink" title="使用反射读取配置文件动态创建任意的对象"></a>使用反射读取配置文件动态创建任意的对象</h3><p>我们现在有这么一个需求，那就是希望创建任意一个类的对象，并且调用相应的方法，要求不能更改代码，而只需要更改配置文件即可。现在我们创建一个config.properties的配置文件，内容如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">className=Animal</span><br><span class="line">methodName=eat</span><br></pre></td></tr></table></figure><p>我们要做的就是读取配置文件，然后根据配置文件创建相应类的对象并且调用其方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建Properties读取配置文件</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        pro.load(<span class="keyword">new</span> FileReader(<span class="string">"G:\\JavaProject\\Fourth\\src\\config.properties"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得类名和方法名</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据类名获取Class对象</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//使用无参构造方法创建对象</span></span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们运行一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat ...</span><br></pre></td></tr></table></figure><p>现在我们要创建什么类的对象并且要调用什么方法，只需要修改配置文件就可以了，不用修改代码了。虽然还有很多的问题，比如只能使用无参构造方法创建对象，只能调用无参的方法，不过即使是这样也让我们感受到了反射的强大。</p>]]></content>
    
    <summary type="html">
    
      介绍Java反射技术的基本使用
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="反射" scheme="https://lastknightcoder.gitee.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2019-07-13T16:00:00.000Z</published>
    <updated>2019-07-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章会介绍<code>Java 8</code>中的一些新特性(不包括<code>Lambda</code>表达式，因为在<a href="https://lastknightcoder.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">Java多线程</a>这篇文章中介绍过了)。主要内容是<code>Java 8</code>中新增的函数式接口以及<code>Stream</code>流，还有方法引用。</p><h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><p>函数式接口指的就是接口里面只含有一个抽象方法。这样我们就可以使用<code>Lambda</code>表达式编程，这是一种函数式编程的思想，强调的是怎么做。<code>Java 8</code>提供了很多的函数式接口，这里我们介绍常见的函数式接口。</p><ul><li><code>Supplier\&lt;T&gt;</code></li><li><code>Consumer\&lt;T&gt;</code></li><li><code>Predicate\&lt;T&gt;</code></li><li><code>Functional\&lt;T,R&gt;</code></li></ul><h3 id="Supplier-lt-T-gt"><a href="#Supplier-lt-T-gt" class="headerlink" title="Supplier&lt;T&gt;"></a>Supplier&lt;T&gt;</h3><p>该接口里面有一个<code>T get()</code>方法，按照字面意思，是提供者的意思，表示生产出一个与泛型类型<code>T</code>相同的数据。下面我们来讲一个例子说明此接口的使用。假设有一个方法，需要返回一个字符串，该字符串由<code>Supplier</code>接口的<code>get()</code>方法产生，而产生什么样的字符串，则由程序员在调用该方法是传入<code>Lambda</code>决定。如下方法传入一个<code>Supplier</code>接口得到一个字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = getString(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="Consumer-lt-T-gt"><a href="#Consumer-lt-T-gt" class="headerlink" title="Consumer&lt;T&gt;"></a>Consumer&lt;T&gt;</h3><p>与<code>Supplier</code>接口不同的是，<code>Consumer</code>接口是消费或者说处理一个与泛型类型相同数据类型的数据，它有一个<code>accept(T t)</code>方法，该方法用来消费数据，假设有下面这一个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleString</span><span class="params">(String str, Consumer&lt;String&gt; consumer)</span> </span>&#123;</span><br><span class="line">    consumer.accept(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>Consumer</code>来消费(处理)传入的这个字符串，而怎么消费，就取决与程序员在调用该方法时传入的<code>Lambda</code>，这时对程序员来说，就是怎么做的问题，相当于传入一个方法去处理数据，这就是函数式编程，这里我们就简单的将传入的数据进行打印</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleString(<span class="string">"Hello Again!"</span>, (String str) -&gt; &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello Again!</span><br></pre></td></tr></table></figure><p><code>Consumer</code>接口中有一个默认方法<code>andThen(Consumer consumer)</code>，看下面的程序说明它的用处</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con1.andThen(con2).accept(str); <span class="comment">//con1和con2都是Consumer接口的实现类对象</span></span><br><span class="line"><span class="comment">//相当于下面的代码</span></span><br><span class="line">con1.accept(str);</span><br><span class="line">con2.accept(str);</span><br></pre></td></tr></table></figure><p>假设有一个方法有需要传入两个<code>Consumer</code>接口对数据进行消费</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleInterger</span><span class="params">(Integer i, Consumer&lt;Integer&gt; con1, Consumer&lt;Integer&gt; con2)</span> </span>&#123;</span><br><span class="line">    con1.andThen(con2).accept(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>mian</code>方法中使用，<code>con1</code>对数字进行<code>+10</code>然后打印，<code>con2</code>对数字进行<code>*10</code>然后打印</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleInteger(<span class="number">10</span>, (i) -&gt; &#123;</span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;, (i) -&gt; &#123;</span><br><span class="line">    i = i * <span class="number">10</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="Predicate-lt-T-gt"><a href="#Predicate-lt-T-gt" class="headerlink" title="Predicate&lt;T&gt;"></a>Predicate&lt;T&gt;</h3><p><code>Predicate</code>接口中有一个<code>test(T t)</code>，它的作用是对某种数据类型进行判断，它返回一个<code>boolean</code>值。假设有一个集合，我们对其中的元素进行判断，符合条件放入一个新的集合，看下面的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">(HashMap&lt;String,Integer&gt; map, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个集合用以放符合条件的元素</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; resmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历集合</span></span><br><span class="line">    Set&lt;String&gt; key = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String str : key) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(str);</span><br><span class="line">        <span class="comment">//对值进行判断</span></span><br><span class="line">        <span class="keyword">boolean</span> res = predicate.test(val);</span><br><span class="line">        <span class="comment">//如果值符合条件，就加入新的集合</span></span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            resmap.put(str,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在<code>main</code>方法中进行调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">map.put(<span class="string">"奥特曼"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//筛选出年龄小于等于20岁的</span></span><br><span class="line">HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resmap);</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;佟丽娅=<span class="number">20</span>, 迪丽热巴=<span class="number">18</span>, 古力娜扎=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><p><code>Predicate</code>还有三个默认方法</p><ul><li><code>and(Predicate\&lt;T&gt; pre)</code><ul><li>与</li></ul></li><li><code>or(Predicate\&lt;T&gt; pre)</code><ul><li>或</li></ul></li><li><code>negate()</code><ul><li>非</li></ul></li></ul><p>假设对于上面的那个方法，我提出一个新的需求，要求不仅年龄要小超过<code>20</code>岁，而且年龄要大于<code>18</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">(HashMap&lt;String,Integer&gt; map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; resmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; key = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String str : key) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(str);</span><br><span class="line">        <span class="keyword">boolean</span> res = predicate1.and(predicate2).test(val);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            resmap.put(str,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;, (Integer i) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resmap);</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;佟丽娅=<span class="number">20</span>, 古力娜扎=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><p>至于<code>or()</code>和<code>negate()</code>的使用方法同上。</p><h3 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T,R&gt;"></a>Function&lt;T,R&gt;</h3><p>该接口的作用是将<code>T</code>这种数据类型转化为<code>R</code>这种数据类型，它里面有一个<code>R apply(T t)</code>方法。下面这个方法将一个字符串转化为一个整数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">StrToInt</span><span class="params">(String str, Function&lt;String, Integer&gt; fun)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main()</code>方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = StrToInt(<span class="string">"123"</span>, (String str) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将字符串转化为数字</span></span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//打印该数字</span></span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p><code>Function</code>接口中还有一个默认方法<code>andThen(Function&lt;T,R&gt; fun)</code>，这个方法与在上面介绍的<code>Consumer</code>接口的<code>andThen()</code>很像，但是有点不同，<code>Consumer</code>接口的<code>andThen</code>是两个对象消费同一个数据，而<code>Function</code>接口的<code>addThen()</code>是将第一个<code>fun</code>处理后的结果拿给第二个<code>fun</code>去处理，相当于<code>apply(apply())</code>。比如现在我有一个需求，将一个字符串转化为数字，然后将这个数字，<code>+10</code>然后再转化为字符串，这个方法可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">StrPlus</span><span class="params">(String str, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;String,Integer&gt; fun1, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;Integer,String&gt; fun2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun1.andThen(fun2).apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s =  StrPlus(<span class="string">"123"</span>, (String str) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将字符串转化为数字并加10</span></span><br><span class="line">    Integer i = Integer.parseInt(str);</span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, (Integer i) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将数字转化为字符串</span></span><br><span class="line">   <span class="keyword">return</span> i + <span class="string">""</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">133</span></span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><code>Stream</code>流是<code>Java 8</code>引入的新特性，首先它跟<code>I/O</code>流没有任何的关系，它主要是用来处理集合、数组问题的。要看<code>Stream</code>流有什么用处，还是要看集合处理有什么缺点。</p><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>有下面这么一个数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"赵敏"</span>, <span class="string">"张翠山"</span>, <span class="string">"小昭"</span>, <span class="string">"张良"</span>&#125;;</span><br></pre></td></tr></table></figure><p>现在我们有如下要求</p><ul><li>筛选出以”张”字开头的字符串，放入一个<code>Arraylist</code>集合中</li><li>在<code>ArrayList</code>集合中筛选出字符串长度为<code>3</code>的字符串，放入一个新的集合</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">        list1.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list1);</span><br><span class="line">ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String string : list1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        list2.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张无忌, 张三丰, 张翠山, 张良]</span><br><span class="line">[张无忌, 张三丰, 张翠山]</span><br></pre></td></tr></table></figure><p>现在我们使<code>Stream</code>流的方式实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line">stream.filter(str -&gt; str.startsWith(<span class="string">"张"</span>))</span><br><span class="line">        .filter(str -&gt; str.length() == <span class="number">3</span>)</span><br><span class="line">        .forEach(str -&gt; System.out.print(str + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张无忌 张三丰 张翠山</span><br></pre></td></tr></table></figure><p>我们发现使用<code>Stream</code>流的代码比遍历集合简单很多，因为使用集合直接遍历真正核心的代码就那么一两句，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">        list1.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码中核心的就是<code>string.startsWith(&quot;张&quot;)</code>，而其他的代码是为了达到这个目的不得不写的代码。这就是集合相较于<code>Stream</code>流的局限性所在，观察<code>Stream</code>流的写法，根本没有什么遍历集合的代码，直接就是你想要干的事情。</p><h3 id="获取Stream流的方法"><a href="#获取Stream流的方法" class="headerlink" title="获取Stream流的方法"></a>获取Stream流的方法</h3><p>获取<code>Stream</code>流有两种方法</p><ul><li><code>Collection</code>中新加的<code>stream()</code>方法，该方法可以得到一个<code>Stream</code>流，对于<code>Map</code>集合，可以通过<code>keySet(),values(),entrySet()</code>等方法得到<code>Set</code>集合，然后通过<code>Set</code>对象调用<code>stream()</code>方法得到<code>Stream</code>流</li><li><code>Stream</code>流的静态方法<code>of()</code>，该方法接收一个可变参数，所以可以传入一个数组</li></ul><p>下面做一个演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"哪吒"</span>);</span><br><span class="line">        list.add(<span class="string">"杨戬"</span>);</span><br><span class="line">        Stream stream1 = list.stream();</span><br><span class="line">        stream1.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="string">"女"</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="string">"女"</span>);</span><br><span class="line">        map.put(<span class="string">"哪吒"</span>,<span class="string">"男"</span>);</span><br><span class="line">        map.put(<span class="string">"杨戬"</span>,<span class="string">"男"</span>);</span><br><span class="line">        Set&lt;String&gt; key = map.keySet();</span><br><span class="line">        Stream stream2 = key.stream();</span><br><span class="line">        stream2.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; vals = map.values();</span><br><span class="line">        Stream stream3 = vals.stream();</span><br><span class="line">        stream3.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream stream4 = entries.stream();</span><br><span class="line">        stream4.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        String[] strings = &#123;<span class="string">"迪丽热巴"</span>, <span class="string">"古力娜扎"</span>, <span class="string">"哪吒"</span>, <span class="string">"杨戬"</span>&#125;;</span><br><span class="line">        Stream stream5 = Stream.of(strings);</span><br><span class="line">        stream5.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        stream6.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream中的常见方法"><a href="#Stream中的常见方法" class="headerlink" title="Stream中的常见方法"></a>Stream中的常见方法</h3><p><code>Stream</code>流中的方法分为两类，一类叫做延迟方法，该方法返回的还是一个<code>Stream</code>流对象，所以可以进行链式编程，如<code>filter()</code>；另一类叫做终结方法，该方法不返回<code>Stream</code>流对象，如<code>forEach()</code>， <code>count()</code>(终结方法只有这两个，其他的都是延迟方法)。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>该方法需要传入的是一个<code>Predicate\&lt;T&gt;</code>接口，这个接口我们在常用函数式接口讲过，它是对某中数据进行测试，而<code>filter</code>的作用就是如果<code>test(T t)</code>返回的是<code>true</code>，那么就将这个数据加入到新的流中，遍历完流中所有的元素后返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当字符串以迪开头时返回true，加入到新的流中，这个流会被返回</span></span><br><span class="line">Stream&lt;String&gt; stream1 = stream.filter(s -&gt; s.startsWith(<span class="string">"迪"</span>));</span><br><span class="line"><span class="comment">//forEach是后面要介绍的方法，这里只需要理解为遍历流并打印</span></span><br><span class="line">stream1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迪丽热巴</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>该方法传入的是一个<code>Function&lt;T,R&gt;</code>接口，所以它的作用是将一个类型的转转化为另一个类型的流。如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个流，这个流是字符串的长度</span></span><br><span class="line">Stream&lt;Integer&gt; stream1 = stream.map(s -&gt; s.length());</span><br><span class="line">stream1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>这时结果报错了</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java43.png"/></center><p>这是因为这个<code>stream</code>在调用上面的<code>filter()</code>的时候已经使用过了，而流使用了一次就会关闭，不能在使用，这就是为什么会报错的原因，所以我们把代码改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个流，这个流是字符串的长度</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(strings).map(s -&gt; s.length());</span><br><span class="line">stream2.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>这时输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>该方法传入的是一个<code>Consumer\&lt;T&gt;</code>接口，是一个终结方法，该方法会遍历流中的元素，然后使用<code>Consumer</code>接口中的<code>accept()</code>方法对元素进行处理，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>会逐个打印出流中的元素。</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit</code>方法需要传入一个<code>long</code>类型的数值<code>maxSize</code>，该方法会截取流中的前<code>maxSize</code>个元素放到新流中并返回，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是链式编程</span></span><br><span class="line">Stream.of(strings).limit(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迪丽热巴</span><br><span class="line">古力娜扎</span><br></pre></td></tr></table></figure><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>该方法接收一个<code>long</code>类型的数据<code>n</code>，它会跳过流中的前<code>n</code>个元素，将剩下的元素放入到一个新流中并返回，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(strings).skip(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">哪吒</span><br><span class="line">杨戬</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>该方法不需要传入参数，返回一个<code>long</code>类型的整数，该整数是流中元素的个数，这个方法是一个终结方法，不返回<code>Stream</code>流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> num = Stream.of(strings).count();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>我们之前在<code>Stream</code>流使用<code>forEach()</code>去打印流中的元素，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>但是打印这个方法<code>(System.out.println())</code>是已经存在了的，我们可不可以直接传入这个方法，在这里或者说是引用这个方法，答案是可以的，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>在这里我们引用了<code>System.out</code>对象的<code>println</code>方法，这行语句的作用是上面的语句作用是完全相同的，这就是方法的引用，<code>::</code>就是方法引用的运算符，这是新增的运算符。</p><p>那方法引用也要遵循一定的原则，比如你引用的对象必须是存在的，你引用的方法需要传入的参数的个数和类型必须是对的上的，否则就会抛出异常，由于方法的性质不同，所以有很多类型的引用，比如</p><ul><li>对象引用成员方法</li><li>类引用静态方法</li><li><code>super</code>引用父类方法</li><li><code>this</code>引用成员方法</li><li>引用构造方法</li><li>引用数组构造方法</li></ul><p>下面会详细的展开讲解。</p><h3 id="对象引用成员方法"><a href="#对象引用成员方法" class="headerlink" title="对象引用成员方法"></a>对象引用成员方法</h3><p>其实</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>就是对象引用成员方法，我们引用了<code>System.out</code>对象的成员方法<code>println</code>。</p><h3 id="类引用静态方法"><a href="#类引用静态方法" class="headerlink" title="类引用静态方法"></a>类引用静态方法</h3><p>假设有一个接口<code>Calculate</code>，里面只有一个抽象方法<code>cal(int i)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这是一个函数式接口，现在在有一个方法需要调用这个接口去得到一个数字的绝对值，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAbs</span><span class="params">(<span class="keyword">int</span> i, Calculate calculate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate.cal(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>Math</code>类的静态方法<code>abs()</code>可以做到这件事情，所以我们可以直接引用这个方法，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = getAbs(-<span class="number">10</span>,Math::abs);</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="super引用父类成员方法"><a href="#super引用父类成员方法" class="headerlink" title="super引用父类成员方法"></a>super引用父类成员方法</h3><p>假设有一个<code>Greet</code>接口，里面只有一个抽象方法<code>greet()</code>，所以这是一个函数接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个父类<code>Person</code>，里面有一个<code>greet()</code>方法，这个方法在后面是要被子类引用的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个子类<code>Student</code>继承了<code>Person</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Greet gre)</span> </span>&#123;</span><br><span class="line">        gre.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="keyword">super</span>::greet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Student</code>中的<code>sayHello()</code>方法需要一个<code>Greet</code>接口，然后我们又在<code>greet()</code>方法中调用了这个方法，并且传入一个<code>super::greet</code>的方法引用(当然这样的代码没有什么意义，只是为了演示)，我们在main中创建一个对象，并调用此方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"小明"</span>);</span><br><span class="line">student.greet();</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 小明</span></span><br></pre></td></tr></table></figure><h3 id="this引用成员方法"><a href="#this引用成员方法" class="headerlink" title="this引用成员方法"></a>this引用成员方法</h3><p>还是以上面的<code>Student</code>类为例，假设<code>Student</code>类中有一个成员方法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tempt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我今晚有空哦"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>greet()</code>方法中再增加一个<code>sayHello()</code>，这时方法的引用指向的是<code>tempt</code>方法，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sayHello(<span class="keyword">super</span>::greet);</span><br><span class="line">    sayHello(<span class="keyword">this</span>::tempt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在<code>main</code>方法中运行一下，输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 小明</span></span><br><span class="line"><span class="string">我今晚有空哦</span></span><br></pre></td></tr></table></figure><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>现在假设有这么一个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Personable</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">getPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面只有一个抽象方法<code>getPerson</code>，所以这是一个函数式接口，该方法根据<code>name</code>返回一个<code>Person</code>对象，现在有一个方法需要传入这个接口得到一个<code>Person</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">(String name, Personable personable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> personable.getPerson(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在<code>main</code>方法中调用该方法，传入的接口我们使用构造器引用<code>Person::new</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = getPerson(<span class="string">"迪丽热巴"</span>,Person::<span class="keyword">new</span>);</span><br><span class="line">person.greet();</span><br></pre></td></tr></table></figure><p>运行输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 迪丽热巴</span></span><br></pre></td></tr></table></figure><h3 id="引用数组构造方法"><a href="#引用数组构造方法" class="headerlink" title="引用数组构造方法"></a>引用数组构造方法</h3><p>引用数组构造方法的格式是<code>int[]::new</code>(这里只以<code>int</code>为例，当然也可以<code>double[]::new</code>)，具体的使用方法同上面的<code>Person</code>类的构造方法引用一致，这里就不多加介绍了。</p>]]></content>
    
    <summary type="html">
    
      Java8中的新特性
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="JDK 8" scheme="https://lastknightcoder.gitee.io/tags/JDK-8/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://lastknightcoder.gitee.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://lastknightcoder.gitee.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h2><p>一个软件可以同时干多件事情，就是多线程，目前我们编写的程序都是单线程的，在main方法中从上到下的进行，执行完上面的程序才能执行后面的程序。下面就将讲解如何写多线程程序。</p><p>在Java中创建多线程有两种放法，一种是继承Thread类，然后重写它的run()方法。第二种是实现Runnable接口，并且实现run()方法。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>继承Thread类实现多线程的步骤为</p><ul><li>继承Thread类，重写run()方法</li><li>创建类对象，调用继承的start()方法</li></ul><p>我们写一个MyThread类继承自Thread类，并重写run方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个测试类，在其main方法中创建MyThread对象，并且调用对象继承自Thread的start()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java23.png"/></center><p>观察到main方法中的程序和MyThread的run()方法中的程序在交替的进行。而不是在等待我执行完了，另一个在执行，而是两个在同时的执行，这就是多线程。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>实现Runnable接口实现多线程的步骤为</p><ul><li>实现Runnable接口并实现run()方法</li><li>在main中创建实现类对象</li><li>将实现类对象多为参数传入Thread()的构造方法，得到一个Thread对象</li><li>该Thread对象调用start()方法</li></ul><p>下面进行演示，首先创建一个类实现Runnable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Run"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面在实现类中实现多线程，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> MyRun(); <span class="comment">//创建实现类对象</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(run); <span class="comment">//实现类对象作为参数传入Thread的构造方法</span></span><br><span class="line">thread.start(); <span class="comment">//Thread对象调用start()方法启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java24.png"/></center><p>可以观察到main中的程序和run()方法中的程序是在同时进行的。</p><h3 id="Thread中的常见方法"><a href="#Thread中的常见方法" class="headerlink" title="Thread中的常见方法"></a>Thread中的常见方法</h3><ul><li>getName()<ul><li>获得线程的名称</li></ul></li><li>currentThread()<ul><li>获得正在执行的线程</li></ul></li><li>setName(String str)<ul><li>设置线程的名字</li><li>也可以通过new Thread(String str)设置线程的名字</li></ul></li><li>sleep(long l)<ul><li>线程休眠l毫秒</li></ul></li></ul><p>我们修改MyRun中的run()方法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//获得当前线程并且获得当前线程的名字</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改main方法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> MyRun();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(run);</span><br><span class="line">thread.setName(<span class="string">"run"</span>); <span class="comment">//增加了这一行，设置线程的名字</span></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java25.png"/></center><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>现在考虑这么一个问题，有三个售票机在售票，那么它们不能发生售出同样的票，也不能售出不存在的票。现在我要用一个类模拟售票机售票，并使用多线程模拟同时售票，新建一个SellTicket类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>; <span class="comment">//总共10张票</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类的main方法中创建三个线程同时售票</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable sellTicket = <span class="keyword">new</span> SellTicket();</span><br><span class="line"><span class="comment">//创建三个线程 注意必须使用的同一个售票机对象 否则他们就是各自10张票而不是总共10张票</span></span><br><span class="line"><span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line"><span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line"><span class="keyword">new</span> Thread(sellTicket).start();</span><br></pre></td></tr></table></figure><p>输出为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java26.png"/></center><p>我们发现出现了不同的售票线程售出了相同的票，并且有的售票线程售出了不存在的票-1。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>之所以会出现上面的问题，就是因为在有的售票机卖出了票，即进入了if语句后，但是还未进行ticket–操作，但是这个时候这个线程失去了CPU的执行权，并且别的线程拿到了CPU的执行权，由于未对ticket–，所以它们拿到的是同一张票，所以这就是为什么它们能卖出同一张票的原因。同理卖出不存在的票也是同种原因。</p><p>那么如何解决这个问题，我们必须要求在售票机在完成售票并且对ticket–之前，别的售票机不能对ticket进行操作，这样就不会出现票重复和卖出不存在的票的情况了，而实现这个的技术就叫做同步。有三种实现方式，分别是</p><ul><li>synchronized代码块</li><li>同步方法</li><li>Lock锁</li></ul><p>下面具体介绍用法。</p><h4 id="sychronized代码块"><a href="#sychronized代码块" class="headerlink" title="sychronized代码块"></a>sychronized代码块</h4><p>sychronized代码块的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sychronized(锁对象) &#123;</span><br><span class="line">    <span class="comment">//需要同步的代码，也就是可能出现问题的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中锁对象可以是任意的对象，当一个线程执行到同步代码块时，会将该锁对象交给这个线程，当这个线程执行完同步代码块时，会释放锁对象，所以如果这个线程在同步代码块内失去了CPU的执行权，因为别的线程没有锁对象，就不能进入同步代码块执行，就会进入堵塞状态，等待锁对象被释放。所以锁对象就相当于是钥匙了，要保证多个线程的锁对象要相同，这样就只有一把钥匙了。</p><p>我们重新修改SellTicket的类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>; <span class="comment">//总共10张票</span></span><br><span class="line">    Object object = <span class="keyword">new</span> Object(); <span class="comment">//锁对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">            <span class="comment">//同步代码块 一次只有一个线程执行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java27.png"/></center><p>这次我们发现没有卖出重复的票，也没有卖出不可能的票。</p><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>同步方法其实就是使用synchronized修饰的方法，这个方法每次也只能有一个线程执行，它的锁对象是this，我们把上面买票的程序抽取出为一个方法sellTicket()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">        ticket --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时run()可简化为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">        sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java28.png"/></center><p>也达到了同样的效果。</p><p>注意：</p><ul><li>同步方法也可以为静态方法，不过这时的锁对象不在是this了，而是本类的class属性，也是一个对象。</li></ul><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p>Lock是一个接口，它比较灵活。之前我们讲到，在线程执行到synchronized代码块时，会获得锁对象，在执行完代码块时，会释放锁对象，但是这些对我们都是不可见的，而Lock灵活在我们自己觉得在哪里加锁，哪里释放锁。它有两个方法</p><ul><li>lock()<ul><li>加锁</li></ul></li><li>unlock()<ul><li>释放锁</li></ul></li></ul><p>lock()一般写在同步代码前，unlock()写在同步代码后。ReentrantLock是Lock的实现类，下面我们将演示如何使用Lock锁同步，修改run方法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//创建Lock锁实现类对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">        lock.lock();  <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">            ticket --;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java29.png"/></center><p>可见达到了同步的效果。</p><h2 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h2><p>当我们排队买奶茶时，我们对老板说我们要一杯奶茶，然后我们就等着，老板去制作奶茶，等老板制作好奶茶后去喊我们。这其实就是等待唤醒，当多个线程去操作同一个资源时，比如奶茶，就需要一方(顾客)等着，等待另一方(老板)唤醒，总不能奶茶没有好我去抢吧。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>在讲解等待唤醒之前，我们先对线程的状态有一个大致的了解，看图</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java30.png"/></center><p>当我们创建一个线程对象还没有start()时，这时它处于New状态；当我们执行start()方法后，这时的线程状态由New转向Runnable运行状态；如果执行完run()方法，或者调用了stop()方法或者抛出了异常那么该线程进入死亡状态。如果在Runnable状态失去了CPU的执行权，那么就会进入Blocked阻塞状态；线程在这里等待CPU的执行权，拿到了CPU的执行权就会从该状态来到Runnable状态；如果线程在运行时执行了sleep(l)或wait(l)(l为等待的时间)方法，那么就会由Runnable状态进入Timed waiting状态，在这个状态中，线程放弃争夺CPU的执行权，当等待的时间到了之后，如果CPU空闲，那么就进入Runnable状态，如果忙碌，那么就进入Blocked状态，与其他线程一起争夺CPU的执行权。如果在Runnable执行了wait()(不带参数的)方法，就会进入Waiting永久等待状态，直到锁对象执行notify()方法唤醒，如果CPU空闲，就进入Runnable状态，否则进入Blocked状态争夺CPU执行权。</p><h3 id="等待唤醒-1"><a href="#等待唤醒-1" class="headerlink" title="等待唤醒"></a>等待唤醒</h3><p>这里的等待唤醒指的就是上面提及的Runnable状态执行wait()方法到Waiting永久等待状态，以及执行notiify()方法有永久等待状态到Runnable状态。前者为等待，后者为唤醒。</p><p>注意：</p><ul><li>只有锁对象才能调用wait()和notify()方法</li><li>wait()和notify()的调用者应该是同一锁对象，并且必须写在同步代码块中</li><li>执行wait()被唤醒后，会继续执行wait()后面的代码</li><li>notify()一次只能唤醒一个线程，唤醒的是睡眠最久的线程，notifyAll()能够唤醒所有的线程</li></ul><p>下面以最先提及的买奶茶为例演示这一过程。首先创建Runnable顾客类和老板类和奶茶类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">    String taste; <span class="comment">//奶茶口味</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//奶茶有没有做好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MilkTea milkTea; <span class="comment">//作为锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerThread</span><span class="params">(MilkTea milkTea)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.milkTea = milkTea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (milkTea) &#123; </span><br><span class="line">                <span class="keyword">if</span> (milkTea.flag == <span class="keyword">false</span>) &#123; <span class="comment">//奶茶没有准备好</span></span><br><span class="line">                    System.out.println(<span class="string">"老板来杯珍珠奶茶"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        milkTea.wait(); <span class="comment">//等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(milkTea.taste + <span class="string">"真好喝"</span>); <span class="comment">//被唤醒后会执行这个</span></span><br><span class="line">                milkTea.flag = <span class="keyword">false</span>; <span class="comment">//奶茶喝完了</span></span><br><span class="line">                milkTea.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopper</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MilkTea milkTea; <span class="comment">//作为锁对象 和Customer相同</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shopper</span><span class="params">(MilkTea milkTea)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.milkTea = milkTea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (milkTea) &#123;</span><br><span class="line">                <span class="keyword">if</span> (milkTea.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        milkTea.wait(); <span class="comment">//等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"做奶茶中 ..."</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    milkTea.taste = <span class="string">"珍珠奶茶"</span>;</span><br><span class="line">                    milkTea.flag = <span class="keyword">true</span>;</span><br><span class="line">                    System.out.println(milkTea.taste + <span class="string">"做好了"</span>);</span><br><span class="line">                    milkTea.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面在测试类中创建两个线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MilkTea milkTea = <span class="keyword">new</span> MilkTea(); <span class="comment">//作为锁对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CustomerThread(milkTea)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Shopper(milkTea)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java31.png"/></center><p>这就是等待唤醒的过程。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>当我们需要一个新的线程执行任务，我们就会创建一个新的线程，但是如果这个线程执行的任务很少，并且我们需要频繁的创建线程，这个创建线程的过程会很耗费时间，所以我们就想有没有一个机制，我们不用创建线程，当我们需要线程时我们去取，当我们用完时，我们还给它。这样就不需要频繁创建线程，省去时间，提高效率。线程池可以帮我们实现这一个想法。</p><p>那接下来的问题我们怎么使用Java为我们准备的线程池，Executors提供了一个静态方法newFixedThreadPool(int nThreads)，这个方法接收的参数是线程池中线程的个数，返回一个ExecutorService对象，然后我们就可以使用该对象的submit(Runnable task)方法，传入一个Runnable实现类对象就可以了。下面我们来示例一番</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个匿名内部类</span></span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//长度有三个线程的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>); </span><br><span class="line">        <span class="comment">//三个线程执行任务</span></span><br><span class="line">        threadPool.submit(run);</span><br><span class="line">        threadPool.submit(run);</span><br><span class="line">        threadPool.submit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>我们在创建一个线程时，我们一般需要做一下的步骤</p><ul><li>创建一实现类实现Runnable接口</li><li>重写run方法</li><li>创建实现类对象</li><li>将该对象传入Thread的构造方法中</li></ul><p>上面的写法可以简化，省去创建一个实现类，直接创建一个匿名内部类</p><ul><li>创建一个Runnable匿名内部类</li><li>重写run方法</li><li>将该对象传入Thread的构造方法中</li></ul><p>其实上面有很多的代码是多余，真正有用的代码就是run()方法里面的代码，但是为了创建一个线程我们不得不要创建一个对象，然后巴拉巴拉。其实有时候我们不关心谁来做，只需要告诉我怎么做，比如一个线程你只需要告诉我run()方法就可以了，告诉我怎么做就可以了，但是我们却要创建一个对象等等一系列的操作才能达到这个目的。</p><h3 id="Lambda的使用"><a href="#Lambda的使用" class="headerlink" title="Lambda的使用"></a>Lambda的使用</h3><p>Java在JDK 1.8中引入了Lambda表达式，可以极大简化我们的编程，可以做到我上面所说的只关心怎么做的问题，不需要创建对象。我们来看看下面这段代码用Lambda怎么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>Lambda的写法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在你可能没有看懂这个写法，下面让我为你解释一番。首先我们注意到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被简单的替换为了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两段代码很像，但是Lambda省略了很多的东西。首先我们知道Thread()里面传的是一个Runnable实现类的对象，该类重写类run方法，真正有用的就是run方法，所以我们把这些全部省略了，直接传入一个run()就可以了，并且由于run()方法的方法名是确定的，我们连run方法名都可以省去，返回值类型也是确定，所以我们也可以省去，最后只剩一个参数列表，在参数列表与方法体之间加入-&gt;就是Lambda表达式。使用Lambda不用创建对象，我们只需要传入一个方法，告诉它怎么做就可以了。这个也叫做函数式编程。</p><p>Lambda表达式的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了熟悉Lambda表达式的使用，我们来看一个例子，定义一个Calculator的接口，里面有一个方法叫<code>calculate(int a, int b);</code>，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中定义一个方法，该方法需要<code>Calculator</code>接口作为参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = calculator.calculate(a,b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法表示的是，a,b经过Calculator计算之后得到一个数，而计算方法，根据我们传入的calculator而定，这明显是我们只需要告诉计算器怎么做就行，我们把做的方法告诉它，使用Lambda表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">int</span> result1 = cal(<span class="number">2</span>,<span class="number">3</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">int</span> result2 = cal(<span class="number">2</span>,<span class="number">3</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result2);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>根据我们传入的方法不同，这个计算器就不同，计算器关心的就是怎么做，你告诉怎么做就可以。</p><h3 id="Lambda的省略格式"><a href="#Lambda的省略格式" class="headerlink" title="Lambda的省略格式"></a>Lambda的省略格式</h3><p>其实上面的Lambda还可以进行化简，因为还有很多是可以推断出来的，比如参数列表里面的参数类型可以省略，因为这个参数类型时确定的，不可能会变的。如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = cal(<span class="number">2</span>,<span class="number">3</span>, (a, b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果方法体里面只有一条语句时，那么花括号也可以省略，这时分号也可以省略，如果这条语句是return语句，那么return也可以省略，因为必须是要返回一个值的，这个可以推断出来，所以可以省略，所以上面又可以简写为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = cal(<span class="number">2</span>,<span class="number">3</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>如果参数列表里面只有一个参数的话，那么小括号也可以省略</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">param -&gt; &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式的使用前提"><a href="#Lambda表达式的使用前提" class="headerlink" title="Lambda表达式的使用前提"></a>Lambda表达式的使用前提</h3><p>虽然Lambda表达式这么好用，但是是有使用前提的</p><ul><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<ul><li>比如Runnable接口，里面只有一个run()方法是抽象方法</li><li>比如上面定义的Calculator接口，里面也只有一个抽象方法calculate()</li></ul></li><li>使用Lambda必须具有<strong>上下文推断</strong>。<ul><li>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li><li>不能是我要一个Calculator接口的calculate()方法，你给我传一个Runnable的run()方法，兄弟，暗号对不上啊。</li></ul></li></ul><blockquote><p>备注：有且仅有一个抽象方法的接口，称为”<strong>函数式接口</strong>“。</p></blockquote>]]></content>
    
    <summary type="html">
    
      有关于Java多线程的介绍以及一点有关于Lambda的知识
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://lastknightcoder.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习" scheme="https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java常用API</title>
    <link href="https://lastknightcoder.gitee.io/Java%E5%B8%B8%E7%94%A8API/"/>
    <id>https://lastknightcoder.gitee.io/Java%E5%B8%B8%E7%94%A8API/</id>
    <published>2019-07-11T16:00:00.000Z</published>
    <updated>2019-07-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>API全称叫做Application Programming Interface，翻译成应用程序编程接口，其实你把它看做是Java的使用说明书进行，它告诉你Java有哪些类，有哪些方法，你直接用就可以，相当于给你一个插座(接口)，你用的时候插上去就行。</p><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><p>我们之前做的都是从屏幕输出，现在将介绍如何获取从键盘输入。Scanner类是系统提供的一个类，它可以帮助我们从键盘获取输入。一般使用系统提供的类分为三部分</p><ul><li>导包</li><li>创建对象</li><li>使用</li></ul><p>导包语句放在package之后，放在public class之前，如果使用的类与当前类属于同一个包，那么不用导入，如果要使用的类在java.lang包下，也不需要导入。导包的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名; <span class="comment">//导入指定包下面的类</span></span><br><span class="line"><span class="keyword">import</span> 包名.*;  <span class="comment">//导入指定包下的所有类</span></span><br></pre></td></tr></table></figure><p>Scanner类位于java.util包下，所以我们需要导入，下面介绍如何使用Scanner类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">//1. 导包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建一个Scanner对象</span></span><br><span class="line">        <span class="comment">//Scanner的构造方法需要传入参数，这里传入的是System.in，代表的是从键盘输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 使用</span></span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();   <span class="comment">//获得从键盘输入的一个整数</span></span><br><span class="line">        String str = sc.next();   <span class="comment">//获得从键盘输入的一个字符串</span></span><br><span class="line">        <span class="comment">//打印输入的结果</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行效果为：</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java16.gif"/></center><p><strong>注意：</strong></p><ul><li>其实从键盘输入全部都是字符串，即使你输入的是65这里的整数，系统得到的只是对于的ASCII码值，而nextInt()方法之所以能获得整数，是因为nextInt()方法做了处理，将字符串转化为了整数。</li><li>next()方法只能获得一个字符串，如输入的是Hello World，它只能得到Hello。</li></ul><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java17.gif"/></center><h1 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h1><p>Random类的作用主要是用于产生随机数的，它位于java.util包下面。下面介绍它的两个主要的方法</p><ul><li>nextInt()：产生一个随机整数，范围时整个int的大小</li><li>nextInt(int n)：产生一个[0,n)的整数，左闭右开。</li></ul><p>下面将介绍Random的使用。下面这个程序将产生10个随机整数，范围为整个int整数的范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java18.gif"/></center><p>可见产生的整数是随机的，并且范围时整个int的范围，正值和负值都有。</p><p>下面这个程序将产生10范围为1-10的随机整数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandomAgain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">10</span>) + <span class="number">1</span>); <span class="comment">//nextInt(10)的范围为0-9，+1变为1-10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java19.gif"/></center><p>输出的数字的范围在1-10之间，并且输出的数字是随机的。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String这个类是我们最常用的一个类了，因为我们会牵涉到很多的字符串的操作，所以这里要详细讲一下String类。</p><h2 id="String类的定义"><a href="#String类的定义" class="headerlink" title="String类的定义"></a>String类的定义</h2><p>String类位于java.lang包中，我们在之前讲过，java.lang是默认导入的，所以我们不需要导入这个包，这也是为什么在之前我们可以直接的使用String这个类。字符串效果上相当于是一个字节数组。</p><p>String作为引用类型，所以String对象的创建当然要借助于构造方法了，String的构造方法有很多，这里只讲常见的三种String构造方法。</p><ul><li>public String()<ul><li>创建一个空字符串</li></ul></li><li>public String(char[] array)<ul><li>根据一个字符数组来创建一个字符串</li></ul></li><li>public String(byte[] array)<ul><li>根据一个字节数组来创建一个字符串</li></ul></li></ul><p>下面我将演示通过这三种方法创建字符串对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(); <span class="comment">//""</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(chars); <span class="comment">//"abc"</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(bytes); <span class="comment">//"abc"</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>因为字符串是在是太常用，通过构造方法创建有点麻烦，所以系统设计出可以通过<code>&quot;&quot;</code>的字面量的形式来创建一个String对象，这也是我们经常使用的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Java程序中所有字符串的字面值（<code>&quot;&quot;</code>）都是String类的实例</li><li>字符串一旦创建不可改变</li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>我们知道可以通过字面量（<code>&quot;&quot;</code>）的形式来创建字符串对象，这样创建对象与使用构造方法创建的对象有什么不同呢? 下面我们来看一个字符串比较的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line">        System.out.println(str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>在这里我们创建了四个字符串，他们的内容都是”abc”，现在我要对它们进行比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line">System.out.println(str1 == str4);</span><br><span class="line">System.out.println(str3 == str4);</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>这里得到的结果可能与你想象的不一样，所以我要详细讲一下。</p><p>首先==比较符比较的是什么？由于字符串都是引用类型，所以这里比较的是它们的地址，那按道理说，每创建一个对象，会在堆中开辟一个空间，每个空间的地址都不一样，那么它们比较的值应该都是false，那么为什么通过字面量创建的字符串对象比较出来的结果是true呢？</p><p>要解释这一个现象，就需要知道一个东西，那就是常量池。程序中直接用双引号写上的（即通过字面量创建的字符串），都在常量池中，而new出来的对象不再常量池中。现在记住这一句话，我们去内存看看到底怎么回事，由于这次不牵涉到方法区，我们只画出栈内存和堆内存。</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java20.png"/></center><h2 id="字符串的相关方法"><a href="#字符串的相关方法" class="headerlink" title="字符串的相关方法"></a>字符串的相关方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>之前我们说==比较是基于地址的比较，但是我们如果基于内容比较怎么办？比如说上面的字符串如果进行比较的话，就会返回true。有两个方法，第一个是equals()方法，该方法其实也是基于==比较的，不过String类重写了该方法，只要两个字符串的内容相同就会返回true。这里又提到了重写，不懂没关系，只要知道，字符串调用这个方法是基于内容的比较，而不是基于地址的比较，下面演示一番。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));</span><br><span class="line">        System.out.println(str1.equals(str3));</span><br><span class="line">        System.out.println(str1.equals(str4));</span><br><span class="line">        System.out.println(str3.equals(str4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>equals()方法具有对称性</li><li>如果比较的双方一个是常量，一个是变量，推荐使用常量调用方法</li></ul><p>针对第二条的原因是，如果变量str未被初始化，那么它的初始值是null，null根本没有equals方法，所以调用该方法会报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str; <span class="comment">//str = null</span></span><br><span class="line">str.equals(<span class="string">"abc"</span>); <span class="comment">//会报错</span></span><br><span class="line"><span class="string">"abc"</span>.equals(str); <span class="comment">//不会报错，会返回false</span></span><br></pre></td></tr></table></figure><p>字符串比较的第二个方法是equalsIgnoreCase()，该方法与equals不同的是，该方法的比较忽略大小写，而equals()是大小写敏感的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello"</span>.equalsIgnoreCase(<span class="string">"Hello"</span>));</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>与字符串截取有关的方法是substring()，该方法有两种常用的重载</p><ul><li>substring(int index)<ul><li>从index截取到末尾</li></ul></li><li>substring(int begin, int end)<ul><li>从begin截取到end，左闭右开[begin, end)</li></ul></li></ul><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>介绍三个方法</p><ul><li>toCharArray()<ul><li>将字符串转换为char[]</li></ul></li><li>getBytes()<ul><li>将字符串转换为byte[]</li></ul></li><li>replace(CharSequence oldString, CharSequence newString)<ul><li>这里的CharSequence是接口，这里不懂也没关系，知道这个可以接收字符串类型就可以</li><li>这个方法的作用是新的字符串替换旧的字符串</li></ul></li></ul><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>与字符串分割的方法只有一个</p><ul><li>split(String regex)<ul><li>按照regex的规则分割字符串，返回一个字符串数组</li></ul></li></ul><p>按照regex的规则分割字符串可能有点难以理解，其实这里的regex是正则表达式，不懂的话看懂下面的例子就可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"a,b,c"</span>;</span><br><span class="line"></span><br><span class="line">        String[] strings = str.split(<span class="string">","</span>); <span class="comment">//按照逗号的分割字符串，得到的是["a","b","c"]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">            System.out.println(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果要按”.”规则分割的话，不能写”.”，要写成”\.”，因为.在正则表达式中有特殊的含义，所以需要转义。</li></ul><h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>Arrays位于java.util包中。这个类提供了很多的静态方法，实现数组的常见操作。在这里我们介绍两个常用的方法</p><ul><li>toString<ul><li>接收一个数组参数</li><li>将参数数组变成字符串 [元素1，元素2， …]</li></ul></li><li>sort<ul><li>按默认升序（从小到大）对数组进行排序</li><li>对于String，按字母在Unicode表中的大小排序</li><li>对于自定义的类型，需要Comparable或Comparator接口的支持</li></ul></li></ul><p>下面演示两个方法的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个整型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays.toString() 我们不用遍历数组打印了</span></span><br><span class="line">        System.out.println(Arrays.toString(arrays));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对数组进行排序 这里不是返回一个新的数组 而是对原有数组进行排序</span></span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        <span class="comment">//将排序后的数组打印出来</span></span><br><span class="line">        System.out.println(Arrays.toString(arrays));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>Math类位于java.util包中，该类包含了很多与数学计算相关的静态方法。这里介绍几个与整数操作有关的方法</p><ul><li>abs()<ul><li>取绝对值</li><li>abs(-2) = 2</li></ul></li><li>ceil()<ul><li>向上取整</li><li>ceil(2.1) = 3，ceil(-2.1) = -2</li></ul></li><li>floor()<ul><li>向下取整</li><li>·floor(2.1) = 2，floor(-2.1) = -3</li></ul></li><li>round()<ul><li>四舍五入</li><li>round(2.1) = 2，round(-2.1) = -2</li></ul></li></ul><p>当然Math类还包含很多的方法，具体的可以查阅资料。</p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object类是所有类的父类，所有类都默认继承了（直接或间接）Object类。所以所有的类都默认有Object类中的成员方法。这里介绍两个比较重要的Object类的成员方法</p><ul><li>toString()</li><li>equals(Object object)</li></ul><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>我们在之前一直有用System.out.println()语句打印信息到控制台，当我们传入一个引用类型变量的时候，它会调用该对象的toString()方法，由于Object类的toString方法是默认打印堆内存的地址值，所以这也是为什么我们在打印数组时，打印出的是地址值。而我们打印String类型时，打印出的却是它的内容，这时因为String重写toString()方法。</p><p>为了验证我们的猜想，我们看下面这么一个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在创建一个Person对象，并且打印出来，然后调用toString()方法，在打印一遍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestToString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(per);</span><br><span class="line">        System.out.println(per.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person@<span class="number">4554617</span>c</span><br><span class="line">Person@<span class="number">4554617</span>c</span><br></pre></td></tr></table></figure><p>我们发现结果是一样的，现在我们在Person类中重写toString()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm a Person object"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行一遍，输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m a Person object</span></span><br><span class="line"><span class="string">I'</span>m a Person object</span><br></pre></td></tr></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>在前面我们比较字符串时，我们说==是对象的地址值进行比较，而equals方法是基于内容的比较。事实上，Object类的equals方法也是进行对象地址值的比较，只不过是<strong>String类重写了equals方法</strong>。</p><p>我们可以通过重写equals方法来设置怎样两个对象才是相等的。比如还是以Person类进行举例，它有姓名和年龄两个成员变量，我们认为如果两个人的姓名和年龄都是一样的，那么我们就认为这两个人的对象是相同的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为要使用Person对象的name和age属性，所以要向下转型</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person person = (Person) obj;</span><br><span class="line">            <span class="comment">//如果姓名和年龄相同，就认为对象是相同的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.name == person.name &amp;&amp; <span class="keyword">this</span>.age == person.age) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在测试类类中测试一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>,<span class="number">20</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>,<span class="number">28</span>);</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.equals(person2));  <span class="comment">//年龄和姓名不一样，返回false</span></span><br><span class="line">        System.out.println(person1.equals(person3)); <span class="comment">//名字和年龄一样，返回true</span></span><br><span class="line">        System.out.println(person1 == person3); <span class="comment">//地址值是不同的，所以是false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>Date是有关于日期的类，它位于java.util包中。现在主要介绍它的两种常用的构造方法，以及一个有关于格式化输出的类SimpleDateFormat。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();  <span class="comment">//默认得到的是当前时间的日期</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="keyword">long</span> l); <span class="comment">//接收一个毫秒值，该毫秒值代表的是距离时间原点消耗的毫秒值</span></span><br></pre></td></tr></table></figure><p>时间原点规定为1970年1月1日的<code>00:00:00</code>时刻。现在简单演示Date类的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sat Jul <span class="number">20</span> <span class="number">19</span>:<span class="number">26</span>:<span class="number">26</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><p>可见Date类重写了toString()方法。</p><p>Date类有一个getTime的方法，它可以获得该date对象对应的毫秒值，现在我们通过这个方法获得一个毫秒值，然后利用该毫秒值作为第二个构造函数的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> ms = date.getTime();</span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(ms);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sat Jul <span class="number">20</span> <span class="number">19</span>:<span class="number">29</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br><span class="line">Sat Jul <span class="number">20</span> <span class="number">19</span>:<span class="number">29</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>上面的时间输出其实不符合我们的使用习惯，所以我们可以让输出的日期符合我们的使用习惯。DateFormat这个类是为此而存在的，不过它是一个抽象类，SimpleDateFormat类继承了该类，我们可以使用该类格式化日期输出。</p><p>首先就是如何创建一个对象，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(模式);</span><br></pre></td></tr></table></figure><p>可能这里还不能理解模式是个什么鬼，那么就要看下面这个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日"</span>);</span><br></pre></td></tr></table></figure><p>“yyyy年MM月dd日”就是模式，差不多就是模板吧，也就是你想要格式化输出的格式，其中yyyy代表年，MM代表月，dd代表日，HH代表小时，mm代表分，ss代表秒。</p><p>这里主要介绍它的两个方法</p><ul><li>format<ul><li>接收一个日期对象，返回一个字符串，这个字符串的格式与你上面定义的模式相同</li></ul></li><li>parse<ul><li>接收一个字符串，这个字符串的格式必须与你定义的模式相同，否则会报错</li><li>方法一个Date对象</li><li>parse方法会抛出一个异常，对于抛出异常的方法，要么继续抛出异常，要么使用try-catch处理</li></ul></li></ul><p>下面介绍这个类的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;  <span class="comment">//parse方法有可能抛出这个异常，这里我们不处理，继续抛出</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();  <span class="comment">//创建一个Date对象作为后面format方法的参数</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>); <span class="comment">//定义输出格式</span></span><br><span class="line">        String formatDate = simpleDateFormat.format(date);  <span class="comment">//获得由date转化得到的格式化输出字符串</span></span><br><span class="line">        System.out.println(formatDate);</span><br><span class="line"></span><br><span class="line">        Date dateAgain = simpleDateFormat.parse(<span class="string">"2017年5月13日 15:23:14"</span>); <span class="comment">//根据指定的格式解析出一个Date对象</span></span><br><span class="line">        System.out.println(dateAgain); <span class="comment">//打印该Date对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>年<span class="number">07</span>月<span class="number">20</span>日 <span class="number">19</span>:<span class="number">43</span>:<span class="number">18</span></span><br><span class="line">Sat May <span class="number">13</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">14</span> CST <span class="number">2017</span></span><br></pre></td></tr></table></figure><h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><p>Calendar是一个有关于日期的类，它提供了一些操作日历的方法，它是一个抽象类，所以不能创建Calendar对象，我们可以通过它的静态方法getInstance()得到它的一个子类对象，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>这里仅简单介绍它的四个方法</p><ul><li>get(int field)<ul><li>根据指定field值获取日历信息，field值一般为Calendar类的静态常量，如get(Calendar.YEAR)可以获得有关于年份的信息</li></ul></li><li>set(int field, int value)<ul><li>设置指定的field为指定的value</li></ul></li><li>add(int field, int amount)<ul><li>为指定field加上amount</li><li>这里需要注意的是，如果加上数值之后超过范围之后，会有进位。比如现在为7月，我给MONTH加上了10，那么现在年份会加1年，并且此时的月份为7 + 10 -12 = 5。</li></ul></li><li>getTime()<ul><li>返回当前日历对应得Date对象</li></ul></li></ul><p>下面简单演示方法的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCalendar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        System.out.println(calendar); <span class="comment">//打印出的不是地址，可见Calendar也重写了toString()方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH) + <span class="number">1</span>); <span class="comment">//西方的月份是从0开始的，所以这里我加1</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.DATE));</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); <span class="comment">//与上面DATE的效果是一样的</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(calendar.get(Calendar.SECOND));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============="</span>);</span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2020</span>);  <span class="comment">//设置年份为2020年</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        calendar.add(Calendar.MONTH,<span class="number">10</span>);  <span class="comment">//给月份加10个月，现在为2021年5月了</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH) + <span class="number">1</span>);</span><br><span class="line">        Date dateAgain = calendar.getTime();  <span class="comment">//得到一个日期对象</span></span><br><span class="line">        System.out.println(dateAgain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.GregorianCalendar[time=<span class="number">1563623852127</span>,areFieldsSet=<span class="keyword">true</span>,areAllFieldsSet=<span class="keyword">true</span>,lenient=<span class="keyword">true</span>,zone=sun.util.calendar.ZoneInfo[id=<span class="string">"Asia/Shanghai"</span>,offset=<span class="number">28800000</span>,dstSavings=<span class="number">0</span>,useDaylight=<span class="keyword">false</span>,transitions=<span class="number">29</span>,lastRule=<span class="keyword">null</span>],firstDayOfWeek=<span class="number">1</span>,minimalDaysInFirstWeek=<span class="number">1</span>,ERA=<span class="number">1</span>,YEAR=<span class="number">2019</span>,MONTH=<span class="number">6</span>,WEEK_OF_YEAR=<span class="number">29</span>,WEEK_OF_MONTH=<span class="number">3</span>,DAY_OF_MONTH=<span class="number">20</span>,DAY_OF_YEAR=<span class="number">201</span>,DAY_OF_WEEK=<span class="number">7</span>,DAY_OF_WEEK_IN_MONTH=<span class="number">3</span>,AM_PM=<span class="number">1</span>,HOUR=<span class="number">7</span>,HOUR_OF_DAY=<span class="number">19</span>,MINUTE=<span class="number">57</span>,SECOND=<span class="number">32</span>,MILLISECOND=<span class="number">127</span>,ZONE_OFFSET=<span class="number">28800000</span>,DST_OFFSET=<span class="number">0</span>]</span><br><span class="line"><span class="number">2019</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">57</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line">=============</span><br><span class="line"><span class="number">2020</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Thu May <span class="number">20</span> <span class="number">19</span>:<span class="number">57</span>:<span class="number">32</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure><h1 id="System"><a href="#System" class="headerlink" title="System"></a>System</h1><p>System是有关于系统的类，这里不会介绍那么高深的内容，主要介绍两个静态方法</p><ul><li>currentTimeMillis()<ul><li>获得当前系统距时间原点的毫秒值</li><li>这个方法可以用来计算程序损耗的实践</li><li>在程序开始执行前获取一个时间，在程序执行完成获取一个时间，两个时间相减就可以知道程序执行的时间，就可以知道程序的哪一部分最耗时，从而做出优化</li></ul></li><li>arraycopy()<ul><li>该方法的作用是将源数组从指定位置开始复制，有一个参数规定了复制的长度，复制到另一个数组，这个数组也规定了起始的位置</li><li>该方法接收五个参数</li><li>第一个参数是一个源数组src，第二个参数是源数组的起始位置，第三个参数是目的数组，第四个参数是目的数组的起始位置，第五个参数是复制的长度</li><li>如果你在这里没有理解，请看下面的例子</li></ul></li></ul><p>下面简单演示这两个方法的使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis(); <span class="comment">//循环执行前获取一次时间</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123; <span class="comment">//1000万次</span></span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();  <span class="comment">//循环结束后获取一次时间</span></span><br><span class="line">        <span class="keyword">double</span> time = (end - start) / <span class="number">1000.0</span>;  <span class="comment">//将单位转化为s</span></span><br><span class="line">        System.out.println(<span class="string">"共花费"</span> + time + <span class="string">"s"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们将源数组的前三个元素替换目的数组的前三个元素</span></span><br><span class="line">        <span class="keyword">int</span>[] array1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;      <span class="comment">//源数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;     <span class="comment">//目的数组</span></span><br><span class="line">        System.out.println(<span class="string">"转换前"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">        System.arraycopy(array1, <span class="number">0</span>, array2, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">//前三个元素，所以都是从索引0开始</span></span><br><span class="line">        System.out.println(<span class="string">"转换后"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">共花费<span class="number">0.011</span>s</span><br><span class="line">转换前</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">转换后</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>可见程序是执行的相当的快。</p>]]></content>
    
    <summary type="html">
    
      有关于Java一些常用API的介绍
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://lastknightcoder.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习" scheme="https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java集合与泛型</title>
    <link href="https://lastknightcoder.gitee.io/Java%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/"/>
    <id>https://lastknightcoder.gitee.io/Java%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/</id>
    <published>2019-07-07T16:00:00.000Z</published>
    <updated>2019-07-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是集合的意思，你可以把它看做一种装东西的容器，就像数组一样。它是一个接口，有很多的类实现了它，比如Arralist，LinkedList，HashMap，等等很多。不同的类使用不同的方法去实现，所以他们之间的某些性能是不同的。</p><h3 id="Collection中的方法"><a href="#Collection中的方法" class="headerlink" title="Collection中的方法"></a>Collection中的方法</h3><p>我们这次学习的是Collection接口中的方法，虽然实现它的类很多，但是它们实现的方法的功能都是一样。这里介绍七个方法</p><ul><li>add(E e)<ul><li>添加元素</li></ul></li><li>clear()<ul><li>清空集合中的所有元素</li></ul></li><li>remove(E e)<ul><li>删除元素</li></ul></li><li>contains(E e)<ul><li>查看是否包含某个元素</li></ul></li><li>isEmpty()<ul><li>查看数组是否为空</li></ul></li><li>size()<ul><li>返回集合的长度，即元素的个数</li></ul></li><li>toArray<ul><li>返回一个Onject类型的数组</li></ul></li></ul><p>下面我们以ArrayList为例来学习上面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//多态写法</span></span><br><span class="line">        <span class="comment">//测试add</span></span><br><span class="line">        collection.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        collection.add(<span class="string">"令狐冲"</span>);</span><br><span class="line">        collection.add(<span class="string">"郭靖"</span>);</span><br><span class="line">        collection.add(<span class="string">"杨过"</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//测试contains</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">"杨过"</span>));</span><br><span class="line">        <span class="comment">//测试size</span></span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line">        <span class="comment">//测试remove</span></span><br><span class="line">        collection.remove(<span class="string">"杨过"</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//测试toArray</span></span><br><span class="line">        Object[] objects = collection.toArray();</span><br><span class="line">        System.out.println(Arrays.toString(objects));</span><br><span class="line">        <span class="comment">//测试clear</span></span><br><span class="line">        collection.clear();</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到我们创建Collection对象时，与一般类相比创建多了&lt;&gt;，这个叫做泛型。是什么意思呢? 我们定义数组的话有不同的数据类型，来定义保存什么类型的数据，同样的Collection也有不同的数据类型，来决定里面保存的是什么类型的数据。而数据类型就是写在里面，目前我们就这么理解泛型，有关泛型更加详细的用法，下面会进行介绍。在=号的右边也有&lt;&gt;号，从JDK 1.7开始，右边的&lt;&gt;里面可以什么都不写，之前里面也要写数据类型，但是和右边的一样，所以没必要在写一遍。另一个需要注意的是，泛型（也就是&lt;&gt;里面的数据类型）必须是引用类型，不能是基本类型。</p><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张无忌, 令狐冲, 郭靖, 杨过]</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[张无忌, 令狐冲, 郭靖]</span><br><span class="line">[张无忌, 令狐冲, 郭靖]</span><br><span class="line">[]</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>我们对集合一个重要的操作就是对集合进行遍历，不同于数组，集合不是所有的都是有序的，所以无法通过索引对集合进行遍历，那我们就只能通过迭代器Iterator来遍历集合，Iterator也是一个接口，集合有一个iterator()方法，可以获取迭代器实现类的对象。迭代器主要有两个方法</p><ul><li>hasNext()<ul><li>判断集合中是否还有下一个元素，有则返回true</li></ul></li><li>next()<ul><li>取出集合中的下一个元素，如何集合中没有元素，使用该方法会抛出异常，所以应该先进行判断是否还有下一个元素</li></ul></li></ul><p>下面我们来示例使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//HashSet是一个无序的集合</span></span><br><span class="line">        Collection&lt;String&gt; collection = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        collection.add(<span class="string">"亚瑟"</span>);</span><br><span class="line">        collection.add(<span class="string">"妲己"</span>);</span><br><span class="line">        collection.add(<span class="string">"安其拉"</span>);</span><br><span class="line">        collection.add(<span class="string">"狄仁杰"</span>);</span><br><span class="line">        collection.add(<span class="string">"李白"</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[李白, 妲己, 狄仁杰, 亚瑟, 安其拉]</span><br></pre></td></tr></table></figure><p>可见HashSet是一个无序的集合，所以不能通过索引去获取集合中的元素，我们使用迭代器去遍历集合中的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = collection.iterator(); <span class="comment">//由集合的iterator()方法创建迭代器</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">//判断集合中是否还有下一个元素</span></span><br><span class="line">    String string = iterator.next(); <span class="comment">//取出下一个元素，每取出一个元素，指针向后移动</span></span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">李白</span><br><span class="line">妲己</span><br><span class="line">狄仁杰</span><br><span class="line">亚瑟</span><br><span class="line">安其拉</span><br></pre></td></tr></table></figure><h3 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h3><p>我们知道不能通过一般的for循环去遍历集合，所以Java中有一个增强的for循环，利用它可以遍历集合和数组，它的实现原理就是迭代器的原理，不过使用的是for循环的形式，我们把它叫做foreach循环，格式如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 变量名 : 集合)</span><br></pre></td></tr></table></figure><p>它会自动的取出集合中的元素，并且赋值给变量，然后你就可以在foreach循环中对取出的元素进行操作了，还是以上面的集合为例，演示如何使用foreach循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String string : collection) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">李白</span><br><span class="line">妲己</span><br><span class="line">狄仁杰</span><br><span class="line">亚瑟</span><br><span class="line">安其拉</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>泛型我们之前在使用Collection集合时就已经接触过，那么为什么会使用泛型，比如你正在写一个集合给别人使用，但是你不知道别人会保存什么数据类型，你不能写死了说只能保存String类型，这个时候我就会使用泛型，保存什么类型的数据由别人自己觉得，就像数组一样。</p><p>如果省略泛型的话，那么默认为Object类型，比如下面我创建一个ArrayList集合，没有写泛型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"AA"</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AA</span><br><span class="line"><span class="number">2</span></span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>这个时候ArrayList集合的对象能够添加任何的数据类型，因为所有的类都继承了Object类，而基本数据类型会进行自动装箱操作转化为对应的包装类。其实上面就是多态的写法，而多态的写法我们也知道它的弊端，他不能调用子类特有的方法，如果我们需要调用子类的方法的话就需要向下转型，这很容易发生异常，并且在编译时不会报错。并且一般我们在集合保存相同的数据类型，所以这个时候我们可以使用泛型。使用泛型的话至少有这两个优点</p><ul><li>避免了类型转换的麻烦</li><li>编译时就可以看到错误<ul><li>如果一个String的ArrayList添加Integer数据，那么编译时就会报错</li></ul></li></ul><h3 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>泛型定义在类中的格式应该如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中E就代表泛型，它会在创建对象的时候确定E是什么类型，比如ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();，那么这个时候E就是String。这么定义以后，我们就可以在类中的方法中使用E，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以让它作为方法的参数和返回值，如果在创建对象的时候传入的E是String，那么这些方法的参数或者返回全部都是String类型的。我们可以看做E是一个接收类类型的变量。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法中定义泛型，格式如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型&gt; 返回值 方法名(参数列表) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如下面这么定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(M m)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型会在调用方法时确定，比如传入的是一个String类型的参数，那么M就是String。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在接口中定义的格式如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类实现接口可以指定泛型是什么或者不指定，就是这个意思</p><ul><li>指定</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现类 implements InterfaceName&lt;String&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不指定</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现类&lt;E&gt; implements InterfaceName&lt;E&gt;</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>假设我要写一个方法，输入一个ArrayList对象，要求打印输入列表的所有元素，但是ArrayList是什么类型的不知道，所以方法参数类型不能写死，不能这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们在上面学了方法的泛型，所以我们可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(ArrayList&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java停供了一种更加方面的写法，即使用通配符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中?代表的就是通配符，指的就是能够匹配任何的数据类型。</p><p>不仅如此我们还能够对通配符进行限定，如</p><ul><li>? extends E<ul><li>说明参数的类型必须是<code>E</code>的子类或者<code>E</code>本身</li></ul></li><li>? super E<ul><li>说明参数的类型必须是<code>E</code>的父类或者<code>E</code>本身</li></ul></li></ul><p>比如下面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTongpeifu</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收的类型必须为Number类的子类或者Number类本身</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(ArrayList&lt;? extends Number&gt; list)</span> </span>&#123; </span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收的类型必须为Number类的父类或者Number类本身</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(ArrayList&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Number&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        show(list1); <span class="comment">//Interger是Number的子类，可以</span></span><br><span class="line">        show(list2); <span class="comment">//String类与Number类没有关系，报错</span></span><br><span class="line">        show(list3); <span class="comment">//Object不是Number的子类，报错</span></span><br><span class="line">        show(list4); <span class="comment">//Number本身，可以</span></span><br><span class="line"></span><br><span class="line">        show2(list1); <span class="comment">//Interger是子类，报错 </span></span><br><span class="line">        show2(list2); <span class="comment">//String没关系，报错</span></span><br><span class="line">        show2(list3); <span class="comment">//Object是父类，可以</span></span><br><span class="line">        show2(list4); <span class="comment">//Number本身，可以</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java21.png"/></center><p>与我们分析的一致。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口是Collection的子接口，实现它的类有ArrayList和LinkedList，ArrayList的底层实现原理是数组，所以它的查询速度快，但是它的增删操作很慢，LinkedList的底层实现原理是链表，所以它的查询操作很慢，它的增删操作很快。</p><h3 id="List集合的特点"><a href="#List集合的特点" class="headerlink" title="List集合的特点"></a>List集合的特点</h3><p>List接口的特点有</p><ul><li>有序，所以可以通过索引访问元素</li><li>集合中的元素允许重复</li></ul><p>因为List接口可以有索引，所以除了Collection中的方法，List还有其特有的方法如下</p><ul><li>add(int index, E e)<ul><li>在指定索引中的位置添加元素，后面的元素向后推移</li></ul></li><li>remove(int index)<ul><li>删除指定索引的元素，并且返回删除的元素</li></ul></li><li>get(int index)<ul><li>获得指定索引处的元素</li></ul></li><li>set(int index, E e)<ul><li>将索引处为元素替换为e</li></ul></li></ul><p>下面示例上面的四个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//[1, 5, 7]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//add(int index, E e)</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">8</span>); <span class="comment">//在索引为2的地方插入8</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[1, 5, 8, 7]</span></span><br><span class="line">        <span class="comment">//get(int index)</span></span><br><span class="line">        <span class="keyword">int</span> num1 = list.get(<span class="number">1</span>); <span class="comment">//获得索引为1的元素</span></span><br><span class="line">        System.out.println(num1); <span class="comment">//5</span></span><br><span class="line">        <span class="comment">//set(int index, E e)</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">//设置索引为0的元素为4</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[4, 5, 8, 7]</span></span><br><span class="line">        <span class="keyword">int</span> num2 = list.remove(<span class="number">2</span>); <span class="comment">//删除索引为2的元素</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[4, 5, 7]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p>因为List集合是有序的，所以有三种方法可以进行遍历</p><ul><li>普通for循环</li><li>迭代器</li><li>增强for循环</li></ul><p>下面进行示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通for写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器写法</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Integer i = iterator.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for写法</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList在之前我们讲解Collection时就有接触到，所以这里就简单的介绍它。ArrayList集合的使用非常的简单，在上面已经演示过了，并且它的方法都是实现List里面的方法，而这些方法的使用在上面已经了解了，下面看看ArrayList简单例子即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList对象 里面保存的都是String类型</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向列表中添加三个元素</span></span><br><span class="line">        list.add(<span class="string">"张三"</span>);</span><br><span class="line">        list.add(<span class="string">"李四"</span>);</span><br><span class="line">        list.add(<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印列表</span></span><br><span class="line">        System.out.println(list);  <span class="comment">//ArrayList对toString()方法重写了，所以打印输出不是地址值</span></span><br><span class="line">        <span class="comment">//获取列表里面的元素</span></span><br><span class="line">        System.out.println(<span class="string">"列表的第一个元素为："</span> + list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">"列表的第二个元素为："</span> + list.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"列表的第三个元素为："</span> + list.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"列表的长度为："</span> + list.size());  <span class="comment">//获取列表的长度</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        System.out.println(<span class="string">"删除的元素为："</span> + list.remove(<span class="number">1</span>)); <span class="comment">//删除第二个元素，即删除李四</span></span><br><span class="line">        System.out.println(<span class="string">"列表的长度为："</span> + list.size()); <span class="comment">//列表的长度</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张三, 李四, 王五]</span><br><span class="line">列表的第一个元素为：张三</span><br><span class="line">列表的第二个元素为：李四</span><br><span class="line">列表的第三个元素为：王五</span><br><span class="line">列表的长度为：<span class="number">3</span></span><br><span class="line">===============</span><br><span class="line">删除的元素为：李四</span><br><span class="line">列表的长度为：<span class="number">2</span></span><br><span class="line">[张三, 王五]</span><br></pre></td></tr></table></figure><p>上面代码的注释已经详细说明上面代码的功能，这里说一下一个特别的地方。当我们打印数组名时，会得到数组的地址，但是当我们打印ArrayList对象，输出的不是地址，而是里面的元素，这是因为ArrayList重写了toString()方法，当System.out.println()里面传入的是引用类型时，会调用该引用类型的toString方法，由于ArrayList重写了toString()方法，所以打印输出的不是地址，没有重写该方法的类，打印输出默认是地址。如果在这里你搞不懂什么重写，toString()方法都是什么，那么没关系，你只要知道<strong>直接打印ArrayList对象名，输出的不是地址，而是里面包含的所有元素</strong>，具体重写是什么，toString()是什么，在后面的继承部分将会有阐述。</p><p>需要注意的是，泛型只能是引用类型，不能是基本数据类型，那么如果我们想要保存基本数据类型怎么办。当然是有办法的，Java中为每一个基本数据类型提供了一个包装类，它虽然是一个类，但是你在使用时完全把它当做基本数据类型就可以，因为泛型里面不能是基本数据类型，才会有这么一个包装类。下表是基本数据类型与包装类对应的名称</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>上面除了int和char对应的包装类不只是首字母大写，其他都是只要首字母大写即可。下面我将演示如何存储基本数据类型，以int类型为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDataToArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把Integer当做int看待即可，我们不需要new 一个Integer对象 编译器会帮我们做处理，我们不需要担心</span></span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">25</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印列表</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">100</span>, <span class="number">25</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure><p>在基本数据类型与包装类之间有自动装换，基本数据类型转换为包装类的过程叫做<strong>装箱</strong>，包装类转化为基本数据类型的过程叫做<strong>拆箱</strong>，从JDK 1.5开始就支持自动装箱和自动拆箱。即我们可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interger a = <span class="number">12</span>; <span class="comment">//自动装箱 int -- Interger</span></span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">//自动拆箱 Interger -- int</span></span><br></pre></td></tr></table></figure><p>所以我们在使用时把Interger看做int就可以了。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是List的实现类，它的底层原理是基于链表实现的，所以除了List接口中的方法，它还提供了很多与头尾有关的方法，如</p><ul><li>addFirst</li><li>addLast</li><li>removeFirst</li><li>removeLast</li><li>getFirst</li><li>getLast</li><li>push<ul><li>同addFirst一样</li></ul></li><li>pop<ul><li>同removeFirst</li></ul></li></ul><p>下面进行示范</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="string">"AAA"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"BBB"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//addFirst 在"AAA"前面添加元素"CCC"</span></span><br><span class="line">        linkedList.addFirst(<span class="string">"CCC"</span>);</span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[CCC, AAA, BBB]</span></span><br><span class="line">        <span class="comment">//push 在"CCC"前面添加"DDD"</span></span><br><span class="line">        linkedList.push(<span class="string">"DDD"</span>);</span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[DDD, CCC, AAA, BBB]</span></span><br><span class="line">        <span class="comment">//pop 删除"DDD"</span></span><br><span class="line">        System.out.println(linkedList.pop()); <span class="comment">//DDD</span></span><br><span class="line">        <span class="comment">//获得第一个元素 getFirst</span></span><br><span class="line">        System.out.println(linkedList.getFirst()); <span class="comment">//CCC</span></span><br><span class="line">        <span class="comment">//removeFirst 删除第一个元素</span></span><br><span class="line">        System.out.println(linkedList.removeFirst()); <span class="comment">//CCC</span></span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[AAA, BBB]</span></span><br><span class="line">        <span class="comment">//removeLast 删除最后一个元素</span></span><br><span class="line">        System.out.println(linkedList.removeLast()); <span class="comment">//BBB</span></span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[AAA]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本类型与包装类"><a href="#基本类型与包装类" class="headerlink" title="基本类型与包装类"></a>基本类型与包装类</h2><p>在前面我们就讲过这个概念，不过当时讲的不够详细，现在深入讲解。首先我们知道包装类是什么，因为基本数据类型它不是引用类型，而由于泛型必须是引用类型，所以才有包装类。包装类就是将基本数据类型包装为一个类，这个类我们完全可以当做基本数据类型使用，并且包装类除此之外，还提供了一些方法用法操作基本数据类型，这是基本数据类型所没有的。</p><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>首先我们将如何进行装箱操作，即将基本数据类型转换为对象的包装类，下面全部以Integer为例，其余的同理，Integer对象的创建有两种方法，一种是通过构造方法，一种是通过Integer的一个静态方法</p><ul><li>构造方法<ul><li>Interger(int value)<ul><li>接收一个int类型的数值</li></ul></li><li>Interger(String str)<ul><li>接收一个字符串，该字符串要符合规定的格式，如”100”</li></ul></li></ul></li><li>静态方法<ul><li>valueOf()<ul><li>接收的参数同构造方法，也可以接收字符串类型的参数</li></ul></li></ul></li></ul><p>下面演示如何创建Interger对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer in1 = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">Integer in2 = <span class="keyword">new</span> Integer(<span class="string">"20"</span>);</span><br><span class="line">Integer in3 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">Integer in4 = Integer.valueOf(<span class="string">"2000"</span>);</span><br><span class="line">System.out.println(in1 + <span class="string">" "</span> + in2 + <span class="string">" "</span> + in3 + <span class="string">" "</span> + in4);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">20</span> <span class="number">200</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>那如何通过包装类得到一个基本数据类型呢？通过intValue方法，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = in1.intValue();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>自从JDK 1.5以后就实现了自动装箱和拆箱，可以直接把基本数据类型赋值给包装类，也可以把包装类直接赋值给基本数据类型，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer num = <span class="number">10</span>; <span class="comment">//自动装箱 相当于 Integer num = new Interger(10)  不过现在是自动进行的了</span></span><br><span class="line"><span class="keyword">int</span> i = num; <span class="comment">//自动拆箱 相当于 int i = num.intValue()</span></span><br></pre></td></tr></table></figure><h3 id="基本数据类型与字符串类型相互转换"><a href="#基本数据类型与字符串类型相互转换" class="headerlink" title="基本数据类型与字符串类型相互转换"></a>基本数据类型与字符串类型相互转换</h3><p>基本数据类型转换为字符串类型</p><ul><li>基本数据类型 + “”,如100 + “”得到”100”</li><li>包装类的toString(参数)，这个不是Onject的toString()方法，因为它有参数，不是重写<ul><li>如Integer.toString(100)得到”100”</li></ul></li><li>String类的valueOf(参数)方法，如String.valueOf(100)得到”100”</li></ul><p>字符串转基本数据类型</p><ul><li>包装类的parseXxx，如Integer.parseInt(“100”)得到基本数据类型100</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set接口也是Collection的子接口，它的实现类有HaseSet，LinkedHashSet，HashSet是无序的，LinkedHashSet是有序的。</p><h3 id="Set集合的特点"><a href="#Set集合的特点" class="headerlink" title="Set集合的特点"></a>Set集合的特点</h3><ul><li>集合中的元素不能重复</li><li>没有索引</li></ul><p>下面看一个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">//无序且不能重复 [1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见集合的顺序与添加的顺序无关，并且添加重复的元素是不行的。</p><blockquote><p>Set集合不能添加重复元素的原理：Set集合的底层原理是Hash表，首先会根据要添加的元素计算出它的哈希值，根据哈希值添加到数组中，数组中存储的是链表或者红黑树，元素会添加到数组里面的链表或者红黑树中。一般不同的元素会添加到数组的不同索引中，即不同的链表或红黑树中，但是也有可能虽然元素不同，但是它们的哈希值相同，这个就叫做哈希冲突。如果发生了哈希冲突，那么会使用equals()方法判断该链表或红黑树中是否存在与这个元素相同的元素，如果有，那么就不添加，如果没有，那么就添加。</p></blockquote><p>所以如果你要添加自定义的类型，那么就要重写Object类的hashCode()方法和equals()方法。</p><h3 id="Set集合的遍历"><a href="#Set集合的遍历" class="headerlink" title="Set集合的遍历"></a>Set集合的遍历</h3><p>Set由于它是无序的，所以它不能使用普通for循环遍历，所以只能使用</p><ul><li>迭代器</li><li>增强for</li></ul><p>由于与List差不多，这里就不在演示了。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet是HashSet的子类，但是它是有序的。如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">"aaa"</span>);</span><br><span class="line">        set.add(<span class="string">"ccc"</span>);</span><br><span class="line">        set.add(<span class="string">"bbb"</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">//[aaa, ccc, bbb] 与添加的顺序相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数指的方法能够接受的参数可以为多个，定义格式如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型... 变量名</span><br></pre></td></tr></table></figure><p>它的底层原理是数组，会把这多个元素放到一个数组中。假设下面方法接受多个整数类型的参数，但是不知道能接受多少个，然后打印出这些数的和，那么就可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestKebiancanshu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... ints)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ints就是一个数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            sum += ints[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//可以传入多个参数，也可以不传 </span></span><br><span class="line">        sum(<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>一个方法只能有一个可变参数</li><li>一个方法如果有多个参数，可变参数要写在末尾</li></ul><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections是一个工具类，它提供了很多的静态方法用来对Collection集合进行操作。我们下面就简单介绍Collections类的三个方法</p><ul><li>addAll(Collection&lt;? super T&gt; c, T… elements)<ul><li>接收两个参数，第一个为Collection集合，第二个参数为可变参数</li><li>为集合添加多个元素，如addAll(list, 1, 2, 3)</li></ul></li><li>shuffle(List&lt;?&gt; list)<ul><li>接收一个List集合，将集合里面的元素随机打乱</li></ul></li><li>sort(List&lt;T&gt; list)<ul><li>接收一个list集合，将按照默认升序的规则排序</li><li>如果集合里面装的是自定义的类的对象，那么该类要实现Comaprable接口，并且要重写compareTo()方法</li></ul></li><li>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)<ul><li>接收一个List集合和一个实现Comparator接口的类的对象，可以传入匿名类</li></ul></li></ul><p>下面演示方法的使用</p><ul><li>addAll</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArratList&lt;&gt;();</span><br><span class="line">Collections.addAll(list1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(list1); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li>shuffle</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">Collections.shuffle(list2);</span><br><span class="line">System.out.println(list2);  <span class="comment">//[6, 4, 3, 5, 2, 1]</span></span><br></pre></td></tr></table></figure><ul><li>sort(List&lt;T&gt; list)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先演示对Integer类的排序</span></span><br><span class="line">List&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list3, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">Collections.sort(list3);</span><br><span class="line">System.out.println(list3); <span class="comment">//[1, 4, 5, 6, 7, 10]</span></span><br></pre></td></tr></table></figure><p>下面演示自定义类的排序，首先我们定义一个Person类，它有name和age属性，我们根据age的大小进行升序排序，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age; <span class="comment">//降序o.age - this.age</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试该类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>, <span class="number">18</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"刘亦菲"</span>, <span class="number">21</span>);</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list4, p1, p2, p3);</span><br><span class="line">Collections.sort(list4);</span><br><span class="line">System.out.println(list4);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Person&#123;name=<span class="string">'迪丽热巴'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'古力娜扎'</span>, age=<span class="number">20</span>&#125;, Person&#123;name=<span class="string">'刘亦菲'</span>, age=<span class="number">21</span>&#125;]</span><br></pre></td></tr></table></figure><ul><li>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</li></ul><p>这次我们不需要实现Comparable接口，只需要传入一个Comparator的实现类对象就可以，该类重写Comparator中的compare方法，在该方法中规定了排序的规则，我们可以传入一个匿名类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list5 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list5, p1, p2, p3);</span><br><span class="line">Collections.sort(list5, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list5);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Person&#123;name=<span class="string">'迪丽热巴'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'古力娜扎'</span>, age=<span class="number">20</span>&#125;, Person&#123;name=<span class="string">'刘亦菲'</span>, age=<span class="number">21</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>之前我们介绍的集合如List，Set都是单列集合，下面我们将介绍双列集合Map，它是通过键K去寻找值V的，所以说它是一个双列集合。它是一个接口，它的常用子类有HashMap和LinkedHashMap。其中HashMap是无序的，即在集合中存储的顺序与你添加的顺序是不一致的。LinkedHashMap是有序，即添加顺序与保存的顺序相同。LinkedHashMap是HashMap的子类。我们之前介绍的HashSet类是调用HashMap实现的，它只利用了HashMap的K。</p><h3 id="Map集合的方法"><a href="#Map集合的方法" class="headerlink" title="Map集合的方法"></a>Map集合的方法</h3><p>下面介绍Map集合的常用方法</p><ul><li>put(key, value)<ul><li>向Map中添加一对键值对，由于Map集合中的key是不能重复的，如果Map中已经存在该key，那么将集合中该key所对应的value值替换为添加的value，即相当于更新，并且返回被替换的value值，如果该集合中不存在该key，那么将该键值对添加，并且返回null</li></ul></li><li>get(key)<ul><li>通过键值来获得对应的value值，如果集合不存在该key，那么返回null</li></ul></li><li>remove(key)<ul><li>根据键来删除该键值对，如果该key不存在，那么返回null，如果存在，那么返回对应的value值</li></ul></li><li>containsKey(key)<ul><li>判断集合中是否存在键key，有则返回true，否则返回false</li></ul></li></ul><p>下面简单演示这四个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里已经有"迪丽热巴"这个键了，所以对应的值会被更改为20，并将该值18返回</span></span><br><span class="line">        <span class="comment">//这里最好使用Integer接收，因为可能返回null 而基本数据类型不能被赋值为null</span></span><br><span class="line">        Integer val1 = map.put(<span class="string">"迪丽热巴"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(val1); <span class="comment">//18</span></span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;佟丽娅=20, 迪丽热巴=20, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过键去获得值</span></span><br><span class="line">        Integer val2 = map.get(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        System.out.println(val2); <span class="comment">//19</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除键"佟丽娅"对于的键值对</span></span><br><span class="line">        Integer val3 = map.remove(<span class="string">"佟丽娅"</span>);</span><br><span class="line">        System.out.println(val3); <span class="comment">//20</span></span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;迪丽热巴=20, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否包含键"佟丽娅"</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">"佟丽娅"</span>)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历Map集合"><a href="#遍历Map集合" class="headerlink" title="遍历Map集合"></a>遍历Map集合</h3><p>主要有两个方法用来遍历Map集合</p><ul><li>keySet<ul><li>该方法会返回Set集合，里面是key的值，然后我们可以遍历该Set集合来遍历Map集合</li></ul></li><li>entrySet<ul><li>该方法也返回一个Set集合，不过这个集合里面的是Entry对象，Entry是Map的内部类，该类会在添加键值对时创建一个Entry对象保存相应的key和value的信息，我们可以通过Entry对象的getKey()和getValue()方法来获得键和值。同样我们可以遍历该Set集合来遍历Map集合</li></ul></li></ul><p>下面演示两个方法的使用</p><ul><li>keySet</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得key的Set集合</span></span><br><span class="line">        Set&lt;String&gt; set1 = map.keySet();</span><br><span class="line">        <span class="comment">//遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span> (String set: set1) &#123;</span><br><span class="line">            System.out.println(set + <span class="string">"="</span> + map.get(set));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Entry对象组成的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set2 = map.entrySet();</span><br><span class="line">        <span class="comment">//遍历该集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; set : set2) &#123;</span><br><span class="line">            System.out.println(set.getKey() + <span class="string">"="</span> + set.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">佟丽娅=<span class="number">20</span></span><br><span class="line">迪丽热巴=<span class="number">18</span></span><br><span class="line">古力娜扎=<span class="number">19</span></span><br><span class="line">佟丽娅=<span class="number">20</span></span><br><span class="line">迪丽热巴=<span class="number">18</span></span><br><span class="line">古力娜扎=<span class="number">19</span></span><br></pre></td></tr></table></figure><h2 id="斗地主案例练习"><a href="#斗地主案例练习" class="headerlink" title="斗地主案例练习"></a>斗地主案例练习</h2><p>该案例模拟斗地主的发牌和看牌过程，加强对集合的使用。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们要使用Map&lt;Integer, String&gt;集合来保存一副扑克，Integer是索引，String是对应的扑克牌。我们通过索引去找牌，到时候把索引发给玩家就可以，这样因为玩家拿到的是索引，那么就可以进行排序。我们首先要创建一副扑克，可以使用两个String数组，一个保存花色，一个保存数字，然后通过循环组合两个数组来组合一副扑克牌。因为我们要进行排序，所以Integer的大小和牌的大小要一一对应，即0对应大王，1对应小王，2-5对应四个2，以此类推。洗牌我们可以使用Collections的shuffle()方法，由于该方法要求传入List集合，我们要创建一个List集合，该集合要保存Integer索引。发牌就把索引发给玩家，玩家通过索引去Map集合中看牌。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doudizhu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用两个数组组合形成一幅扑克牌</span></span><br><span class="line">        String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line">        String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将扑克牌存储到Map集合中，键为整数索引，方便排序，值为牌，通过索引拿牌</span></span><br><span class="line">        Map&lt;Integer,String&gt; poker = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为使用Collections.shuffle方法洗牌，所以要使用List集合存储索引</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将大小王添加到Map中，并将索引添加到List中</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        poker.put(index,<span class="string">"大王"</span>);</span><br><span class="line">        list.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        poker.put(index,<span class="string">"小王"</span>);</span><br><span class="line">        list.add(index);</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个数组组合形成一副牌</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                poker.put(index,color+number);</span><br><span class="line">                list.add(index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; player1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发牌，将索引发给玩家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipai.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                player1.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                player2.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                player3.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给牌排序</span></span><br><span class="line">        Collections.sort(player1);</span><br><span class="line">        Collections.sort(player2);</span><br><span class="line">        Collections.sort(player3);</span><br><span class="line">        Collections.sort(dipai);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看牌</span></span><br><span class="line">        lookPoker(player1,poker,<span class="string">"刘德华"</span>);</span><br><span class="line">        lookPoker(player2,poker,<span class="string">"周润发"</span>);</span><br><span class="line">        lookPoker(player3,poker,<span class="string">"周星驰"</span>);</span><br><span class="line">        lookPoker(dipai,poker,<span class="string">"底牌"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看牌方法 通过玩家的索引去Map集合中找到对应的牌  并打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookPoker</span><span class="params">(ArrayList&lt;Integer&gt; list, Map&lt;Integer,String&gt; poker,String name)</span> </span>&#123;</span><br><span class="line">        System.out.print(name + <span class="string">"的牌是： "</span>);</span><br><span class="line">        <span class="comment">//通过玩家的索引，去poker中取牌</span></span><br><span class="line">        <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">            System.out.print(poker.get(number) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java22.gif"/></center>]]></content>
    
    <summary type="html">
    
      讲解Java常用的集合以及与泛型有关的知识
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="泛型" scheme="https://lastknightcoder.gitee.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="集合" scheme="https://lastknightcoder.gitee.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象</title>
    <link href="https://lastknightcoder.gitee.io/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lastknightcoder.gitee.io/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-07-04T16:00:00.000Z</published>
    <updated>2019-07-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在最初的开始，人们编写程序的基于过程的，那时候的编程方式是面向过程的。但是人们发现，随着代码规模的扩大，编写大规模的程序使用面向过程的方法十分的困难，这时候人们必须提出一种新的编程思想，使得编写大型程序变得简单。这种思想就是面向对象的思想。</p><p>就像我们学习数学一样，随着我们学习的深入，我们一直在进行抽象，比如从数抽象到代数，并且不断提出新的概念，提出很多的定理，方便我们的学习研究。面向对象也是一样，它把实际中的事物抽象出来，这个事物可以是我们见到的实物，比如椅子，桌子，手机，也可以是我们我们看不见的东西，比如某个系统。这个抽象出来的东西我们叫做类，我们利用类的概念，可以清楚的把握类与类之间的关系，使得程序的结构十分的清晰，便于管理，便于开发大型的程序。</p><p>我们把抽象出来的东西叫做类，那么一个类的实例就是对象。比如，我们把人抽象为了一个类，这是一个抽象的概念，那么小明这个具体的人就是该类的一个实例，也叫做对象。我们把椅子抽象为一个类，一个具体的椅子就是一个对象。类可以看做是对象的模板，对象可以看做是类的具体实现。</p><p>我们可以通过两个方面是描述一个事物，一个是属性，比如说对于人这个类，它的属性就有姓名，身高，年龄等等，这些都是它的属性，另一个就是行为，比如说人的行为有吃饭，睡觉等等。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类使用关键字class进行定义，我们在之前用过很多次，但是我们之前不知道这是什么，比如在HelloWorld案例中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中HelloWorld表示的就是类名。类定义的格式是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们有提到，一个事物可以由属性和行为两部分描述，表现在程序书写中为成员变量和成员方法，其中变量用来描述类的属性，方法用来描述类的行为，前面加上成员二字以表示与局部变量的不同，例如下面定义了一个Person类，它有姓名，年龄属性，有吃和睡的行为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃吃吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡睡睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到成员变量时定义在类当中的，并且成员方法没有使用关键字static修饰。</p><p>我们定义了一个类，那我们怎么使用它呢? 从前面我们了解到，类是一个抽象的概念，是一个模板，我们要将它具体化才能够使用它，类是不能够直接使用的，而具体化的过程就是创建一个对象。创建对象的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名称 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><p>例如下面创建一个per的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃吃吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡睡睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Person per = <span class="keyword">new</span> Person(); <span class="comment">//创建一个名为per的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建这个对象的模板是Person类，那么它就应该有name, age属性和eat, sleep行为，那么我们怎么去使用这些东西呢? 方法就是通过点语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.属性 <span class="comment">//使用属性</span></span><br><span class="line">对象名.方法() <span class="comment">//使用方法</span></span><br></pre></td></tr></table></figure><p>例如下面我们打印出per对象的属性值，并且调用它的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person per = <span class="keyword">new</span> Person(); <span class="comment">//创建一个名为per的对象</span></span><br><span class="line">    System.out.println(per.name);</span><br><span class="line">    System.out.println(per.age);</span><br><span class="line">    per.eat();</span><br><span class="line">    per.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">吃吃吃</span><br><span class="line">睡睡睡</span><br></pre></td></tr></table></figure><p>我们发现per.name的值是null，per.age的值是0，实际上我们并没有给per.name和per.age赋值，系统在创建对象时会有默认值，规则和数组的一样。</p><h2 id="类的内存模型"><a href="#类的内存模型" class="headerlink" title="类的内存模型"></a>类的内存模型</h2><p>我们来看看执行下面的代码，在内存中发生了什么</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃吃吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡睡睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person(); <span class="comment">//创建一个名为per的对象</span></span><br><span class="line">        System.out.println(per.name);</span><br><span class="line">        System.out.println(per.age);</span><br><span class="line">        per.eat();</span><br><span class="line">        per.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器首先会在方法区中找main方法，然后将它推入栈中</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java08.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>这行语句会在main中创建一个per变量，接着会在堆中开辟出一块空间，存储的是per这个对象，这个对象是以方法区中的类为模板的，该对象具有成员变量和成员方法。但是注意的是，对象的成员方法是地址值，指向方法区中的方法的信息，当调用方法时，会根据该地址值去方法区中寻找该方法。由于每个对象的行为都是一样的，只是属性不同，所以不需要在堆中为每一个对象都开辟空间来保存方法的信息，只需要保存一个地址值即可。这样做可以节省内存空间。</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java09.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(per.name);</span><br><span class="line">System.out.println(per.age);</span><br><span class="line">per.eat();</span><br><span class="line">per.sleep();</span><br></pre></td></tr></table></figure><p>上面的语句是访问对象的成员变量和成员方法，首先会根据per对象保存的地址值，去堆中寻找对应的保存地址，然后根据成员变量名去访问数据。调用成员方法，分为了四步，第一步是根据per对象的地址值找到堆中的方法；第二步，堆中的方法保存的地址值，根据堆中的地址值去方法区中查找方法的信息；第三步，将方法压入栈中，栈会为该方法开辟一块空间；第四步，方法执行完毕，方法被栈移除。</p><h2 id="对象与方法"><a href="#对象与方法" class="headerlink" title="对象与方法"></a>对象与方法</h2><p>对象作为一种数据类型，它也可以作为方法的参数和返回值。与数组一样，传递的是地址值，返回的也是地址值。</p><h3 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printObject</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line">    System.out.println(per.name);</span><br><span class="line">    System.out.println(per.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象作为返回值"><a href="#对象作为返回值" class="headerlink" title="对象作为返回值"></a>对象作为返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPersonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person per = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><p>成员变量与局部变量的区别</p><ul><li><strong>定义的位置不一样</strong><ul><li>局部变量：定义在方法中</li><li>成员变量：定义在方法之外，定义在类中</li></ul></li><li><strong>作用范围不一样</strong><ul><li>局部变量：只能在方法中使用</li><li>成员变量：在类中都可以使用</li></ul></li><li><strong>默认值</strong><ul><li>局部变量：没有默认值</li><li>成员变量：有默认值，规则同数组</li></ul></li><li>在内存中的位置不一样<ul><li>局部变量：在栈内存中</li><li>成员变量：在堆内存中</li></ul></li><li>生命周期<ul><li>局部变量：随着方法的进栈而产生，随着方法的出栈而消失</li><li>成员变量：随着对象的创建而产生，随着对象的被垃圾回收而消失</li></ul></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象有三大特性，分别为</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>下面详细讲述其中的封装。</p><p>我们知道，当我们创建了一个对象之后，可以通过点(.)语法去访问成员变量，也可以为它赋值，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.name = <span class="string">"李四"</span>;</span><br><span class="line">        per.age = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我叫做：李四，我：<span class="number">20</span>岁。</span><br></pre></td></tr></table></figure><p>但是一旦我们将成员变量使用修饰符private修饰的话，那么我们就不能通过.语法访问成员变量了，如下面的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.name = <span class="string">"李四"</span>; <span class="comment">//编译成功</span></span><br><span class="line">        per.age = <span class="number">20</span>; <span class="comment">//编译成功</span></span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现怎么使用private修饰的变量怎么还可以访问，不是说不可以访问了吗? 这是因为main方法是Person类的方法，在一个类里面是可以随便访问的，现在有一个Test类，然后我们去访问数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.name = <span class="string">"李四"</span>; <span class="comment">//编译失败</span></span><br><span class="line">        per.age = <span class="number">20</span>; <span class="comment">//编译失败</span></span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private就是私有的意思，意味的这个变量的私密的，外部不可以访问，如果要访问的话，只能通过getter和setter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String who)</span></span>&#123;</span><br><span class="line">        name = who;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在Test类中创建Person对象访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.setName(<span class="string">"李四"</span>); <span class="comment">//通过setter方法去设置成员变量的值</span></span><br><span class="line">        per.setAge(<span class="number">20</span>); <span class="comment">//通过setter方法去设置成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我叫做：李四，我：<span class="number">20</span>岁。</span><br></pre></td></tr></table></figure><p>明显可见，下面的代码量比上面大了很多，感觉这么做是多此一举，那么为什么要这么做呢？考虑下面这么一种情况，如果没有进行封装，那么我们可以使用<code>.</code>语法为age变量赋值，我们可以赋值为-20，这明显是不合理的，但是可以进行赋值，如果我们进行封装，那么我们可以在setter方法中进行判断，使得一些不合理的，有害的操作不能够正常赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getter方法和setter方法的格式一般为”get变量名”或”set变量名”，根据驼峰命名法，变量名首字母需要大写，如上面的setAge, getAge。但是如果getter方法的返回值是boolean类型的话，我们一般写成isXxx的形式。</p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>考虑上例我们的setter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String who)</span></span>&#123;</span><br><span class="line">    name = who;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我一直想写成这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的想法是第一个name是成员变量name，第二个name是传入的参数，但是这样不行，因为这时的两个name都被看做是传入的参数，那有什么办法可以解决成员变量与局部变量重名的问题吗？方法就是使用this关键字，修改上面代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时this.name就代表的是成员变量name。那么this到底是个什么东西？<strong>哪个对象调用这个方法，那么this就是调用这个方法的对象</strong>.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">per.setName(<span class="string">"李四"</span>);</span><br></pre></td></tr></table></figure><p>per这个对象调用setName方法，那么这时的this就是per。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法其实就是创建对象的方法，用new在创建对象，就是在调用这个方法。还记得我们是怎么创建对象的吗</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>其中Person()就是构造方法。</p><h3 id="构造方法的定义"><a href="#构造方法的定义" class="headerlink" title="构造方法的定义"></a>构造方法的定义</h3><p>构造方法定义的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>构造方法名要与类名的完全一样，包括大小写</li><li>不要写返回值类型，void也不要写</li><li>不能return一个具体的返回值</li></ul><p>构造方法同成员方法一样，是定义在类中的，但是我们好像到现在从来没有定义过构造方法，但是我们却可以使用，这时为什么？</p><ul><li>如果我们没有编写构造方法，那么编译器会为我们自动生成一个构造方法，该构造方法没有参数，方法体为空，比如像这样</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是一旦当我们定义了一个构造方法，那么编译器不会自动生成一个构造方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>,name = name;</span><br><span class="line">    <span class="keyword">this</span>,age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义个一个构造方法，此时总共就这一个构造方法，编译器不会自动生成。但是我们一般还会写一个无参的构造方法，继承那里会讲到为什么。</p><ul><li>构造方法也可以进行重载，在上面我们已经演示了</li></ul><h3 id="利用构造方法进行初始化"><a href="#利用构造方法进行初始化" class="headerlink" title="利用构造方法进行初始化"></a>利用构造方法进行初始化</h3><p>我们一般可以利用构造方法进行初始化，注意我们之前初始化都是这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person();</span><br><span class="line">per.setName(<span class="string">"李四"</span>);</span><br><span class="line">per.setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>现在我们定义一个有两个参数的构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以这么调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这一行的代码与上面三行代码的效果是一样的。</p><h2 id="一个标准的类"><a href="#一个标准的类" class="headerlink" title="一个标准的类"></a>一个标准的类</h2><p>一个标准的类应该满足一下特点</p><ul><li>所有的成员变量都使用private修饰</li><li>为每一个成员变量编写一个setter,getter方法</li><li>编写一个无参构造函数</li><li>编写一个有参构造函数</li></ul><p>一个标准的类也叫做Java Bean。</p><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>所谓的匿名对象，指的就是没有名字的对象。即在创建对象时，并没有为它赋予变量名。由于它没有名字，没有变量保存它的地址，所以它只能够使用一次，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().age;</span><br></pre></td></tr></table></figure><p>如果某个对象只使用一次的话，我们可以考虑使用匿名对象。</p><h3 id="匿名对象作为方法的参数"><a href="#匿名对象作为方法的参数" class="headerlink" title="匿名对象作为方法的参数"></a>匿名对象作为方法的参数</h3><p>匿名对象也是对象，当然可以作为方法的参数。匿名对象传入方法的是地址值，下面举一个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getNum方法接收一个Scanner对象，返回一个int类型的数值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(Scanner sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入了一个匿名对象</span></span><br><span class="line">        <span class="keyword">int</span> num = getNum(<span class="keyword">new</span> Scanner(System.in));</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行效果为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java10.gif"/></center><h3 id="匿名对象作为方法的返回值"><a href="#匿名对象作为方法的返回值" class="headerlink" title="匿名对象作为方法的返回值"></a>匿名对象作为方法的返回值</h3><p>匿名对象也可以作为方法的返回值，返回的也是地址值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个Scanner对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">getScannerObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//GetScannerObject方法返回一个Scanner对象</span></span><br><span class="line">        Scanner sc = getScannerObject();</span><br><span class="line">        String str = sc.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行效果为</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java11.gif"/></center><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static关键字我们在之前见到过很多次了，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在定义方法时</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都用到static，而在成员方法中却没有用到static，所以这里我们就来看看static到底是什么，它有什么用。</p><h3 id="static修饰符的作用"><a href="#static修饰符的作用" class="headerlink" title="static修饰符的作用"></a>static修饰符的作用</h3><p>一旦被static修饰，不管是变量还是方法，那么这么变量或方法不再是属于某个对象的，而是属于类，相当于说被static修饰之后，就不是某个人的私有财产，而是大家的公共财产。被static修饰的变量和方法分别叫做静态变量和静态方法。</p><p>访问static修饰的变量或方法，可以通过.语法，可以通过类名.，也可以通过对象名.。以前我们调用成员变量和成员方法就是通过对象名<code>.</code>出来的。但是这里推荐使用类名.，这样大家一眼就可以看出这是共有财产而不是私有财产。而且即使你使用了对象名.，在编译器编译时也会自动转换为类名.。</p><p>为了理解static修饰符，我们来看这么一个例子。假设有一个Student类，里面有一个id成员变量，我们希望每当创建一个对象时，会自动赋予id变量一个值，比如说，如果one第一个创建的学生，那么它的id就是1，以此类推。我们可以使用一个static变量idCounter来计数，每创建一个对象它就加一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idCounter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每创建一个对象，id计数器加一，并且赋给id</span></span><br><span class="line">        <span class="keyword">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">//每创建一个对象，id计数器加一，并且赋给id</span></span><br><span class="line">        <span class="keyword">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student one = <span class="keyword">new</span> Student(<span class="string">"one"</span>);</span><br><span class="line">        System.out.println(<span class="string">"我的名字是："</span> + one.name + <span class="string">"我的id是："</span>  + one.id);</span><br><span class="line">        Student two = <span class="keyword">new</span> Student(<span class="string">"two"</span>);</span><br><span class="line">        System.out.println(<span class="string">"我的名字是："</span> + two.name + <span class="string">"我的id是："</span>  + two.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我的名字是：one我的id是：<span class="number">1</span></span><br><span class="line">我的名字是：two我的id是：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里我要解释一下，为什么有的方法使用static修饰了，我们知道，如果使用static修饰，该方法就可以通过类<code>.</code>出来，如果这个方法是本类的，那么类名可以省略不写。比如这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在这里调用add方法，属于同一个类，可以省略类名</span></span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要直接在main方法中直接使用这个方法，我们就会使用static修饰。这里只是解释前面为什么有的方法要使用static修饰，因为我们希望直接调用。</p><p>这里有关static有几个需要注意的事项</p><ul><li>静态只能访问静态，静态不能访问非静态。即在静态方法里面，不能访问成员变量，也不能调用成员方法。这时因为在内存中，先有静态内容，后有非静态内容。”先人不知后人，后人知道先人”。</li><li>静态方法中不能使用this。我们知道，谁调用这个方法，那么this就是这个对象。但是调用静态方法是类，而不是对象，即使使用对象调用静态方法，编译器在编译时也会转换为类调用。</li></ul><h3 id="static的内存图"><a href="#static的内存图" class="headerlink" title="static的内存图"></a>static的内存图</h3><p>在方法区中有一块内存空间，专门用以保存静态变量的</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java12.png"/></center><p>从上面的图可以看出来，静态变量与对象没有任何关系。</p><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块的格式是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码块写在类中。它的特点是在第一次创建对象的时候执行唯一的一次。后面在创建对象不会再执行。它先于构造方法的执行。它的作用一般是为了初始化静态变量。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承，主要解决的是共性抽取。子类继承了父类，就拥有父类所有的成员变量和成员方法。除此之外，子类还可以拥有自己的内容。子类与父类的关系，可以这么理解：子类就是一个父类。比如父类是人，子类是学生，子类就是父类说的就是<strong>学生是人</strong>。也叫is-a关系。</p><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>子类通过extends关键字基础父类，而父类的定义与一般类的定义相同，现在假设有一个父类Person和一个子类Student。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//子类拥有父类的成员变量和成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子类访问父类成员变量"><a href="#子类访问父类成员变量" class="headerlink" title="子类访问父类成员变量"></a>子类访问父类成员变量</h3><p>上面讲过，一旦子类继承了父类，那么子类就拥有子类的所有成员变量和成员方法。那么子类怎么访问父类的成员变量，这里分为重名和不重名两种</p><ul><li>不重名<ul><li>这种情况最简单，这时是直接用子类对象<code>.</code>父类的成员变量就可以访问</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.name;</span><br><span class="line">stu.age;</span><br></pre></td></tr></table></figure><ul><li>重名<ul><li>直接<ul><li>如果使用子类对象<code>.</code>的话，访问的就是子类的成员变量</li></ul></li><li>间接<ul><li>间接指的就是通过成员方法访问，此时举个例子说明</li></ul></li></ul></li></ul><p>假设父类有一个<code>int num;</code>，子类也有一个<code>int num;</code>。现在父类有一个showA方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果子类对象调用这个方法的话，那么使用的就是父类的num。现在如果子类有一个showB方法，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子类对象调用这个方法，那么使用就是子类的num。简而言之，方法属于谁，就用谁的。</p><h3 id="区分三种变量"><a href="#区分三种变量" class="headerlink" title="区分三种变量"></a>区分三种变量</h3><p>这三种变量指的就是</p><ul><li>父类的成员变量</li><li>子类的成员变量</li><li>局部变量</li></ul><p>之前我们讲过区分局部变量和成员变量，我们使用this关键字加以区分。现在假设在子类的一个成员方法中，父类，子类有成员变量name，而该方法也有一个局部变量，这时我们这么区分，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.name;      <span class="comment">//父类的name</span></span><br><span class="line"><span class="keyword">this</span>.name;       <span class="comment">//子类的name</span></span><br><span class="line">name             <span class="comment">//局部变量name</span></span><br></pre></td></tr></table></figure><p>同理，如果子类有成员方法和父类的一个成员方法重名的话，如果我们想在子类的某个成员方法中使用父类的这个成员方法的话，我们可以使用super.父类方法()调用。super这个关键字指的就是父类对象。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>之前我们有多次提到重写的概念，那么重写是什么? 重写指的就是子类的某个方法与父类的方法的方法名称一样，参数列表也一样，相当于把父类的这个方法覆盖了。当我们使用子类对象.这个方法时，优先使用子类的方法。</p><p>重写的方法需要满足一定的要求，如下：</p><ul><li>必须父子类方法名相同，参数列表相同</li><li>子类方法的返回值范围要小于父类方法(Object &gt; String)</li><li>子类方法的权限必须大于等于父类的权限操作符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权限修饰符的大小熟悉怒</span></span><br><span class="line"><span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; (<span class="keyword">default</span>) &gt; <span class="keyword">private</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>有一个注解，@Override，把它放在要重写的方法前面，可以检查是否重写正确，比如你重写的方法漏掉了一个字母，这相当于你自己有了一个新的成员方法，并不是重写，编译器不会报错，这可能会造成问题，因为你是想重写的。但是你如果在方法前面加上@Override，它会检查这个方法是不是重写，如果不是会报错。这个是可选的，但是推荐使用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>    <span class="comment">//写在方法的前面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中的构造方法"><a href="#继承中的构造方法" class="headerlink" title="继承中的构造方法"></a>继承中的构造方法</h3><p>为了讲解清楚，假设有两个类，一个是Person类，是父类，另一个是Student类，是子类。两个方法的定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的构造方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我要讲的是，在子类构造方法的第一行，默认有<code>super();</code>，这个代表调用父类的构造方法，即在调用子类构造方法时，会先调用父类的无参构造方法，现在我们创建一个Student对象，看看打印输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtends</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是父类的构造方法</span><br><span class="line">我是子类的构造方法</span><br></pre></td></tr></table></figure><p>可见是默认会调用父类的无参构造方法。所以我们在之前建议为类写一个无参的构造方法，因为在创建子类对象时会先调用父类的无参构造方法，如果父类没有的话，会报错。</p><p><strong>注意：</strong></p><ul><li>super调用必须是第一个语句，比如下面会报错</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是子类的构造方法"</span>);</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//会报错，因为不是第一个语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这也意味着在方法中只能调用一次super()方法，因为第二个super不是第一个语句了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"name"</span>,<span class="number">12</span>);  <span class="comment">//假设父类有一个有参构造方法 由于不是第一个语句，报错</span></span><br><span class="line">                       <span class="comment">//这意味着只能调用一个super()方法</span></span><br><span class="line">    System.out.println(<span class="string">"我是子类的构造方法"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>this()可以调用本类的构造方法，this()也必须是第一个语句，所以this()和super()不能同时出现。</li><li>如果父类有有参数的构造方法，我们可以在子类的构造方法中显式的调用该方法，如上面super(“name”,12)，这个时候就不会默认调用无参的构造方法。所以父类中没有无参的构造方法不一定会报错。建议最好还是写一个吧，即使什么都没有，有特殊需求的除外。</li></ul><h3 id="继承的三个特征"><a href="#继承的三个特征" class="headerlink" title="继承的三个特征"></a>继承的三个特征</h3><ul><li>Java语言是单继承的，只能有一个直接父类</li><li>可以有多级继承，继承的源头是Object</li><li>一个子类的直接父类是唯一的，但是可以有多个子类</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽样方法：使用关键字abstract修饰的方法，抽象方法没有方法体，直接大括号结束。抽样方法所在的类必须是抽样类，抽样类的定义是在class前面加abstract。</p><p>如下定义了一个抽样类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eat(), sleep()方法是抽样方法，没有方法体，直接分号结束。</p><p><strong>注意：</strong></p><ul><li>不能直接创建抽象类对象，应当用一个类继承该抽象类，该类必须重写所有的抽象方法，如果该类没有重写所有的抽象方法，那么该类也必须是抽象类。</li><li>抽象类可以有构造方法，给抽象类的成员变量初始化</li><li>抽样类不一定要有抽象方法，但是含抽象方法的类必须是抽象类</li></ul><p>如下创建一个Dog类继承抽象类Animal</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪汪..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"呼呼呼..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">汪汪汪...</span><br><span class="line">呼呼呼...</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是公共的规范标准。</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>我们类的定义是使用class关键字，而接口的定义是使用interface关键字。如下定义了一个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口里面可以有什么，这与版本有关。</p><ul><li>Java 7<ul><li>常量</li><li>抽象方法</li></ul></li><li>Java 8(新增)<ul><li>默认方法</li><li>静态方法</li></ul></li><li>Java 9(新增)<ul><li>私有方法</li></ul></li></ul><h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ul><li>接口不能够直接使用，需要一个类去实现它。我们在之前使用extends去继承一个类，而实现一个接口使用implements关键字，如</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现必须实现接口中的所有抽样方法。如果没有全部实现，那么该类必须为抽样类</li><li>创建实现类对象使用</li></ul><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>接口中的抽样方法的修饰符必须是public abstract，所这两个关键字可以省去，如下的写法都是对的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//不省略</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//只省略public</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;   <span class="comment">//只省略abstract</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;          <span class="comment">//两个都省略</span></span><br></pre></td></tr></table></figure><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>默认方法的定义为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值 方法名(参数列表) &#123; <span class="comment">//修饰符必须是public，所以public可以省略</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认方法就要解决的是升级问题。假设你要升级一个接口，如果你添加一个抽象方法的话，那么由于实现类没有实现该抽象方法，那么实现类就不能使用，这样是不合理的。但是添加默认方法的话，实现类不需要实现该方法，实现类可以正常的使用，并且可以通过实现类对象调用该默认方法。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法的定义为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值 方法名(参数列表)&#123; <span class="comment">//同default方法，public可以省略</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类不能直接调用静态方法，只能通过接口<code>.</code>静态方法调用。因为一个实现类是可以同时实现多个接口的，如何多个接口有相同的静态方法，那么通过实现类调用静态方法，那么调用哪个呢？所以实现类是不能直接调用静态方法的。不同于继承，因为继承只有一个直接父类。</p><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>私有方法是为解决代码重复问题的。假设有两个默认方法，这两个默认方法的代码重复很多，那我们想着可以把重复的代码抽出来形成一个新的方法，然后在这两个默认方法中调用这个新方法就可以。但是这个新方法是一个中间方法，应当是只能在接口内才能够被调用，所以不能是默认方法。这个方法应该被定义为私有方法。</p><p>私有方法分为两类</p><ul><li>普通私有方法<ul><li>解决默认方法代码重复问题，只使用private修饰</li></ul></li><li>静态私有方法<ul><li>解决静态方法代码重复问题，使用private static修饰</li></ul></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>接口中也能定义”成员变量”，只不过必须使用public static final修饰，final代表的就是不可变的意思，所以就相当于是一个常量。接口中的常量必须进行赋值，不能不赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>对于常量，我们采用所有字母大写，并且单词之间使用下划线分割。接口使用常量的方法是接口<code>.</code>常量，原因同静态方法一样。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>接口没有静态代码块和构造方法</li><li>一个类可以同时实现多个接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">... implements 接口<span class="number">1</span>，接口<span class="number">2</span>，...</span><br></pre></td></tr></table></figure><ul><li>如果实现的两个接口有相同的抽象方法，只需要实现一个即可</li><li>不能没有实现所有的抽象方法，那么就必须是抽象类</li><li>如果实现的两个接口有重复的默认方法，那么实现类必须重写该默认方法</li><li>一个类的直接父类与接口的默认方法重复的话，优先使用直接父类的方法</li><li>接口与接口之间多继承的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口 extends 接口<span class="number">1</span>，接口<span class="number">2</span>，...</span><br></pre></td></tr></table></figure><p>如果继承的多个接口默认方法重复，那么必须重写，且重写的方法必须为默认方法。如果抽象方法重复，只继承一个。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>继承和实现接口是多态的基础。</p><h3 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h3><p>多态的定义就是父类引用指向子类对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类 对象名 = <span class="keyword">new</span> 子类();</span><br><span class="line">接口 对象名 = <span class="keyword">new</span> 实现类();</span><br></pre></td></tr></table></figure><p>如假设有一个父类Person和一个子类Student如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">String name = <span class="string">"父类"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String name = <span class="string">"子类"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我使用多态的写法，创建一个Student对象指向Person引用，并且调用show方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muti</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Student();</span><br><span class="line">        per.show();</span><br><span class="line">        </span><br><span class="line">        System.out.println(per.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时的输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是子类的show方法</span><br><span class="line">父类</span><br></pre></td></tr></table></figure><p>是不是有点难以理解上面的输出，下面讲解一下为什么会有上面的输出。</p><h3 id="多态访问成员变量和成员方法的规则"><a href="#多态访问成员变量和成员方法的规则" class="headerlink" title="多态访问成员变量和成员方法的规则"></a>多态访问成员变量和成员方法的规则</h3><h4 id="访问成员方法的规则"><a href="#访问成员方法的规则" class="headerlink" title="访问成员方法的规则"></a>访问成员方法的规则</h4><ul><li>如果多态写法创建的对象，调用成员方法时，在编译时看左边，即看父类有没有这个方法，如果父类没有，那么会报错，如下面我在Student中新建了一个子类特有的方法，如果使用per对象调用的话，将会发生错误。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"子类"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAgain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类特有的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java13.jpg"/></center><p>我们观察到程序报错了，因为父类并没有这个方法。</p><ul><li>在运行时看右边，即如果这个方法子类重写了，那么调用子类的方法，我们在上面也看到了，输出的是子类的方法</li><li>口诀：”编译看左边，运行看右边”</li></ul><h4 id="访问成员变量的规则"><a href="#访问成员变量的规则" class="headerlink" title="访问成员变量的规则"></a>访问成员变量的规则</h4><p>访问成员变量的规则与访问成员方法的规则不同。</p><ul><li>访问成员变量时，编译时的规则也一样，如果父类没有该变量，则访问不了该变量。访问不了子类的变量。</li><li>即使子类中的成员变量与父类中的成员变量重名，那么访问的也是父类的成员变量，在上面我们已经看到了，我们在打印输出name是输出的是父类的成员变量。</li><li>口诀：”编译看左边，运行也看左边”</li></ul><h3 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h3><p>对象转型分为向上转型和向下转型。</p><h4 id="对象向上转型"><a href="#对象向上转型" class="headerlink" title="对象向上转型"></a>对象向上转型</h4><p>多态就是向上转型，因为是子类对象指向父类的引用。创建的是子类的对象，但是使用却是当做父类对象使用。多态有一个明显的弊端就是无法使用子类特有的方法和子类的成员变量。</p><h4 id="对象向下转型"><a href="#对象向下转型" class="headerlink" title="对象向下转型"></a>对象向下转型</h4><p>我们提到了多态的弊端，但是我就是要使用子类的特有方法怎么办，这个时候我们可以使用向下转型，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu = (Student) per; <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p>这样我们就可以使用Student对象特有的方法了，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        Student stu = (Student) per;</span><br><span class="line">        stu.showAgain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是子类特有的方法</span><br></pre></td></tr></table></figure><p>但是，向下转型要注意，我原来是Student对象才能转为Student对象，我如果原来不是，那么运行时会抛出异常，如下面我创建一个Teacher继承了Person，现在我要把per强行转型为Teacher对象</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java14.png"/></center><p>我们观察到，在编译时并没有报错，现在我们来运行一下</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java15.png"/></center><p>抛出了ClassCastException异常，意思是类型转换异常。所以向下转型不安全。</p><p>那我们为什么不直接创建一个子类对象指向子类呢？何必多次一举使用多态写法然后又给转回来呢? 我们来看这么一个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Person per)</span></span></span><br></pre></td></tr></table></figure><p>这个类的方法参数只要求是Person就可以，它不管你是Student还是Teacher，所以如果我们把Student对象传进去，这是不是多态的写法，如果我们在里面要用到Student特有的方法，我们是不是要向下转型。</p><p>其实常常我们使用接口作为参数，表示的意思就是我才不管你是什么，你只有实现我的接口就可以了，那么我就可以使用你了。比如有一个接口叫做USB，那么传进来的参数，你只要实现了我们USB接口就可以，不管你是鼠标实现了还是键盘实现了，你只要实现了，我就可以用。这就是多态的用法啊。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>上面我们说了，对象的向下转型是有风险的，因为如果我不是Student你给我转给Student那么会抛出异常的。现在instanceof关键字可以解决这个问题，他可以判断多态创建的父类引用为哪个子类。具体用法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">多态创建的父类引用 <span class="keyword">instanceof</span> 子类</span><br></pre></td></tr></table></figure><p>该表达式返回一个boolean值，如果多态创建的父类引用是这个子类，那么返回true，否则返回false。例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Student();</span><br><span class="line">per <span class="keyword">instanceof</span> Student; <span class="comment">//true</span></span><br><span class="line">per <span class="keyword">instanceof</span> Teacher; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>现在考虑这么一个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Person per)</span></span></span><br></pre></td></tr></table></figure><p>我们现在就在方法中根据per instanceof Xxx的结果进行安全的向下转型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (per <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">        Student student = (Student) per;</span><br><span class="line">        <span class="comment">//实现Student对象特有的操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (per <span class="keyword">instanceof</span> Teacher) &#123;</span><br><span class="line">        Teacher teacher = (Teacher) per;</span><br><span class="line">        <span class="comment">//实现Teacher对象特有的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final关键字可以修饰</p><ul><li>一个类<ul><li>修饰一个类时，该类不能够被继承</li><li>所以final不能和abstract关键字一起使用，因为抽象类不能自己创建对象，只能被继承</li></ul></li><li>方法<ul><li>修饰一个方法时，子类不能重写该方法</li></ul></li><li>局部变量<ul><li>修饰一个局部变量时，这个变量不能进行更改</li><li>下面两种写法都可以</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>成员变量<ul><li>因为成员变量有默认值，所以要手动赋值</li><li>要么直接赋值，要么在构造方法中进行赋值，在构造方法中赋值时，所有的构造方法都要进行赋值，即使是无参构造方法，也要进行赋值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//下面的写法是错误的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Xxx</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>权限修饰符总共有四种，权限从大到小的顺序为</p><ul><li>public</li><li>protected</li><li>(default)，就是什么都不写</li><li>private</li></ul><p>下表列出了不同修饰符下的访问规则</p><table><thead><tr><th></th><th>同一个类</th><th>同一个包</th><th>不同包的子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>public</td><td>能</td><td>能</td><td>能</td><td>能</td></tr><tr><td>protected</td><td>能</td><td>能</td><td>能</td><td><strong>不能</strong></td></tr><tr><td>(default)</td><td>能</td><td>能</td><td><strong>不能</strong></td><td><strong>不能</strong></td></tr><tr><td>private</td><td>能</td><td><strong>不能</strong></td><td><strong>不能</strong></td><td><strong>不能</strong></td></tr></tbody></table><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是一个很重要的概念，主要分为两类</p><ul><li>成员内部类</li><li>局部内部类<ul><li>匿名内部类</li></ul></li></ul><p>下面我们来看一下内部类的使用</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类就像成员变量和成员方法一样定义在类里面，比如有一个叫做Body，内部还有一个类叫做Heart。我们可以这么定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以随意的访问外部类的成员变量和成员方法，但是外部类要访问内部类要借助内部类对象。</p><p>如何使用成员内部类</p><ul><li>在外部类的方法中使用内部类，然后在main方法中调用外部类的方法。</li><li>直接创建内部类的对象，创建格式为</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类 对象名 = <span class="keyword">new</span> 外部类().<span class="keyword">new</span> 内部类();</span><br></pre></td></tr></table></figure><p>比如上面我想创建一个Heart对象就可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Body.Heart heart = <span class="keyword">new</span> Body().<span class="keyword">new</span> Heart();</span><br></pre></td></tr></table></figure><p>内部类变量与外部类变量重名问题，假设外部类有一个成员变量num，内部类也有一个成员变量num，在内部类的成员方法中也有一个局部变量num，现在在内部类的这个方法中怎么访问外部类的成员变量，怎么访问内部类的成员变量。如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">this</span>.num <span class="comment">//内部类的成员变量</span></span><br><span class="line">外部类名.<span class="keyword">this</span>.name <span class="comment">//外部类的成员变量</span></span><br></pre></td></tr></table></figure><p>现在来看一个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">//外部类的num</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">//内部类的num</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            System.out.println(num); <span class="comment">//打印局部变量</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">//打印内部类的成员变量</span></span><br><span class="line">            System.out.println(Body.<span class="keyword">this</span>.num); <span class="comment">//打印外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Body.Heart heart = <span class="keyword">new</span> Body().<span class="keyword">new</span> Heart();</span><br><span class="line">        heart.showNum(<span class="number">30</span>); <span class="comment">//局部变量num</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类就是定义在方法内部的类，定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 局部内部类名 </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不要写任何的修饰符。这并不代表它的修饰符权限是(default)，因为修饰符没有意义，类定义在方法的内部，只有在方法内部在能够访问。</p><p>我们在这里适时的总结一下修饰符修饰类</p><ul><li>外部类<ul><li>只能是public, (default)</li></ul></li><li>内部类<ul><li>成员内部类<ul><li>可以是四种修饰符的任意一种</li></ul></li><li>局部内部类<ul><li>什么都不能写</li></ul></li></ul></li></ul><p>局部内部类如果想访问方法中的局部变量，那么这个变量必须是局部final的，什么叫做有效final呢？指的就是没有使用final修饰符修饰（当然你使用final修饰更加的保险），但是变量的值没有发生改变。比如下面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testlocalInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的num虽然没有使用final修饰符修饰，但是它只进行了一次赋值，所以是有效final的，所以在局部内部类中可以访问该变量。假设num又进行了赋值，那么将会编译失败。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是相当重要的概念了。如果接口实现类(或者是父类的子类)只使用一次，那么这种情况可省略掉该类的定义，而改为使用匿名内部类。</p><p>比如有一个接口，叫做USB好了，然后在一个Computer类中要使用该接口，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useUsb</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">        usb.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建一个类去实现USB接口，然后创建对象，传入Computer的这个方法中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpUSB</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开USB设备"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭USB设备"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useUsb</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">        usb.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        ImpUSB impUSB = <span class="keyword">new</span> ImpUSB();</span><br><span class="line">        computer.useUsb(impUSB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打开USB设备</span><br><span class="line">关闭USB设备</span><br></pre></td></tr></table></figure><p>但是这样写未必太麻烦了，这个类只使用了一次，但是为了使用这个接口，我却要写一个类去实现该接口，然后创建对象使用，未必有点麻烦。Java提供了更加方便的方法，那就是匿名内部类。</p><p>匿名内部类的定义格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称() &#123;</span><br><span class="line">    <span class="comment">//在这里覆盖重写接口所有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们匿名内部类来实现上面同样的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">    <span class="comment">//创建匿名内部类</span></span><br><span class="line">    USB usb = <span class="keyword">new</span> USB() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"花式打开USB设备"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"花式关闭USB设备"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    computer.useUsb(usb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">花式打开USB设备</span><br><span class="line">花式关闭USB设备</span><br></pre></td></tr></table></figure><p>在这里我们并没有创建一个实现类去实现USB接口，而是创建了一个匿名内部类，这个类没有名字（这也是为什么叫做匿名内部类），所以它不能通过它在创建新的对象。正如匿名对象一样，只能调用一次方法。</p><p>匿名内部类的注意事项</p><ul><li>匿名内部类在创建对象时，只能使用唯一的一次</li><li>匿名对象在调用方法只能调用唯一的一次</li><li>匿名内部类是省略了类的名称，匿名对象是省略了对象的名称</li></ul>]]></content>
    
    <summary type="html">
    
      讲解Java面向对象有关的知识，包含类，对象，抽象类，接口等概念
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="面向对象" scheme="https://lastknightcoder.gitee.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://lastknightcoder.gitee.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/"/>
    <id>https://lastknightcoder.gitee.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/</id>
    <published>2019-07-03T16:00:00.000Z</published>
    <updated>2019-07-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个程序-HelloWorld"><a href="#第一个程序-HelloWorld" class="headerlink" title="第一个程序: HelloWorld"></a>第一个程序: HelloWorld</h2><p>下面将书写Java的第一个程序，它的作用是在命令行输出Hello World!。新建一个文件，文件名为HelloWorld.java，使用记事本或其他代码编辑工具打开，敲入以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在命令行中输入</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p>然后就可以在命令行中看到Hello World!输出了。</p><p><strong>注意事项：</strong></p><ul><li>class后面的HelloWorld要与文件名一样，包括大小写</li><li>在命令行使用javac或者java命令时，要保证所处的路径与文件HelloWorld.java在同一个路径，否则会报错，解决办法有两种<ul><li>第一种，使用cd命令切换到HelloWorld.java文件的目录</li><li>第二种，javac或者java命令后跟上HelloWorld.java的完整路径名称</li></ul></li><li>javac命令后面有后缀.java，java命令后面没有任何的后缀</li></ul><p>现在稍微解释上面程序的意思，因为刚刚起步，很多东西现在都解释不了，所以在这里并不要求弄懂。第一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br></pre></td></tr></table></figure><p>这里，我们只需要记住HelloWorld必须与文件名<strong>相同</strong>。第二行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure><p>这个是固定的写法，几乎每个程序都是这么写的，这个是程序的入口，程序从这里开始执行。第三行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>这个语句是关键的程序，它的作用就是向屏幕输出字符，这里我们输入的是Hello World!，注意输出的语句需要被双引号括起来。</p><h2 id="标识符与命名规范"><a href="#标识符与命名规范" class="headerlink" title="标识符与命名规范"></a>标识符与命名规范</h2><p>标识符的命名规范</p><ul><li>由数字、字母、下划线和美元符组成</li><li>不能由数字开头</li><li>不能是关键字</li></ul><p>上面是标识符命名的硬性规范，即如果不按照上面的来做，那么程序在编译时不能够通过，下面介绍软性规范，意思就是如果你不按照下面的来，编译器不会报错，但是软性规范是大家约定俗成的，大家都遵守的，所以我们要按照下面的来</p><ul><li>类名：大驼峰命名法，即首字母<strong>全部大写</strong>，如HelloWorld</li><li>变量名与方法名：小驼峰命名法，即第一个首字母小写，后面的首字母全部大写，如helloWorld</li></ul><h2 id="Java中的常量"><a href="#Java中的常量" class="headerlink" title="Java中的常量"></a>Java中的常量</h2><p>Java中的常量分为：</p><ul><li>字符串常量：使用双引号括起来的，如”Hello World!”</li><li>整型常量：其实就是整数，如5</li><li>浮点数：小数，如2.5</li><li>字符常量：用单引号括起来的，单引号里面必须有一个字符，不可以没有，也不可以多于一个，如’ab’,’’都是错误的，另外这个字符可以是中文，如’中’</li><li>布尔常量：只有两个值true和false</li><li>空常量：null，这个在这里不多做介绍</li></ul><p>在前面我们学习了向屏幕输出Hello World!，类似的，在这里我们可以尝试着把常量输出出来，新建一个文件为Constant.java，注意前面提及的命名规范，Constant是类名，所以首字母需要大写，然后在该文件中敲入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下面我将输出一些常量</span></span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>); <span class="comment">//输出字符串常量</span></span><br><span class="line">        System.out.println(<span class="number">5</span>); <span class="comment">//输出整型常量</span></span><br><span class="line">        System.out.println(<span class="number">2.5</span>); <span class="comment">//输出浮点型常量</span></span><br><span class="line">        System.out.println(<span class="string">'a'</span>); <span class="comment">//输出字符型常量</span></span><br><span class="line">        System.out.println(<span class="keyword">true</span>); <span class="comment">//输出布尔型常量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>不能打印出null，如System.out.println(null)会报错</li><li>上面//后面的内容为注释，编译器会自动的忽略，注释是对程序的解释，是为了帮助人看懂程序的</li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中的数据类型分为基本数据类型和引用数据类型，引用数据类型暂且不提，这里的重点是掌握基本数据类型，基本数据类型分为四类：</p><ul><li>整型</li><li>浮点型</li><li>字符型</li><li>布尔类型</li></ul><p>整型可以细分为：</p><ul><li>byte</li><li>short</li><li>int</li><li>long</li></ul><p>上面整型数据类型都表示整数，只是表示的范围大小不一样，byte使用<strong>一个字节</strong>即8bit来表示一个整数的大小，表示的范围为-128~127，short使用<strong>两个字节</strong>来表示，范围比byte大一点，大约在几万左右，int使用<strong>四个字节</strong>来表示，是最常用的数据类型，因为它的范围已经大到足够我们日常使用了，long使用<strong>八个字节</strong>来表示，比int的范围还要大，但是由于使用int已经足够了，从节省空间的角度讲，没必要用long。</p><p>浮点型可以分为</p><ul><li>float</li><li>double</li></ul><p>float使用<strong>四个字节</strong>来表示小数，虽然使用的是四个字节，但是表示的范围比使用八个字节的long更大，double使用<strong>八个字节</strong>来表示小数，所以使用double表示小数更精确，我们在平常使用最多的就是double。</p><p>字符型没法细分，只有一个，那就是char类型，使用两个字节表示。</p><p>布尔型也没有办法细分，只有一个，那就是boolean，使用一个字节表示，它只有两个值true和false。</p><p><strong>注意：</strong></p><ul><li>字符串不是基本数据类型，它是引用类型，这个后面详细阐述。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的命名需要服从前面所讲的标识符所需遵从的硬性或软性的规定。变量的声明方法为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型 变量名</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure><p>上面是对变量的声明，但是没有对变量进行赋值，没有被赋值的变量是不能被使用的，否则会报错，下面举一些例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> by = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">122222222222222L</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.2F</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>对float变量进行赋值时，后面需要加上F</li><li>对long类型的变量进行赋值时，后面需要加上L(大小写都可以，不过小写的l像1，所以建议使用大写)，当右边常量的值的大小小于int类型的范围时，L可以省略</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>Java中，整型常量的类型默认为int，浮点型常量的类型默认为double</li><li>在一个花括号内部，变量名不能相同</li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>数据类型转换分为两种：</p><ul><li>自动类型转换，也称为隐型转换</li><li>强制类型转换</li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>当将某数据类型的值赋值给某个能够表示更大范围的数据类型的变量时，会发生自动类型转换，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a = b;</span><br></pre></td></tr></table></figure><p>上面的b是byte类型，a是int类型，int类型的范围更加的大，所以将b赋值给a时会自动类型转换，将20转化为int类型赋值给a，但是b还是byte类型。但是不能将大范围的数据类型的值赋值给更小范围数据类型的变量，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">byte</span> b = a; <span class="comment">//不行，编译器会报错</span></span><br></pre></td></tr></table></figure><p>范围从小到大的顺序为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java01.png"/></center><p>箭头代表可以转换。</p><p>在前面我们提及到，当将一个整数赋值给long类型的变量时，如果表示的范围没有超过int，那么可以不写后面的L，这时因为发生了自动类型转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = <span class="number">12</span>; <span class="comment">//后面没有加L，Java默认整数类型为int，这里发生了自动类型转换</span></span><br></pre></td></tr></table></figure><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>上面提及到大范围不能转向小范围，但是我们可以强行转换，比如我想将int类型的数值转化为byte类型的数值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) a;</span><br></pre></td></tr></table></figure><p>在要转换的数据前面加上(byte)就可以强行转化为byte类型。</p><p>虽然可以将大范围转化为小范围，但是我们在平常时不会这么干，因为往往将大范围的数转化为小范围的数时，会有精度损失，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) d; <span class="comment">//结果为3，小数点后面的数直接舍去，并不是四舍五入</span></span><br></pre></td></tr></table></figure><p>我们知道Java的整数默认为int，那么下面的语句为什么没有报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">20</span>; <span class="comment">//20是int类型，int不能转byte，为什么没有报错</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">30</span>; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p>这是因为，在编译时，编译器会检查右边数值的范围，如果没有超过byte或者short能够表示的大小，那么编译器会自动帮我们强制类型转换为byte或short，相当于</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> s = (<span class="keyword">short</span>) <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h3 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h3><ol><li>char,short,byte类型在进行计算时，会自动提升为int类型参与计算</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//下面这行语句会报错</span></span><br><span class="line"><span class="keyword">byte</span> num3 = num1 + num2; <span class="comment">//在计算时，num1和num2会自动的提升为int类型，而int类型不能转为byte，所以会报错</span></span><br></pre></td></tr></table></figure><p>但是，下面的写法是正确的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>当右边全是常量时，编译器在编译时会直接计算，相当于下面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>由于3没有超出byte能够表示的范围，所以会被强制转换为byte。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">//下面这行语句会输出一个数字</span></span><br><span class="line">System.out.println(c + <span class="number">0</span>); <span class="comment">//65</span></span><br></pre></td></tr></table></figure><p>我们知道char是一个字符，那么为什么字符可以进行计算呢？这是因为计算机在底层是使用数字表示字符的，比如上面’A’就是使用数字65表示的，上面的字符与数字0进行计算，会自动提升为int类型，所以最后输出的就是数字。</p><p>我们需要知道几个特殊字符对应的数字</p><table><thead><tr><th>字符</th><th>ASCII码</th></tr></thead><tbody><tr><td>‘0’</td><td>48</td></tr><tr><td>‘A’</td><td>65</td></tr><tr><td>‘a’</td><td>97</td></tr></tbody></table><p>大写字母与小写字母之间差32。</p><ol><li>boolean类型不能进行数据类型转换</li></ol><p>例如，下面将对boolean类型进行转换，是错误的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = i; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (<span class="keyword">boolean</span>) i; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> i1 = b; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> i2 = (<span class="keyword">int</span>) b; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Java中的运算符分为以下几种：</p><ul><li>算术运算符</li><li>赋值运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>三元运算符</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符包括以下几种：</p><ul><li>+，加法</li><li>-，减法</li><li>*，乘法</li><li>/，除法</li><li>%，取余</li><li>++，自增</li><li>–，自减</li></ul><p>不同类型的数据之间进行运算，得到的结果的数据类型为范围最大的那个数据类型，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">2</span> + <span class="number">3.5</span>; <span class="comment">//int + double ==&gt; double</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span> + <span class="number">3.5</span>; <span class="comment">//该写法错误</span></span><br></pre></td></tr></table></figure><p>加法有两种作用：</p><ul><li>两数字间进行加法运算</li><li><strong>字符串的连接</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">3</span> + <span class="number">5</span>;  <span class="comment">//进行加法运算，结果为8</span></span><br><span class="line">String s = <span class="string">"Hello"</span> + <span class="string">"World"</span>; <span class="comment">//拼接为HelloWorld</span></span><br></pre></td></tr></table></figure><p><strong>注意：任何数据类型与字符串连接时，会自动变成字符串</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="number">1</span> + <span class="string">"Hello"</span>; <span class="comment">//1Hello</span></span><br></pre></td></tr></table></figure><p>除法需要注意的是，<strong>两个整数相除，得到的还是整数</strong>，即使除不尽，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>/<span class="number">3</span>; <span class="comment">//a = 3</span></span><br></pre></td></tr></table></figure><p>下面重点介绍++和–，由于二者十分的相似，这里只介绍++。++的作用是自动加1，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">a++; <span class="comment">//相当于a = a + 1 a变为了4</span></span><br></pre></td></tr></table></figure><p>其中++可以在变量的前面，也可以在变量的后面，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a++;</span><br><span class="line">++a;</span><br></pre></td></tr></table></figure><p>二者的作用均是使变量a加1，当二者如上单独使用时，二者没有区别，但是当混合使用时，有区别，具体表现如下</p><ul><li>++a：先将a进行+1，然后使用a</li><li>a++：先使用a，再将其进行+1</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">b = a++; <span class="comment">//先使用a，即先将a的值赋值给b，所以b=3，然后+1，所以最后a=4</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">b = ++a; <span class="comment">//先将a+1，即a=4，然后将a赋值给b，所以b=4</span></span><br></pre></td></tr></table></figure><p>–的作用是减1，其用法同++一模一样，这里不多加介绍。</p><p><strong>注意：</strong></p><ul><li>常量不能进行++,–运算</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span>++;  <span class="comment">//该写法是错误的</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符分为基本赋值运算符和复合赋值运算符</p><ul><li>基本赋值运算符<ul><li>=</li></ul></li><li>复合赋值运算符<ul><li>+=</li><li>-=</li><li>*=</li><li>/=</li><li>%=</li></ul></li></ul><p>基本赋值运算符的作用就是把右边的值赋给左边的变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>; <span class="comment">//把3赋给变量a</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>常量是不变的，不能被赋值，所以常量不能出现在赋值运算符的左边</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span> = <span class="number">30</span>; <span class="comment">//该写法是错误的</span></span><br></pre></td></tr></table></figure><p>复合赋值运算符，这里介绍+=，其他与它类似</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">a += <span class="number">3</span>; <span class="comment">//相当于a = a + 3</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">//相当于a = a * 3</span></span><br><span class="line"><span class="comment">// 其他的同理可以知道... ...</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>复合赋值运算符隐含了强制类型转换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">s += <span class="number">2</span>; <span class="comment">//这里暗含了强制类型转换，s + 2得到的是一个int类型，被强制转换为了short类型，所以相当于s = (short) (s + 2);</span></span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符对操作数进行比较，得到一个boolean数据类型的值，比较运算符包含以下：</p><ul><li>==：判断两个数是否相等</li><li>&gt;</li><li>&lt;</li><li>&gt;=：大于等于</li><li>&lt;=</li><li>!=：判断两个数是否不相等</li></ul><p><strong>注意：</strong></p><ul><li>在判断某变量属于某区间，比如是否大于3小于5时，不能写成3 &lt; x &lt; 5，应当使用后面提及的逻辑运算符3 &lt; x &amp;&amp; x &lt; 5</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符的对象是boolean数据类型的值，包含下面三个操作</p><ul><li>&amp;&amp;：与操作，当两个操作数同时为true时，结果才为true</li><li>||：或操作，两个操作数中有一个操作数为true时，结果就为true</li><li>!：非操作，!true = false, !false = true</li></ul><p><strong>注意：</strong></p><ul><li>逻辑运算符的操作对象为boolean，所以如果操作对象不为boolean类型时，会报错</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="number">5</span> &amp;&amp; <span class="number">2</span>; <span class="comment">//会报错</span></span><br><span class="line"><span class="keyword">boolean</span> b = <span class="number">5</span> &amp;&amp; <span class="keyword">true</span>; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><ul><li><strong>短路</strong><ul><li>表达式1 &amp;&amp; 表达式2：当表达式1为假时，已经可以判断出结果为假，所以不会对表达式2进行判断，不会执行表达式2</li><li>表达式1 || 表达式2：当表达式1为真时，已经可以判断出结果为真，同上。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">System,out.println(<span class="keyword">false</span> &amp;&amp; a++ &lt; <span class="number">100</span>); <span class="comment">//此时进行了短路运算，a++ &lt; 100没有得到执行，所以a = 3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span> || a++ &lt; <span class="number">100</span>); <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>这里的三元指的是有三个操作数，上面我们介绍的运算符的操作数要么是一个的，如++,–,!，要么是两个的，如+,-,…，三元运算符的格式是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量 = 条件判断 ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>首先会进行条件判断，如果条件判断得到的结果为true，那么会将表达式1的结果赋值给变量，此时表达式2不会得到执行；否则将表达式2的结果赋值为变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">4</span> &gt; <span class="number">3</span> ? a : b++; <span class="comment">//c = 3，表达式2没有执行，b = 4</span></span><br><span class="line">System.out.println(b);   <span class="comment">//输出为4</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>变量的类型必须与表达式的结果的类型一致，否则会报错</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">4</span> &gt; <span class="number">3</span> ? <span class="number">2</span> : <span class="number">2.5</span>; <span class="comment">//该语句是错的，2.5是double类型，不能转化为int</span></span><br></pre></td></tr></table></figure><p>可能有的人会说返回的2，为什么会报错，因为在实际中，判断语句的结果不是确定的，否则直接将2赋值给c好了，根本不需要判断，因此两个表达式的结果都有可能赋值给变量，编译器会检查表达式得到的数据类型。</p><ul><li>单独写三元表达式是错误的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>; b = <span class="number">3</span>;</span><br><span class="line">a &gt; b ? a : b; <span class="comment">//这么单独写是错误的</span></span><br></pre></td></tr></table></figure><p>但是可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a &gt; b ? a : b); <span class="comment">//这么写是对的</span></span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程指的就是程序执行的顺序，写过汇编的同学都知道，用汇编写程序的流程控制都是jump的，各种跳来跳去，这会导致程序的流程极其的不清楚，当出现bug时，极其的难以调试，我们称这种程序为“意大利面条”，意思就是像意大利面条一样交缠在一起，极其混乱。</p><p>后来人们发现，只需要三种结构就可以写出任何的程序，这三种结构就是<strong>顺序结构，选择结构，循环结构</strong>，使用这三种结构使得程序条理清晰，结构清晰。下面就详细的介绍这三种结构。</p><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构指的就是程序从上到下，按照顺序执行，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"我是第一条语句"</span>);</span><br><span class="line">System.out.println(<span class="string">"我是第二条语句"</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是第一条语句</span><br><span class="line">我是第二条语句</span><br></pre></td></tr></table></figure><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>有时候我们需要根据某种状态来判断哪段程序应该执行，比如用户输入用户名和密码，根据是否输入正确来决定程序的行为。</p><p>选择结构分为两大类，一个与关键字if,else有关，一个与关键字switch,case有关，下面详细进行介绍。</p><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><h5 id="单独一个if"><a href="#单独一个if" class="headerlink" title="单独一个if"></a>单独一个if</h5><p>使用方法为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断语句) &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对判断语句进行判断，如果结果为真，则执行if里面的代码，如果为假，则跳过整个语句。</p><h5 id="if-else语句-1"><a href="#if-else语句-1" class="headerlink" title="if-else语句"></a>if-else语句</h5><p>上面if语句是当结果为真时执行语句块，但是当结果为假却什么都不干，我们希望当结果为假时，也能有相应的操作，那么就要用到if-else语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断语句) &#123;</span><br><span class="line">    <span class="comment">//if语句块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//else语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当结果为真时，执行if语句块，结果为假时，执行else语句块。</p><h5 id="if-else-if-else语句级联"><a href="#if-else-if-else语句级联" class="headerlink" title="if-else-if else语句级联"></a>if-else-if else语句级联</h5><p>有时候，我们不仅需要的是一次判断，而是多个判断，比如有一个分段函数，根据函数的不同取值，选择不同的函数，比如<br>$$<br>y =<br>\begin{cases}<br>2x - 1, &amp;x &lt; 1 \\<br>2x, &amp;1 \leq x &lt; 2 \\<br>2x + 1, &amp;x \geq 2<br>\end{cases}<br>$$</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> &lt;= x &amp;&amp; x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//x &gt;= 2</span></span><br><span class="line">    y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch-case语句"></a>switch-case语句</h4><p>switch-case语句的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> 常量n:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段程序的执行过程为，首先计算switch表达式的结果，然后将表达式的结果与常量1,常量2,…比较，看是否相等，如果与其中某个常量相等，则会执行相应的语句块。如果与所有的case常量都不相等，那么就会执行default中的语句。</p><p><strong>注意：</strong></p><ul><li>多个case的常量不能相同</li><li>switch表达式的结果只能是下面的几种类型<ul><li>基本数据类型：byte,short,char,int</li><li>引用类型：String，枚举类型</li></ul></li><li>case的顺序可以发生改变</li></ul><p>另外，比较重要的是，其实break不是必须的，可以省略，如果省略的话，由于没有break，程序会继续执行下去，直到遇到break或者程序执行结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="number">1</span>); <span class="comment">//不会退出程序，继续执行</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">break</span>;                 <span class="comment">//在这里遇到break，退出</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>循环指的就是重复执行某段程序，一般循环由下面四部分组成</p><ul><li>初始化</li><li>条件判断</li><li>循环体</li><li>循环控制语句</li></ul><p>循环有三种，分别是</p><ul><li>for循环</li><li>while循环</li><li>do-while循环</li></ul><p>下面详细介绍。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句; 条件判断; 循环控制) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的顺序为，先执行初始化语句，然后进行条件判断，如果结果为真，那么进入循环体，如果结果为假，那么退出循环，执行完循环体后，接着执行循环控制语句，然后进行条件判断，循环往复。如下面的例子打印出1-100的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123; <span class="comment">//注意，这个i只能在for循环里面用，在外面不能用</span></span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (判断语句) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会对判断语句进行判断，真就执行循环体，假就退出循环。执行完循环体，接着进行判断，循环往复。下面的例子计算1-100的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//初始化语句</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123; <span class="comment">//判断语句</span></span><br><span class="line">    sum = sum + i; <span class="comment">//循环体</span></span><br><span class="line">    i++; <span class="comment">//循环控制语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>do-while循环的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125; <span class="keyword">while</span> (条件判断);</span><br></pre></td></tr></table></figure><p>首先会执行一次循环体，然后进行条件判断，真就继续执行循环体，否则退出循环。</p><p>do-while循环与while循环的区别是，do-while一定会执行一次循环体，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="循环控制break和continue"><a href="#循环控制break和continue" class="headerlink" title="循环控制break和continue"></a>循环控制break和continue</h4><p>当在循环体中执行到break时，会直接退出循环，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;      <span class="comment">//当i = 2时退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>当在循环体中执行到continue时，退出此次循环，直接进行下一次循环，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//退出此次循环，后面的代码不执行了，直接执行循环控制语句i++，进入下一次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>当循环一直进行下去，不能退出，那么就成为了死循环，例如下面就是一个死循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123; <span class="comment">//省略了条件判断语句，默认为真，是死循环</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123; <span class="comment">//省略了循环控制语句，i一直为0，条件判断一直为真，为死循环</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环里面可以嵌套着一个循环，例如输出九九乘法表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%d*%d=%2d  "</span>,j,i,j*i); <span class="comment">//类似于C语言，格式化输出，以便对齐</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>*<span class="number">1</span>= <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>= <span class="number">2</span>  <span class="number">2</span>*<span class="number">2</span>= <span class="number">4</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>= <span class="number">3</span>  <span class="number">2</span>*<span class="number">3</span>= <span class="number">6</span>  <span class="number">3</span>*<span class="number">3</span>= <span class="number">9</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>= <span class="number">4</span>  <span class="number">2</span>*<span class="number">4</span>= <span class="number">8</span>  <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">5</span>= <span class="number">5</span>  <span class="number">2</span>*<span class="number">5</span>=<span class="number">10</span>  <span class="number">3</span>*<span class="number">5</span>=<span class="number">15</span>  <span class="number">4</span>*<span class="number">5</span>=<span class="number">20</span>  <span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>= <span class="number">6</span>  <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>= <span class="number">7</span>  <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>= <span class="number">8</span>  <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>= <span class="number">9</span>  <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure><h2 id="方法入门"><a href="#方法入门" class="headerlink" title="方法入门"></a>方法入门</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>方法定义的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数) &#123;</span><br><span class="line">    代码 ...;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中修饰符目前固定为public static，方法要符合之前在标识符里面的规定。</p><p>注意：</p><ul><li>方法不能定义在方法里面</li><li>方法定义的前后顺序无所谓</li><li>方法应在class和main方法之间定义</li><li>return的作用有两个，第一个是终止程序退出方法，第二个是返回值</li><li>如果返回值的类型时void，可以只写return;，代表退出方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义了一个方法，该方法的作用是计算两个int整数的和，并返回一个int类型的值</span></span><br><span class="line">    <span class="comment">//该方法接收两个int类型的参数，返回一个int类型的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main方法的顺序可以和上面add方法的顺序颠倒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... ...</span></span><br><span class="line">        <span class="comment">//不能在里面定义方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数);</span><br></pre></td></tr></table></figure><p>例如，在main方法中调用上面定义的add方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用add方法，其中2 和 3是参数，必须是int类型，否则会报错</span></span><br><span class="line">        <span class="keyword">int</span> c = add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//使用变量c来接受方法返回的结果，此时c = 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载指的是两个方法的方法名相同，但是参数列表不同，参数列表不同包括三个方面</p><ul><li>参数个数不同</li><li>参数类型不同</li><li>参数顺序不同</li></ul><p>例如，下面的方法是重载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, intj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> i, <span class="keyword">double</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> i, intj)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>判断方法是否是重载，关键是看方法名是否相同，参数列表是否不同，与修饰符，返回值没有任何的关系</li></ul><p>例如，下面的方法不是重载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">//与修饰符无关，参数列表相同，所以不是重载，编译会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">int</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">//与返回值无关，参数列表相同，所以也不是重载，编译会报错</span></span><br></pre></td></tr></table></figure><p>下面举一个注意事项，假设有下面这么一个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> j)</span></span>;</span><br></pre></td></tr></table></figure><p>在main方法中，我们可以这么调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">//我们可以传入两个整数，因为会进行自动类型转换为double</span></span><br></pre></td></tr></table></figure><p>然后我们对该方法重载了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">//参数列表的顺序不同，是重载</span></span><br></pre></td></tr></table></figure><p>如果我们还在main方法中传入两个整数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add (<span class="number">2</span>, <span class="number">2</span>); <span class="comment">//这时会报错</span></span><br></pre></td></tr></table></figure><p>因为在调用这个方法时，发现两个方法都可以，所以编译器就会感到模糊，不知道调用哪一个方法，就会报错。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>假设你要保存一组学生的成绩，我们会考虑每个学生用不同的变量保存，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> score2 = <span class="number">80</span>;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>这样写的话代码很长，并且不利于批量操作，比如如果我要给每个学生加上十分，那我们只能这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">score1 = score1 + <span class="number">10</span>;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>这只是体力活。</p><p>Java中专门有一类数据类型用来保存这样的数据，它叫做数组，下面我们将详细介绍。</p><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>数组的初始化分为两组，分别为动态初始化（指定长度）和静态初始化（指定内容）。</p><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>动态初始化的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>例如，下面声明了一个长度为3的int类型的数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>动态初始化其实可以分为两部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array = <span class="keyword">new</span> array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>静态初始化的格式为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[] &#123;内容&#125;;</span><br></pre></td></tr></table></figure><p>例如，下面创建了一个String类型的数组，里面有3个字符串，内容之间使用逗号隔开</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[]&#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span> &#125;;</span><br></pre></td></tr></table></figure><p>编译器会自动计算内容的个数来确定数组的长度。静态初始化还有省略格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;内容&#125;;</span><br></pre></td></tr></table></figure><p>例如上面的例子用省略格式重写为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span> &#125;</span><br></pre></td></tr></table></figure><p>静态初始化也可以看做是由两部分组成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str;</span><br><span class="line">str = <span class="keyword">new</span> String[] &#123;  <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span>  &#125;;</span><br></pre></td></tr></table></figure><p>但是省略格式不能这样看，例如下面的写法是错误的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str;</span><br><span class="line">str = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>数组的长度在程序运行期间是固定的，不能够发生改变</li><li>可以通过数组名.length来得到数组的长度</li><li>静态初始化会根据内容来自动推算出数组的长度</li></ul><h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>我们通过数组名[索引]的方式来访问数组里面的内容，这里需要注意的是索引值是从0开始的，所以索引的范围为<strong>0~数组长度-1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrays[<span class="number">0</span>]);  <span class="comment">//访问数组中的第一个元素，输出1</span></span><br><span class="line">System.out.println(arrays[<span class="number">1</span>]);  <span class="comment">//访问数组中的第二个元素，输出2</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>索引的范围不能超过数组的长度，否则会报错</li></ul><p>例如对于上面定义的数组，下面的代码会报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array[<span class="number">3</span>]; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><ul><li>动态初始化有默认值，不同类型的默认值不同，如下</li></ul><table><thead><tr><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>整型(byte,short,int,long)</td><td>0</td></tr><tr><td>浮点型(float和double)</td><td>0.0</td></tr><tr><td>字符(char)</td><td>‘\u0000’</td></tr><tr><td>布尔型(boolean)</td><td>false</td></tr><tr><td>引用内容</td><td>null</td></tr></tbody></table><ul><li>静态初始化其实也有默认值，不过马上又被赋值被覆盖了</li></ul><h3 id="Java的内存模型"><a href="#Java的内存模型" class="headerlink" title="Java的内存模型"></a>Java的内存模型</h3><p>Java的内容模型分为五部分，分别是</p><ul><li>栈(Stack)<ul><li>存放的都是局部变量，变量一旦超出作用域，立刻从栈内存中消失</li><li>当调用方法运行时，栈会为方法开辟一块空间</li></ul></li><li>堆(Heap)<ul><li>凡是new出来的，都在堆中</li><li>堆内存里面的东西都有一个地址值</li><li>堆内存里的数据都有默认值，同数组的默认值</li></ul></li><li>方法区(Method Area)<ul><li>存储class相关的信息，包括方法的信息</li></ul></li><li>本地方法栈(Native Method Stack)<ul><li>与操作系统相关</li></ul></li><li>寄存器(PC Register)<ul><li>与CPU相关，速度非常的快</li></ul></li></ul><p><strong>目前我们需要关注的前三个</strong>。</p><h3 id="数组的内存图"><a href="#数组的内存图" class="headerlink" title="数组的内存图"></a>数组的内存图</h3><p>下面我们来看一段代码，然后从内存的角度看看发生了什么</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(array1); <span class="comment">// 猜猜打印出什么</span></span><br><span class="line">    </span><br><span class="line">    array1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    System.out.println(array1[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] array2 = array1;</span><br><span class="line">    System.out.println(array2); </span><br><span class="line">    array2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    System.out.println(array1[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[I@<span class="number">15</span>db9742</span><br><span class="line"><span class="number">10</span></span><br><span class="line">[I@<span class="number">15</span>db9742</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>下面将从内存的角度解释，首先第一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure><p>该方法的信息会保存在方法区中，如果方法区中没有该方法，那么程序会报错。然后找到<code>main</code>方法后，这时会把main推入栈中，栈内存会为main方法开辟一块空间</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java02.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这一行是动态初始化数组，首先会在main方法中分配一块空间保存变量array1的值，在堆中会开辟一块空间，空间的大小为3个int的大小，里面的默认值为0，在堆中存放的东西都有一个地址，array1保存的就是这个地址。访问数组就是通过这个地址去访问在堆中保存的数据的。</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java03.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(array1);</span><br></pre></td></tr></table></figure><p>这一行打印变量array1的值，我们知道array1保存的是数组在堆中的地址，所以输出的是[I@15db9742，其中[代表类型为数组，I代表是int类型，@符号后面的十六进制数字是地址的哈希值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(array1[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>第一行是对数组中的第一个元素赋值为10，原来数组中的元素默认为0，现在改变为了10。在内存中的过程为，首先根据array1保存的地址去寻找在堆中的数组，然后根据索引值去寻找对应的位置，然后对数据进行修改</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java04.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array2 = array1;</span><br><span class="line">System.out.pritnln(array2);</span><br></pre></td></tr></table></figure><p>这行语句声明了一个数组变量array2，它的值与array1的值相同，所以输出结果为[I@15db9742。这表示两个数组变量指向在堆中的同一个数组</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java05.png"/></center><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">System.out.println(array1[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>上面的语句表示通过array2修改数组中的元素array2[1]为200，由于array1和array2指向的是同一个数组，所以array2对数组进行修改也会影响到array1。所以输出的结果是200而不是0。</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java06.png"/></center><h3 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h3><p>学习了数组的内容之后，我们做几个练习巩固一下知识。</p><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>遍历数组指的就是访问数组中的每一个元素。我们使用for循环，将数组中的每一个元素打印出来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="找到数组中的最大值"><a href="#找到数组中的最大值" class="headerlink" title="找到数组中的最大值"></a>找到数组中的最大值</h4><p>思路为，想象为这是一个打擂台，数组中的元素就是挑战者，首先让数组中的第一个元素为擂主，后面的挑战者（数组元素）去挑战，比擂主强的话就成为新的擂主，比擂主弱那么擂主就继续在台上，那么最后所有人都挑战完了，那么此刻的擂主就是最强的男人。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max = array[<span class="number">0</span>]; <span class="comment">//擂主为第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123; <span class="comment">//挑战者不断挑战</span></span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">        max = array[i];      <span class="comment">//如果挑战者比擂主强，那么换擂主，否则擂主不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max); <span class="comment">//此刻的擂主就是最强的</span></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><p>所谓的数组反转就是相对应的位置调换顺序，比如索引为0与索引为array.length-1（最后一个元素）调换位置，一般的索引为i的元素与索引为array.length-1-i的元素交换位置，那么交换的条件就是i &lt; array.length -1 - i得到i &lt; (array.length -1) / 2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = array.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[len -<span class="number">1</span> -i];</span><br><span class="line">    array[len -<span class="number">1</span> -i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="数组与方法"><a href="#数组与方法" class="headerlink" title="数组与方法"></a>数组与方法</h3><p>数组可以作为函数的参数，也可以作为函数的返回值返回。</p><h4 id="方法作为函数参数"><a href="#方法作为函数参数" class="headerlink" title="方法作为函数参数"></a>方法作为函数参数</h4><p>下面定义一个方法，该方法的作用是打印出数组里面的所有的元素，该方法接收一个整型的数组参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span> <span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面在main方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">printArray(array);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>数组传递的是地址值，所以printArray方法中的array与main方法中的array指向的是同一个数组，所以如果在printArray方法中对数组元素进行修改的话，会影响到main方法中的array。</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java07.png"/></center></li><li><p>随着printArray方法的执行完成，在栈内存中会将为printArray开辟的空间出栈，此时printArray方法中的array变量会立即消失。</p></li><li><p>不仅是数组，引用类型作为方法的参数，传递的都是地址值</p></li></ul><h4 id="数组作为方法返回值"><a href="#数组作为方法返回值" class="headerlink" title="数组作为方法返回值"></a>数组作为方法返回值</h4><p>下面有一个方法，该方法接收一个数组，返回该数组的所有数字之和及平均数，由于return语句只能返回0或1个值，要返回两个值的话，我们可以返回一个数组，数组的第一个值表示和，第二个值表示平均数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] getSumAndAvg (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123; <span class="comment">//求和</span></span><br><span class="line">        sum = sum + array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> avg = sum / array.length; <span class="comment">//得到平均数</span></span><br><span class="line">    <span class="keyword">double</span>[] result = &#123; sum, avg &#125;;  <span class="comment">//创建一个数组，第一个值为sum 第二个值为avg</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span>[] resArr = getSumAndAvg(array);    <span class="comment">//得到数组</span></span><br><span class="line">System.out.println(<span class="string">"Sum is "</span> + resArr[<span class="number">0</span>]); <span class="comment">//打印输出和</span></span><br><span class="line">System.out.println(<span class="string">"Average is "</span> + resArr[<span class="number">1</span>]); <span class="comment">//打印输出平均数</span></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sum is <span class="number">26.0</span></span><br><span class="line">Average is <span class="number">5.2</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>方法返回时数组的地址值，内存分析过程同上类似</li><li>返回引用数据类型，返回的也是地址值</li></ul>]]></content>
    
    <summary type="html">
    
      讲解Java基础知识，包含常量，变量，数据类型，运算符，流程控制，方法以及数组等知识
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="基础知识" scheme="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java开发环境搭建</title>
    <link href="https://lastknightcoder.gitee.io/Java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://lastknightcoder.gitee.io/Java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2019-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java环境搭建分为三步：</p><ul><li>下载JDK</li><li>安装JDK</li><li>环境变量配置</li></ul><p>下面将详细介绍安装的步骤。</p><h2 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h2><p>首先进入<a href="www.oracle.com">Oracle官网</a>进行下载</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down1.png"/></center><p>点击Downloads</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down2.png"/></center><p>点击Java</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down3.png"/></center><p>选择Java(JDK) for Developers</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down4.png"/></center><p>这是JDK 12，是最新版的，目前主流的是JDK 8，我们往下翻</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down5.png"/></center><p>点击JDK DOWNLOAD</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down6.png"/>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down7.png"/></center><p>选择合适自己机器的版本下载，一般现在的机器都是<code>64</code>为，选择下载即可，但我们点击下载时，它要我们登录</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down8.png"/></center><p>这里提供一个账号</p><ul><li>用户名：<a href="mailto:2696671285@qq.com">2696671285@qq.com</a></li><li>密码：Oracle123</li></ul><p>登录成功后就开始下载了</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down9.png"/></center><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>安装JDK就是一直点next即可，因为JDK是包含JRE的，所以JRE可以不必安装。这里需要注意的是，不要将安装目录安装在中文目录下，因为可能会碰到各种各样的问题，我们将它扼杀在摇篮里即可。这里需要记住安装的路径，比如我安装的路径是</p><ul><li>G:\java</li></ul><p>安装好以后里面是这样的</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down10.png"/></center><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>现在要进行环境变量的配置，可能你不知道为什么需要进行配置。我们看这么一个情况，你在命令行输入一个命令，比如notepad(它会打开一个记事本)，但是当你输入一串乱七八糟的字符时，它会提示你</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down11.png"/></center><p>那命令行怎么知道notepad是一个命令，而你乱输入的字符不是命令呢? 因为当你输入字符后，命令行会去一个路径找是否有这个命令，如果有那么执行该命令，没有就会报出上面那样的错误。为了我们能够在命令行中使用有关于Java的命令，我们就要将有关Java的命令添加到路径中，这个路径就是我们要去配置的东西。那么与Java有关的命令放在哪里，首先打开你安装的那个目录</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down10.png"/></center><p>然后进入bin文件夹，这个文件夹里面就是有关Java的各种命令</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down12.png"/></center><p>比如我的路径为</p><ul><li>G:\java\bin</li></ul><p>现在来到桌面，右键我的电脑，点击属性</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down13.png"/></center><p>然后按照以下步骤</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down14.png"/></center><p>会进入下面这个界面</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down15.png"/></center><p>点击新建，将你刚刚复制的路径粘贴上去</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down16.png"/></center><p>现在大功告成了。为了检验是否配置成功，我们打开命令行，输入java和javac命令，如果出现下面的界面就说明成功了</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down17.png"/>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down18.png"/></center><p>如果提示命令找不到之类的，说明配置失败了，就要回头仔细看看是不是漏掉了什么。</p>]]></content>
    
    <summary type="html">
    
      适合小白的从零搭配Java开发环境及变量配置
    
    </summary>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/categories/Java/"/>
    
      <category term="Element" scheme="https://lastknightcoder.gitee.io/categories/Java/Element/"/>
    
    
      <category term="Java" scheme="https://lastknightcoder.gitee.io/tags/Java/"/>
    
      <category term="学习" scheme="https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="软件安装及配置" scheme="https://lastknightcoder.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>CSS基础</title>
    <link href="https://lastknightcoder.gitee.io/CSS%E5%9F%BA%E7%A1%80/"/>
    <id>https://lastknightcoder.gitee.io/CSS%E5%9F%BA%E7%A1%80/</id>
    <published>2019-02-11T16:00:00.000Z</published>
    <updated>2019-02-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h1><p>之前我们学习过HTML的基本知识，对于网页来说，HTML搭建的只是框架，而对于网页的美容，则需要用到CSS，CSS就可以看做是网页的美容师。CSS的全称叫做Cascading Style Sheets,中文名字叫层叠样式表。我们可以用CSS设置字体的颜色，字体的大小以及图片外形，排版布局等等”美颜”的工作。</p><h2 id="CSS的书写位置"><a href="#CSS的书写位置" class="headerlink" title="CSS的书写位置"></a>CSS的书写位置</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>CSS的书写位置有三个，第一个是行内，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">style</span>=<span class="string">"属性1:属性值1; 属性2:属性值2 ..."</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就是把这个一级标题设置为红色。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span> = <span class="string">"color:red"</span>&gt;</span>CSS入门<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内嵌式"><a href="#内嵌式" class="headerlink" title="内嵌式"></a>内嵌式</h3><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        选择器&#123;属性1:属性值1; 属性2:属性值2; ...&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如下面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是把所有的h1标签的文字颜色设置为红色。</p><h3 id="外链式"><a href="#外链式" class="headerlink" title="外链式"></a>外链式</h3><p>外链式指的是HTML文件与CSS文件分开写，在实际工作中就是这么干的。但是为了方便，我在介绍CSS的使用的时候一般会用内嵌式。外链式的写法如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"CSS文件的路径"</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span>/ &gt;</span></span><br></pre></td></tr></table></figure><p>link标签是单标签，它是放在head标签内的。在使用link标签时，必须指定link标签的三个属性,如下:</p><ul><li>href:定义所链接外部样式表文件的URL,可以是相对路径，也可以是绝对路径。</li><li>type:定义所链接文档的类型，在这里需要指定为”text/CSS”,表示链接的外部文件为CSS样式表。</li><li>rel:定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个样式表文件。</li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>使用HTML的标签名作为选择器，为HTML的某一标签指定统一的<code>CSS</code>样式。比如上面的</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p>就是标签选择器，使用h1作为选择器，所有的h1标签包含的文字都被设置为红色。</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>类选择器是最常用的选择器，类选择器使用.（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名&#123;</span><br><span class="line">    属性:属性值;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签在调用CSS样式时，使class=”类名”即可，比如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.red</span>&#123;</span></span><br><span class="line">            color : red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>CSS入门<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们声明了一个类选择器，类名叫做red,在h1标签中，我们通过class=”red”调用了该类，所以h1标签所包含的文字设置成了红色。</p><h3 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h3><p>如果我们在标签中需要调用多个类怎么办，比如有两个类分别为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line">.font14&#123;</span><br><span class="line">    font-size=14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果加入h1标签要调用这两个类的话，写法如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span> = <span class="string">"red font14"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个就叫做多类名选择器。</p><p>还有一个问题就是，如果调用的多个类有冲突怎么办?比如调用的两个类一个设置颜色为红色，一个设置颜色为蓝色，是如何处理这种冲突?</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line">.blue&#123;</span><br><span class="line">    color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设h1调用如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"blue red"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你觉得会是蓝色还是红色的?答案是蓝色的，虽然调用时blue写在red前面，你想red会覆盖blue,所以会是红色，实际上最终的效果与调用的顺序无关，而与CSS书写的顺序有关，由于CSS书写时red在blue的上面，所以只有最后的blue生效。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>与类选择器很相似，不管调用方式是通过id来调用的，并且书写方式上有差别，即将.改为了#。如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>名&#123;</span><br><span class="line">    属性:属性值;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式同类调用方式，不过用的不是class=””而是id=””。与类选择器不同的是，由于id是唯一的，不同的标签的id不能相同，所以该种方法只能给唯一的一个id设置样式。并且id选择器能做到的，类选择器也能做到，所以实际上类选择器是用的最多的。</p><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>书写方式如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    属性:属性值;</span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>*</code>就是通配符，代表所有标签的意思，意思是所有的标签都会被设置成这样的样式，该种方法在开发几乎不用。</p><h1 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h1><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p>font-size属性是用来设置字体大小的，字体大小的单位有很多，其中最常用的就是px,代表的是像素，1px代表的就是一个像素的大小。比如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>在网页中普遍使用14px+,并且尽量用偶数大小，因为奇数可能在低版本的浏览器中出现莫名的问题。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>font-family属性是用来设置字体的，比如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-family</span>: "楷体";</span><br></pre></td></tr></table></figure><p>英文字体可以不加引号，但是如果英文字体含有空格，则需要加上引号，比如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-family</span>: "<span class="selector-tag">Times</span> <span class="selector-tag">New</span> <span class="selector-tag">Roman</span>";</span><br></pre></td></tr></table></figure><p>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。</p><p>在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、UTF-8等)不匹配时会产生乱码的错误。xp系统不支持类似微软雅黑的中文。解决办法是可以使用CSS Unicode字体表示，比如 <code>font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;</code> 就表示设置字体为微软雅黑。其中 <code>\5FAE\8F6F\96C5\9ED1</code> 就是Unicode字体。常见中文对应的Unicode字体如下:</p><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table><h2 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h2><p>font-weight属性是用来设置字体粗细的，可选属性值有normal, bold, older, lighter,除了有着四种值可选外，其值还可以是数字，范围为100-900并且必须为100的倍数。normal相当于是400,bold相当于是700,一般建议用数字。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-weight</span>: 400;</span><br></pre></td></tr></table></figure><h2 id="字体风格"><a href="#字体风格" class="headerlink" title="字体风格"></a>字体风格</h2><p>font-style属性是用来设置字体风格的，有两种值可选，分别是normal对于正常的字体风格，另一个是italic对应的是斜体风格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-style</span>: <span class="selector-tag">italic</span>;</span><br></pre></td></tr></table></figure><h2 id="综合连写"><a href="#综合连写" class="headerlink" title="综合连写"></a>综合连写</h2><p>假如我们设置字体的时候，四个都要设置，假如我要设置字体大小为20px,字体为微软雅黑，字体粗细为500,字体风格为斜体，我们会这样写:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"\5FAE\8F6F\96C5\9ED1"</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">500</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于字体样式写的比较频繁，这么写的话过于的繁琐，所以CSS规定可以对其综合连写，如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: italic <span class="number">500</span> <span class="number">20px</span> <span class="string">"\5FAE\8F6F\96C5\9ED1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中书写顺序必须为font-style, font-weight, font-size, font-family,其中font-size和font-family不可以省略。</p><h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>color属性用以设置文本的颜色，其取值有三种方法:</p><ul><li>red,green,blue…等内置的颜色</li><li>使用十六进制，比如#FF0000，其中十六进制的前两位代表三基色中的红色，中间两位代表绿色，后两位代表蓝色。所以#FF0000代表的就是红色。</li><li>使用RGB代码，比如红色为rgb(255,0,0)。</li></ul><p>其中第二种方法使用的最多，如果十六进制的三对每两位是相同的，则可以缩写为一个，比如#FF0000可以缩写为#F00。#FFDD66可以缩写为#FD6。</p><h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><p>line-height属性用以设置行高，比如对一个段落来说，其行与行之间的距离太小了，则可以通过设置行高来调整行间的距离。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h2><p>text-align用以设置文本的水平对齐方式，可选值有三个，分别为left, right, center。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>text-indent用以设置段落首行的缩进距离，一般设置为2em即两个字的距离：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-indent</span>: 2<span class="selector-tag">em</span>;</span><br></pre></td></tr></table></figure><h2 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h2><p>text-decoration属性用来修饰文本，有一下几个值可选:</p><ul><li>none：取消文本修饰或无修饰</li><li>underline：下划线</li><li>overline：上划线</li><li>line-through：删除线</li></ul><h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>假如有下面这么一个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>后代选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>开心<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>快乐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>乐观<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望将开心和快乐变成红色，而不影响乐观，即将div标签下的p标签设置为红色，但不是所有的p标签设置为红色，所以不能这么写</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你们可能会写一个类，然后让这两个p标签去调用，但是假设div下有很多这样的p标签的话，这样做就不现实，我这里使用的是后代选择器，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即设置div标签下的p标签设置为红色。因为乐观所处的p标签不在div标签下，所以乐观不受影响。效果如下:</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css02.png"/></center><h2 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h2><p>假设有这么一个案例</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>子代选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>一级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>一级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>一级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>二级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望一级菜单变为红色，而二级菜单不受到影响，如果我们使用后代选择器</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul li a &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么li标签下的所有a标签都会受到影响，二级菜单也会受到影响，这个时候我们需要用子代选择器</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul&gt;li&gt;a &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面便是子代选择器的写法，与后代选择器不同，子代只包括”儿子”,而后代则是包括后代所有的。所以使用子代选择器，受到影响的只有li标签下的a标签，二级菜单没有受到影响。效果为:</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css03.png"/></center><h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><p>假设有下面这么一个案例</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>交集选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望将第三个div标签中的文字设置为红色。很简单的一个方法就是这样</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让第三个div标签去调用，但是我们这里做出要求，当p标签去调用这个类时，它的颜色不会改变。这个时候我们就要用到交集选择器</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div.red &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的选择器表明，只有div标签调用这个类才会生效，其他标签调用这个类不会生效，这就是交集选择器。</p><h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>假设又有下面这个案例</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>并集选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>123<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望div,p.h1标签都设置为红色，其他的不变，我们可以这样写</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">h1 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用并集选择器可以使上面的代码大大减少</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div, p, h1 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用逗号将标签或者类名隔开。</p><h2 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h2><p>什么是伪类选择器，伪类选择器是向某些选择器添加特殊效果，比如为链接添加特殊效果,链接伪类选择器有四个，分别为</p><ul><li>link：未访问过的链接状态</li><li>visited：已访问过的链接状态</li><li>hover：鼠标放上去时的链接状态</li><li>active：鼠标按下时的链接状态</li></ul><p>类选择器使用点.,而伪类选择器使用冒号:。现在我们有这个需要，当未访问链接时，链接字体为25px,无下划线，当鼠标放上去时，颜色变为红色，当按下时颜色变为橙色，当访问后，颜色为绿色。CSS样式按如下写</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;     <span class="comment">/*取消下划线*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css05.gif"/></center><p>当未按下链接时，链接为蓝色，按把鼠标放上去时，链接变为红色，当按下链接时，链接变为橙色，当访问完链接后，链接变为了绿色。需要<strong>注意</strong>的一点是，伪类选择器的顺序必须按照lvha的顺序来，否则会达不到想要的效果。在实际的开发中，一般只用到hover,不会写的这么复杂，即我们只需要当鼠标放上去变颜色就行，如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="标签显示模式"><a href="#标签显示模式" class="headerlink" title="标签显示模式"></a>标签显示模式</h1><p>我们把标签分为三类，一类为块级(block)标签，一类为行内(inline)标签,最后一类为二者的综合，为行内块(inline-block)标签。每个块标签通常都会独自占据一整行或多整行，可以对其设置<strong>宽度、高度、对齐</strong>等属性，常用于网页布局和网页结构的搭建。常见的块级标签包括</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>~<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">ul</span>&gt;</span>、<span class="tag">&lt;<span class="name">ol</span>&gt;</span>、<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>行内标签（内联标签）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般<strong>不可以</strong>设置<strong>宽度、高度、对齐</strong>等属性，常用于控制页面中文本的样式。常见的行内标签包括</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">strong</span>&gt;</span>、<span class="tag">&lt;<span class="name">b</span>&gt;</span>、<span class="tag">&lt;<span class="name">em</span>&gt;</span>、<span class="tag">&lt;<span class="name">i</span>&gt;</span>、<span class="tag">&lt;<span class="name">del</span>&gt;</span>、<span class="tag">&lt;<span class="name">s</span>&gt;</span>、<span class="tag">&lt;<span class="name">ins</span>&gt;</span>、<span class="tag">&lt;<span class="name">u</span>&gt;</span>、<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设我们对行内标签设置其宽高属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做是没有效果的。链接a的宽高属性不会改变。</p><p>在行内元素中有几个特殊的标签——<code>&lt;img /&gt;</code>、<code>&lt;input /&gt;</code>、<code>&lt;td&gt;</code>，<strong>可以对它们设置宽高和对齐属性</strong>，有些资料可能会称它们为行内块标签。那么标签的这种显示模式可不可以转换呢? 答案是可以，我们可以使用display属性对其进行转换，如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span>;       <span class="comment">/*将块级标签转换为行内标签*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>;        <span class="comment">/*将行内标签转换为块级标签*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>; <span class="comment">/*将块级标签或者行内标签转换为行内块标签*/</span></span><br></pre></td></tr></table></figure><p>我们来看一个例子，假设有下面的程序</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标签显示模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            a &#123;</span><br><span class="line"><span class="css">                <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;  <span class="comment">/*取消下划线*/</span></span></span><br><span class="line"><span class="css">                <span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;       <span class="comment">/*设置背景颜色，用以观察该标签显示模式的转换*/</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为标签a是行内标签，所以这三个标签是显示在一行内的，如下:</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css06.png"/></center><p>并且无法对其设置宽高以及对齐属性。现在我们将标签<code>a</code>的显示模式改为块级模式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css07.png"/></center><p>可见链接已经变为了块级标签，一个标签占据一整行，并且我们可以对其设置宽高属性以及对其方式，如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果为</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css08.png"/></center><p>可见链接a的宽高发生了变化，并且其内的文字水平居中对齐了。我们可以把所有的标签看做是一个盒子，有的盒子是占据一行的，并且可以设置其大小，有的盒子只能在行内，并且不能设置其大小，还有的盒子虽然在行内，但是可以设置其大小。我们就用CSS对盒子进行操作，或摆放，或修饰，或改变盒子的显示模式等等。</p><h1 id="导航栏练习"><a href="#导航栏练习" class="headerlink" title="导航栏练习"></a>导航栏练习</h1><p>现在我们要做一个导航栏，其最终效果如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css09.gif"/></center><p>我们要求导航栏的布局居中显示，并且其内的文字也要居中对齐。并且当鼠标放在网站导航上，其背景图片发生变换。</p><p>首先第一步便是显示着六个链接，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下:</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css10.png"/></center><p>第二步，取消下划线，并且设置字体颜色为白色，并且添加背景图片，由于链接标签a是行内标签，其大小不可以改变，为了使添加的背景图片吻合，还需要改变其显示模式为display: inline-block,然后设置其宽高属性为图片宽高的大小。如下:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none; <span class="comment">/*取消下划线*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>; <span class="comment">/*设置字体颜色为白色*/</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(bg.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，为了只影响导航栏的链接标签，这里我们用了后代选择器。效果如下:</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css11.png"/></center><p>这个时候我们发现导航栏没有居中对齐，并且里面的文字没有居中对齐</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置.nav类里的文字居中对齐，但是div里面的是链接，text-align属性还有用吗? 答案是可以，链接在块类标签里面可以当做是文字处理，这是一个知识点，记住了。效果如下：</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css12.png"/></center><p>我们发现导航栏居中对齐了现在我们需要将链接里面的文字水平居中对齐和垂直居中对齐，在.nav a加入如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>;  <span class="comment">/*当行高等于标签设置的高度时，会使文字垂直居中对齐*/</span></span><br></pre></td></tr></table></figure><p>效果如下</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css13.png"/></center><p>现在最后一步就是将鼠标放上去，背景图片改变，我们使用伪类hover,如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"bgc.png"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了只对导航栏的链接生效，这里也用了后代选择器，效果如下:</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css14.gif"/></center><p>到这里我们已经完整的实现了导航栏的案例，下面贴出完整的代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>导航栏案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>; <span class="comment">/*取消下划线*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>; <span class="comment">/*设置字体颜色为白色*/</span></span></span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 120px;</span><br><span class="line">            height: 50px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">bg</span><span class="selector-class">.png</span>);</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>("<span class="selector-tag">bgc</span><span class="selector-class">.png</span>");</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.nav</span> &#123;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="行高-1"><a href="#行高-1" class="headerlink" title="行高"></a>行高</h1><p>在之前我们有提到这个属性line-height，该属性用来设置行高，并且我们用它来设置过行间距。为了明白行高指的是什么之间的距离，我们需要明白下面这个图</p><center>    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css15.png"/></center><p>一个文本内容被四条线划分，而行高指的就是基线与基线之间的距离，当不设置行高时，行高的大小为字体的大小，所以行与行之间是紧贴着的。</p><p>在导航栏练习中，为了使文字能够垂直居中对齐，我们让line-height的大小等于盒子的大小，为了解释这一现象，我们先看一下盒子的组成，盒子的高度由上距离，下距离和文本内容的高度组成，上距离的大小为(行高-内容高度)/2,下距离的高度=盒子高度-上距离的高度-内容高度。当文本垂直居中显示时，上距离的高度等于下距离的高度，这时上距离的高度=(盒子高度-内容高度)/2,对比于上距离高度的公式，得到此时行高等于盒子的高度。所以这就解释了为什么当行高等于盒子高度时，文字会垂直水平居中，当行高增大时，上距离的高度增大，文字会向下移动。</p>]]></content>
    
    <summary type="html">
    
      讲解CSS基础知识
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="CSS" scheme="https://lastknightcoder.gitee.io/categories/Web/CSS/"/>
    
    
      <category term="基础知识" scheme="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="CSS" scheme="https://lastknightcoder.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="https://lastknightcoder.gitee.io/HTML%E5%85%A5%E9%97%A8/"/>
    <id>https://lastknightcoder.gitee.io/HTML%E5%85%A5%E9%97%A8/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需要的开发工具"><a href="#需要的开发工具" class="headerlink" title="需要的开发工具"></a>需要的开发工具</h2><p>由于目前的市场上Google的占有率最高，所以我们用Chorme作为开发用的浏览器，而写代码的工具有很多，我一般用WebStorm。</p><h2 id="第一个HTML页面"><a href="#第一个HTML页面" class="headerlink" title="第一个HTML页面"></a>第一个HTML页面</h2><p>一般新入手一个语言，都是先敲一个代码，然后在解释这个代码，按照惯例都是显示<code>Hello World</code>,所以这里就在网页中显示<code>Hello World</code>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上的程序可以写在任何文本编辑器中，然后将后缀名改为<code>.html</code>，用浏览器打开即可。</p><p>一般写html的格式应该如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;html&gt;,&lt;head&gt;</code>等等称为标签，在html中，内容都是由标签来呈现的，而标签分为双标签和单标签，一般我们遇到的都是双标签，比如上面的<code>&lt;html&gt;&lt;/html&gt;</code>是双标签，<code>&lt;html&gt;</code>是开始标签，<code>&lt;/html&gt;</code>是结束标签。单标签比如<code>&lt;br /&gt;</code>是换行标签，它的作用是换行。</p><p>其中<code>&lt;body&gt;&lt;/body&gt;</code>标签里写的东西才是网页呈现的内容，比如上面的<code>Hello World</code>就是写在<code>body</code>标签里面的,而<code>&lt;head&gt;&lt;/head&gt;</code>标签里写的东西都不会呈现在网页中，一般写的都是网页的信息，比如所用的编码，网页的标题，网页的版权等等。</p><p>我们一般会在第一行加上<code>&lt;!DOCTYPE html&gt;</code>,这个是用来告诉浏览器我们使用的浏览器版本，这么写的话就代表我们使用的是html5的版本。</p><h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在<code>html</code>中共有6种标题，分别是</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">... ...</span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中h1为最大的标题，称为一级标题，<code>h6</code>称为六级标题，上面的标题标签都是双标签。</p><p>我们在网页中看看标题的效果:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示显示效果：</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html01.png"/></center></center><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落标签是用<code>&lt;p&gt;&lt;/p&gt;</code>标签来呈现的，在<code>&lt;p&gt;</code>标签内部的内容视为一个段落，该标签会根据浏览器窗口的大小自动换行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。</span><br><span class="line">        予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，</span><br><span class="line">        亭亭净植，可远观而不可亵玩焉。(甚爱 一作：盛爱)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。</span><br><span class="line">        噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人?牡丹之爱，宜乎众矣!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示显示效果：</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html02.png"/></center><p>在<code>html</code>代码中进行换行操作时，在网页显示时不会进行换行操作，<code>html</code>中所有的功能都是由标签实现的，所以换行也需要换行标签实现。</p><p>我们可以见到，段落之间会自动换行，并且段落之间还隔有一个空行。</p><h3 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h3><p>水平线标签<code>&lt;hr /&gt;</code>是一个单标签，它的作用是显示一条水平线。</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>换行标签为<code>&lt;br /&gt;</code>,也是一个单标签，它的作用是换行，换行之后，不会像段落一样之间还有一个空行，而是两行会紧贴着。</p><h3 id="两个无语义化的标签"><a href="#两个无语义化的标签" class="headerlink" title="两个无语义化的标签"></a>两个无语义化的标签</h3><p><code>&lt;div&gt;&lt;/div&gt;</code>和<code>&lt;span&gt;&lt;/span&gt;</code>,这两个标签没有实际的功能，在后面主要是配合<code>CSS</code>进行布局，所以这里就不要管它好了。</p><p><code>&lt;div&gt;</code>标签会实现自动换行，所以一行只能有一个<code>&lt;div&gt;</code>标签，<code>&lt;span&gt;</code>不会自动换行，所以一行可以有多个<code>&lt;span&gt;</code>标签。</p><p>我们来看一个简单的例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>会自动换行<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>不会自动换行<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>可以有多个<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示显示效果：</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html03.png"/></center><h2 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h2><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><p>加粗标签有两个，分别为<code>&lt;b&gt;&lt;/b&gt;</code>和<code>&lt;strong&gt;&lt;/strong&gt;</code>,二者都能进行加粗，不过<code>&lt;strong&gt;</code>标签比较有语义，所以用的比较多。</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>斜体标签也有两个，分别为<code>&lt;i&gt;&lt;/i&gt;</code>和<code>&lt;em&gt;&lt;/em&gt;</code>,同样的，<code>&lt;em&gt;</code>用的比较多。</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>同样也有两个，分别为<code>&lt;s&gt;&lt;/s&gt;</code>和<code>&lt;del&gt;&lt;/del&gt;</code>,后面的有语义，用的多。</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>两个，分别为<code>&lt;u&gt;&lt;/u&gt;</code>和<code>&lt;ins&gt;&lt;/ins&gt;</code>,后面的有语义，为<code>insert</code>的缩写，用的较多。</p><p>简单的演示一下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">del</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ins</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示显示效果：</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html04.png"/></center><h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><p>向网页中添加图片的方法为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片的路径"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个单标签，<code>src</code>称为标签<code>&lt;img&gt;</code>的属性，它的值应该为图片的路径。</p><p>而路径又分为绝对路径和相对路径,下面将简单介绍一下二者，假设有如下的目录结构</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">磁盘<span class="selector-tag">C</span></span><br><span class="line">    <span class="selector-tag">file1</span>文件夹</span><br><span class="line">        <span class="selector-tag">html</span><span class="selector-class">.md</span></span><br><span class="line">        <span class="selector-tag">p1</span><span class="selector-class">.png</span></span><br><span class="line">        <span class="selector-tag">image</span>文件夹</span><br><span class="line">            <span class="selector-tag">p2</span><span class="selector-class">.png</span></span><br><span class="line">    <span class="selector-tag">p3</span><span class="selector-class">.png</span></span><br></pre></td></tr></table></figure><p>现在我打开的是html.md文件,如果我要与绝对路径插入p1.png, p2.png, p3.png这三张图片，那么方法是这样的</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"C:/file1/p1.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"C:/file1/image/p2.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"C:/p3.png"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果以相对路径插入图片，那么图片相对于该文件的位置就很重要，下面演示如何以相对路径插入图片</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"p1.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/p2.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../p3.png"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>p1.png和文件html.md处于同一级目录，所以直接写src=”p1.png”即可，而p2.png位于image文件夹，该文件夹与html.md文件处于同一目录，所以写为src=”image/p2.png”,而p3.png位于上级目录，<code>..</code>表示上一级目录，所以写为src=”../p3.png”。</p><p>图像标签除了有<code>src</code>属性外，还有其他的属性，如下</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">alt</td><td align="left">图像不能显示时的替换文本</td></tr><tr><td align="left">title</td><td align="left">鼠标悬停显示的内容</td></tr><tr><td align="left">width, height</td><td align="left">宽度和高度，设置其中一个就可以，会等比例的缩放</td></tr><tr><td align="left">border</td><td align="left">添加边框，其值为边框的粗细</td></tr></tbody></table><p>下面给一个示例写法:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"p1.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span> <span class="attr">title</span>=<span class="string">"p1.png"</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><p>我们碰到，当我们点击一句话就可以跳转到一个网页，或者点击一张图片跳转。那么这个就是用链接标签实现的。链接标签为:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接地址"</span>&gt;</span>跳转的文字或图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如你<a href="https://www.baidu.com" target="_blank" rel="noopener">点击这里</a>就会跳转到百度。比较需要注意的是，跳转到外部的网页要写成<a href="https://www.baidu.com，而不要写成www.baidu.com。" target="_blank" rel="noopener">https://www.baidu.com，而不要写成www.baidu.com。</a> 另外，注意这个跳转是在本页面打开的，而不是新打开一个页面，如果需要在新页面打开，则可以改变其属性target的值，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> <span class="attr">target</span> = <span class="string">"_blank"</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>target有两种值可选，分别为_self和_blank,默认为_self，即在本页面打开。除了可以跳转到外链，也可以在页面内进行跳转，你可以给一个标签设定一个id值,比如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.png"</span> <span class="attr">id</span> = <span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我给这张插入的图片设了id值为1,那么我可以通过下面的语句跳转到这张图片</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#1"</span>&gt;</span>跳转到1.png<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过id跳转前面要加#号。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>该种列表在实际中使用的较多,效果大概是这样</p><ul>    <li>足球</li>    <li>篮球</li></ul><p>无序列表的标签为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意:<code>&lt;ul&gt;&lt;/ul&gt;</code>标签里面只能放<code>&lt;li&gt;&lt;/li&gt;</code>标签，而<code>&lt;li&gt;&lt;\li&gt;</code>能放任何内容。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表也经常用，其标签与无序的很相似</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果是这样</p><ol>    <li>足球</li>    <li>篮球</li></ol><p>注意事项同无序。</p><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>使用以下格式定义自定义列表</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>球类<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><dl>    <dt>球类</dt>    <dd>足球</dd>    <dd>篮球</dd></dl><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格在网页中也很常见，其写法为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>物理<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>99<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其效果为</p><table>    <tr>        <td>学科</td>        <td>分数</td>    </tr>    <tr>        <td>物理</td>        <td>99</td>    </tr></table><p><code>&lt;table&gt;&lt;/table&gt;</code>标签就表示表格，而<code>&lt;tr&gt;&lt;/tr&gt;</code>表示一行，<code>&lt;td&gt;&lt;/td&gt;</code>表示一个单元格。table标签有很多的属性，如下</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>align</td><td>该属性设定对齐方式，有left,center,right三个值可选</td></tr><tr><td>cellspacing</td><td>单元格与单元格之间的距离，默认为2</td></tr><tr><td>cellpadding</td><td>单元格内的字与单元格之间的距离，默认为1</td></tr></tbody></table><p>一般我们设置table的以下三个属性为0，这三个属性分别为cellspacing, cellpadding, border，称之为”三参为0”。我们还可使用<code>&lt;caption&gt;&lt;/caption&gt;</code>标签设置表格的标题，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>物理<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>99<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table>    <caption>成绩单</caption>    <tr>        <td>学科</td>        <td>分数</td>    </tr>    <tr>        <td>物理</td>        <td>99</td>    </tr></table><p>因为表头比较特殊，所以有的时候我们在表头中不用td，使用th,该标签会加粗居中，我们改动如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果为</p><table>    <caption>成绩单</caption>    <tr>        <th>学科</th>        <th>分数</th>    </tr>    <tr>        <td>物理</td>        <td>99</td>    </tr></table><p>下面讲的这个在实际中也经常遇到的是单元格合并。假如有下面这个表格</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table>    <tr>        <td>123</td>        <td>123</td>        <td>123</td>    </tr>    <tr>        <td>123</td>        <td>123</td>        <td>123</td>    </tr>    <tr>        <td>123</td>        <td>123</td>        <td>123</td>    </tr></table><p>我希望将最后一行的后两列合并成一个单元格,首先我们要知道单元格的合并分为行和并rowspan和列合并colspan,行合并是自左而右的，列合并是自上而下的。将最后一行的后两列合并为一个，所以是列和并，并且是两个合并成一个，所以colspan = “2”,所以上面的程序改为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果为</p><table>    <tr>        <td>123</td>        <td>123</td>        <td>123</td>    </tr>    <tr>        <td>123</td>        <td>123</td>        <td>123</td>    </tr>    <tr>        <td>123</td>        <td colspan="2">123</td>    </tr></table><p>在第三个tr(代表第三行)的第二个td处设置colspan=”2”,因为要合并最后一列，所以要删去最后一个td。</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>现实中会经常提交表单，比如在注册邮箱时，你就需要提交表单，表单由三部分组成，表单控件，提示文本和表单域。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html05.png"/></center><p>现在重点介绍表单控件，因为这个包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。与表单有关的标签是<code>&lt;input/ &gt;</code>,<code>&lt;input/ &gt;</code>是一个单标签，根据其属性type设置不同的值，可以指定不同的控件类型，如:</p><table><thead><tr><th>type的值</th><th>控件</th></tr></thead><tbody><tr><td>text</td><td>单行文本输入框</td></tr><tr><td>password</td><td>密码输入框</td></tr><tr><td>radio</td><td>单选按钮</td></tr><tr><td>checkbox</td><td>复选框</td></tr><tr><td>button</td><td>普通按钮</td></tr><tr><td>submit</td><td>提交按钮</td></tr><tr><td>reset</td><td>重置按钮</td></tr><tr><td>image</td><td>图像形式的提交按钮</td></tr><tr><td>file</td><td>文件域</td></tr></tbody></table><p><code>&lt;input/ &gt;</code>还有其他的属性配合type属性使用，如下</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>name</td><td>控件的名称</td></tr><tr><td>value</td><td>控件的默认文本值</td></tr><tr><td>size</td><td>控件在页面中的显示宽度，只能为正整数</td></tr><tr><td>checked</td><td>定义选择控件默认被选中的项</td></tr><tr><td>maxlength</td><td>控件允许输入的最大字符数</td></tr></tbody></table><p>这里我想说一下单选按钮，假设有两个单选按钮，比如男和女让你选，按道理只能选一个，如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以发现两个都可以选到，解决办法将二者的name属性设置为相同的，比如sex,相同的name代表他们是同一组的，对于单选按钮，同一组的只能选中一个。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html06.gif"/></center><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候你只能选一个。</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html07.gif"/></center><p>下面要介绍一个<code>&lt;label&gt;&lt;/label&gt;</code>标签，当label与一个表单控件绑定时，点击该label会获得该控件的输入焦点,那么如何与表单控件绑定呢?使用for属性,如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"word"</span>&gt;</span>Sex<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"word"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你点击Sex,会自动获得输入焦点。效果如下:</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html08.gif"/></center><p>text只能输入一行的文本，事实上，我们在网页中经常见可以输入多行文本的输入框，比如在我们发表评论时的输入框，多行输入的标签是textarea,使用方法如下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"每行中的字符数"</span> <span class="attr">rows</span>=<span class="string">"显示的行数"</span>&gt;</span></span><br><span class="line">  默认显示文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><center><img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html09.png"/></center><p>最后一个要介绍的就是下拉菜单，下拉菜单的标签是</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下所示</p><center><select>    <option>北京</option>    <option>上海</option>    <option>青岛</option></select></center><p>当option中设置selected属性为selected=”selected”,那么这个option是默认选中项。比如我要设置上海为默认选中项那么</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><center><select>    <option>北京</option>    <option selected="selected">上海</option>    <option>青岛</option></select></center>]]></content>
    
    <summary type="html">
    
      讲解HTML基础知识，包含文本，图片，链接，表格，表单标签等知识
    
    </summary>
    
    
      <category term="Web" scheme="https://lastknightcoder.gitee.io/categories/Web/"/>
    
      <category term="HTML" scheme="https://lastknightcoder.gitee.io/categories/Web/HTML/"/>
    
    
      <category term="基础知识" scheme="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="HTML" scheme="https://lastknightcoder.gitee.io/tags/HTML/"/>
    
  </entry>
  
</feed>
