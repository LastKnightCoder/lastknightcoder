<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="熊滔"><meta name="description" content="人生天地间，忽如远行客"><link rel="alternative" href="/atom.xml" title="Coder" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>重建二叉树 - Coder</title>
<link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/main.css">

<link rel="stylesheet" href="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="https://lastknightcoder.gitee.io/js/jquery-3.1.1.min.js"></script>

<script src="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="https://lastknightcoder.gitee.io/">Coder</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-05-31T16:00:00.000Z">2020-06-01 00:00:00</time><h1 class="post__title"><a href="https://lastknightcoder.gitee.io/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">重建二叉树</a></h1><div class="post__main echo"><blockquote>
<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</blockquote>
<p>首先通过一个例子看看前序遍历和中序遍历的特点，如下二叉树</p>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/image-20200602190620264.png" width="50%"/>

<p>它的前序遍历和中序遍历的结果为</p>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200601125610.png" width="60%"/>

<p>我们分析一下前序遍历和中序遍历的结构</p>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200601125638.png" width="60%"/>

<p>我们的思路是首先根据前序遍历找到根节点的值(第一个)，接着根据找到的根节点的值，在中序遍历中找到根节点的位置，在中序遍历中根节点左边的值是它的左子树的中序遍历，右边是它的右子树的中序遍历，并且进一步可以得到左右子树的长度，根据左右子树的长度，可以在前序遍历中找到左子树的前序遍历和右子树的前序遍历，然后重复上面的过程，又可以找到左右子树的根节点的值以及相应的左右子树，以此类推，即可重建二叉树。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二叉树的定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        BinaryTree left;</span><br><span class="line">        BinaryTree right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preorder 前序遍历的数组</span></span><br><span class="line">    <span class="comment">// inorder 中序遍历的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTree <span class="title">constructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"preorder or inorder is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helpContructBinaryTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据前序遍历数组和中序遍历数组获得根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTree <span class="title">helpContructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历的第一个值就是根节点</span></span><br><span class="line">        BinaryTree root = <span class="keyword">new</span> BinaryTree(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有数组只有一个值</span></span><br><span class="line">        <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inStart == inEnd &amp;&amp; preorder[preStart] == inorder[inStart]) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"wrong input"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得中序遍历根节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> inOrderRoot = inStart;</span><br><span class="line">        <span class="keyword">for</span> (; inOrderRoot &lt;= inEnd; inOrderRoot++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[inOrderRoot] == root.value) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在中序遍历中没有找到根节点 则输入的数组有错误</span></span><br><span class="line">        <span class="keyword">if</span> (inOrderRoot &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"wrong input"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右子树的长度</span></span><br><span class="line">        <span class="keyword">int</span> leftLength = inOrderRoot - inStart;</span><br><span class="line">        <span class="keyword">int</span> rightLength = inEnd - inOrderRoot;</span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据左子树的前序遍历和中序遍历获得左子树的根节点</span></span><br><span class="line">            <span class="comment">// [preStart + 1, preStart + leftLength] 左子树的前序遍历的范围</span></span><br><span class="line">            <span class="comment">// [inStart, inOrderRoot - 1] 左子树的中序遍历的范围</span></span><br><span class="line">            root.left = helpContructBinaryTree(preorder, preStart + <span class="number">1</span>, preStart + leftLength,</span><br><span class="line">                    inorder, inStart, inOrderRoot - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 同左子树</span></span><br><span class="line">            root.right = helpContructBinaryTree(preorder, preStart + leftLength + <span class="number">1</span>, preEnd,</span><br><span class="line">                    inorder, inOrderRoot + <span class="number">1</span>, inEnd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/">剑指offer</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="https://lastknightcoder.gitee.io/img/wechatpay.png" title="微信"><img src="https://lastknightcoder.gitee.io/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2019 - 2020 熊滔</div></footer>
<script src="https://lastknightcoder.gitee.io/js/scroller.js"></script>

<script src="https://lastknightcoder.gitee.io/js/main.js"></script>
</body></html>