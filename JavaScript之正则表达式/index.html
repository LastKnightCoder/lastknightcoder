<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="熊滔"><meta name="description" content="人生天地间，忽如远行客"><link rel="alternative" href="/atom.xml" title="Coder" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>JavaScript之正则表达式 - Coder</title>
<link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/main.css">

<link rel="stylesheet" href="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="https://lastknightcoder.gitee.io/js/jquery-3.1.1.min.js"></script>

<script src="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="https://lastknightcoder.gitee.io/">Coder</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-05-27T16:00:00.000Z">2020-05-28 00:00:00</time><h1 class="post__title"><a href="https://lastknightcoder.gitee.io/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript之正则表达式</a></h1><div class="post__main echo"><p>在字符串的处理中，我们经常要进行字符串的匹配，校验等等操作。比如校验字符串的格式是否符合邮箱，电话号码的格式，校验密码是否符合要求，密码中是否包含数字和字母等等；又或者匹配得到某种规则的字符串。这一些操作如果使用常规的方法进行字符串操作，会花费较大的代价，包括时间和精力。</p>
<p>正则表达式是用来表达字符串的规则，它可以检验字符串是否符合某个特定的规则，或者匹配字符串中符合规则的字符，在一般的使用中，正则表达式一般用来匹配字符串中的字符或者字符串中特定的位置。</p>
<h2 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h2><p><code>JavaScript</code> 正则对象的创建有两种常见的方法，一是使用 <code>RegExp</code> 构造函数进行创建，二是使用字面量的方法进行创建，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'hello'</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> regex2 = <span class="regexp">/hello/g</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>hello</code> 表示字符串的规则，用来匹配字符串中的<code>&quot;hello&quot;</code>，<code>g</code> 表示进行全局匹配(<code>global</code>)，像这样的标志还有两个，<code>m</code> 表示进行多行匹配(<code>multiline</code>)，<code>i</code> 表示忽略大小写(<code>ignoreCase</code>)，这三个标志互不冲突，可以同时使用，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/igm</span>;</span><br></pre></td></tr></table></figure>

<p>具体标志的作用在后面讲解。在实际的使用中，我们一般会使用字面量的形式创建正则对象，相对于使用构造函数，字面量的创建比较简便，不过如果需要动态的创建正则对象，或者根据字符串创建正则对象，那么可以考虑使用构造函数的方式。</p>
<h3 id="正则对象中的属性"><a href="#正则对象中的属性" class="headerlink" title="正则对象中的属性"></a>正则对象中的属性</h3><ul>
<li><code>global</code>：布尔值，是否设置了 <code>g</code> 标志</li>
<li><code>ignoreCase</code>：布尔值，是否设置了 <code>i</code> 标志</li>
<li><code>lastIndex</code>：整数，从字符串的某个位置开始匹配，默认为 <code>0</code></li>
<li><code>multiline</code>：布尔值，是否设置了 <code>m</code> 标志</li>
<li><code>source</code>：正则表达式的字符串表示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d&#123;3&#125;hello$/ig</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.global); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.source); <span class="comment">// \d&#123;3&#125;hello$</span></span><br></pre></td></tr></table></figure>

<h3 id="正则对象中的方法"><a href="#正则对象中的方法" class="headerlink" title="正则对象中的方法"></a>正则对象中的方法</h3><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><code>test()</code>，该方法接收一个字符串参数，返回一个布尔值，用来判断该字符串是否符合正则对象的规则，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec()</code> 方法是用来捕获匹配到的字符，该方法接收一个字符串，返回一个数组，数组的第一项表示与整个模式匹配的字符串，第二项表示第一个捕获组(捕获组的概念如果不懂，可以看了括号的作用在回来看)，第三项表示第二个捕获组，以此类推。返回的数组与普通数组不同的是，该数组还有三个属性，<code>index</code> 、 <code>input</code> 和 <code>groups</code>，<code>index</code> 表示匹配到的字符在原始字符串中的位置，从 <code>0</code> 开始；<code>input</code> 表示输入的原始字符串，<code>groups</code> 表示捕获组的名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(he)(ll)(o)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"so hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200527135642.png" width="80%"/>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">3</span>,</span><br><span class="line">  input: <span class="string">'so hello'</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果正则对象的标志有 <code>g</code> 的话，那么在执行 <code>exec()</code> 方法后会改变 <code>lastIndex</code> 为匹配字符串后字符的 <code>index</code>，接下来再次执行 <code>exec()</code> 方法时将会从 <code>lastIndex</code> 处开始匹配，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"ab abc abc"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/ab/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">regex.exec(string); <span class="comment">// 匹配不到会返回 null</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 重新变为 0</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数RegExp的属性"><a href="#构造函数RegExp的属性" class="headerlink" title="构造函数RegExp的属性"></a>构造函数RegExp的属性</h3><p>构造函数 <code>RegExp</code> 中有一些静态属性，这些属性会保存最近一次正则对象操作的一些信息，并且这些属性有两种方法访问，一种是具有语义的长属性名，一种是简短的短属性名，具体如下：</p>
<ul>
<li><code>input</code>：短属性名为 <code>$_</code>，最近一次要匹配的字符串</li>
<li><code>lastMatch</code>：<code>$&amp;</code>，最近一次的匹配项</li>
<li><code>leftContext</code>：$`， <code>input</code> 中 <code>lastMatch</code> 的左边部分</li>
<li><code>rightContext</code>：<code>$&#39;</code>，<code>input</code> 中 <code>lastMatch</code> 的右边部分</li>
<li><code>$1, $2, ...</code>：后面介绍</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"he hello llo"</span>;</span><br><span class="line">regex.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input); <span class="comment">// he hello llo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// he_ (从_表示空格)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// _llo</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>在字符串中，有许多的方法也是与正则表达式有关的，如 <code>replace</code>，<code>match</code>，下面就简单介绍一下。</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p><code>replace()</code> 方法的作用是使用新的字符串替换字符串中的某些内容，该方法接收两个参数，第一个参数表示字符串中要被替换的内容，它可以是一个具体的字符串或者是一个正则对象，第二个参数为一个字符串，这个参数是用来替换第一个参数的，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"gello"</span>;</span><br><span class="line">string = string.replace(<span class="string">'g'</span>, <span class="string">'h'</span>); <span class="comment">// 将 string 中的 g 替换为 h</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"abc"</span>;</span><br><span class="line">string = string.replace(<span class="regexp">/[ab]/g</span>, <span class="string">'#'</span>); <span class="comment">// 将字符串中的 a 或 b 替换为 #</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// ##c</span></span><br></pre></td></tr></table></figure>

<p>在上面中使用了 <code>[ab]</code>，这个表示 <code>a</code> 或者 <code>b</code>，具体会在元字符那里讲解。</p>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>match</code> 方法的作用与 <code>exec</code> 的作用差不多，不过一个是 <code>RegExp</code> 对象的方法，一个是 <code>String</code> 对象的方法。<code>match</code> 方法接收一个正则对象，它返回一个数组，根据正则对象是否设置了 <code>g</code> 标志，返回的结果也不相同。</p>
<p>如果没有设置 <code>g</code> 标志，即不会全局匹配，只会匹配一次，那么它返回的结果与 <code>exec</code> 返回的结果相同，数组的第一个元素表示匹配的字符串，后面的元素表示捕获组，并且也有 <code>input</code>，<code>index</code>，<code>groups</code>等属性，表示的含义也痛 <code>exec</code>，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(<span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello'</span>,</span><br><span class="line">  groups: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">h</span>: <span class="string">'he'</span>, <span class="attr">l</span>: <span class="string">'ll'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这次的正则表达式跟以往的不同，这次我设置了捕获组的名称，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?<span class="xml"><span class="tag">&lt;<span class="name">h</span>&gt;</span>he)</span></span><br></pre></td></tr></table></figure>

<p>即将捕获组 <code>(he)</code> 的名称设置为了 <code>h</code>，设置捕获组名称的格式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?&lt;捕获组名称&gt;捕获组内容)</span><br></pre></td></tr></table></figure>

<p>为捕获组设置名称，可以方便在后面进行引用。</p>
<p>如果设置了 <code>g</code> 标志，这时返回值与 <code>exec</code> 方法就不同了，它会将字符串中所有符合正则表达式规则的内容都匹配出来，并放入数组中，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello' ]</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">"hello helloworld"</span>;</span><br><span class="line">result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure>

<p>这时设置的捕获组的信息就提取不到了，所以从某种程度上说，<code>exec</code> 的功能比 <code>match</code> 更加的强大，不过 <code>exec</code> 并不能一次提取出字符串中所有符合规则的内容，而是需要做一个循环，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello helloworld"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 当 re.exec()不为 null 时</span></span><br><span class="line"><span class="keyword">while</span> (result = re.exec(string)) &#123;</span><br><span class="line">    results.push(result[<span class="number">0</span>]); <span class="comment">// result 中还包含了捕获组的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><p>上面使用正则表达式进行匹配都是进行精确的匹配，如 <code>/hello/</code>，匹配字符串中的 <code>hello</code> 内容，这样我们根本无法领会到正则表达式的强大，正则表达式正是强大在它模糊匹配的能力，比如我们在 <code>Windows</code> 中进行文件查找，有时我们不记得文件的具体名称，比如忘了某个字母，这个时候我们会用 <code>.</code> 去表示任意的字母去进行查找。现在我们就来讲讲正则表达式模糊匹配的能力。</p>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>在进行匹配的时候，如果我们不确定某个位置的字符是什么，我们可以使用表示特定含义的字符来占据这个位置，比如 <code>[abc]</code> 表示这个位置是 <code>a</code>，<code>b</code>，<code>c</code> 中的某个字符。如果我们想表示这个字符是小写字母，按照上面的写法，你可能会这么写 <code>[abcdefghijklmnopqrstuvwxyz]</code>，这样的写法有点反人类，我们可以使用范围表示法来代替上面的写法，如 <code>[a-z]</code> 的写法就表示所有的小写字母，同理 <code>[A-Z]</code> 就表示所有的大写字母，<code>[0-9]</code> 就表示数字，<code>[0-9a-zA-Z]</code> 表示这个位置可以是数字，小写字母，大写字母。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let re = /[a-zA-Z0-<span class="number">9</span>]/;</span><br><span class="line">console.log(re.test(<span class="string">'0'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'s'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'S'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'?'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>[]</code> 中加入 <code>^</code> 表示取反，如 <code>[^0-9]</code> 表示非数字，即它可以匹配所有的非数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/[^0-9]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"?"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用<strong>元字符</strong>来占据位置，比如 <code>\d</code> 就代表数字，它的作用与 <code>[0-9]</code> 是一样的，常见的元字符如下所示(不包含表示位置的元字符，表示位置的元字符在后面介绍)</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>表示数字</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>表示空白字符，包括空格，回车，制表符等等</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>表示数字，大小写字母和下划线，相当于 <code>[0-9a-zA-Z_]</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>表示任意一个字符</td>
</tr>
</tbody></table>
<p>来看几个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示数字</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空白字符</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\s/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示大小写字母，数字和下划线</span></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\w/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"A"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"_"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与在 <code>[]</code> 中加入 <code>^</code>表示取反，上面的元字符也有对应的元字符表示取反的概念</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\D</code></td>
<td>与 <code>\d</code> 相反，表示非数字</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>与 <code>\s</code> 相反，表示非空白字符</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>与 <code>\w</code> 相反，表示非单词</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\S/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"9"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\W/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"0"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>现在我们假设使用正则表达式去匹配电话号码，假设电话号码就是 <code>11</code> 位数字，所以写出来的正则表达式是这样的 <code>\d\d\d\d\d\d\d\d\d\d\d</code>，这种写法也相当的反人类，不仅难读(需要一个个数才知道有多少个数)，而且写起来也麻烦，我们可以使用量词来简写上面的表达式，如 <code>\d{11}</code> 就表示 <code>\d</code> 连续出现 <code>11</code> 次，常见的量词写法如下</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>{n}</code></td>
<td>表示连续出现 <code>n</code> 次</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>表示连续出现 <code>m-n</code>，最少出现 <code>m</code>，最多出现 <code>n</code> 次</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>表示连续出现最少 <code>n</code> 次(包括 <code>n</code> 次)</td>
</tr>
<tr>
<td><code>*</code></td>
<td>表示连续出现<strong>任意</strong>多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>表示连续出现 <code>1</code> 次或 <code>1</code> 次以上</td>
</tr>
<tr>
<td><code>?</code></td>
<td>表示出现 <code>0</code> 次或 <code>1</code> 次</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 5 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;5&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"123 1234 12345 654321"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12345', '65432' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 2-3 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;2,3&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12', '123', '123' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现 4 位及 4 位以上的数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4,&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234 12345"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '1234', '12345' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 可以出现任意次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab*c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ac', 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 1 次或 1 次以上</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 0 次或 1 次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab?c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re));</span><br></pre></td></tr></table></figure>

<h3 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h3><p>所谓的贪婪匹配就是尽可能的多匹配，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abbbb' ]</span></span><br></pre></td></tr></table></figure>

<p>明明匹配 <code>ab</code> 也可以，但是它会尽可能多的匹配，这就是贪婪模式，与此相对的是惰性匹配，惰性匹配就是在满足条件的情况下会尽可能的少匹配，如上例就会匹配 <code>ab</code>，在默认的情况下是贪婪匹配，要使用惰性匹配就要使用惰性量词</p>
<table>
<thead>
<tr>
<th>贪婪</th>
<th>惰性</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>+?</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>*?</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>??</code></td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td><code>{n,m}?</code></td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td><code>{n,}?</code></td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+?/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ab' ]</span></span><br></pre></td></tr></table></figure>

<p>现在考虑根据 <code>html</code> 字符串获得某 <code>id</code> 属性，如 <code>&lt;div id=&quot;container&quot; class=&quot;active&quot;&gt;&lt;/div&gt;</code>，如果我们使用贪婪匹配的话，考虑这样的匹配规则 <code>/id=&quot;.*&quot;/</code>，那么捕获到的并不是我们想要的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container" class="active"</span></span><br></pre></td></tr></table></figure>

<p>我们发现匹配到的是 <code>id=&quot;container&quot; class=&quot;active&quot;</code>，因为在贪婪模式下再符合条件的情况下会尽可能多的匹配，所以会直接匹配到最后一个双引号，解决办法有两种，其中简单的解决办法就是使用惰性匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*?"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure>

<p>另一种办法就比较 <code>trick</code>，我觉得只可意会，难以言传</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id="[^"]*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure>

<p>仔细体会上面的写法吧，我觉得很好用，比如获得某标签的标签名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/&lt;[^&gt;]*&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// &lt;div&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>有时候我们需要在多个分支之间进行选择，比如匹配十六进制表示的颜色，有两种表示，一种是 <code>#F4E242</code> 六位的，一种是简写的 <code>#FFF</code> 三位表示的，我们可以使用 <code>|</code> 来表示或的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"#FFF"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"#F34E23"</span></span><br><span class="line"><span class="built_in">console</span>.log(string1.match(regex)); <span class="comment">// [ '#FFF' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(string2.match(regex)); <span class="comment">// [ '#F34E23' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><h3 id="分组与分支"><a href="#分组与分支" class="headerlink" title="分组与分支"></a>分组与分支</h3><p>假设我们要匹配 <code>I love Java</code> 和 <code>I love C</code> 这两句话，你可能会写出这样的正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love Java|C/</span><br></pre></td></tr></table></figure>

<p>但是这个正则表达式表示的是 <code>I love Java</code> 或者 <code>C</code> 而不是 <code>I love C</code>，正确的写法应该是这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love (Java|C)/</span><br></pre></td></tr></table></figure>

<p><code>Java</code> 和 <code>C</code> 选其一。</p>
<h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>假设我们要匹配一个格式为 <code>yyyy-mm-dd</code> 格式的日期，并且希望获得年月日，那么可能会这么写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string)[<span class="number">0</span>]; <span class="comment">// 2020-05-27</span></span><br><span class="line"><span class="keyword">let</span> results = result.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + results[<span class="number">0</span>]); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + results[<span class="number">1</span>]); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + results[<span class="number">2</span>]); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure>

<p>其实我们可以通过添加括号来捕获数据，对于被括号包起来的数据，其匹配的内容会被提取出来，添加到返回的数组中，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + result[<span class="number">1</span>]); <span class="comment">// 第一个捕获组 \d&#123;4&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + result[<span class="number">2</span>]); <span class="comment">// 第二个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + result[<span class="number">3</span>]); <span class="comment">// 第三个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br></pre></td></tr></table></figure>

<p>上面我们对年月日的规则使用括号包了起来，在进行匹配时，对应被匹配到的数据会添加到数组中，在介绍 <code>exec</code> 方法时，其返回的数组，第一个元素表示匹配到的字符串，后面的元素表示捕获组(括号包起来)中捕获的内容。</p>
<h4 id="RegExp的属性-1…"><a href="#RegExp的属性-1…" class="headerlink" title="RegExp的属性$1…"></a>RegExp的属性$1…</h4><p>除了可以根据返回的数组 <code>result</code> 来得到捕获的数据，还可以通过在上面提过一嘴的 <code>RegExp</code> 构造函数的属性 <code>$1, $2, $3 ...</code> 等等来获得所捕获的内容，其中 <code>$1</code> 表示第一个捕获组所匹配的内容，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + <span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure>

<p>每次在使用正则表达式进行匹配时，<code>RegExp</code> 中的 <code>$1, $2, $3 ...</code> 也会相应的更新。</p>
<h4 id="括号嵌套"><a href="#括号嵌套" class="headerlink" title="括号嵌套"></a>括号嵌套</h4><p>现在考虑如果括号有嵌套的情况，比如上面日期格式捕获更精准的表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(\d&#123;<span class="number">4</span>&#125;)-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|([<span class="number">1</span><span class="number">-2</span>]\d)|(<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>]))/</span><br></pre></td></tr></table></figure>

<p>上面括号嵌套的很复杂，在原理上，被括号包起来的规则所匹配的内容都会被捕获，那么嵌套带来的问题就是，捕获的顺序哪个在前，哪个在后，其实也很简单，根据左括号来，比如上式中的捕获顺序为</p>
<ol>
<li><code>(\d{4})</code></li>
<li><code>((0\d)|(1[0-2]))</code></li>
<li><code>(0\d)</code></li>
<li><code>(1[0-2])</code></li>
<li><code>((0[1-9])|([1-2]\d)|(3[0-1]))</code></li>
<li><code>(0[1-9])</code></li>
<li><code>([1-2]\d)</code></li>
<li><code>(3[0-1])</code></li>
</ol>
<p>所以如果使用上面的正则表达式进行捕获得到年月日的信息，根据分析年是第一捕获组，月是第二捕获组，日是第五捕获组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">5</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>由于无用的捕获组太多，导致想要提取包含信息的捕获组获取困难，其实仔细观察，里面的大多数括号主要是为分支做准备的，对于这些捕获组，我们可以考虑不捕获，仅仅作为分支使用，我们在括号里面的前方加入 <code>?:</code> 表示该括号匹配的内容不进行捕获，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((?:0[1-9])|(?:1[0-2]))-((?:0[1-9])|(?:[1-2]\d)|(?:3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">3</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>如果作为分支的括号太多，为每一个分支添加 <code>?:</code> 也比较费力，那么可以考虑给包含信息的捕获组命名，命名的方法在上面有提到过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;(0[1-9])|(1[0-2]))-(?&lt;day&gt;(0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"><span class="keyword">let</span> groups = result.groups;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groups.year, groups.month, groups.day); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>通过给捕获组命名，可以方便的通过 <code>groups</code> 对象得到想要的数据。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>现在再次考虑匹配日期，已知下面这三种日期格式都可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-12</span></span><br><span class="line"><span class="number">2017</span> <span class="number">02</span> <span class="number">12</span></span><br><span class="line"><span class="number">2017</span>/<span class="number">02</span>/<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>所以你可能会写出这样的正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d&#123;<span class="number">4</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;/</span><br></pre></td></tr></table></figure>

<p>经过测试，发现能符合要求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是你会发现一些意外的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>前后的分隔符不一致的情况也能够匹配，而我们要求的是前后的分隔符是一样的，这个时候我们可以通过引用分组，使得前面和后面的分隔符是一样的，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;(-| |\/)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>注意到我们对于后面的分组，我们使用了 <code>\1</code> 去进行替代，<code>\1</code> 的意思就是代表引用第一个分组，这样就可以做到这个地方与前面的分组相同。同理我们也可以使用 <code>\2</code> 表示引用第二个分组(如果有的话，如果没有就单纯的表示匹配字符串 <code>&quot;\2&quot;</code>)。</p>
<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="相关元字符"><a href="#相关元字符" class="headerlink" title="相关元字符"></a>相关元字符</h3><p>正则表达式中的最后一个内容就是关于位置的匹配，与字符匹配不同，位置匹配时匹配字符间的位置，常见有关位置的元字符如下</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>开头位置</td>
</tr>
<tr>
<td><code>$</code></td>
<td>结尾位置</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>单词边界，即 <code>\w</code> 与 <code>\W</code> 之间的位置</td>
</tr>
<tr>
<td><code>(?=p)</code></td>
<td>匹配 <code>p</code> 模式前面的位置，具体见例子</td>
</tr>
<tr>
<td><code>(?&lt;=p)</code></td>
<td>匹配 <code>p</code> 模式后面的位置</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/^/</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[JS] hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/$/</span>, <span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/\b/g</span>, <span class="string">"#"</span>); <span class="comment">// \b 是 \w 与 \W 之间的位置，表示单词的边界</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [#JS#] #hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 前面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] #hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 后面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br></pre></td></tr></table></figure>

<p>同理，也有元字符表示与上面相反的意义</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\B</code></td>
<td>与 <code>\b</code> 相反，表示非单词边界</td>
</tr>
<tr>
<td><code>(?!p)</code></td>
<td>与 <code>(?=p)</code> 相反，表示不是 <code>p</code> 前面位置的所有位置</td>
</tr>
<tr>
<td><code>(?&lt;!p)</code></td>
<td>与 <code>(?&lt;=p)</code> 相反，表示不是 <code>p</code> 后面位置的所有位置</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/\B/g</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[J#S]# h#e#l#l#o</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 前面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# h#e#l#l#o#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 后面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# #h#e#l#l#o</span></span><br></pre></td></tr></table></figure>

<h3 id="千位分隔符案例"><a href="#千位分隔符案例" class="headerlink" title="千位分隔符案例"></a>千位分隔符案例</h3><p>现在来做一个案例，将数字转化为千位分隔符表示法，如 <code>12345678</code> 转化为 <code>12,345,678</code>，我们首先找到后三位数字的前面位置，然后添加逗号，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 12345,678</span></span><br></pre></td></tr></table></figure>

<p>进一步弄出所有的逗号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>); <span class="comment">// 12,345,678</span></span><br></pre></td></tr></table></figure>

<p>但是还是有一个小小问题，测试的数字个数是三的倍数的时候，在开头也会添加一个逗号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"123456789"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// ,123,456,789</span></span><br></pre></td></tr></table></figure>

<p>我们可以修改正则表达式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(?!^)(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br></pre></td></tr></table></figure>

<p>其中 <code>(?!^)</code> 表示不是开头的位置。如果希望支持更多的格式，比如 <code>1234567 12345678</code> 转换为 <code>1,234,567 12,345,678</code>，只要将上面的表达式中的开头，结尾替换为 <code>\b</code> 即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"1234567 12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(?!\b)(\d&#123;3&#125;)+\b)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1,234,567 12,345,678</span></span><br></pre></td></tr></table></figure>

<p>考虑到 <code>(?!\b)</code> 就相当于 <code>\B</code>，所以上面的表达式也可简写如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(?=\B(\d&#123;<span class="number">3</span>&#125;)+\b)/g</span><br></pre></td></tr></table></figure>

<h3 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h3><p>正则表达式有三个常见的标志，分别为全局模式 <code>g</code>，表示进行全局匹配，如果不设置该标志，那么只会匹配一次，如果字符串后面还要符合规则的字符串，是不会被匹配的，对于 <code>exec()</code> 方法，非全局模式下不会更改 <code>lastIndex</code>，即 <code>lastIndex</code> 始终是 <code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非全局替换 只会替换匹配到的第一个 hello</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re1, <span class="string">"#"</span>)); <span class="comment">// # hello</span></span><br><span class="line"><span class="comment">// 全局替换 字符串中所以的 hello 都会被替换</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re2, <span class="string">"#"</span>)); <span class="comment">// # #</span></span><br></pre></td></tr></table></figure>

<p>第二标志 <code>i</code> 很好理解，即忽略大小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(string)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(string)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第三个标志 <code>m</code> 表示多行模式，它只会影响 <code>^,$</code>，如果不是多行模式，那么 <code>^, $</code> 就表示字符串的开头和结尾，如果是多行模式，那么 <code>^,$</code> 就表示每一行的开头和结尾。</p>
<p>非多行模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 非多行 ^,$ 表示字符串的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/g</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#I </span></span><br><span class="line"><span class="attribute">love</span> </span><br><span class="line">java<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>多行模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 多行模式 ^,$ 表示每一行的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/gm</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#I #</span><br><span class="line">#love #</span><br><span class="line">#java#</span><br></pre></td></tr></table></figure>







</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript 正则表达式</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="https://lastknightcoder.gitee.io/img/wechatpay.png" title="微信"><img src="https://lastknightcoder.gitee.io/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2019 - 2020 熊滔</div></footer>
<script src="https://lastknightcoder.gitee.io/js/scroller.js"></script>

<script src="https://lastknightcoder.gitee.io/js/main.js"></script>
</body></html>