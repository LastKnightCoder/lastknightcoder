<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring常见注解 | Coder</title><meta name="description" content="Spring常见注解"><meta name="keywords" content="Java Spring 注解开发"><meta name="author" content="熊滔"><meta name="copyright" content="熊滔"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://lastknightcoder.gitee.io/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring常见注解"><meta name="twitter:description" content="Spring常见注解"><meta name="twitter:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522214503.png"><meta property="og:type" content="article"><meta property="og:title" content="Spring常见注解"><meta property="og:url" content="https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"><meta property="og:site_name" content="Coder"><meta property="og:description" content="Spring常见注解"><meta property="og:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522214503.png"><meta property="article:published_time" content="2020-05-21T16:00:00.000Z"><meta property="article:modified_time" content="2020-05-21T16:00:00.000Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"><link rel="next" title="Ajax跨域" href="https://lastknightcoder.gitee.io/Ajax%E8%B7%A8%E5%9F%9F/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: 'https://lastknightcoder.gitee.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lastknightcoder.gitee.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="https://lastknightcoder.gitee.io/atom.xml" title="Coder" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://lastknightcoder.gitee.io/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="https://lastknightcoder.gitee.io/archives/"><div class="headline">文章</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="https://lastknightcoder.gitee.io/tags/"><div class="headline">标签</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="https://lastknightcoder.gitee.io/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC简要介绍"><span class="toc-number">1.</span> <span class="toc-text">IoC简要介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuration"><span class="toc-number">2.</span> <span class="toc-text">@Configuration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ComponentScan"><span class="toc-number">3.</span> <span class="toc-text">@ComponentScan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#value和basepackages"><span class="toc-number">3.1.</span> <span class="toc-text">value和basepackages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#basePackageClasses"><span class="toc-number">3.2.</span> <span class="toc-text">basePackageClasses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nameGenerator"><span class="toc-number">3.3.</span> <span class="toc-text">nameGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useDefaultFilters"><span class="toc-number">3.4.</span> <span class="toc-text">useDefaultFilters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#includeFilters"><span class="toc-number">3.5.</span> <span class="toc-text">includeFilters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#excludeFilters"><span class="toc-number">3.6.</span> <span class="toc-text">excludeFilters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean"><span class="toc-number">4.</span> <span class="toc-text">@Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#name和value"><span class="toc-number">4.1.</span> <span class="toc-text">name和value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autowireCandidate"><span class="toc-number">4.2.</span> <span class="toc-text">autowireCandidate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Import"><span class="toc-number">5.</span> <span class="toc-text">@Import</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ImportSelector"><span class="toc-number">5.1.</span> <span class="toc-text">ImportSelector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ImportBeanDefinitionRegistrar"><span class="toc-number">5.2.</span> <span class="toc-text">ImportBeanDefinitionRegistrar</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PropertySource"><span class="toc-number">6.</span> <span class="toc-text">@PropertySource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DependsOn"><span class="toc-number">7.</span> <span class="toc-text">@DependsOn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lazy"><span class="toc-number">8.</span> <span class="toc-text">@Lazy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conditional"><span class="toc-number">9.</span> <span class="toc-text">@Conditional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile"><span class="toc-number">10.</span> <span class="toc-text">@Profile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动注入"><span class="toc-number">11.</span> <span class="toc-text">自动注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired和-Qualifier"><span class="toc-number">11.1.</span> <span class="toc-text">@Autowired和@Qualifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inject和-Named"><span class="toc-number">11.2.</span> <span class="toc-text">@Inject和@Named</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource"><span class="toc-number">11.3.</span> <span class="toc-text">@Resource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Primary"><span class="toc-number">12.</span> <span class="toc-text">@Primary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostConstruct和-PreDestroy"><span class="toc-number">13.</span> <span class="toc-text">@PostConstruct和@PreDestroy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">14.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522214503.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="https://lastknightcoder.gitee.io/">Coder</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="https://lastknightcoder.gitee.io/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Spring常见注解</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-22 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-22 00:00:00"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="https://lastknightcoder.gitee.io/categories/Java/Web/">Web</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>介绍 <code>Spring</code> 框架中的常见注解(<strong><code>NO XML</code></strong>)，在介绍 <code>Spring</code> 注解之前，简要的介绍一下 <code>IoC</code>。</p>
<h2 id="IoC简要介绍"><a href="#IoC简要介绍" class="headerlink" title="IoC简要介绍"></a>IoC简要介绍</h2><p><code>IoC(Inverse of Control)</code> 的意思是控制反转，意思就是控制权发生转换，以前我们需要某个类的对象，都是直接 <code>new</code> 出来的，现在有了<code>IoC</code>，对象创建的控制权交给 <code>Spring</code>，如果我们需要某个对象，向 <code>IoC</code> 容器拿，如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/IoC202005201751.png" width="60%"/>

<p>上面将 <code>Dog</code> 类对象放入容器的过程我们成为<strong>注入</strong>，容器我们一般称为 <code>IoC</code> 容器或者 <code>Spring</code> 容器。上面做的好处可以减少类与类之间的耦合性，耦合性这个词可能高大尚，我举个例子，比如 <code>Dog</code> 类发生了改变，高耦合性意味着如果有类依赖 <code>Dog</code> 类的话，那么相应的该类有可能也要发生改变，如果耦合度低的话，也就是根本察觉不到自己依赖了 <code>Dog</code> 类，根本就不需要改变。</p>
<p>我们在像容器要某个对象时，察觉不到某个类的所在(因为一般使用接口去接收从容器中拿的对象)，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal = ioc.getObject(<span class="string">'dog'</span>);</span><br></pre></td></tr></table></figure>

<p>假设 <code>Dog</code> 实现了 <code>Animal</code> 接口，<code>ioc</code> 对象表示 <code>IoC</code> 容器，<code>getObject()</code> 表示从容器中获得对象的方法，而传入的参数表示对象在容器中的 <code>id</code>。如果 <code>Dog</code> 类发生改变(但是他在容器中的 <code>id</code> 是不会变的)，我们获取 <code>Dog</code> 对象的方式还是和上面一样，不需要发生改变。假设如果是直接 <code>new Dog()</code> 的话，如果 <code>Dog</code> 的类名变了，那么所有直接依赖 <code>Dog</code> 类的所有类都要发生改变，这就是低耦合的好处。</p>
<blockquote>
<p><strong>注意</strong>：要使用 <code>Spring IoC</code>，记得在 <code>pom.xml(Maven)</code> 中导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p><code>@Configuration</code> 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(</span><br><span class="line">        annotation = Component<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    )</span></span><br><span class="line">    String value() default "";</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 <code>@Configuration</code> 修饰的类是 <code>Spring</code> 的配置类，所谓的配置类就是用来配置用的，可以配置扫描哪些包，将这些包下的类注入到 <code>IoC</code> 容器中，也可以配置将特定的类注入到 <code>IoC</code> 容器中。</p>
<p>被 <code>@Configuration</code> 修饰的类也会被注入到 <code>IoC</code> 容器中，<code>@Configuration</code> 有一个 <code>value</code> 值，它是用来设置该类对象在 <code>IoC</code> 容器中的 <code>id</code>，如果不设置，那么默认是类名，不过首字母要改为小写，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SpringConfiguration</code> 是 <code>Spring</code> 的配置类，由于 <code>@Configuration</code> 没有配置<code>id</code>，所以它在 <code>IoC</code> 容器中的 <code>id</code> 为 <code>springConfiguration</code>，我们可以在测试类中测试，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        SpringConfiguration springConfiguration = ac.getBean(<span class="string">"springConfiguration"</span>, SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(springConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AnnotationConfigApplicationContext</code> 可以看做是 <code>IoC</code> 容器，我们传入配置类所在的包 <code>config</code> 给它，它会扫描该包找到配置类，然后根据配置类为容器注入对象，在上面我们在配置类中什么都没有做，所以不会向 <code>IoC</code> 容器注入别的对象。</p>
<p>接着我们通过获得对象的方法 <code>getBean()</code> 获得了配置类 <code>SpringConfiguration</code> 的对象，该方法需要传入在 <code>IoC</code> 容器中的 <code>id</code>，因为没有指定，默认是 <code>springConfiguration</code>。</p>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p><code>@ComponentScan</code> 注解的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(ComponentScans<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ComponentScan</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() <span class="keyword">default</span> AnnotationScopeMetadataResolver<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedProxyMode <span class="title">scopedProxy</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">resourcePattern</span><span class="params">()</span> <span class="keyword">default</span> "**<span class="comment">/*.class";</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    boolean useDefaultFilters() default true;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    ComponentScan.Filter[] includeFilters() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    ComponentScan.Filter[] excludeFilters() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    boolean lazyInit() default false;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    @Retention(RetentionPolicy.RUNTIME)</span></span></span><br><span class="line"><span class="function"><span class="comment">    @Target(&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="comment">    public @interface Filter &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        FilterType type() default FilterType.ANNOTATION;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">        @AliasFor("classes")</span></span></span><br><span class="line"><span class="function"><span class="comment">        Class&lt;?&gt;[] value() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">        @AliasFor("value")</span></span></span><br><span class="line"><span class="function"><span class="comment">        Class&lt;?&gt;[] classes() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">        String[] pattern() default &#123;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>该注解的作用是扫描包或者类，将扫描到类注入到 <code>IoC</code> 容器中。由上面可见，该类的属性还是挺多的，这里介绍几个重要的属性。</p>
<h3 id="value和basepackages"><a href="#value和basepackages" class="headerlink" title="value和basepackages"></a>value和basepackages</h3><p>这两个属性放在一起讲是因为他们互为别名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>它们的作用是一样的，规定要扫描哪些包，从定义看，它们的值都是字符串数组，我们在 <code>com.xt.service</code> 下定义 <code>ServiceTest</code> 类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Spring</code> 的配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.xt.service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在配置类中规定了要扫描的包为<code>com.xt.service</code>，接着我们在测试类中测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.ServiceTest;</span><br><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        ServiceTest serviceTest = ac.getBean(<span class="string">"serviceTest"</span>, ServiceTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        serviceTest.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是却发生异常，在容器中没有名为 <code>serviceTest</code> 的对象</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520180852.png"/>

<p>这是因为即使扫描了 <code>ServiceTest</code> 所在的包，但并不是该包下所有的类都会被注入到容器中，而是被 <code>@Component</code> 注解所修饰的类才会被注入到容器中，所以我们要为 <code>ServiceTest</code> 加上 <code>@Component</code> 注解，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行测试类，结果如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520181342.png" width="40%"/>

<blockquote>
<p>注意：<code>@Component</code> 还有几个衍生注解，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，这些注解的作用与 <code>@Component</code> 一毛一样，那为什么要创建这些注解，主要是他们所代表的的语义，<code>@Controller</code> 主要用在 <code>Web</code> 层的类上，<code>@Service</code> 主要用在 <code>Service</code> 层上，而 <code>@Repository</code> 主要用在 <code>Dao</code> 层上，程序员看到某类被什么注解修饰，就可以明白该类的职责是什么了。</p>
</blockquote>
<p>如果 <code>@ComponentScan</code> 没有指定任何值，那么默认会扫描该类所在的包及其子包，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ComponentScan</code> 没有指定任何值，那么就会默认扫描 <code>config</code> 包下的类及其子包下的类。</p>
<h3 id="basePackageClasses"><a href="#basePackageClasses" class="headerlink" title="basePackageClasses"></a>basePackageClasses</h3><p><code>basePackageClasses</code> 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>该属性的值是一个字节码数组，当设置指定字节码时，会扫描指定字节码所在包及其子包，假设有如下结构</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215316.png" width="30%"/>

<p><code>UserServiceImpl</code> 实现了 <code>UserService</code> 接口，二者内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Spring</code> 的配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses = UserService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们配置 <code>basePackageClasses</code> 为 <code>UserService.class</code>，所以会扫描 ``UserService<code>所在的包及其子包，所以</code>UserServiceImpl` 会被注入到容器中，我们在测试类中测试如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        UserService userService = ac.getBean(<span class="string">"userServiceImpl"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.doService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/>

<h3 id="nameGenerator"><a href="#nameGenerator" class="headerlink" title="nameGenerator"></a>nameGenerator</h3><p>该属性的作用是设置注入到容器中的对象(我们一般称这个对象为 <code>bean</code>)的 <code>id</code> 名称的生成规则，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>在上面我们可以看到，默认使用了 <code>BeanNameGenerator</code> 这个类去生成 <code>id</code> 的名称，而生成的规则在上面介绍过，即 <code>id</code> 为类名，不过首字母要小写， <code>Spring</code> 中的有关默认 <code>id</code> 名称生成的部分源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decapitalize</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; <span class="number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="number">1</span>)) &amp;&amp;</span><br><span class="line">                    Character.isUpperCase(name.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chars[] = name.toCharArray();</span><br><span class="line">    chars[<span class="number">0</span>] = Character.toLowerCase(chars[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，如果对于第一个字母和第二个字母都为大写的这种特殊的类名是不会将首字母变为小写的。</p>
<p>除了可以使用默认的生成规则，我们还可以自己自定义 <code>id</code> 的生成规则，在 <code>custom</code> 包下新建 <code>CustomBeanNameGenerator</code> 类，该类的作用就是 <code>id</code> 名称的生成规则，该类需要实现 <code>BeanNameGenerator</code> 接口，详细如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanNameGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        String beanName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 判断该类是否是由注解注入的</span></span><br><span class="line">        <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// 如果是强转为 AnnotatedBeanDefinition 以获得有关注解的信息</span></span><br><span class="line">            AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition;</span><br><span class="line">            <span class="comment">// 获得注解的信息</span></span><br><span class="line">            AnnotationMetadata annotationMetadata = annotatedBeanDefinition.getMetadata();</span><br><span class="line">            <span class="comment">// 获得所有注解</span></span><br><span class="line">            Set&lt;String&gt; types = annotationMetadata.getAnnotationTypes();</span><br><span class="line">            <span class="comment">// 遍历所有注解</span></span><br><span class="line">            <span class="keyword">for</span> (String type: types) &#123;</span><br><span class="line">                <span class="comment">// 获得注解的属性</span></span><br><span class="line">                AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(annotationMetadata.getAnnotationAttributes(type, <span class="keyword">false</span>));</span><br><span class="line">                <span class="comment">// 如果该注解为Component或其衍生注解(暂不考虑 JSR 规范，如 @Resource)且value属性有值</span></span><br><span class="line">                <span class="comment">// 并且 annotationAttributes 不为null</span></span><br><span class="line">                <span class="keyword">if</span> (annotationAttributes != <span class="keyword">null</span> &amp;&amp; isStereotypeWithNameValue(type, annotationMetadata.getMetaAnnotationTypes(type), annotationAttributes)) &#123;</span><br><span class="line">                    <span class="comment">// 获得 value 属性的值</span></span><br><span class="line">                    Object value = annotationAttributes.get(<span class="string">"value"</span>);</span><br><span class="line">                    <span class="comment">// 如果value为String，则强转</span></span><br><span class="line">                    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                        String strValue = (String) value;</span><br><span class="line">                        <span class="comment">// value 值长度不为 0</span></span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.hasLength(strValue)) &#123;</span><br><span class="line">                            <span class="comment">// 如果 beanName 有值，说明已经设置过了 此时 value 与 beanName 不同，说明产生了冲突，抛出异常</span></span><br><span class="line">                            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strValue.equals(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"多个注解设置了value，产生了冲突"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                beanName = strValue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 没有 Component 及其衍生注解或者没有设置 value 值，则采用默认自定义的类名生成规则</span></span><br><span class="line">        <span class="keyword">return</span> beanName != <span class="keyword">null</span> ? beanName : buildDefaultBeanName(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该注解是否是Component及其衍生注解 并且有 value 属性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType, Set&lt;String&gt; metaAnnotationTypes, @Nullable Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isStereotype = annotationType.equals(<span class="string">"org.springframework.stereotype.Component"</span>) || metaAnnotationTypes.contains(<span class="string">"org.springframework.stereotype.Component"</span>) || annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) || annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">        <span class="keyword">return</span> isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 bean id 生成</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得全限定类名，如com.xt.service.impl.UserServiceImpl</span></span><br><span class="line">        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">        <span class="comment">// 获得类名 如UserServiceImpl</span></span><br><span class="line">        String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">        <span class="comment">// 默认生成规则为 my + 类名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"my"</span> + shortClassName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>id</code> 生成规则为如果 <code>@Component</code> 及其衍生注解设置了 <code>id</code> 名称，则使用设置的名称，否则默认的 <code>id</code> 名称为 <code>my +</code> 类名。现在将 <code>SpringConfiguration</code> 的 <code>@ComponentScan</code> 的 <code>nameGenerator</code> 设置为 <code>CustomBeanNameGenerator.class</code>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> custom.CustomBeanNameGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(nameGenerator = CustomBeanNameGenerator<span class="class">.<span class="keyword">class</span>, <span class="title">basePackages</span> </span>= <span class="string">"com.xt.service.impl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserServiceImpl</code> 的内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见使用 <code>@Service</code> 修饰了，但是没用设置 <code>value</code> 值，所以默认生成的 <code>id</code> 是 <code>myUserServiceImpl</code>，在测试类中测试如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line">        <span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        <span class="comment">// id 已经改为了 myUserServiceImpl</span></span><br><span class="line">        UserService userService = ac.getBean(<span class="string">"myUserServiceImpl"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.doService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/>

<p>可见我们的自定义 <code>id</code> 生成规则生效了，现在修改 <code>UserServiceImpl</code> 如下，这次设置 <code>id</code> 值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们的规则，这时的 <code>id</code> 名为设定的值，即 <code>userService</code>，修改测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService userService = ac.getBean(<span class="string">"userService"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/>

<p>在此修改 <code>UserServiceImpl</code>，这次使用多个注解修饰，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"userServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，这时会抛出异常，如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520233312.png"/>

<h3 id="useDefaultFilters"><a href="#useDefaultFilters" class="headerlink" title="useDefaultFilters"></a>useDefaultFilters</h3><p>在 <code>@ComponentScan</code> 中有一个属性 <code>useDefaultFilters</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">useDefaultFilters</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br></pre></td></tr></table></figure>

<p>它的值默认为 <code>true</code>，即如果被扫描的类被 <code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>这四个注解修饰时，那么将该类对象注入到容器中，如果为 <code>false</code>，那么被这四个注解修饰的类</p>
<h3 id="includeFilters"><a href="#includeFilters" class="headerlink" title="includeFilters"></a>includeFilters</h3><p><code>includeFilters</code> 属性的作用是允许符合过滤规则的类对象注入到容器中，它的值是一个 <code>Filter</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Filter &#123;</span><br><span class="line">    <span class="function">FilterType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FilterType.ANNOTATION</span>;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"classes"</span>)</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] pattern() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解有一个 <code>type</code> 属性，它的默认取值为 <code>FilterType.ANNOTATION</code>，表示过滤的规则为注解，如果我们设置 <code>value</code> 属性为某注解的字节码对象，那么被该注解修饰的类对象可以注入到容器中，比如允许自定义 <code>@MyAnno</code> 注解所修饰的类注入到容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(includeFilters = <span class="meta">@ComponentScan</span>.Filter(MyAnno<span class="class">.<span class="keyword">class</span>))</span></span><br></pre></td></tr></table></figure>

<p>在扫描的类中，如果该类被自定义注解 <code>@MyAnno</code> 修饰，那么该类对象会被注入到容器中。</p>
<h3 id="excludeFilters"><a href="#excludeFilters" class="headerlink" title="excludeFilters"></a>excludeFilters</h3><p>与 <code>includeFilters</code> 的作用相反，对于符合过滤规则的类对象不能被注入到容器中，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = <span class="meta">@ComponentScan</span>.Filter(Service<span class="class">.<span class="keyword">class</span>))</span></span><br></pre></td></tr></table></figure>

<p>上面的注解的作用是，扫描到的类如果被 <code>@Service</code> 修饰，那么该类对象不能被加入到容器中。</p>
<p>在上面我们知道 <code>Filter</code> 注解中，它的 <code>type</code> 属性为 <code>FilterType.ANNOTATION</code>，即被某注解修饰，他会(<code>includeFilters</code>)/不可以(<code>excludeFilters</code>)加入到容器中，其实 <code>type</code> 还可以有多种取值，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FilterType &#123;</span><br><span class="line">    ANNOTATION,</span><br><span class="line">    ASSIGNABLE_TYPE,</span><br><span class="line">    ASPECTJ,</span><br><span class="line">    REGEX,</span><br><span class="line">    CUSTOM;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们在介绍 <code>FilterType.CUSTOM</code>，这表示我们可以自定义过滤规则，定义过滤规则的类需要实现 <code>TypeFilter</code> 接口。在 <code>custom</code> 中新建 <code>CustomFilter</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> custom.CustomFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">        basePackages = <span class="string">"com.xt.service"</span>, </span><br><span class="line">        includeFilters = </span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(</span><br><span class="line">                type = FilterType.CUSTOM, </span><br><span class="line">                classes = CustomFilter<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">        )</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>CustomFilter</code> 实现的 <code>match</code> 始终返回 <code>true</code>，所以被扫描到的类对象会被无条件的注入到容器中，我们修改 <code>com.xt.service.impl.UserServiceImpl</code> 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xt.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类没有被任何注解修饰，就是一个普通的类，但是它的对象还是会注入到容器中，测试类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xt.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        UserService userService = ac.getBean(<span class="string">"userServiceImpl"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.doService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200520215806.png" width="30%"/>

<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>对于我们自己写的类，我们可以通过 <code>@Component</code> 及其衍生注解，使得被扫描到时被注入到容器中，但是对于第三方的类库，由于已经被编译为了字节码，我们已经无法修改，即不能再别人的源码上加上注解，那么我们如果想将第三方类库对象注入到容器，我们该怎么办呢，使用 <code>@Bean</code> 可以解决这个问题。<code>@Bean</code> 的定义为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">Autowire <span class="title">autowire</span><span class="params">()</span> <span class="keyword">default</span> Autowire.NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> "<span class="params">(inferred)</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以数据源对象 <code>DataSource</code> 对象为例，首先导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在扫描配置类时，会扫描配置类中被 <code>@Bean</code> 注解的方法，会将该方法返回的对象注入到容器中，这是默认的 <code>id</code> 名称为<strong>方法名</strong>。测试类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        DataSource dataSource = ac.getBean(<span class="string">"createDataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521154944.png" width="70%"/>

<p>可见容器中有 <code>DataSource</code> 对象了。</p>
<blockquote>
<p>如果被 <code>@Bean</code> 注解的方法重载了的话，那么会将重载的方法返回的对象注入容器，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无参函数"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参函数"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个 <code>createJdbcTemplate</code> 方法，根据上面所说，重载的方法，即下面那个有参数的函数返回的对象会被注入到容器中，可以在测试类中测试如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        JdbcTemplate jdbcTemplate = ac.getBean(<span class="string">"createJdbcTemplate"</span>, JdbcTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521163655.png" width="50%"/>
</blockquote>
<h3 id="name和value"><a href="#name和value" class="headerlink" title="name和value"></a>name和value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>按照上面的定义，<code>name</code> 和 <code>value</code> 互为别名，它们的作用就是设置注入到容器对象的 <code>id</code> 名称。</p>
<h3 id="autowireCandidate"><a href="#autowireCandidate" class="headerlink" title="autowireCandidate"></a>autowireCandidate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br></pre></td></tr></table></figure>

<p>该属性的作用与 <code>@Autowired</code> 有关，当我们使用 <code>@Autowired</code> 自动注入时，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>

<p>容器会将其中的 <code>dataSource</code> 对象注入到成员变量中，但是如果 <code>autowireCandidate</code> 设置为 <code>false</code>，那么该对象就不能使用 <code>@Autowired</code> 自动注入，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(autowireCandidate = <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时就不能将 <code>dataSource</code> 对象通过 <code>@Autowired</code> 注解自动注入到成员变量 <code>dataSource</code> 中，再次运行测试代码，会抛出异常。</p>
<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>在实际的开发中，可能有多个配置类，比如数据库的配置类，那么主配置类就要导入数据库配置类的配置，这时就需要用到 <code>@Import</code> 注解。<code>@Import</code> 注解的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Import</code> 注解的作用是导入 <code>value</code> 属性所指明的类，将这些类对象注入到容器中，如有下面的数据库配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(@Autowired DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在主配置类中导入该配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(JdbcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在导入 <code>JdbcConfiguration</code> 时，会扫描 <code>JdbcConfiguration</code> 中的方法，将被 <code>@Bean</code> 注解的方法返回的对象注入到容器中，所以这时 <code>DataSource</code> 对象和 <code>JdbcTemplate</code> 对象会被注入到容器中，在测试类测试如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        DataSource dataSource = ac.getBean(<span class="string">"dataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        JdbcTemplate jdbcTemplate = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">assert</span> dataSource != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">assert</span> jdbcTemplate != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类顺利运行，没有报错</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521171027.png" width="40%"/>

<blockquote>
<p><code>JdbcConfiguration</code> 它也会被注入容器中，这时它的 <code>id</code> 为它的全限定类名，而不是类名首字母小写，即<code>config.JdbcConfiguration</code></p>
</blockquote>
<h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>当我们需要动态的决定导入哪些类时，或者需要大量导入类时，我们可以为 <code>@Import</code> 传入自定义导入类，该类需要实现 <code>ImportSelector</code> 接口。该接口中有一个方法 <code>String[] selectImports(AnnotationMetadata annotationMetadata)</code>，该方法返回一个字符串数组，这个数组包含的是要添加到容器中的类名。</p>
<p>因为我们过滤规则使用 <code>AspectJ</code> 表达式，所以需要导入相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在我们完成这么一个功能，读取配置文件中的过滤规则和要扫描的包，将扫描包中符合过滤规则的类对象添加到容器中，在 <code>resources</code> 下新建 <code>customImport.properties</code> 如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.expression</span>=<span class="string">com.xt.service.impl.*</span></span><br><span class="line"><span class="meta">custom.basePackage</span>=<span class="string">com.xt</span></span><br></pre></td></tr></table></figure>

<p>过滤规则使用 <code>ASPECTJ</code> 格式的过滤规则，扫描的包为 <code>com.xt</code>，新建类 <code>custom.CustomImport</code> 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.AspectJTypeFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImport</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 AspectJ 表达式表示过滤规则</span></span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line">    <span class="comment">// 扫描的包</span></span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件 初始化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据配置文件获得过滤规则和扫描的包</span></span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadAllProperties(<span class="string">"customImport.properties"</span>);</span><br><span class="line">            expression = properties.getProperty(<span class="string">"custom.expression"</span>);</span><br><span class="line">            basePackage = properties.getProperty(<span class="string">"custom.basePackage"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner = <span class="keyword">new</span> ClassPathScanningCandidateComponentProvider(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 根据 aspectj 表达式转换为对应的过滤器</span></span><br><span class="line">        TypeFilter typeFilter = <span class="keyword">new</span> AspectJTypeFilter(expression, CustomImport<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="comment">// 将过滤器添加到扫描器中</span></span><br><span class="line">        scanner.addIncludeFilter(typeFilter);</span><br><span class="line">        <span class="comment">// 创建 Set 集合保存扫描到的符合过滤规则的类</span></span><br><span class="line">        Set&lt;String&gt; classes = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 使用过滤器扫描指定包，得到符合过滤规则的类 并添加到 classes 中</span></span><br><span class="line">        scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName()));</span><br><span class="line">        <span class="comment">// 将 classes 转换为字符串数组返回</span></span><br><span class="line">        <span class="keyword">return</span> classes.toArray(<span class="keyword">new</span> String[classes.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521205507.png" width="25%"/>

<p>根据上面的过滤规则，只有 <code>UserServiceImpl</code> 会被添加到容器中(除配置类)，在测试类中测试一番</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String[] names = ac.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name: names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类是获得容器所有对象的 <code>id</code>，并打印出来，如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521205739.png" width="70%"/>

<p>除了前面五个做初始化工作的对象以及配置类对象，只有 <code>UserServiceImpl</code> 被添加到容器中，这次我们修改过滤规则为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">custom.expression=com.xt..*</span><br><span class="line">custom.basePackage=com.xt</span><br></pre></td></tr></table></figure>

<p><code>Aspectj</code> 表达式为将 <code>com.xt</code> 包及其子孙包下的所有类都添加到容器中，再次运算测试类，输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521210557.png" width="85%"/>

<p>这时 <code>com.xt.utils.Logger</code> 对象也被添加到容器中了。</p>
<blockquote>
<p>注意：上面的 <code>UserServiceImpl</code> 和 <code>Logger</code> 都没有使用任何注解进行修饰，就是一个普通的 <code>Java</code> 类。</p>
</blockquote>
<h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p><code>ImportBeanDefinitionRegistrar</code> 的功能同 <code>ImportSelector</code>，不过二者的返回值不同，<code>ImportSelector</code> 返回一个要添加到容器中类名名称组成的数组，而 <code>ImportBeanDefinitionRegistrar</code> 什么都不返回，说明在 <code>ImportBeanDefinitionRegistrar</code> 内部已经将扫描包下符合规则的类添加到容器中去了。现在我们要实现与上面相同的功能，新建 <code>custom.CustomImportBeanDefinitionRegistrar</code>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.AspectJTypeFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomImportBeanDefinitionRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadAllProperties(<span class="string">"customImport.properties"</span>);</span><br><span class="line">            expression = properties.getProperty(<span class="string">"custom.expression"</span>);</span><br><span class="line">            basePackage = properties.getProperty(<span class="string">"custom.basePackage"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到扫描器</span></span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(registry, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 得到过滤器</span></span><br><span class="line">        TypeFilter typeFilter = <span class="keyword">new</span> AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        scanner.addIncludeFilter(typeFilter);</span><br><span class="line">        <span class="comment">// 扫描指定包 将符合过滤规则的类对象直接注入到容器中</span></span><br><span class="line">        scanner.scan(basePackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的大部分工作与 <code>CustomImport</code> 是一样的，就是最后使用了 <code>ClassPathBeanDefinitionScanner</code> 对象直接扫描包，将符合过滤规则的类对象注入到容器中。配置文件和配置类如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.expression</span>=<span class="string">com.xt..*</span></span><br><span class="line"><span class="meta">custom.basePackage</span>=<span class="string">com.xt</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> custom.CustomImportBeanDefinitionRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(CustomImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类与上面相同，运行测试类，结果如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200521213142.png" width="70%"/>

<p>与 <code>ImportSelector</code> 实现的效果相同，不过有一点不同的是，<code>ImportSelector</code> 的 <code>id</code> 生成规则为<strong>全限定类名</strong>，而 <code>ImportBeanDefinitionRegistrar</code> 的 <code>id</code> 为<strong>类名首字母小写</strong>。</p>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p><code>@PropertySource</code> 注解的作用是用来读取资源文件，该注解的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(PropertySources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">PropertySource</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他不仅可以读取 <code>properties</code> 文件，还可以读取 <code>xml</code> 文件，甚至可以通过自定义 <code>yml</code> 文件解析器读取 <code>yml</code> 文件。</p>
<p>主配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbc.properties"</span>)</span><br><span class="line"><span class="meta">@Import</span>(&#123;JdbcConfig<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主配置类中读取了配置文件 <code>jdbc.properties</code>，配置文件和 <code>JDBC</code> 配置类 <code>JdbcConfig</code> 如下所示</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/sb</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(@Autowired DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将通过 <code>PropertySource</code> 读取到的资源，通过 <code>@Value</code> 注解，以 <code>Spring EL</code> 表达式的形式注入到了成员变量中。同时也可以读取 <code>xml</code> 文件，我们新建 <code>jdbc.xml</code>， 内容如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM <span class="string">"http://java.sun.com/dtd/properties.dtd"</span>&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;entry key="jdbc.driver"&gt;com.mysql.jdbc.Driver&lt;/entry&gt;</span><br><span class="line">    &lt;entry key=<span class="string">"jdbc.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:3306/sb&lt;/entry&gt;</span></span><br><span class="line">    &lt;entry key="jdbc.username"&gt;root&lt;/entry&gt;</span><br><span class="line">    &lt;entry key="jdbc.password"&gt;root&lt;/entry&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<p>修改 <code>@PropertySource</code> 的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbc.xml"</span>)</span><br></pre></td></tr></table></figure>

<p>由上面可以看出，<code>xml</code> 文件相对于 <code>properties</code> 有更加明显的层级关系，结构比较清楚，但是这种优点的代价就是冗余性性很高，为了表达真正有用的信息，加入很多无用的内容。为了整合 <code>properties</code> 和 <code>xml</code> 的优点，人们提出了一个新的格式的文件 <code>YAML</code>(文件后缀名为<code>.yml</code>)，它不仅书写简单，并且可以表达层级关系，新建 <code>jdbc.yml</code> 如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">com.mysql.jdbc.driver</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sb</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>但是 <code>@PropertySource</code> 默认只支持 <code>propeties</code> 和 <code>xml</code> 文件的读取，如果要支持 <code>yml</code> 文件的读取，就需要自己定义解析类，我们可以借助第三方的类库来解析 <code>yml</code> 文件，在 <code>pom.xml</code> 中导入解析 <code>yml</code> 类库的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在配置类中修改如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"jdbc.yml"</span>, factory = CustomYAMLPropertySourceFactory<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<p>新建 <code>custom.CustomYAMLPropertySourceFactory</code> 实现 <code>PropertySourceFactory</code> 接口，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertiesPropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.EncodedResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomYAMLPropertySourceFactory</span> <span class="keyword">implements</span> <span class="title">PropertySourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource encodedResource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean factoryBean = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        <span class="comment">// 解析 yaml 文件</span></span><br><span class="line">        factoryBean.setResources(encodedResource.getResource());</span><br><span class="line">        <span class="comment">// 将解析的文件转换为 properties</span></span><br><span class="line">        Properties properties = factoryBean.getObject();</span><br><span class="line">        <span class="comment">// spring 默认能解析 properties，使用 spring 源码的类去解析</span></span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? <span class="keyword">new</span> PropertiesPropertySource(name, properties) : <span class="keyword">new</span> PropertiesPropertySource(encodedResource.getResource().getFilename() ,properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DependsOn"><a href="#DependsOn" class="headerlink" title="@DependsOn"></a>@DependsOn</h2><p>有的时候一个 <code>Bean</code> 对象需要在另一个 <code>Bean</code> 对象注入到容器之后才能注入到容器，比如 <code>One</code> 类对 <code>Two</code> 类有依赖关系，在逻辑上需要先注入 <code>Two</code> 对象，<code>One, Two</code> 的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">One</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"one被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Two被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522114839.png" width="20%"/>

<p><code>One</code> 先于 <code>Two</code> 先注入容器中，如果需要 <code>One</code> 在 <code>Two</code> 后，可以加上 <code>@DependsOn</code>,如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.DependsOn;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"two"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">One</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"one被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行测试类</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522115044.png" width="20%"/>

<p>这时 <code>Two</code> 类对象先被创建。</p>
<h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p><code>@Lazy</code> 是用来延迟加载时机的，一般我们在初始化容器时，就会将扫描到的类对象注入到容器中，如果对于一个大型的项目，可能会有成千上万个类，如果在一开始就将全部的对象注入到容器，会大大的延缓项目的启动时间，所以为了提高效率，我们可以在需要该类对象时才把对象注入到容器中，还是在上例中，新建 <code>Three</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Three</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"three被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522115609.png" width="40%"/>

<p>我们只是在测试类中初始化了容器，但是 <code>Three</code> 类对象已经被注入到容器中了。这时我们对 <code>Three</code> 使用 <code>@Lazy</code> 注解，再次运行测试类</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522115834.png" width="40%"/>

<p>这时 <code>Three</code> 类对象并没有被创建，只有我们第一次向容器获取所需对象时，才会被注入到容器中，修改测试类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> example.Three;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        Three three = ac.getBean(<span class="string">"three"</span>, Three<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522120057.png" width="40%"/>

<blockquote>
<p><strong>注意：</strong><code>@Lazy</code> 注解对于范围为单例的类有效。</p>
</blockquote>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p><code>@Conditional</code> 注解是用来设定注入条件的，当扫描到某类或者方法时，是否将该类对象或返回对象注入到容器，根据 <code>@Conditional</code> 指定的条件决定。<code>@Conditional</code> 注解的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解只有一个 <code>value</code> 属性，该属性的值是一个继承了 <code>Condition</code> 接口的字节码对象，<code>Condition</code> 接口有一个 <code>match</code> 方法，该方法返回一个布尔值，当返回 <code>true</code> 时，可以将对象注入到容器中，否则不行。</p>
<p>现在我们有两个数据源，一个是 <code>Windows</code> 下的数据源，一个是 <code>Linux</code> 下的数据源，现在我们的任务根据操作系统来决定使用哪个数据源注入到容器中，<code>JdbcConfig</code> 类定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> condition.LinuxCondition;</span><br><span class="line"><span class="keyword">import</span> condition.WindowsCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Conditional</span>(WindowsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataSource</span> <span class="title">createWindowsDataSource</span>() </span>&#123;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="comment">// 用以观察哪个数据源被注入到容器中</span></span><br><span class="line">        System.out.println(<span class="string">"Windows Env"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataSource</span> <span class="title">createLinuxDataSource</span>() </span>&#123;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="comment">// 用以观察哪个数据源被注入到容器中</span></span><br><span class="line">        System.out.println(<span class="string">"Linux Env"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面我们对 <code>Windows</code> 和 <code>Linux</code> 的数据源都使用了 <code>Conditional</code> 注解，分别使用 <code>WindowsCondition</code> 和 <code>LinuxCondition</code> 类来决定是否注入到容器中，二类的内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得环境对象</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">// 获得操作系统名称</span></span><br><span class="line">        String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(osName);</span><br><span class="line">        <span class="comment">// 如果包含 Windows 则可以注入</span></span><br><span class="line">        <span class="keyword">if</span> (osName.contains(<span class="string">"Windows"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(osName);</span><br><span class="line">        <span class="keyword">if</span> (osName.contains(<span class="string">"Linux"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类和测试类如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="meta">@Import</span>(JdbcConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        DataSource dataSource = ac.getBean(<span class="string">"dataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522130104.png" width="40%"/>

<h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p>有的时候我们在不同的环境下注入到容器中的类是不同的，比如开发环境、测试环境和生产环境下三者注入的类是不同的，要实现这样的效果，我们可以使用上面提及的 <code>@Conditional</code> 注解，但是考虑到上述问题比较常见，所以 <code>Spring</code> 为我们提供了 <code>@Profile</code> 注解来实现这样的功能， <code>@Profile</code> 的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">	String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以观察到 <code>@Profile</code> 的底层也是使用了 <code>@Conditional</code> 注解，<code>@Profile</code> 注解只有一个属性值 <code>value</code>，它是用来定义环境名称的，比如我们一般使用 <code>dev</code> 代表开发环境，<code>test</code> 代表测试环境，<code>prod</code> 代表生产环境。</p>
<p>在配置好类属于哪个环境后，可以通过容器对象中环境对象中的<code>setActiveProfiles()</code>方法来激活对应的环境，这样只有对应环境的类会被注入到容器中，我们新建三个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dev</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开发环境"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试环境"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产环境"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config.SpringConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能传入配置类的所在包 或者配置字节码对象 否则所有三个类都不会被注入</span></span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 设置激活的环境</span></span><br><span class="line">        ac.getEnvironment().setActiveProfiles(<span class="string">"dev"</span>);</span><br><span class="line">        <span class="comment">// 设置配置类</span></span><br><span class="line">        ac.register(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 刷新容器</span></span><br><span class="line">        ac.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522132300.png" width="30%"/>

<h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><p>我们一般在 <code>Service</code> 层中会用到 <code>Dao</code> 层中的对象，所以在 <code>Service</code> 中一般会有一个 <code>Dao</code> 层的成员变量，这个对象一般是在容器中的，所以 <code>Service</code> 层需要向容器索取对象，我们可以使用注解使得容器中的对象自动注入到对应的成员变量中，下面就介绍几个常用的自动注入注解。</p>
<h3 id="Autowired和-Qualifier"><a href="#Autowired和-Qualifier" class="headerlink" title="@Autowired和@Qualifier"></a>@Autowired和@Qualifier</h3><p><code>@Autowired</code> 注解首先会根据成员变量的类型去容器中找对应类型的注解，如果有多个相同类型的对象，那么会使用成员变量的名称作为 <code>id</code> 去容器中寻找对应的对象。</p>
<p><code>JdbcConfig</code> 类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们向容器中注入了两个 <code>DataSource</code> 对象，这时我们在 <code>TestAutowired</code> 中使用 <code>@AutoWired</code> 注解，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAutowired</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在容器中有两个 <code>DataSource</code> 类型的对象，所以 <code>@Autowired</code> 无法根据类型自动注入，所以 <code>@Autowired</code> 会根据变量名 <code>dataSource</code> 作为 <code>id</code> 去容器中寻找对象注入，但是在容器中并没有 <code>id</code> 为 <code>dataSource</code> 的对象，所以不能够成功注入。</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522203827.png"/>

<p>为了解决上面 <code>@Autowired</code> 注解存在的问题，我们可以通过 <code>@Qualifier</code> 注解指定自动注入的 <code>id</code> 名称，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"dataSource1"</span>)</span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>@Qualifier</code> 注解不能单独使用，必须配合 <code>@Autowired</code> 注解或后面提到的 <code>@Inject</code> 注解使用</li>
<li><code>@Autowired</code> 有一个属性为 <code>required</code>，该属性是规定是否要求一定要注入成功，默认为 <code>true</code>，即必须注入成功，否则抛出异常。</li>
</ul>
</blockquote>
<h3 id="Inject和-Named"><a href="#Inject和-Named" class="headerlink" title="@Inject和@Named"></a>@Inject和@Named</h3><p>使用 <code>@Inject</code> 和 <code>@Named</code> 需要导入对象的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>@Inject</code> 注解是 <code>JSR330</code> 规范规定的注解，它的作用也是实现自动注入注解，它的规则是根据类型自动注入，如果有多个相同类型的对象，那么会保错，与 <code>@Autowired</code> 注解不同，并不会以变量名作为 <code>id</code> 继续寻找。</p>
<p><code>@Named</code> 注解也是 <code>JSR330</code> 规范规定的注解，它可以和 <code>@Inject</code> 注解配合使用，它是用来设置在容器中的 <code>id</code> 名称的，与 <code>@Qualifier</code> 注解一样，<code>@Named</code> 注解不能单独使用，必须配合 <code>@Autowired</code> 注解或 <code>@Inject</code> 使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"dataSource1"</span>)</span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure>

<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p><code>@Resource</code> 注解是 <code>JSR250</code> 规范规定的注解，它有一个 <code>name</code> 属性，该属性是用来指定自动注入对象在容器中的 <code>id</code>，同 <code>@Named</code> 和 <code>@Qualifier</code> 不同，他可以单独使用，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"dataSource1"</span>)</span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure>

<h2 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h2><p>当我们仅仅使用 <code>Autowired</code> 时，如果容器中有多个相同类型的对象且容器没有与成员变量名相同的对象，那么注入是会失败的，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure>

<p>这时自动注入会失败，这时我们可以使用 <code>@Primary</code> 来表明那个对象时主要的，当有多个类型相同的对象时，优先注入该对象，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时使用 <code>@Autowired</code> 注解，会默认注入这个 <code>DataSource</code> 对象。</p>
<h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><p>在创建 <code>Bean</code> 后，可能需要做一些初始化的工作，这时我们可以使用 <code>@PostConstruct</code> 注解，在对象被销毁前，可能需要做一些资源的回收工作，这时我们可以使用 <code>@PreDestroy</code>，这两个注解只能放在方法上，新建一个 <code>utils.Logger</code> 类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化工作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"资源回收工作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>@PostContruct</code> 注解了 <code>init</code> 方法和使用 <code>PreDestroy</code> 注解了 <code>destroy</code> 方法，这意味着当创建<code>Logger</code> 对象后会执行 <code>init</code> 方法进行初始化，在 <code>Logger</code> 对象销毁前，会执行 <code>destroy</code> 执行资源回收工作。现进行验证，配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"utils"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在创建容器时 会创建 Logger 对象并注入，创建对象后会执行 init 方法</span></span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"config"</span>);</span><br><span class="line">        <span class="comment">// 销毁容器， Logger 对象会被一同销毁 在销毁前会执行 destroy 方法</span></span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522213747.png" width="50%"/>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1hE411o7w7" target="_blank" rel="noopener">Spring高级之注解驱动开发</a></li>
<li><a href="https://blog.csdn.net/baidu_37107022/article/details/89163959" target="_blank" rel="noopener">@Profile进行环境切换</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">熊滔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/">https://lastknightcoder.gitee.io/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lastknightcoder.gitee.io" target="_blank">Coder</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="https://lastknightcoder.gitee.io/tags/Java-Spring-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/">Java Spring 注解开发</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200522214503.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://lastknightcoder.gitee.io/img/wechatpay.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://lastknightcoder.gitee.io/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="https://lastknightcoder.gitee.io/Ajax%E8%B7%A8%E5%9F%9F/"><img class="next_cover" data-src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/bg83.png" onerror="onerror=null;src='https://lastknightcoder.gitee.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ajax跨域</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 熊滔</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://lastknightcoder.gitee.io/js/utils.js"></script><script src="https://lastknightcoder.gitee.io/js/main.js"></script><script src="https://lastknightcoder.gitee.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="https://lastknightcoder.gitee.io/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
      pangu.spacingElementById('content-inner')
})</script><script src="https://lastknightcoder.gitee.io/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>