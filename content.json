[{"title":"数值的整数次方","date":"2020-06-11T16:00:00.000Z","path":"/数值的整数次方/","text":"实现函数 double power(double base, int exponent)，求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。 由于不需要考虑大数问题，所以很快就可以写出这样的代码 public static double power(double base, int exponent) &#123; double result = 1.0; for (int i = 0; i &lt; exponent; i++) &#123; result *= base; &#125; return result;&#125; 但是这样的写法却不是完美的，如果指数是负数怎么办，从上面的程序看是不对的，另外如果 base 为 0 并且指数 exponent 为负数，此时 0 作为分母是没有意义的，所以进一步我们编写如下 public static double power(double base, int exponent) &#123; // 浮点数相等不能用 == if (Math.abs(base) &lt; 0.0000000001 &amp;&amp; exponent &lt; 0) &#123; throw new RuntimeException(\"不能出现0的负次幂\"); &#125; // 获得指数的绝对值 int absExponent = Math.abs(exponent); // 使用计算指数为正数的方法计算值 double result = powerWithPositiveExponent(base, absExponent); // 如果指数为负数，取倒数 if (exponent &lt; 0) &#123; result = 1 / result; &#125; return result;&#125;// 该方法是用来求exponent为正数时的情况private static double powerWithPositiveExponent(double base, int exponent) &#123; double result = 1.0; for (int i = 0; i &lt; exponent; i++) &#123; result *= base; &#125; return result;&#125; 至此我们的代码已经比较好了，但是如果对效率进行极致的追求的话，我们还可以仔细的分析，对于 $a^n$ 我们可以分解如下 $$ a^n = \\begin{cases} a^{n/2} \\cdot a^{n/2} & n \\% 2 == 0 \\\\ a^{(n-1)/2} \\cdot a^{(n-1)/2} \\cdot a & n \\% 2 == 1 \\end{cases} $$ 比如我们求解 $a^{32}$ 次方，按照上面的求解方法，我们要进行 $32$ 次循环，但是通过上面的分析，我们知道 $32$ 次方可以看做是两个 $16$ 次方相乘，而 $16$ 次方又可以看做是两个 $8$ 次方的相乘，以此递推，只要 $\\log_2 32 = 5$ 次即可得到结果，所以我们进一步修改 powerWithPositiveExponent 如下 private static double powerWithPositiveExponent(double base, int exponent) &#123; if (exponent == 0) &#123; return 1.0; &#125; else if (exponent == 1) &#123; return base; &#125; double result = anotherPowerWithPositiveExponent(base, exponent &gt;&gt; 1); result *= result; // 使用位运算而不是求余 % if ((exponent &amp; 0x1) == 1) &#123; result *= base; &#125; return result;&#125; 在上面我们使用了 exponent &gt;&gt; 1，如果 exponent 为偶数，那么 exponent &gt;&gt; 1 = exponent / 2，如果 exponent 为奇数，那么 exponent &gt;&gt; 1 = (exponent - 1) / 2，所以我们不需要判断 exponent 是奇是偶，然后决定是除 $2$ 还是减去 $1$ 之后除 $2$。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"二进制中1的个数","date":"2020-06-10T16:00:00.000Z","path":"/二进制中1的个数/","text":"题目：请实现一个函数，输入一个整数，输出该数二进制表示中 $1$ 的个数。例如，把 $9$ 表示成二进制是 $1001$，有 $2$ 位是 $1$。因此，如果输入 $9$，则该函数输出 $2$。 我们通过将数字与 $1$ 相与，即可知道数字的二进制的最后一位是否为 $1$，我们只要逐渐的将数字进行右移，即可统计出数字中 $1$ 的数目，所以会写下这样的代码 public static int numbersOfOne(int n) &#123; int count = 0; while (n != 0) &#123; if ((n &amp; 1) != 0) &#123; count++; &#125; n = n &gt;&gt; 1; &#125; return count;&#125; 但是上面的代码有一个问题，那就是如果输入的整数为负数呢? 根据负数的表示原则，它的首位是 $1$ 来表示数字的正负性，在右移的过程中，首位会进行补 $1$ 以表示它的符号还是负的，这个时候统计出的数字就是错误的了，并且会造成上面代码的死循环，如下以 $8$ 位表示的 $-7$ 为例 为了解决负数引起的问题，我们可以反其道而行之，让 $1$ 进行左移，然后与数字相与，同样也可以统计出数字 $1$ 的个数，所以修改代码如下 public static int numbersOfOne(int n) &#123; int count = 0; int flag = 1; while (flag != 0) &#123; if ((n &amp; flag) != 0) &#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count;&#125; 但是我们发现统计负数中 $1$ 的个数的结果与我们想象的不符，比如我们统计 $-7$ 的个数，结果为 public static void main(String[] args) &#123; System.out.println(numbersOfOne(-7)); // 30&#125; 结果是 $30$ 而不是 $4$，难道是我们的算法错了，其实不是，而是计算机存储数字是以其补码进行存储的，对于正数来说，它的补码是它本身，而对于负数，则是将除符号位进行取反，然后加 $1$，所以 $-7$ 的补码为 上面计算出一个数字二进制表示的 $1$ 的个数需要进行 $32$ 次循环(对于 int 类型的数据)，我们可以进一步对算法进行改进，使得二进制中有几个 $1$ 则进行几次循环。为了理解下面讲的算法，我们来看一下将一个数字减去 $1$ 它的二进制会发生什么变化? 先说结论，假设数字二进制最右边的 $1$ 在第 $m$ 位，即第 $m$ 位后面的位全是 $0$，在减去 $1$ 之后，第 $m$ 位的 $1$ 变成 $0$，后面的 $0$ 全部变为 $1$，而第 $m$ 位前面的数字保持不变，以 $8$ 位表示的 $10$ 为例 那么我们将数字 $n$ 与 $n - 1$ 进行相与会得到什么，因为 $n - 1$ 第 $m$ 位前面的数字不变，所以 $n - 1$ 的第 $m$ 位以前的数字与 $n$ 相同，所以 $n$ &amp; $n - 1$ 得到的第 $m$ 位以前的二进制是不变的，而 $n - 1$ 第 $m$ 位变成 $0$，以及第 $m$ 位以后的 $0$ 变为 $1$，所以 $n$ &amp; $n - 1$ 得到的第 $m$ 位及第 $m$ 位以后的二进制是 $0$，所以 $n$ &amp; $n - 1$ 的效果就是将数字 $n$ 中最右边的 $1$ 给去除了 所以我们就可以写出这样的代码 public static int numbersOfOne(int n) &#123; int count = 0; while(n != 0) &#123; count++; n = (n - 1) &amp; n; &#125; return count;&#125; 每次循环会去除一个 $1$，所以二进制中有几个 $1$，便会进行几次循环。 扩展： 用一条语句判断一个整数是不是 $2$ 的整数次方。一个整数如果是 $2$ 的整数次方，那么它的二进制表示中有且只有一位是 $1$，而其他所有位都是 $0$。所以我们统计该数二进制中 $1$ 的个数，如果是一个，那么就是 $2$ 的整数次方。 输入两个整数 $m$ 和 $n$，计算需要改变 $m$ 的二进制表示中的多少位才能得到 $n$。比如 $10$ 的二进制表示为 $1010$，$13$ 的二进制表示为 $1101$，需要改变 $1010$ 中的 $3$ 位才能得到 $1101$。我们可以分两步解决这个问题，首先将这两个数进行异或，这样 $m$ 和 $n$ 二进制不同的位会得到 $1$，相同的位是 $0$，我们只要统计异或后二进制中 $1$ 的个数，即可得到需要改变的位数。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剪绳子","date":"2020-06-09T16:00:00.000Z","path":"/剪绳子/","text":"题目：给你一根长度为 $n$ 的绳子，请把绳子剪成 $m$ 段($m、n$ 都是整数，$m &gt; 1, n &gt; 1$)，每段绳子的长度记为 $k[0], k[1], …, k[m]$。请问 $k[0] \\times k[1] \\times … \\times k[m]$ 可能的最大乘积是多少? 例如当绳子的长度是 $8$ 时，我们把它剪成长度分别为 $2、3、3$ 的三段，此时得到的最大乘积是 $18$。 我们定义长度为 $n$ 的绳子剪成若干段后，所能得到的最大长度为 $f(n)$。如果我们将绳子一段剪为长度为 $i$ 和 $n - i$，那么这时长度为 $n$ 能够被剪成的乘积是：长度为 $i$ 能够剪成的乘积 × 长度为 $n-i$ 能够剪成的乘积，因为 $f(i)$ 和 $f(n - i)$ 分别表示长度为 $i$ 和 $n - i$ 能够剪成的乘积最大值，所以这时长度为 $n$ 能够被剪成的乘积的最大值是 $f(i) \\times f(n - i)$，所以 $f(n) = \\max{f(i) \\times f(n - i)}(i = 1, 2, …, n - 1)$。所以我们只要遍历 $i$，找出所有 $f(i) \\times f(n - i)$ 中的最大值，这个值便是 $f(n)$。 为了求出 $f(n)$，我们还需要知道 $f(2), f(3)$ 这些初始值。当长度为 $2$ 时，只能剪成两段都为 $1$ 的两段，这时乘积的长度为 $f(2) = 1 \\times 1 = 1$；当长度为 $3$ 时，可以被剪成 $1$ 和 $2$ 的两段或者三段为 $1$ 的三段，因为 $1 \\times 2 &gt; 1 \\times 1 \\times 1$，所以 $f(3) = 2$。 代码如下： public class Cut &#123; public static int cut(int n) &#123; if (n &lt; 2) &#123; return 0; &#125; else if (n == 2) &#123; return 1; &#125; else if (n == 3) &#123; return 2; &#125; // 使用 results 数组保存 f(2) f(3) ... f(n) // results[n] = f(n) int[] results = new int[n + 1]; results[0] = 0; // results[1] = 1 而不是 0 因为已经被切成两段，所以这里可以不继续切 results[1] = 1; // results[2] = 2 而不是 1 也是同理 results[2] = 2; // results[3] = 3 而不是 2 也是同理 results[3] = 3; for (int i = 4; i &lt;= n; i++) &#123; int max = 0; // 遍历所有 j， for (int j = 1; j &lt;= i / 2; j++) &#123; int result = results[j] * results[i - j]; if (max &lt; result) &#123; max = result; &#125; &#125; results[i] = max; &#125; return results[n]; &#125; public static void main(String[] args) &#123; System.out.println(cut(8)); // 18 &#125;&#125; 总结： 我们将一个大问题切分为多个小问题，并且将小问题的解组合起来得到大问题的解，这样的解法我们称之为动态规划。如果题目是求一个问题的最优解(通常是最大值或最小值)，并且该问题可以被分为若干个子问题，子问题之间还有重叠的更小的问题，那么就考虑可以使用动态规划的解法。 在使用动态规划求解问题最优解时，为了防止多次重复计算子问题，我们一般会先将子问题的最优解存储下来，再根据此来计算问题的最优解。我们在之前的斐波那契数列的求解过程中，便是将原来的前两项值先保存下来，然后计算后一项的值；在上面的问题中，我们也是使用 results 数字将子问题的最优解保存下来，然后据此计算最优解。 所以在使用动态规划解决问题时，我们往往从上往下分析问题，找到问题最优解与子问题最优解之间的关系，然后从下往上求解问题，存储子问题的最优解，以防产生重复的计算。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lastknightcoder.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"回溯法","date":"2020-06-08T16:00:00.000Z","path":"/回溯法/","text":"在解决算法问题时，我们的第一个想法可能就是暴力法，比如暴力枚举所有可能的结果，但是暴力法的效率太低了，有时候达不到我们的要求。在这里我们介绍一种比暴力法稍微高级一点的算法，回溯法。回溯法是在多个可能的分支中选择一支，如果满足条件则继续查找，如果不满足结果，则回溯到上一个节点。 假如我们有下图所示结构 我们想在该树形结构中找到 &quot;abc&quot; 的路径，过程如下所示 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 这是一个可以使用回溯法解决的问题。首先判断矩阵的某个位置是否为字符串的第 $i$ 个字符，如果是继续向四周查找第 $i+1$ 个字符，并以此类推，直到找到最后一个字符；如果不是第 $i$ 个字符，则回溯到上一个位置去查找第 $i$ 个字符。因为已经经过了的路径不能重复经过，所以我们使用一个布尔矩阵 visited 来表示是否访问过矩阵中的某个位置。代码如下： public class Path &#123; // matrix：字符矩阵 // str：要查找的字符串 public static boolean hasPath(char[][] matrix, char[] str) &#123; // 对输入参数合法性的判断 if (matrix == null || matrix.length &lt; 1 || matrix[0].length &lt; 1) &#123; return false; &#125; // 获得矩阵的行数和列数 int rows = matrix.length; int columns = matrix[0].length; // 定义一个布尔矩阵，用以确定矩阵某个元素已经被访问过 boolean[][] vistied = new boolean[rows][columns]; // 初始化布尔矩阵 for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; vistied[row][column] = false; &#125; &#125; // pathLength表示以匹配的字符串的长度 int pathLength = 0; // 遍历矩阵进行匹配 for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (hasPathCore(matrix, row, column, str, pathLength, vistied)) &#123; return true; &#125; &#125; &#125; return false; &#125; // 判断位置 (row, column) 是否有第 pathLength 个字符后的路径 public static boolean hasPathCore(char[][] martix, int row, int column, char[] str, int pathLength, boolean[][] visited) &#123; // pathLength 表示以匹配的字符的个数，如果个数大于等于(其实这里等于就可以)字符串的长度，则匹配成功 if (pathLength &gt;= str.length) &#123; return true; &#125; // 后续是否匹配 boolean hasPath = false; // 如果该位置匹配，且该位置在矩阵内 if (row &gt;= 0 &amp;&amp; row &lt; martix.length &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; martix[0].length &amp;&amp; martix[row][column] == str[pathLength] &amp;&amp; !visited[row][column]) &#123; // 匹配长度+1 pathLength++; // 设置为已访问 visited[row][column] = true; // 在四周进行匹配 hasPath = hasPathCore(martix, row, column - 1, str, pathLength, visited) || hasPathCore(martix, row - 1, column, str, pathLength, visited) || hasPathCore(martix, row + 1, column, str, pathLength, visited) || hasPathCore(martix, row, column + 1, str, pathLength, visited); // 如果四周的路径都不匹配，进行回溯，匹配的长度和已访问设置为false if (!hasPath) &#123; pathLength--; visited[row][column] = false; &#125; &#125; return hasPath; &#125; public static void main(String[] args) &#123; char[][] matrix = &#123; &#123;'a', 'b', 't', 'g'&#125;, &#123;'c', 'f', 'c', 's'&#125;, &#123;'j', 'd', 'e', 'h'&#125; &#125;; char[] str = &#123;'t', 'c', 'f', 'd', 'j'&#125;; System.out.println(hasPath(matrix, str)); // true &#125;&#125; 题目：地上有一个 $m$ 行 $n$ 列的方格。一个机器人从坐标 $(0, 0)$ 的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。例如当 $k$ 为 $18$ 时，机器人能进入 $(35, 37)$，因为 $3 + 5 + 3 + 7 = 18$。但它不能进入方格 $(35, 38)$，因为 $3 + 5 + 3 + 8 = 19$。请问该机器人能够到达多少个格子? 这道题目和上道题很相似，同样可以使用回溯法进行解决。当机器人进入 $(i,j)$ 的格子时，判断它是否能进入，如果能进入，则继续判断相邻的四个格子是否能进入。同理，我们也会用一个布尔矩阵来标记是否访问过该矩阵，以防重复统计，完整代码如下： public class RobotCount &#123; // threshold：阈值，即题目中的 k 值 // rows, columns 矩阵的行数和列数 public static int movingCount(int threshold, int rows, int columns) &#123; // 输入参数合法性验证 if (threshold &lt;= 0 || rows &lt;= 0 || columns &lt;= 0) &#123; return 0; &#125; // 布尔矩阵 boolean[][] visited = new boolean[rows][columns]; // 布尔矩阵初始化 for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; visited[row][column] = false; &#125; &#125; // 从坐标 (0, 0) 开始移动 return movingCountCore(threshold, rows, columns, 0, 0, visited); &#125; // 从坐标 (row, column) 开始移动能够访问的格子数 private static int movingCountCore(int threshold, int rows, int columns, int row, int column, boolean[][] visited) &#123; int count = 0; // 如果能进入坐标 (row, column) if (check(threshold, rows, columns, row, column, visited)) &#123; // 标记以访问 visited[row][column] = true; // 进入相邻的四个格子 count = 1 + movingCountCore(threshold, rows, columns, row - 1, column, visited) + movingCountCore(threshold, rows, columns, row, column - 1, visited) + movingCountCore(threshold, rows, columns, row + 1, column, visited) + movingCountCore(threshold, rows, columns, row, column + 1, visited); &#125; return count; &#125; // 判断是否能进入坐标 (row, column) private static boolean check(int threshold, int rows, int columns, int row, int column, boolean[][] visited) &#123; if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &amp;&amp; (getDigitalNumber(row) + getDigitalNumber(column)) &lt;= threshold &amp;&amp; !visited[row][column]) &#123; return true; &#125; return false; &#125; // 获得数字 n 的数位和 private static int getDigitalNumber(int number) &#123; int sum = 0; while (number &gt; 0) &#123; sum += number % 10; number = number / 10; &#125; return sum; &#125; public static void main(String[] args) &#123; System.out.println(movingCount(10, 100, 100)); // 309 &#125;&#125; 总结： 通常在二维矩阵中查找路径这类问题都可以使用回溯法解决。 通常物体或人在二维方格运动这类问题都可以使用回溯法解决。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.gitee.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"旋转数组的最小数字","date":"2020-06-07T16:00:00.000Z","path":"/旋转数组中最小的数字/","text":"题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。 最简单的方法就是直接扫描一遍数组，找到数组中最小的数字，这样做它的时间复杂度是 $O(n)$，并且没有利用数组原来是已排好序的信息，我们要利用这个信息，以进一步降低时间复杂度。我们分析这个旋转的数组，可以将数组分为两部分： 观察到最小值在第一部分和第二部分的分界处，且在第二部分，另外可以观察到，由于第二部分是数组的前半部分搬到末尾的，所以第二部分中的值是小于等于第一部分中的值。 对于顺序查找问题，我们可以使用二分查找法。我们使用两个指针分别指向第一部分的开头和第二部分的结尾，然后将这两个值与数组中间的值进行比较，如果中间的值比第一部分的开头大，说明中间的值还在第一部分，我们将第一部分的开头指针移动到中间；同理，如果中间值比第二部分末尾的值小，则中间的值还在第二部分，则将第二部分末尾的指针移动到中间。以此类推，直到两个指针相差一个距离，则到了分界处，取第二部分指针所对应的值，该值即为最小值。图示如下： 但是上面的方法却又一个特例，即中间值与两个指针所指的值相等时，则无法知道如何移动指针 上面两个数组都是 {0, 1, 1, 1, 1} 的旋转，并且中间的值与两个指针指向的值相同，但是中间值一个在第一部分，一个在第二部分，所以我们这时是无法知道如何移动指针，碰到这种情况，我们只能顺序查找了，代码如下 public class Min &#123; public static int min(int[] arr) &#123; int start = 0; int end = arr.length - 1; int mid = 0; // 如果 start 的值小于 end，说明数组没有进行旋转，则返回数组的第一个值，这就是 mid = 0 的原因 while (arr[start] &gt;= arr[end]) &#123; // 如果两个指针相差 1 个距离，则返回第二个指针指向的值 if (end - start == 1) &#123; mid = end; break; &#125; mid = (start + end) / 2; // 如何中间的值和两个指针的值相等，则进行顺序查找 if (arr[start] == arr[end] &amp;&amp; arr[start] == arr[mid]) &#123; return minInOrder(arr, start, end); &#125; // 如果中间的值比 start 的值大，则将 start 移至中间 if (arr[mid] &gt;= arr[start]) &#123; start = mid; &#125; else if (arr[mid] &lt; arr[end]) &#123; // 否则中间的值比 end 小，则将 end 移至中间 end = mid; &#125; &#125; return arr[mid]; &#125; // 顺序查找的代码 public static int minInOrder(int[] arr, int start, int end) &#123; int minResult = arr[start]; for (int i = start; i &lt;= end; i++) &#123; if (minResult &gt; arr[i]) &#123; minResult = arr[i]; &#125; &#125; return minResult; &#125; public static void main(String[] args) &#123; int[] arr = &#123;3, 4, 5, 1, 2&#125;; System.out.println(min(arr)); // 1 &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"斐波那契数列","date":"2020-06-06T16:00:00.000Z","path":"/斐波那契数列/","text":"题目：求斐波那契数列的第 $n$ 项。斐波那契数列的定义如下： $$ f(n) = \\begin{cases} 1, & n = 1 \\\\ 1, & n = 2 \\\\ f(n - 1) + f(n - 2), & n > 2 \\end{cases} $$ 斐波那契数列的定义对于大家来说应该很熟了，即斐波那契数列的第 $n$ 项的数字是前两项的和，而在高校的教科书中，斐波那契数列也是作为讲解函数递归很好的例子，所以你会很快写出这样的代码 public static int fibonacci(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; else if (n == 1 || n == 2) &#123; return 1; &#125; return fibonacci(n -1) + fibonacci(n - 2);&#125; 但是上面的程序有个很大的问题，就是运行的速度很慢，我们先看一下运行的时间，再来分析为何这么慢 public static void main(String[] args) &#123; long start = System.nanoTime(); System.out.println(fibonacci(45)); long end = System.nanoTime(); System.out.println((end - start) / 1000000 + \" ms\");&#125; 结果如下 11349031704272 ms 在我的电脑上，计算斐波那契数列第 $45$ 项所需的时间是 4272 ms。现在你可能不知道这个时间是快是慢，但是我们分析一下，我们计算 $f(45)$ 时，我们需要计算 $f(44)$ 和 $f(43)$，在计算 $f(44)$ 时我们又要计算 $f(43)$，说明计算重复了，经过分析它的时间复杂度是 $O(2^n)$。 现在我们考虑另一种解法，我们分析上面的计算是因为重复的计算，如果我们利用前面已有的结果，那么所需的时间即可大大减少，程序如下 public static int fibonacci(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; int firstNumber = 1; int secondNumber = 1; int result = 0; for (int i = 2; i &lt; n; i++) &#123; result = firstNumber + secondNumber; firstNumber = secondNumber; secondNumber = result; &#125; return result;&#125; 上面的时间复杂度只有 $O(n)$，我们测试上面程序计算斐波那契数列的第 $45$ 项所需的时间，如下 11349031700 ms 所需的时间连 1 ms 都不需要，速度相比上面提高的不是一星半点。 题目：青蛙跳台阶。一只青蛙一次可以跳上 $1$ 级台阶，也可以跳上 $2$ 级台阶。求该青蛙跳上一个 $n$ 级的台阶总共有多少种跳法。 其实这个问题仔细想想就可以发现，这道问题就是斐波那契数列的一个变体。考虑第 $n$ 级台阶，青蛙最后一步到达第 $n$ 级台阶只有两种方法，从 $n - 1$ 级跳 $1$ 级，或者从 $n - 2$ 级跳 $2$ 级，设青蛙跳上一个 $n$ 级台阶有 $f(n)$ 种跳法，那么可以得到这样的关系式$$f(n) = f(n - 1) +f(n - 2)$$这个式子不就是斐波那契数列的通项嘛，所以程序的写法也是一样的，不过它们的初始条件不一样，简单分析就可以得到$$f(1) = 1 \\\\f(2) = 2$$具体的程序参考上面。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"用两个栈实现队列","date":"2020-06-03T16:00:00.000Z","path":"/用两个栈实现队列/","text":"题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。 public class TwoStackToQueue &#123; private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; public void appendTail(Integer value) &#123; &#125; public Integer deleteHead() &#123; &#125;&#125; 栈的特点是后进先出，队列的特点是先进先出，如何使用两个栈来实现队列的效果呢? 假设当添加数据时，我们把数据添加到第一个栈中，我们称之为 stack1，例如连续添加 1, 2, 3, 4 四个数据，如下 我们添加数据时向 stack1 添加数据，而取出数据时从 stack2 取出数据，我们再次把 stack1 中的数据依次放入 stack2 中，经过两次入栈的操作，两个后进先出变成了先进先出 现在我们入队和出队的规则应该如下，即入队时将数据压入 stack1 中，出队时从 stack2 中弹出，现在的问题是什么时候将 stack1 中的数据弹出压入到 stack2 中，其实很简单，出队时将 stack2 中的数据弹出，直到 stack2 为空，这时将 stack1 中的数据弹出压入到 stack2 中，然后从 stack2 弹出数据。下面演示一个完整的例子 完整的代码示例如下 import java.util.Stack;public class TwoStackToQueue &#123; private static Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); private static Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); public static void appendTail(Integer value) &#123; // 添加数据从 stack1 添加 stack1.push(value); &#125; public static Integer deleteHead() &#123; // stack2 不为空时 从stack2 弹出数据 if (!stack2.isEmpty()) &#123; return stack2.pop(); &#125; else &#123; // stack2 为空时 且stack1 不为空时，将stack1的数据弹出压入到stack2中 if (!stack1.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; // 然后从 stack2 弹出数据 return stack2.pop(); &#125; else &#123; // stack1 和 stack2 都为空，说明队列为空 抛出异常 throw new RuntimeException(\"Queue is Empty\"); &#125; &#125; &#125;&#125; 扩展：那如何使用两个队列实现一个栈呢?","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"offsetX,pageX,clientX和screenX","date":"2020-06-02T16:00:00.000Z","path":"/offsetX,pageX,clientX,screenX/","text":"在使用的 JavaScript 的过程中，对 offset，page，client 等等所表示的距离一直不是很清楚，现趁有时间系统的学习了一下。上面所述的 offsetX，pageX 等等都是事件对象 event 的属性，当有鼠标事件触发时，可以获得相应的事件对象，该对象中包含着鼠标的各种距离，现总结如下 offsetX：离触发事件元素左边的距离 pageX：离页面左边的距离 clientX：离浏览器左边的距离 screenX：离电脑显示器左边的距离 现在就演示一下，假设有下面的页面结构 上图已经基本可以明白 offsetX 和 clientX的大小，如果没有横向的滚动条的话，pageX 与 clientX 的大小是一样的。如果有滚动条的话，那么 pageX 的距离一般是大于 clientX 的距离的，如下 上图应该已经阐释了 pageX 与 clientX 的不同，那么只剩最后一个 screenX，这个也较好理解，就是鼠标位置离电脑显示器左侧的位置，如果浏览器是最大化的话，屏幕的左侧与浏览器的左侧相同，那么 screenX 的大小与 clientX 的大小相同，如果不是最大化，那么 上面介绍的是横向距离，纵向距离也是相似，offsetY，pageY，clientY，screenY 计算将左侧距离换为上侧距离。 这里还可以在扩展一个距离，scrollX 指的是横向滚动的距离，其实通过分析可以发现$$scrollX = pageX - clientX$$如下图所示","tags":[{"name":"offset client page screen scroll","slug":"offset-client-page-screen-scroll","permalink":"https://lastknightcoder.gitee.io/tags/offset-client-page-screen-scroll/"}]},{"title":"二叉树的下一个节点","date":"2020-06-01T16:00:00.000Z","path":"/二叉树的下一个节点/","text":"题目：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点? 树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。(树的中序遍历指的是先打印左子树，然后打印根节点，最后打印右子树) 我们以下图来分析二叉树的下一个节点 其中标在节点旁边的数字表示打印的顺序，比如节点 4 旁边标注 1，表示它是第一个被打印的，它的中序遍历的结果如下 我们分以下几种情况分析： 该节点有右子树，例如节点 4，节点 3等等，那么它的下一个节点就是它右子树中最左的节点，例如节点 4 右子树最左的节点是 7，所以它的下一个节点是 7，节点 3 的右子树的最左的节点是 8，所以它的下一个节点是 8 该节点没有右子树，且父节点存在，并且它是它父节点的左孩子，那么它的父节点就是它的下一个节点，所以节点 5 的下一个节点是节点 3 该节点没有右子树，父节点存在，并且也不是它父节点的左孩子，如节点 7，那么它就要一直向上寻找，直到某个节点是它父节点的左孩子，此时父节点就是下一个节点。如节点 7 不是它父节点的左孩子，向上寻找，来到父节点 4，它是它父节点的左孩子，所以节点 4 的父节点 2 是节点 7 的下一个节点 如果向上寻找，没有找到某个节点是它父节点的左孩子，那么说明没有下一个节点，如节点 6 没有下一个节点 没有右子树，且父节点不存在，没有下一个节点 完整代码如下： public class NextNode &#123; // 二叉树的定义 private static class BinaryTree &#123; int value; // 还有一个指向父节点的指针 BinaryTree parent; BinaryTree left; BinaryTree right; public BinaryTree(int value) &#123; this.value = value; &#125; &#125; public static BinaryTree findNext(BinaryTree node) &#123; if (node == null) &#123; return null; &#125; // 1. 如果有右子树，下一个节点是右子树的最左子树 if (node.right != null) &#123; BinaryTree next = node.right; while (next.left != null) &#123; next = next.left; &#125; return next; // 没有右子树，且父节点存在 &#125; else if (node.parent != null) &#123; // 2. 如果是父节点的左孩子 if (node == node.parent.left) &#123; return node.parent; &#125; else &#123; // 3. 如果不是父节点的左孩子，向上寻找 while (node.parent != null) &#123; // 直到找到某节点是它父节点的左孩子，父节点是下一个节点 if (node == node.parent.left) &#123; return node.parent; &#125; node = node.parent; &#125; // 没有找到某节点是父节点的左孩子，没有下一个节点 return null; &#125; // 4. 没有右子树，也没有父节点，那么也没有下一个节点 &#125; else &#123; return null; &#125; &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"重建二叉树","date":"2020-05-31T16:00:00.000Z","path":"/重建二叉树/","text":"题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 首先通过一个例子看看前序遍历和中序遍历的特点，如下二叉树 它的前序遍历和中序遍历的结果为 我们分析一下前序遍历和中序遍历的结构 我们的思路是首先根据前序遍历找到根节点的值(第一个)，接着根据找到的根节点的值，在中序遍历中找到根节点的位置，在中序遍历中根节点左边的值是它的左子树的中序遍历，右边是它的右子树的中序遍历，并且进一步可以得到左右子树的长度，根据左右子树的长度，可以在前序遍历中找到左子树的前序遍历和右子树的前序遍历，然后重复上面的过程，又可以找到左右子树的根节点的值以及相应的左右子树，以此类推，即可重建二叉树。 完整代码如下： public class Test &#123; // 二叉树的定义 private static class BinaryTree &#123; int value; BinaryTree left; BinaryTree right; public BinaryTree(int value) &#123; this.value = value; &#125; &#125; // preorder 前序遍历的数组 // inorder 中序遍历的数组 public static BinaryTree constructBinaryTree(int[] preorder, int[] inorder) throws Exception&#123; if (preorder == null || inorder == null) &#123; throw new Exception(\"preorder or inorder is null\"); &#125; return helpContructBinaryTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); &#125; // 根据前序遍历数组和中序遍历数组获得根节点 private static BinaryTree helpContructBinaryTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) throws Exception&#123; // 前序遍历的第一个值就是根节点 BinaryTree root = new BinaryTree(preorder[preStart]); // 如果只有数组只有一个值 if (preStart == preEnd) &#123; if (inStart == inEnd &amp;&amp; preorder[preStart] == inorder[inStart]) &#123; return root; &#125; else &#123; throw new Exception(\"wrong input\"); &#125; &#125; // 获得中序遍历根节点的位置 int inOrderRoot = inStart; for (; inOrderRoot &lt;= inEnd; inOrderRoot++) &#123; if (inorder[inOrderRoot] == root.value) &#123; break; &#125; &#125; // 如果在中序遍历中没有找到根节点 则输入的数组有错误 if (inOrderRoot &gt; inEnd) &#123; throw new Exception(\"wrong input\"); &#125; // 左右子树的长度 int leftLength = inOrderRoot - inStart; int rightLength = inEnd - inOrderRoot; if (leftLength &gt; 0) &#123; // 根据左子树的前序遍历和中序遍历获得左子树的根节点 // [preStart + 1, preStart + leftLength] 左子树的前序遍历的范围 // [inStart, inOrderRoot - 1] 左子树的中序遍历的范围 root.left = helpContructBinaryTree(preorder, preStart + 1, preStart + leftLength, inorder, inStart, inOrderRoot - 1); &#125; if (rightLength &gt; 0) &#123; // 同左子树 root.right = helpContructBinaryTree(preorder, preStart + leftLength + 1, preEnd, inorder, inOrderRoot + 1, inEnd); &#125; return root; &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"TypeScript入门指南","date":"2020-05-29T16:00:00.000Z","path":"/TypeScript入门指南/","text":"介绍TypeScript是什么TypeScript 是什么? 引用官方的定义 TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source. 简单翻译就是 TypeScript 是 JavaScript 的超集，并且可以被编译成 JavaScript。它可以运行在任何浏览器，任何主机，任何操作系统上。并且它是开源的。 看到这里你可能对 TypeScript 还是没有什么感觉，其实在我看来 TypeScript 是对 JavaScript 做了各种限制，这里说的限制并不是贬义的意思，因为 JavaScript 实在是太灵活了，很多的问题只有在运行的时候才会暴露出来，比如对于函数，即使定义时要求传两个参数，但是在使用时却可以传入任意的参数，所以你无法限制使用该函数的用户传入正确的参数，如果碰到不仔细看 API 文档的用户，鬼知道它使用的时候会传入什么，出了问题说不定会甩锅你兼容性做的不好。而 TypeScript 则限制了这一点，在使用时传入的参数必须与定义传入的相同，并且有提示每个参数的作用，用户使用该函数时必须按规定的来。 TypeScript的优势那么 TypeScript 可以为我们带来什么好处： 错误在编译时就可以暴露出来，而不必等到运行时才暴露出来 如下 js 文件 如上，一不小心将变量名写错了，写成了 MyNane，这种错误是很有可能发生的，但是在很多的时候我们自己却很难发现，只有当我们运行该程序报错的时候，我们才有可能根据报错信息，确定报错的原因；更糟糕的是，如果报错的信息不明确，你几乎无法确定是哪里出现问题，到时候要靠一双肉眼去找出这么一个小小的不同，曾经我就有因为变量名写错的问题，我找了半个小时。但是如果我们使用 TypeScript 的话，这样的问题在编译时就会被发现，如下 ts 文件 我们可以发现，在 MyNane 下面出现了红色的波浪线，将鼠标放在上面，还会贴心的给出提示。 智能提示 对于现代的程序员来说，代码的智能提示那是能够大大的提高工作效率的，不仅如此，还可以减少出错的概率，如果你手动写出一个对象的方法名，出错的概率可是很高的，特别是对于一些英语不好的同学。但是问题来了，因为 JavaScript 不是静态类型，而是动态类型，所有的变量都使用 var, let, const 声明，而不是像 C 语言这样静态类型语言，不同的类型使用不同的关键字，如 int, char[] 等等。所以这就意味着 JavaScript 这个类型是可变的，一会儿这是字符串类型，一会儿是数字类型，编译器根本在编译阶段根本不能确定你是什么类型，所以无法给出相应类型的特有方法，比如字符串类型的 toUpperCase() 方法，如下 js 文件 如上，上面的函数的功能是将传入的单词首字母大写，我们只是简单的调用字符串对象的函数 toUpperCase()，但是我们发现当我们打出 word. 时没有给出任何的提出，因为 JavaScript 根本不能确定你传入的是不是字符串，毕竟 JavaScript 是如此的灵活，使用时你可以传入任何类型的参数。但是对于 TypeScript 就不一样了，因为它会对参数的类型做出限制，如下 我们限制了传入的参数必须为 string 类型，在编译的阶段，我们能够肯定传入的一定是 string 类型，所以在函数的方法里面，当我们输入 word. 时会给出字符串对象的所有方法。除此之外，我们还规定了函数必须传入什么类型，这样用户在使用时就不能随便的传入参数，所有的一切必须按规定的来，这又无形的减少了 bug 的产生，并且用户在调用该方法时，还会给出提出，需要传入什么参数类型，必要的时候还可以给出传入参数的意义，如下 TypeScript 的好处还不止这一些，不过就我列举的这两个，就有足够的理由来学 TypeScript 了，TypeScript 更多的好处就需要你在使用的过程中慢慢理会了。 入门使用下面就将介绍 TypeScript 的安装，以及如何将 TypeScript 转化为 JavaScript 代码，毕竟浏览器和 Node 只能运行 JavaScript 代码。 安装TypeScript在安装 TypeScript 之前，确保你的计算机按照好了 Node，如果没有安装，可以去网上搜如何安装，教程很多。安装完成之后，使用 npm 下载 typescript npm install -g typescript 查看版本(主要是验证是否成功安装) tsc -VVersion 3.8.3 编写TypeScript程序新建 greeter.ts function greeter(person: string) &#123; return \"Hello \" + person;&#125;let user = 'XT';console.log(greeter(user)); 在命令行中使用 tsc 命令将它编译为 js tsc greeter.ts 这时会在该目录下生成 greeter.js，greeter.js 的内容为 function greeter(person) &#123; return \"Hello \" + person;&#125;var user = 'XT';console.log(greeter(user)); 接着我们使用 node 运行该 js 文件 node greeter.js 输出为 Hello XT 所以我们一般的流程为，编写 ts 文件，然后使用 tsc 编译为 js 文件，然后使用 node 运行 js 文件查看结果，那有没有什么工具帮我们做这件事情，一个命令直接到位。这里我们推荐使用 ts-node，该命令可以一步到位，就相当于是直接运行 ts 文件，首先下载 ts-node npm install -g ts-node 现在我们可以直接使用 ts-node greeter.ts 查看结果。 基本类型TypeScript 与 JavaScript 最大的不同就是 TypeScript 是一个有类型的语言，我们一般使用下面的方式声明变量 let 变量名: 类型 = 值; 那么 TypeScript 有哪些类型呢? 下面就简单介绍一下。 boolean// 值只能为true或者falselet isDone: boolean = false; numberlet decNumber: number = 20; // 十进制let hexNumber: number = 0x14; // 十六进制 20let binNumber: number = 0b10100; // 二进制 20let octNumber: number = 0o24; //八进制 20 stringlet name: string = \"bob\"; // 单引号，双引号都可以let greetStr: string = `Hello $&#123;name&#125;`; // 支持模板字符串 数组(Array)let list: number[] = [1, 2, 3]; // 数字数组let list: Array&lt;number&gt; = [1, 2, 3]; // 数组泛型 元祖(Turple)规定了数组的长度，以及每个元素的类型 let x: [string, number]; // x有两个元素，第一个元素为字符串，第二个元素为数字x = [\"hello\", 1] enum枚举类型 enum Color &#123; Red, Green, Blue&#125;let colorName: Color = Color.Blue; any任意类型，与写 JavaScript 一样 // 不清楚是什么类型，或者不希望做语法检查，就相当于写JavaScriptlet notSure: any = 4;notSure = false;let list: any[] = [1, true, \"a\"] voidvoid 一般用于表示函数不返回任何值，将它声明为一个变量没有意义 // 不返回任何值function printUser(user): void &#123; console.log(user)&#125;// 声明一个void类型变量是没有意义的let x: void = null; // 只能被赋值为null和undefined undefined, nulllet u: undefined = undefined; // 通常声明变量意义不大let n: null = null; never函数抛出异常或者死循环是可以使用 nerver 作为返回值 // 表示不存在的数据类型 函数抛出异常的时候就可以用never // never是任何类型的子类型，可以赋值给任何的类型function error(message: string): never &#123; throw new Error(message)&#125;function fail() &#123; return error(\"something error\");&#125;// 无限循环，函数不能结束，也可以返回neverfunction inifiniteLoop(): never &#123; while (true) &#123; &#125;&#125; object// 表示非原始类型declare function create(o: object | null): void;create(&#123;prop: 0&#125;); 注意：当没有将变量声明为某个基本类型时，TypeScript 会进行类型推断，如 let str = 'hello'; // str 会被推断为 string 类型 如上，变量 str 会被推断为 string 类型，这时 str 不能被赋值为别的类型 如果变量在声明时并没有被赋值，那么它的类型会被推断为 any，这时它可以被赋予任何类型的值 let str; // str 被推断为 any，可以为赋予任何类型的值str = 'hello';str = 2; 高级类型枚举类型我们使用 enum 来定义枚举类型，如 enum Week &#123; Mon, Tue, Wen, Thu, Fri, Sat, Sun&#125; 枚举类型会被编译为从零递增的数字 var Week;(function (Week) &#123; Week[Week[\"Mon\"] = 0] = \"Mon\"; Week[Week[\"Tue\"] = 1] = \"Tue\"; Week[Week[\"Wen\"] = 2] = \"Wen\"; Week[Week[\"Thu\"] = 3] = \"Thu\"; Week[Week[\"Fri\"] = 4] = \"Fri\"; Week[Week[\"Sat\"] = 5] = \"Sat\"; Week[Week[\"Sun\"] = 6] = \"Sun\";&#125;)(Week || (Week = &#123;&#125;)); 通过编译后的代码可以看出，枚举名和枚举值可以互相引用 console.log(Week[0] === 'Mon'); // trueconsole.log(Week[1] === 'Tue'); // trueconsole.log(Week[2] === 'Wen'); // trueconsole.log(Week[3] === 'Thu'); // trueconsole.log(Week['Fri'] === 4); // trueconsole.log(Week['Sat'] === 5); // trueconsole.log(Week['Sun'] === 6); // true 我们还可以为枚举名手动赋值，如 enum Week &#123; Mon = 1, Tue, Wen, Thu, Fri, Sat, Sun&#125; 我们为 Mon 手动赋值为 1，未手动赋值的项会接着上一项递增，所以 Tue 的值为 2，Wen 的值为 3，以此递增。如果后面递增的数字与前面定义数字重复了，这时是不会报错的，而是会覆盖之前的项 enum Week &#123; Mon = 3, Tue = 1, Wen, Thu, Fri, Sat, Sun&#125; 可见 Thu 的值也是 3，这个时候它的值与 Mon 重复了，但是此时 Week[3] 的值是 Thu 而不是 Mon，因为后面的 Thu 将前面的 Mon 覆盖了 var Week;(function (Week) &#123; Week[Week[\"Mon\"] = 3] = \"Mon\"; Week[Week[\"Tue\"] = 1] = \"Tue\"; Week[Week[\"Wen\"] = 2] = \"Wen\"; Week[Week[\"Thu\"] = 3] = \"Thu\"; // Week[3] 被重新赋值为了\"Thu\" Week[Week[\"Fri\"] = 4] = \"Fri\"; Week[Week[\"Sat\"] = 5] = \"Sat\"; Week[Week[\"Sun\"] = 6] = \"Sun\";&#125;)(Week || (Week = &#123;&#125;)); 函数类型对于函数来说，我们使用函数类型来规范它，一个函数有输入和输出，所以我们使用如下的形式来表示函数类型 (x: number, y:number) =&gt; number 上面就规范这个函数类型的输入为两个 number 类型的参数，输出为 number 类型的参数，如 let add:(x: number, y:number) =&gt; number = (x, y) =&gt; &#123; return x + y;&#125; 上面的 add 函数是一个 (x: number, y:number) =&gt; number 类型的函数，它必须接受两个 number 类型的参数，返回一个 number 类型的参数，如果 add 函数不满足此规则，那么就会报错 在上面 add 返回的是一个 string 类型的值，而不是 number 类型，这时编译器就会报错。 现在考虑有一个减法函数，它也满足上面的函数类型，所以它可以被声明如下 let substract: (x: number, y: number) =&gt; number = (x, y) &#123; return x - y;&#125; 如果还有很多的函数也满足上面的函数类型的话，那是不是每次都要写一般函数类型，所以我们可不可以为这个函数类型起一个别名，这样方便引用，我们可以通过 type 起别名，如下 type compute = (x: number, y: number) =&gt; number;let substract: compute = (x, y) &#123; return x - y;&#125;let add: compute = (x, y) &#123; return x + y;&#125; 如果还有别的函数时这个函数类型的话，我们使用起的别名 compute 进行申明就可以了。 如果我们使用匿名函数的形式声明一个函数，那么它会进行类型推断，如 function add(x: number, y: number): number &#123; return x + y;&#125; 那么 add 会被自动推断为 (x: number, y:number) =&gt; number，如果参数没有注明类型，那么会被推断为 any。 联合类型联合类型表示取值可以为多种类型的一种，如下 let score: string | number; // score 可以为数字，也可以为字符串score = 97;score = \"97\"; // 不会报错 当我们为联合类型进行赋值时，会根据类型推断推断出一个类型，这个时候我们就可以访问该类型所拥有的属性和方法，如 let score: string | number;score = \"97\"; // 被推断为 string 类型score.length; // 可以访问 string 类型的属性和方法 当 TypeScript 不能确定联合类型的具体类型时，那么只能访问联合类型中这些类型的共有的属性和方法，如 function getLength(something: string|number): number &#123; return something.length;&#125; 因为 something 为 string 或者 number 类型，所以它只能访问 string 和 number 类型共有的属性和方法，但是因为 number 类型没有 length 属性，所以上面会报错，如下 接口接口可以看做是对象的类型，接口规定了对象的结构，我们使用 interface 来定义一个接口 interface Person &#123; name: string; age: number;&#125; 上面我们定义一个叫做 Person 的接口，如果某个对象时这个接口类型，那么这个对象就必须含有 name 和 age 属性，并且 name 属性的值为 string，age 属性的值为 number，如下 let person: Person = &#123; name: 'bob', age: 13&#125; 可以说接口规定了对象的结构，定义了对象所必须拥有的属性名，不能多，也不能少，否则会报错，如下 let person: Person = &#123; name: 'bob', age: 13, gender: 'male'&#125; person 中含有接口 Person 不曾定义过的属性 gender，这时就会报错 可选属性有时候我们并不需要对象完全匹配一个形状，这个时候可以定义可选属性，定义的规则如下 interface Person &#123; name: string; age: number; gender?: string;&#125; 在上面我们定义了一个可选属性 gender，这个时候类型为 Person 的对象，可以有 gender 属性，也可以没有 let person: Person = &#123; name: 'bob', age: 13, gender: 'male'&#125; 或者 let person: Person = &#123; name: 'bob', age: 13&#125; 都是可以的。 只读属性有时候我们希望对象的某些属性在定义时被赋值，并且以后不能被更改，那么可以在这个属性定义为只读属性。我们使用 readonly 定义某个属性为只读属性 interface Person &#123; readonly id: number; name: string; age: number;&#125; 当对象的类型为 Person 时，在创建时要为 id 赋值(初始化)，并且这时 id 是只读的，不能被改变 let tom: Person = &#123; id: 1, name: 'Tom', age: 3&#125;tom.id = 2; 上面我们尝试修改 tom 对象的 id，但是因为 id 是只读的，不能被修改，所以上面的程序会报错 任意属性如果我们希望某个接口可以有任意的属性，我们可以使用如下方式 interface Person &#123; name: string; age?: number; [propName: string]: any;&#125; 我们定义了 Person 接口可以有任意的属性，该属性的键值为 string 类型，值为 any 类型。一旦定义了任意属性，那么确定属性和可选属性的类型必须为任意属性所规定的类型的子集。比如修改上面的接口 interface Person &#123; name: string; age?: number; [propName: string]: string;&#125; 因为 age 的值类型为 number，而任意属性规定的值类型为 string，所以会报错 类类可以看做是创建对象的模板，我们使用 class 来定义一个类，一个类中有属性和方法 class Person &#123; public name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;let tom = new Person(\"Tom\", 3); 我们可以通过类来大量的创建对象。在类中有一个方法 constructor()，这个方法叫做构造函数，它的功能是用来初始化属性的。 类的继承我们使用 extends 关键字来实现继承 class Person &#123; public name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person &#123; public score: number; constructor(name: string, age: number, score: number) &#123; super(name, age); this.score = score; &#125;&#125; 通过继承，我们复用父类的属性和方法。在上面我们使用了 super，该方法的作用是调用父类的构造函数初始化父类的属性。 访问权限访问权限有三种，分别为 public，private，protected 三种，在上面我们使用的都是 public 访问权限，使用该权限，可以在任何地方被访问到，例如 class Person &#123; public name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;let tom = new Person(\"Tom\", 3);// 可以直接访问console.log(tom.name, tom.age); // Tom 3 如果使用 private，那么该属性只能在类内部才能被访问，在类的外部不能被访问，如 class Person &#123; private name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;let tom = new Person(\"Tom\", 3);console.log(tom.name, tom.age); 我们将 name 的访问权限修改为了 private，这个时候不能再类外被直接访问，所以上面通过 tom.name 访问属性 name 会报错 如果使用 protected 修饰，那么该属性只能在该类内部及其子类中才能被访问，除此之外不能被访问，如下 class Person &#123; protected name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person &#123; public score: number; constructor(name: string, age: number, score: number) &#123; super(name, age); this.score = score; &#125; // 在子类中可以被访问 public getName(): string &#123; return this.name; &#125;&#125;let alice = new Student(\"Alice\", 4, 5);console.log(alice.getName()); // Alice// 下行语句会报错console.log(alice.name); 如上所示，父类 Person 的 name 属性使用 protected 修饰，所以在子类 Student 中可以访问，但是在父类和子类的外部不能访问 静态属性我们可以使用 static 关键声明静态属性以及静态方法，静态属性和方法是属于类的，而不是具体的对象，使用属性和方法要使用类名调用，如下 class Person &#123; public static max_age:number = 100; public name:string; public age:number; constructor(name:string, age:number) &#123; this.name = name; this.age = age; &#125;&#125;let person = new Person(\"Tom\", 15);// 通过类对象访问实例属性console.log(person.name); // Tom// 通过类访问静态属性console.log(Person.max_age); // 100 readonly我们可以使用 readonly 来修饰类的属性，来表示该属性是只读的，只有在构造函数中初始化该属性，如下 class Person &#123; public readonly name:string; public age:number; constructor(name:string, age:number) &#123; this.name = name; this.age = age; &#125;&#125;let person = new Person(\"Alice\", 12);person.name = \"Bob\"; 在上面我们声明了 name 属性为 readonly，表明 name 属性是只读的，但是在后面我们试图修改该属性，这个时候将会报错 实现接口接口的另一个作用就是对类进行抽象，一个类可以实现接口，当类实现接口时，要求类中必须有接口中定义的属性和方法，如下 interface IPerson &#123; name: string; age: number; gender: string;&#125;class Person implements IPerson&#123; public name:string; public age:number; public gender: string; constructor(name:string, age:number, gender:string) &#123; this.name = name; this.age = age; this.gender = gender; &#125;&#125;let person = new Person(\"Alice\", 12, \"male\"); 其实我对接口的理解，其实就是定义了一个标准。定义了标准之后，对于具体的实现就不关心了，可以和具体的实现解耦。假设我们有一个方法接受一个操作数据库的对象，但是对于不同的厂家(数据库)，具体怎么操作数据库都是不一样的，所以这个对象不能写死是怎么类型。所以我们应该定义操作数据库的标准，比如操作数据库的方法名，方法接收的参数，而对于具体的实现应该由各自的产商编写。只要这些厂商实现了我们的标准，那么它就可以用，类比过来，我们定义的标准就是接口，而各自厂商的实现就是实现了接口的类。 interface OperateDatabase &#123; save: () =&gt; void;&#125;function saveData(obj: OperateDatabase): void &#123; obj.save();&#125; 在上面我们定义一个操作数据库的接口 OperateDatabase，并且定义了一个方法 saveData()，该方法接收一个接口，注意这里我们没有指定是某个特定的对象类型，否则的就会与该类型绑定在一起。接着我们可以两个类实现该接口 class MysqlDatabase implements OperateDatabase &#123; save() &#123; console.log(\"mysql 保存数据\"); &#125;&#125;class RedisDatabase implements OperateDatabase &#123; save() &#123; console.log(\"redis 保存数据\"); &#125;&#125; 这两个类就相当于是这个标准的具体实现。当我们调用 saveData 方法时，将具体的实现类传入即可 saveData(new MysqlDatabase()); // mysql 保存数据saveData(new RedisDatabase()); // redis 保存数据 声明合并函数的合并现在有这么一个函数，它可以接受一个参数，这个参数可以是字符串或者数字，它的功能是将传入的数字或者字符串反转，比如输入 123，则输出 321，输入 hello，则输出 olleh，我们可以定义类如下 function reverse(x: number | string): number|string&#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.toString().split('').reverse().join(''); &#125;&#125; 这个函数的定义有一个缺点，不能精确的表达输入数字时，输出也是数字，输入是字符串时，输出也是字符串。我们可以重载 reverse 的多个定义 function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number|string&#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.toString().split('').reverse().join(''); &#125;&#125; 接口的合并当我们定义了两个相同名字的接口时，接口中的属性会自动进行合并 interface Person &#123; name: string;&#125;interface Person &#123; age: number;&#125; 相当于 interface Person &#123; name: string; age: number;&#125; 如果两个接口有相同的属性，只要它们返回的值的类型相同，就不会有问题，如下 interface Person &#123; name: string; gender: string;&#125;interface Person &#123; age: number; gender:string;&#125; 在两个接口中，它们有相同的属性名 gender，并且它们的定义时一样的，它们的合并也没有问题，相当于如下 interface Person &#123; name: string; age: number; gender:string;&#125; 但是如果有相同的属性，但是定义却不同，即值的类型不同，那么会报错 interface Person &#123; name: string; gender: string;&#125;interface Person &#123; age: number; gender:number;&#125; 上面两个接口的 gender 的定义不同，报错如下 类型断言有时候我们需要将一个不确定的类型断言为具体的类型，比如将一个联合类型断言为其中的某一个具体的类型，这样就可以使用它特有的方法。类型断言的语法为 值 as 类型 或者 &lt;类型&gt;值 上面两种方法都是将值断言为某个具体的类型。因为在 React 中只支持 as 语法，所以推荐使用第一种方法。 联合类型断言为其中具体类型就如上面所说，有时候我们希望将联合类型断言为具体的类型，这样我们就可以使用类型特有的方法，否则只能使用二者公共的方法。我们第一个形状类型 interface Circle &#123; radius: number;&#125;interface Square &#123; size: number;&#125;interface Rectangle &#123; width: number; height: number;&#125;type Shape = Circle | Square | Rectangle; 接着我们定义一个方法，该方法接收 Shape 类型的参数，返回面积，我们可能会这么写 function getArea(s: Shape): number &#123; if (typeof s.radius === 'number') &#123; return 3.14159 * s.radius * s.radius; &#125; else if (typeof s.size === 'number') &#123; return s.size * s.size; &#125; else &#123; return s.width * s.height; &#125;&#125; 但是你会发现一片报红 因为传入的类型 s 根本无法确定是什么具体的类型，我们只能访问 Circle, Square, Rectangle 的公共属性和方法，所以当我们访问他们特有的属性时就会报错，比如 s.radius，所以在访问具体的属性进行判断时，我们要断言为具体的类型，修改如下 function getArea(s: Shape): number &#123; if (typeof (s as Circle).radius === 'number') &#123; s = s as Circle; return 3.14159 * s.radius * s.radius; &#125; else if (typeof (s as Square).size === 'number') &#123; s = s as Square; return s.size * s.size; &#125; else &#123; s = s as Rectangle; return s.width * s.height; &#125;&#125; 我们首先进行断言为具体的类型，然后进行判断。 父类或接口断言为子类或实现类有时候我们需要将父类或接口断言为具体的子类，这样就可以使用子类特有的属性或方法。首先定义一个父类和两个子类 class Person &#123; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person&#123; score: number; constructor(name:string, age: number, score: number) &#123; super(name, age); this.score = score; &#125;&#125;class Teacher extends Person&#123; level: number; constructor(name:string, age: number, level: number) &#123; super(name, age); this.level = level; &#125;&#125; 接着定义一个方法，该方法接收 Person 类型的参数，我们需要断言为具体的子类才能使用子类的属性和方法 function isStudent(p: Person) &#123; if (typeof (p as Student).score === 'number') &#123; return true; &#125; else &#123; return false; &#125;&#125;console.log(isStudent(new Student('Bob', 15, 100))); // true 泛型在定义函数、类和接口时，并不具体指定具体的类型，而是使用一个占位符表示类型，具体的类型在使用的时候传入决定。 函数泛型我们定义一个函数创建一个数组，并设置默认值，数组中存储的具体类型等到使用时确定 function createArray&lt;T&gt;(length: number, defaultValue: T): Array&lt;T&gt; &#123; let x = new Array&lt;T&gt;(length); for (let i = 0; i &lt; length; i++) &#123; x.push(defaultValue); &#125; return x;&#125; 该函数接收两个参数，第一个参数为数组的长度，第二个参数为默认值。该数组的类型我们使用泛型 T 代替，具体的类型在使用时确定，如创建一个长度为 5，类型为 number，默认值为 0 的数组，如下 let arr = createArray&lt;number&gt;(5, 0);console.log(arr); // [ &lt;5 empty items&gt;, 0, 0, 0, 0, 0 ] 因为我们不知道泛型的具体类型，所以不能随意操作它的属性和方法，这个时候我们可以对象泛型做出约束，以便我们可以使用特定的属性或方法，如要求泛型必须符合某个接口 interface Length &#123; length: number;&#125;function getLength&lt;T extends Length&gt;(t: T):number &#123; return t.length;&#125; 上面我们要求泛型 T 继承了接口 Length，即传入的对象 t 必须含有属性 length console.log(getLength(\"123\")); // 3 接口泛型同样的，我们也可以在接口中使用泛型 interface CreateArrayFunc&lt;T&gt; &#123; (length: number, defaultValue: T): Array&lt;T&gt;&#125;let createArray: CreateArrayFunc&lt;number&gt;;createArray = function&lt;T&gt;(length: number, defaultValue: T) &#123; let x: T[] = []; for(let i = 0; i &lt; length; i++) &#123; x.push(defaultValue); &#125; return x;&#125;console.log(createArray(5, 3)); // [ 3, 3, 3, 3, 3 ] 类泛型我们也可以在类中使用泛型 class Stack&lt;T&gt; &#123; data: T[]; size: number; constructor(capacity: number) &#123; this.data = new Array&lt;T&gt;(capacity); this.size = 0; &#125; push (item: T): void &#123; this.data.push(item); this.size++; &#125; pop (): T &#123; this.size--; return this.data.pop() as T; &#125; printStack(): void &#123; console.log(this.data); &#125;&#125; 我们定义了一个 Stack 栈，它里面存储的类型是一个泛型，在我们使用的时候确定，如下 // 定义了一个存储 number 类型数据的栈 容量为10let stack = new Stack&lt;number&gt;(10); stack.push(10);stack.push(5);stack.printStack(); // [ &lt;10 empty items&gt;, 10, 5 ] 参考文献 TypeScript入门教程 TypeScript安利指南","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lastknightcoder.gitee.io/tags/TypeScript/"}]},{"title":"JavaScript之正则表达式","date":"2020-05-27T16:00:00.000Z","path":"/JavaScript之正则表达式/","text":"在字符串的处理中，我们经常要进行字符串的匹配，校验等等操作。比如校验字符串的格式是否符合邮箱，电话号码的格式，校验密码是否符合要求，密码中是否包含数字和字母等等；又或者匹配得到某种规则的字符串。这一些操作如果使用常规的方法进行字符串操作，会花费较大的代价，包括时间和精力。 正则表达式是用来表达字符串的规则，它可以检验字符串是否符合某个特定的规则，或者匹配字符串中符合规则的字符，在一般的使用中，正则表达式一般用来匹配字符串中的字符或者字符串中特定的位置。 正则对象JavaScript 正则对象的创建有两种常见的方法，一是使用 RegExp 构造函数进行创建，二是使用字面量的方法进行创建，如下 let regex1 = new RegExp('hello', 'g');let regex2 = /hello/g; 其中 hello 表示字符串的规则，用来匹配字符串中的&quot;hello&quot;，g 表示进行全局匹配(global)，像这样的标志还有两个，m 表示进行多行匹配(multiline)，i 表示忽略大小写(ignoreCase)，这三个标志互不冲突，可以同时使用，如 let regex = /hello/igm; 具体标志的作用在后面讲解。在实际的使用中，我们一般会使用字面量的形式创建正则对象，相对于使用构造函数，字面量的创建比较简便，不过如果需要动态的创建正则对象，或者根据字符串创建正则对象，那么可以考虑使用构造函数的方式。 正则对象中的属性 global：布尔值，是否设置了 g 标志 ignoreCase：布尔值，是否设置了 i 标志 lastIndex：整数，从字符串的某个位置开始匹配，默认为 0 multiline：布尔值，是否设置了 m 标志 source：正则表达式的字符串表示 let regex = /\\d&#123;3&#125;hello$/ig;console.log(regex.global); // trueconsole.log(regex.ignoreCase); // trueconsole.log(regex.multiline); // falseconsole.log(regex.lastIndex); // 0console.log(regex.source); // \\d&#123;3&#125;hello$ 正则对象中的方法testtest()，该方法接收一个字符串参数，返回一个布尔值，用来判断该字符串是否符合正则对象的规则，如下 let regex = /hello/g;let string1 = \"hello world\";let string2 = \"Hello World\";console.log(regex.test(string1)); // trueconsole.log(regex.test(string2)); // false execexec() 方法是用来捕获匹配到的字符，该方法接收一个字符串，返回一个数组，数组的第一项表示与整个模式匹配的字符串，第二项表示第一个捕获组(捕获组的概念如果不懂，可以看了括号的作用在回来看)，第三项表示第二个捕获组，以此类推。返回的数组与普通数组不同的是，该数组还有三个属性，index 、 input 和 groups，index 表示匹配到的字符在原始字符串中的位置，从 0 开始；input 表示输入的原始字符串，groups 表示捕获组的名称。 let regex = /(he)(ll)(o)/g;let string = \"so hello\";let result = regex.exec(string);console.log(result); 输出为 [ 'hello', 'he', 'll', 'o', index: 3, input: 'so hello', groups: undefined] 如果正则对象的标志有 g 的话，那么在执行 exec() 方法后会改变 lastIndex 为匹配字符串后字符的 index，接下来再次执行 exec() 方法时将会从 lastIndex 处开始匹配，如 let string = \"ab abc abc\";let regex = /ab/g;console.log(regex.lastIndex); // 0regex.exec(string);console.log(regex.lastIndex); // 2regex.exec(string);console.log(regex.lastIndex); // 5regex.exec(string);console.log(regex.lastIndex); // 9regex.exec(string); // 匹配不到会返回 nullconsole.log(regex.lastIndex); // 重新变为 0 构造函数RegExp的属性构造函数 RegExp 中有一些静态属性，这些属性会保存最近一次正则对象操作的一些信息，并且这些属性有两种方法访问，一种是具有语义的长属性名，一种是简短的短属性名，具体如下： input：短属性名为 $_，最近一次要匹配的字符串 lastMatch：$&amp;，最近一次的匹配项 leftContext：$`， input 中 lastMatch 的左边部分 rightContext：$&#39;，input 中 lastMatch 的右边部分 $1, $2, ...：后面介绍 let regex = /hello/g;let string = \"he hello llo\";regex.exec(string);console.log(RegExp.input); // he hello lloconsole.log(RegExp.lastMatch); // helloconsole.log(RegExp.leftContext); // he_ (从_表示空格)console.log(RegExp.rightContext); // _llo 字符串方法在字符串中，有许多的方法也是与正则表达式有关的，如 replace，match，下面就简单介绍一下。 replacereplace() 方法的作用是使用新的字符串替换字符串中的某些内容，该方法接收两个参数，第一个参数表示字符串中要被替换的内容，它可以是一个具体的字符串或者是一个正则对象，第二个参数为一个字符串，这个参数是用来替换第一个参数的，如 let string = \"gello\";string = string.replace('g', 'h'); // 将 string 中的 g 替换为 hconsole.log(string); // hello let string = \"abc\";string = string.replace(/[ab]/g, '#'); // 将字符串中的 a 或 b 替换为 #console.log(string); // ##c 在上面中使用了 [ab]，这个表示 a 或者 b，具体会在元字符那里讲解。 matchmatch 方法的作用与 exec 的作用差不多，不过一个是 RegExp 对象的方法，一个是 String 对象的方法。match 方法接收一个正则对象，它返回一个数组，根据正则对象是否设置了 g 标志，返回的结果也不相同。 如果没有设置 g 标志，即不会全局匹配，只会匹配一次，那么它返回的结果与 exec 返回的结果相同，数组的第一个元素表示匹配的字符串，后面的元素表示捕获组，并且也有 input，index，groups等属性，表示的含义也痛 exec，如下 let string = \"hello\";let result = string.match(/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/);console.log(result); 输出为 [ 'hello', 'he', 'll', 'o', index: 0, input: 'hello', groups: [Object: null prototype] &#123; h: 'he', l: 'll' &#125;] 这次的正则表达式跟以往的不同，这次我设置了捕获组的名称，如 (?&lt;h&gt;he) 即将捕获组 (he) 的名称设置为了 h，设置捕获组名称的格式如下 (?&lt;捕获组名称&gt;捕获组内容) 为捕获组设置名称，可以方便在后面进行引用。 如果设置了 g 标志，这时返回值与 exec 方法就不同了，它会将字符串中所有符合正则表达式规则的内容都匹配出来，并放入数组中，如 let string = \"hello\";let re = /(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g;let result = string.match(re);console.log(result); // [ 'hello' ]string = \"hello helloworld\";result = string.match(re);console.log(result); // [ 'hello', 'hello' ] 这时设置的捕获组的信息就提取不到了，所以从某种程度上说，exec 的功能比 match 更加的强大，不过 exec 并不能一次提取出字符串中所有符合规则的内容，而是需要做一个循环，如下 let string = \"hello helloworld\";let re = /(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g;let result;let results = new Array();// 当 re.exec()不为 null 时while (result = re.exec(string)) &#123; results.push(result[0]); // result 中还包含了捕获组的信息&#125;console.log(results); // [ 'hello', 'hello' ] 字符匹配上面使用正则表达式进行匹配都是进行精确的匹配，如 /hello/，匹配字符串中的 hello 内容，这样我们根本无法领会到正则表达式的强大，正则表达式正是强大在它模糊匹配的能力，比如我们在 Windows 中进行文件查找，有时我们不记得文件的具体名称，比如忘了某个字母，这个时候我们会用 . 去表示任意的字母去进行查找。现在我们就来讲讲正则表达式模糊匹配的能力。 字符组在进行匹配的时候，如果我们不确定某个位置的字符是什么，我们可以使用表示特定含义的字符来占据这个位置，比如 [abc] 表示这个位置是 a，b，c 中的某个字符。如果我们想表示这个字符是小写字母，按照上面的写法，你可能会这么写 [abcdefghijklmnopqrstuvwxyz]，这样的写法有点反人类，我们可以使用范围表示法来代替上面的写法，如 [a-z] 的写法就表示所有的小写字母，同理 [A-Z] 就表示所有的大写字母，[0-9] 就表示数字，[0-9a-zA-Z] 表示这个位置可以是数字，小写字母，大写字母。如下 let re = /[a-zA-Z0-9]/;console.log(re.test('0')); // trueconsole.log(re.test('s')); // trueconsole.log(re.test('S')); // trueconsole.log(re.test('?')); // false 我们可以在 [] 中加入 ^ 表示取反，如 [^0-9] 表示非数字，即它可以匹配所有的非数字 let re = /[^0-9]/;console.log(re.test(\"2\")); // falseconsole.log(re.test(\"a\")); // trueconsole.log(re.test(\"?\")); // true 我们还可以使用元字符来占据位置，比如 \\d 就代表数字，它的作用与 [0-9] 是一样的，常见的元字符如下所示(不包含表示位置的元字符，表示位置的元字符在后面介绍) 元字符 含义 \\d 表示数字 \\s 表示空白字符，包括空格，回车，制表符等等 \\w 表示数字，大小写字母和下划线，相当于 [0-9a-zA-Z_] . 表示任意一个字符 来看几个例子 // 表示数字let re1 = /\\d/;console.log(re1.test(\"2\")); // true// 空白字符let re2 = /\\s/;console.log(re2.test(\" \")); // trueconsole.log(re2.test(\"\\t\")); // trueconsole.log(re2.test(\"\\n\")); // true// 表示大小写字母，数字和下划线let re3 = /\\w/;console.log(re3.test(\"2\")); // trueconsole.log(re3.test(\"a\")); // trueconsole.log(re3.test(\"A\")); // trueconsole.log(re3.test(\"_\")); // true 与在 [] 中加入 ^表示取反，上面的元字符也有对应的元字符表示取反的概念 元字符 含义 \\D 与 \\d 相反，表示非数字 \\S 与 \\s 相反，表示非空白字符 \\W 与 \\w 相反，表示非单词 let re1 = /\\D/;console.log(re1.test(\"2\")); // falseconsole.log(re1.test(\"\\n\")); // truelet re2 = /\\S/;console.log(re2.test(\" \")); // falseconsole.log(re2.test(\"9\")); // truelet re3 = /\\W/;console.log(re3.test(\"0\")); // falseconsole.log(re3.test(\"\\t\")); // true 量词现在我们假设使用正则表达式去匹配电话号码，假设电话号码就是 11 位数字，所以写出来的正则表达式是这样的 \\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d，这种写法也相当的反人类，不仅难读(需要一个个数才知道有多少个数)，而且写起来也麻烦，我们可以使用量词来简写上面的表达式，如 \\d{11} 就表示 \\d 连续出现 11 次，常见的量词写法如下 量词 含义 {n} 表示连续出现 n 次 {m,n} 表示连续出现 m-n，最少出现 m，最多出现 n 次 {n,} 表示连续出现最少 n 次(包括 n 次) * 表示连续出现任意多次 + 表示连续出现 1 次或 1 次以上 ? 表示出现 0 次或 1 次 // 匹配连续出现的 5 位数字let re = /\\d&#123;5&#125;/g;let string = \"123 1234 12345 654321\";console.log(string.match(re)); // [ '12345', '65432' ] // 匹配连续出现的 2-3 位数字let re = /\\d&#123;2,3&#125;/g;let string = \"12 123 1234\";console.log(string.match(re)); // [ '12', '123', '123' ] // 匹配连续出现 4 位及 4 位以上的数字let re = /\\d&#123;4,&#125;/g;let string = \"12 123 1234 12345\";console.log(string.match(re)); // [ '1234', '12345' ] // b 可以出现任意次let re = /ab*c/g;let string = \"ac abc abbc abbbc\";console.log(string.match(re)); // [ 'ac', 'abc', 'abbc', 'abbbc' ] // b 出现 1 次或 1 次以上let re = /ab+c/g;let string = \"ac abc abbc abbbc\";console.log(string.match(re)); // [ 'abc', 'abbc', 'abbbc' ] // b 出现 0 次或 1 次let re = /ab?c/g;let string = \"ac abc abbc abbbc\";console.log(string.match(re)); 贪婪匹配与惰性匹配所谓的贪婪匹配就是尽可能的多匹配，如 let re = /ab+/g;let string = \"abbbb\";console.log(string.match(re)); // [ 'abbbb' ] 明明匹配 ab 也可以，但是它会尽可能多的匹配，这就是贪婪模式，与此相对的是惰性匹配，惰性匹配就是在满足条件的情况下会尽可能的少匹配，如上例就会匹配 ab，在默认的情况下是贪婪匹配，要使用惰性匹配就要使用惰性量词 贪婪 惰性 + +? * *? ? ?? {n,m} {n,m}? {n,} {n,}? let re = /ab+?/g;let string = \"abbbb\";console.log(string.match(re)); // [ 'ab' ] 现在考虑根据 html 字符串获得某 id 属性，如 &lt;div id=&quot;container&quot; class=&quot;active&quot;&gt;&lt;/div&gt;，如果我们使用贪婪匹配的话，考虑这样的匹配规则 /id=&quot;.*&quot;/，那么捕获到的并不是我们想要的 let re = /id=\".*\"/;let string = \"&lt;div id=\\\"container\\\" class=\\\"active\\\"&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // id=\"container\" class=\"active\" 我们发现匹配到的是 id=&quot;container&quot; class=&quot;active&quot;，因为在贪婪模式下再符合条件的情况下会尽可能多的匹配，所以会直接匹配到最后一个双引号，解决办法有两种，其中简单的解决办法就是使用惰性匹配 let re = /id=\".*?\"/;let string = \"&lt;div id=\\\"container\\\" class=\\\"active\\\"&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // id=\"container\" 另一种办法就比较 trick，我觉得只可意会，难以言传 let re = /id=\"[^\"]*\"/;let string = \"&lt;div id=\\\"container\\\" class=\\\"active\\\"&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // id=\"container\" 仔细体会上面的写法吧，我觉得很好用，比如获得某标签的标签名 let re = /&lt;[^&gt;]*&gt;/;let string = \"&lt;div&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // &lt;div&gt; 分支有时候我们需要在多个分支之间进行选择，比如匹配十六进制表示的颜色，有两种表示，一种是 #F4E242 六位的，一种是简写的 #FFF 三位表示的，我们可以使用 | 来表示或的关系 let regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;let string1 = \"#FFF\";let string2 = \"#F34E23\"console.log(string1.match(regex)); // [ '#FFF' ]console.log(string2.match(regex)); // [ '#F34E23' ] 括号的作用分组与分支假设我们要匹配 I love Java 和 I love C 这两句话，你可能会写出这样的正则表达式 /I love Java|C/ 但是这个正则表达式表示的是 I love Java 或者 C 而不是 I love C，正确的写法应该是这样 /I love (Java|C)/ Java 和 C 选其一。 捕获数据假设我们要匹配一个格式为 yyyy-mm-dd 格式的日期，并且希望获得年月日，那么可能会这么写 let re = /\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/;let string = \"2020-05-27\";let result = re.exec(string)[0]; // 2020-05-27let results = result.split(\"-\");console.log(\"year:\" + results[0]); // year:2020console.log(\"month:\" + results[1]); // month:05console.log(\"day:\" + results[2]); // day:27 其实我们可以通过添加括号来捕获数据，对于被括号包起来的数据，其匹配的内容会被提取出来，添加到返回的数组中，如 let re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;let string = \"2020-05-27\";let result = re.exec(string);console.log(\"year:\" + result[1]); // 第一个捕获组 \\d&#123;4&#125; 匹配的内容console.log(\"month:\" + result[2]); // 第二个捕获组 \\d&#123;2&#125; 匹配的内容console.log(\"day:\" + result[3]); // 第三个捕获组 \\d&#123;2&#125; 匹配的内容 上面我们对年月日的规则使用括号包了起来，在进行匹配时，对应被匹配到的数据会添加到数组中，在介绍 exec 方法时，其返回的数组，第一个元素表示匹配到的字符串，后面的元素表示捕获组(括号包起来)中捕获的内容。 RegExp的属性$1…除了可以根据返回的数组 result 来得到捕获的数据，还可以通过在上面提过一嘴的 RegExp 构造函数的属性 $1, $2, $3 ... 等等来获得所捕获的内容，其中 $1 表示第一个捕获组所匹配的内容，如下 let re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;let string = \"2020-05-27\";let result = re.exec(string);console.log(\"year:\" + RegExp.$1); // year:2020console.log(\"month:\" + RegExp.$2); // month:05console.log(\"day:\" + RegExp.$3); // day:27 每次在使用正则表达式进行匹配时，RegExp 中的 $1, $2, $3 ... 也会相应的更新。 括号嵌套现在考虑如果括号有嵌套的情况，比如上面日期格式捕获更精准的表达式 /(\\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\\d)|(3[0-1]))/ 上面括号嵌套的很复杂，在原理上，被括号包起来的规则所匹配的内容都会被捕获，那么嵌套带来的问题就是，捕获的顺序哪个在前，哪个在后，其实也很简单，根据左括号来，比如上式中的捕获顺序为 (\\d{4}) ((0\\d)|(1[0-2])) (0\\d) (1[0-2]) ((0[1-9])|([1-2]\\d)|(3[0-1])) (0[1-9]) ([1-2]\\d) (3[0-1]) 所以如果使用上面的正则表达式进行捕获得到年月日的信息，根据分析年是第一捕获组，月是第二捕获组，日是第五捕获组 let re = /(\\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\\d)|(3[0-1]))/;let date = \"2020-05-27\";let result = re.exec(date);console.log(result[1], result[2], result[5]); // 2020 05 27 由于无用的捕获组太多，导致想要提取包含信息的捕获组获取困难，其实仔细观察，里面的大多数括号主要是为分支做准备的，对于这些捕获组，我们可以考虑不捕获，仅仅作为分支使用，我们在括号里面的前方加入 ?: 表示该括号匹配的内容不进行捕获，如下 let re = /(\\d&#123;4&#125;)-((?:0[1-9])|(?:1[0-2]))-((?:0[1-9])|(?:[1-2]\\d)|(?:3[0-1]))/;let date = \"2020-05-27\";let result = re.exec(date);console.log(result[1], result[2], result[3]); // 2020 05 27 如果作为分支的括号太多，为每一个分支添加 ?: 也比较费力，那么可以考虑给包含信息的捕获组命名，命名的方法在上面有提到过 let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;(0[1-9])|(1[0-2]))-(?&lt;day&gt;(0[1-9])|([1-2]\\d)|(3[0-1]))/;let date = \"2020-05-27\";let result = re.exec(date);let groups = result.groups;console.log(groups.year, groups.month, groups.day); // 2020 05 27 通过给捕获组命名，可以方便的通过 groups 对象得到想要的数据。 反向引用现在再次考虑匹配日期，已知下面这三种日期格式都可以 2017-02-122017 02 122017/02/12 所以你可能会写出这样的正则表达式 /\\d&#123;4&#125;(-| |\\/)\\d&#123;2&#125;(-| |\\/)\\d&#123;2&#125;/ 经过测试，发现能符合要求 console.log(re.test(\"2017-02-17\")); // trueconsole.log(re.test(\"2017 02 17\")); // trueconsole.log(re.test(\"2017/02/17\")); // true 但是你会发现一些意外的情况 console.log(re.test(\"2017-02/17\")); // trueconsole.log(re.test(\"2017-02 17\")); // trueconsole.log(re.test(\"2017 02-17\")); // true 前后的分隔符不一致的情况也能够匹配，而我们要求的是前后的分隔符是一样的，这个时候我们可以通过引用分组，使得前面和后面的分隔符是一样的，如下 let re = /\\d&#123;4&#125;(-| |\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;console.log(re.test(\"2017-02-17\")); // trueconsole.log(re.test(\"2017 02 17\")); // trueconsole.log(re.test(\"2017/02/17\")); // trueconsole.log(re.test(\"2017-02/17\")); // falseconsole.log(re.test(\"2017-02 17\")); // falseconsole.log(re.test(\"2017 02-17\")); // false 注意到我们对于后面的分组，我们使用了 \\1 去进行替代，\\1 的意思就是代表引用第一个分组，这样就可以做到这个地方与前面的分组相同。同理我们也可以使用 \\2 表示引用第二个分组(如果有的话，如果没有就单纯的表示匹配字符串 &quot;\\2&quot;)。 位置匹配相关元字符正则表达式中的最后一个内容就是关于位置的匹配，与字符匹配不同，位置匹配时匹配字符间的位置，常见有关位置的元字符如下 元字符 含义 ^ 开头位置 $ 结尾位置 \\b 单词边界，即 \\w 与 \\W 之间的位置 (?=p) 匹配 p 模式前面的位置，具体见例子 (?&lt;=p) 匹配 p 模式后面的位置 let string = \"[JS] hello\";let result = string.replace(/^/,\"#\");console.log(result); // #[JS] helloresult = string.replace(/$/, \"#\");console.log(result); // [JS] hello#result = string.replace(/\\b/g, \"#\"); // \\b 是 \\w 与 \\W 之间的位置，表示单词的边界console.log(result); // [#JS#] #hello#result = string.replace(/(?=hello)/, \"#\"); // hello 前面的位置console.log(result); // [JS] #helloresult = string.replace(/(?&lt;=hello)/, \"#\"); // hello 后面的位置console.log(result); // [JS] hello# 同理，也有元字符表示与上面相反的意义 元字符 含义 \\B 与 \\b 相反，表示非单词边界 (?!p) 与 (?=p) 相反，表示不是 p 前面位置的所有位置 (?&lt;!p) 与 (?&lt;=p) 相反，表示不是 p 后面位置的所有位置 let string = \"[JS] hello\";let result = string.replace(/\\B/g,\"#\");console.log(result); // #[J#S]# h#e#l#l#oresult = string.replace(/(?!hello)/g, \"#\"); // 不是 hello 前面位置的所有位置console.log(result); // #[#J#S#]# h#e#l#l#o#result = string.replace(/(?&lt;!hello)/g, \"#\"); // 不是 hello 后面位置的所有位置console.log(result); // #[#J#S#]# #h#e#l#l#o 千位分隔符案例现在来做一个案例，将数字转化为千位分隔符表示法，如 12345678 转化为 12,345,678，我们首先找到后三位数字的前面位置，然后添加逗号，如下 let string = \"12345678\";result = string.replace(/(?=(\\d&#123;3&#125;)$)/g,\",\");console.log(result); // 12345,678 进一步弄出所有的逗号 result = string.replace(/(?=(\\d&#123;3&#125;)+$)/g,\",\"); // 12,345,678 但是还是有一个小小问题，测试的数字个数是三的倍数的时候，在开头也会添加一个逗号 let string = \"123456789\";result = string.replace(/(?=(\\d&#123;3&#125;)+$)/g,\",\");console.log(result); // ,123,456,789 我们可以修改正则表达式如下 result = string.replace(/(?=(?!^)(\\d&#123;3&#125;)+$)/g,\",\"); 其中 (?!^) 表示不是开头的位置。如果希望支持更多的格式，比如 1234567 12345678 转换为 1,234,567 12,345,678，只要将上面的表达式中的开头，结尾替换为 \\b 即可 let string = \"1234567 12345678\";result = string.replace(/(?=(?!\\b)(\\d&#123;3&#125;)+\\b)/g,\",\");console.log(result); // 1,234,567 12,345,678 考虑到 (?!\\b) 就相当于 \\B，所以上面的表达式也可简写如下 /(?=\\B(\\d&#123;3&#125;)+\\b)/g 多行模式正则表达式有三个常见的标志，分别为全局模式 g，表示进行全局匹配，如果不设置该标志，那么只会匹配一次，如果字符串后面还要符合规则的字符串，是不会被匹配的，对于 exec() 方法，非全局模式下不会更改 lastIndex，即 lastIndex 始终是 0。 let string = \"hello hello\";let re1 = /hello/;let re2 = /hello/g;// 非全局替换 只会替换匹配到的第一个 helloconsole.log(string.replace(re1, \"#\")); // # hello// 全局替换 字符串中所以的 hello 都会被替换console.log(string.replace(re2, \"#\")); // # # 第二标志 i 很好理解，即忽略大小写 let re1 = /hello/;let re2 = /hello/i;let string = \"Hello\";// 不忽略大小写console.log(re1.test(string)); // false// 忽略大小写console.log(re2.test(string)); // true 第三个标志 m 表示多行模式，它只会影响 ^,$，如果不是多行模式，那么 ^, $ 就表示字符串的开头和结尾，如果是多行模式，那么 ^,$ 就表示每一行的开头和结尾。 非多行模式 let string = \"I \\nlove \\njava\";// 非多行 ^,$ 表示字符串的开头和结尾console.log(string.replace(/^|$/g, \"#\")); 输出如下 #I love java# 多行模式 let string = \"I \\nlove \\njava\";// 多行模式 ^,$ 表示每一行的开头和结尾console.log(string.replace(/^|$/gm, \"#\")); 输出如下 #I ##love ##java#","tags":[{"name":"JavaScript 正则表达式","slug":"JavaScript-正则表达式","permalink":"https://lastknightcoder.gitee.io/tags/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Spring常见注解","date":"2020-05-21T16:00:00.000Z","path":"/Spring常见注解/","text":"介绍 Spring 框架中的常见注解(NO XML)，在介绍 Spring 注解之前，简要的介绍一下 IoC。 IoC简要介绍IoC(Inverse of Control) 的意思是控制反转，意思就是控制权发生转换，以前我们需要某个类的对象，都是直接 new 出来的，现在有了IoC，对象创建的控制权交给 Spring，如果我们需要某个对象，向 IoC 容器拿，如下 上面将 Dog 类对象放入容器的过程我们成为注入，容器我们一般称为 IoC 容器或者 Spring 容器。上面做的好处可以减少类与类之间的耦合性，耦合性这个词可能高大尚，我举个例子，比如 Dog 类发生了改变，高耦合性意味着如果有类依赖 Dog 类的话，那么相应的该类有可能也要发生改变，如果耦合度低的话，也就是根本察觉不到自己依赖了 Dog 类，根本就不需要改变。 我们在像容器要某个对象时，察觉不到某个类的所在(因为一般使用接口去接收从容器中拿的对象)，比如 Animal animal = ioc.getObject('dog'); 假设 Dog 实现了 Animal 接口，ioc 对象表示 IoC 容器，getObject() 表示从容器中获得对象的方法，而传入的参数表示对象在容器中的 id。如果 Dog 类发生改变(但是他在容器中的 id 是不会变的)，我们获取 Dog 对象的方式还是和上面一样，不需要发生改变。假设如果是直接 new Dog() 的话，如果 Dog 的类名变了，那么所有直接依赖 Dog 类的所有类都要发生改变，这就是低耦合的好处。 注意：要使用 Spring IoC，记得在 pom.xml(Maven) 中导入坐标 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; @Configuration@Configuration 的定义： @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor( annotation = Component.class ) String value() default \"\"; boolean proxyBeanMethods() default true;&#125; 被 @Configuration 修饰的类是 Spring 的配置类，所谓的配置类就是用来配置用的，可以配置扫描哪些包，将这些包下的类注入到 IoC 容器中，也可以配置将特定的类注入到 IoC 容器中。 被 @Configuration 修饰的类也会被注入到 IoC 容器中，@Configuration 有一个 value 值，它是用来设置该类对象在 IoC 容器中的 id，如果不设置，那么默认是类名，不过首字母要改为小写，比如 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configurationpublic class SpringConfiguration &#123;&#125; SpringConfiguration 是 Spring 的配置类，由于 @Configuration 没有配置id，所以它在 IoC 容器中的 id 为 springConfiguration，我们可以在测试类中测试，如下 import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); SpringConfiguration springConfiguration = ac.getBean(\"springConfiguration\", SpringConfiguration.class); System.out.println(springConfiguration); &#125;&#125; AnnotationConfigApplicationContext 可以看做是 IoC 容器，我们传入配置类所在的包 config 给它，它会扫描该包找到配置类，然后根据配置类为容器注入对象，在上面我们在配置类中什么都没有做，所以不会向 IoC 容器注入别的对象。 接着我们通过获得对象的方法 getBean() 获得了配置类 SpringConfiguration 的对象，该方法需要传入在 IoC 容器中的 id，因为没有指定，默认是 springConfiguration。 @ComponentScan@ComponentScan 注解的定义 @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123; @AliasFor(\"basePackages\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class; ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; String resourcePattern() default \"**/*.class\"; boolean useDefaultFilters() default true; ComponentScan.Filter[] includeFilters() default &#123;&#125;; ComponentScan.Filter[] excludeFilters() default &#123;&#125;; boolean lazyInit() default false; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;&#125;) public @interface Filter &#123; FilterType type() default FilterType.ANNOTATION; @AliasFor(\"classes\") Class&lt;?&gt;[] value() default &#123;&#125;; @AliasFor(\"value\") Class&lt;?&gt;[] classes() default &#123;&#125;; String[] pattern() default &#123;&#125;; &#125;&#125; 该注解的作用是扫描包或者类，将扫描到类注入到 IoC 容器中。由上面可见，该类的属性还是挺多的，这里介绍几个重要的属性。 value和basepackages这两个属性放在一起讲是因为他们互为别名 @AliasFor(\"basePackages\")String[] value() default &#123;&#125;;@AliasFor(\"value\")String[] basePackages() default &#123;&#125;; 它们的作用是一样的，规定要扫描哪些包，从定义看，它们的值都是字符串数组，我们在 com.xt.service 下定义 ServiceTest 类如下 package com.xt.service;public class ServiceTest &#123; public void service() &#123; System.out.println(\"service...\"); &#125;&#125; Spring 的配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.xt.service\")public class SpringConfiguration &#123;&#125; 我们在配置类中规定了要扫描的包为com.xt.service，接着我们在测试类中测试 import com.xt.service.ServiceTest;import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); ServiceTest serviceTest = ac.getBean(\"serviceTest\", ServiceTest.class); serviceTest.service(); &#125;&#125; 但是却发生异常，在容器中没有名为 serviceTest 的对象 这是因为即使扫描了 ServiceTest 所在的包，但并不是该包下所有的类都会被注入到容器中，而是被 @Component 注解所修饰的类才会被注入到容器中，所以我们要为 ServiceTest 加上 @Component 注解，如下 package com.xt.service;import org.springframework.stereotype.Component;@Componentpublic class ServiceTest &#123; public void service() &#123; System.out.println(\"service...\"); &#125;&#125; 再次运行测试类，结果如下 注意：@Component 还有几个衍生注解，@Controller，@Service，@Repository，这些注解的作用与 @Component 一毛一样，那为什么要创建这些注解，主要是他们所代表的的语义，@Controller 主要用在 Web 层的类上，@Service 主要用在 Service 层上，而 @Repository 主要用在 Dao 层上，程序员看到某类被什么注解修饰，就可以明白该类的职责是什么了。 如果 @ComponentScan 没有指定任何值，那么默认会扫描该类所在的包及其子包，如 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class SpringConfiguration &#123;&#125; @ComponentScan 没有指定任何值，那么就会默认扫描 config 包下的类及其子包下的类。 basePackageClassesbasePackageClasses 的定义如下： Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;; 该属性的值是一个字节码数组，当设置指定字节码时，会扫描指定字节码所在包及其子包，假设有如下结构 UserServiceImpl 实现了 UserService 接口，二者内容如下 package com.xt.service;public interface UserService &#123; void doService();&#125; package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; Spring 的配置类如下 package config;import com.xt.service.UserService;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackageClasses = UserService.class)public class SpringConfiguration &#123;&#125; 我们配置 basePackageClasses 为 UserService.class，所以会扫描 UserService 所在的包及其子包，所以 UserServiceImpl 会被注入到容器中，我们在测试类中测试如下 import com.xt.service.UserService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); UserService userService = ac.getBean(\"userServiceImpl\", UserService.class); userService.doService(); &#125;&#125; 结果如下 nameGenerator该属性的作用是设置注入到容器中的对象(我们一般称这个对象为 bean)的 id 名称的生成规则，如下 Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; 在上面我们可以看到，默认使用了 BeanNameGenerator 这个类去生成 id 的名称，而生成的规则在上面介绍过，即 id 为类名，不过首字母要小写， Spring 中的有关默认 id 名称生成的部分源码如下 public static String decapitalize(String name) &#123; if (name == null || name.length() == 0) &#123; return name; &#125; if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp; Character.isUpperCase(name.charAt(0)))&#123; return name; &#125; char chars[] = name.toCharArray(); chars[0] = Character.toLowerCase(chars[0]); return new String(chars);&#125; 我们可以看到，如果对于第一个字母和第二个字母都为大写的这种特殊的类名是不会将首字母变为小写的。 除了可以使用默认的生成规则，我们还可以自己自定义 id 的生成规则，在 custom 包下新建 CustomBeanNameGenerator 类，该类的作用就是 id 名称的生成规则，该类需要实现 BeanNameGenerator 接口，详细如下 package custom;import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanNameGenerator;import org.springframework.core.annotation.AnnotationAttributes;import org.springframework.core.type.AnnotationMetadata;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import org.springframework.util.ClassUtils;import org.springframework.util.StringUtils;import java.beans.Introspector;import java.util.Map;import java.util.Set;public class CustomBeanNameGenerator implements BeanNameGenerator &#123; public String generateBeanName(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry) &#123; String beanName = null; // 判断该类是否是由注解注入的 if (beanDefinition instanceof AnnotatedBeanDefinition) &#123; // 如果是强转为 AnnotatedBeanDefinition 以获得有关注解的信息 AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition; // 获得注解的信息 AnnotationMetadata annotationMetadata = annotatedBeanDefinition.getMetadata(); // 获得所有注解 Set&lt;String&gt; types = annotationMetadata.getAnnotationTypes(); // 遍历所有注解 for (String type: types) &#123; // 获得注解的属性 AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(annotationMetadata.getAnnotationAttributes(type, false)); // 如果该注解为Component或其衍生注解(暂不考虑 JSR 规范，如 @Resource)且value属性有值 // 并且 annotationAttributes 不为null if (annotationAttributes != null &amp;&amp; isStereotypeWithNameValue(type, annotationMetadata.getMetaAnnotationTypes(type), annotationAttributes)) &#123; // 获得 value 属性的值 Object value = annotationAttributes.get(\"value\"); // 如果value为String，则强转 if (value instanceof String) &#123; String strValue = (String) value; // value 值长度不为 0 if (StringUtils.hasLength(strValue)) &#123; // 如果 beanName 有值，说明已经设置过了 此时 value 与 beanName 不同，说明产生了冲突，抛出异常 if (beanName != null &amp;&amp; !strValue.equals(beanName)) &#123; throw new IllegalArgumentException(\"多个注解设置了value，产生了冲突\"); &#125; else &#123; beanName = strValue; &#125; &#125; &#125; &#125; &#125; &#125; // 没有 Component 及其衍生注解或者没有设置 value 值，则采用默认自定义的类名生成规则 return beanName != null ? beanName : buildDefaultBeanName(beanDefinition); &#125; // 判断该注解是否是Component及其衍生注解 并且有 value 属性 private boolean isStereotypeWithNameValue(String annotationType, Set&lt;String&gt; metaAnnotationTypes, @Nullable Map&lt;String, Object&gt; attributes) &#123; boolean isStereotype = annotationType.equals(\"org.springframework.stereotype.Component\") || metaAnnotationTypes.contains(\"org.springframework.stereotype.Component\") || annotationType.equals(\"javax.annotation.ManagedBean\") || annotationType.equals(\"javax.inject.Named\"); return isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(\"value\"); &#125; // 默认 bean id 生成 private String buildDefaultBeanName(BeanDefinition beanDefinition) &#123; // 获得全限定类名，如com.xt.service.impl.UserServiceImpl String beanClassName = beanDefinition.getBeanClassName(); // 获得类名 如UserServiceImpl String shortClassName = ClassUtils.getShortName(beanClassName); // 默认生成规则为 my + 类名 return \"my\" + shortClassName; &#125;&#125; 上面的 id 生成规则为如果 @Component 及其衍生注解设置了 id 名称，则使用设置的名称，否则默认的 id 名称为 my + 类名。现在将 SpringConfiguration 的 @ComponentScan 的 nameGenerator 设置为 CustomBeanNameGenerator.class，如下 package config;import com.xt.service.UserService;import custom.CustomBeanNameGenerator;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(nameGenerator = CustomBeanNameGenerator.class, basePackages = \"com.xt.service.impl\")public class SpringConfiguration &#123;&#125; UserServiceImpl 的内容如下 package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 可见使用 @Service 修饰了，但是没用设置 value 值，所以默认生成的 id 是 myUserServiceImpl，在测试类中测试如下 import com.xt.service.UserService; import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); // id 已经改为了 myUserServiceImpl UserService userService = ac.getBean(\"myUserServiceImpl\", UserService.class); userService.doService(); &#125;&#125; 输出如下 可见我们的自定义 id 生成规则生效了，现在修改 UserServiceImpl 如下，这次设置 id 值 package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Service;@Service(\"userService\")public class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 根据我们的规则，这时的 id 名为设定的值，即 userService，修改测试类 UserService userService = ac.getBean(\"userService\", UserService.class); 在此修改 UserServiceImpl，这次使用多个注解修饰，如下 package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;@Service(\"userService\")@Component(\"userServiceImpl\")public class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 运行测试类，这时会抛出异常，如下 useDefaultFilters在 @ComponentScan 中有一个属性 useDefaultFilters boolean useDefaultFilters() default true; 它的值默认为 true，即如果被扫描的类被 @Component，@Controller，@Service，@Repository这四个注解修饰时，那么将该类对象注入到容器中，如果为 false，那么被这四个注解修饰的类不会被添加到容器中(但是有可能通过其他注解或属性将该类添加到容器中，如 includeFilters，@Import)。 includeFiltersincludeFilters 属性的作用是允许符合过滤规则的类对象注入到容器中，它的值是一个 Filter 注解 @Retention(RetentionPolicy.RUNTIME)@Target(&#123;&#125;)public @interface Filter &#123; FilterType type() default FilterType.ANNOTATION; @AliasFor(\"classes\") Class&lt;?&gt;[] value() default &#123;&#125;; @AliasFor(\"value\") Class&lt;?&gt;[] classes() default &#123;&#125;; String[] pattern() default &#123;&#125;;&#125; 该注解有一个 type 属性，它的默认取值为 FilterType.ANNOTATION，表示过滤的规则为注解，如果我们设置 value 属性为某注解的字节码对象，那么被该注解修饰的类对象可以注入到容器中，比如允许自定义 @MyAnno 注解所修饰的类注入到容器中 @ComponentScan(includeFilters = @ComponentScan.Filter(MyAnno.class)) 在扫描的类中，如果该类被自定义注解 @MyAnno 修饰，那么该类对象会被注入到容器中。 excludeFilters与 includeFilters 的作用相反，对于符合过滤规则的类对象不能被注入到容器中，如 @ComponentScan(excludeFilters = @ComponentScan.Filter(Service.class)) 上面的注解的作用是，扫描到的类如果被 @Service 修饰，那么该类对象不能被加入到容器中。 在上面我们知道 Filter 注解中，它的 type 属性为 FilterType.ANNOTATION，即被某注解修饰，他会(includeFilters)/不可以(excludeFilters)加入到容器中，其实 type 还可以有多种取值，如下 package org.springframework.context.annotation;public enum FilterType &#123; ANNOTATION, ASSIGNABLE_TYPE, ASPECTJ, REGEX, CUSTOM; private FilterType() &#123; &#125;&#125; 在这里我们在介绍 FilterType.CUSTOM，这表示我们可以自定义过滤规则，定义过滤规则的类需要实现 TypeFilter 接口。在 custom 中新建 CustomFilter 类 package custom;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.core.type.filter.TypeFilter;import java.io.IOException;public class CustomFilter implements TypeFilter &#123; public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; return true; &#125;&#125; 修改配置类如下 package config;import custom.CustomFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.stereotype.Service;@Configuration@ComponentScan( basePackages = \"com.xt.service\", includeFilters = @ComponentScan.Filter( type = FilterType.CUSTOM, classes = CustomFilter.class ))public class SpringConfiguration &#123;&#125; 因为 CustomFilter 实现的 match 始终返回 true，所以被扫描到的类对象会被无条件的注入到容器中，我们修改 com.xt.service.impl.UserServiceImpl 如下 package com.xt.service.impl;import com.xt.service.UserService;public class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 该类没有被任何注解修饰，就是一个普通的类，但是它的对象还是会注入到容器中，测试类如下 import com.xt.service.UserService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); UserService userService = ac.getBean(\"userServiceImpl\", UserService.class); userService.doService(); &#125;&#125; 输出为 @Bean对于我们自己写的类，我们可以通过 @Component 及其衍生注解，使得被扫描到时被注入到容器中，但是对于第三方的类库，由于已经被编译为了字节码，我们已经无法修改，即不能再别人的源码上加上注解，那么我们如果想将第三方类库对象注入到容器，我们该怎么办呢，使用 @Bean 可以解决这个问题。@Bean 的定义为 @Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Bean &#123; @AliasFor(\"name\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] name() default &#123;&#125;; /** @deprecated */ @Deprecated Autowire autowire() default Autowire.NO; boolean autowireCandidate() default true; String initMethod() default \"\"; String destroyMethod() default \"(inferred)\";&#125; 以数据源对象 DataSource 对象为例，首先导入坐标 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置类如下 package config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;@Configurationpublic class SpringConfiguration &#123; @Bean public DataSource createDataSource() &#123; return new DriverManagerDataSource(); &#125;&#125; 在扫描配置类时，会扫描配置类中被 @Bean 注解的方法，会将该方法返回的对象注入到容器中，这是默认的 id 名称为方法名。测试类如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;import javax.sql.DataSource;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); DataSource dataSource = ac.getBean(\"createDataSource\", DataSource.class); System.out.println(dataSource); &#125;&#125; 输出为 可见容器中有 DataSource 对象了。 如果被 @Bean 注解的方法重载了的话，那么会将重载的方法返回的对象注入容器，如 package config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;@Configurationpublic class SpringConfiguration &#123; @Autowired private DataSource dataSource; @Bean public DataSource createDataSource() &#123; return new DriverManagerDataSource(); &#125; @Bean public JdbcTemplate createJdbcTemplate() &#123; System.out.println(\"无参函数\"); return new JdbcTemplate(dataSource); &#125; @Bean public JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; System.out.println(\"有参函数\"); return new JdbcTemplate(dataSource); &#125;&#125; 有两个 createJdbcTemplate 方法，根据上面所说，重载的方法，即下面那个有参数的函数返回的对象会被注入到容器中，可以在测试类中测试如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); JdbcTemplate jdbcTemplate = ac.getBean(\"createJdbcTemplate\", JdbcTemplate.class); System.out.println(jdbcTemplate); &#125;&#125; name和value@AliasFor(\"name\")String[] value() default &#123;&#125;;@AliasFor(\"value\")String[] name() default &#123;&#125;; 按照上面的定义，name 和 value 互为别名，它们的作用就是设置注入到容器对象的 id 名称。 autowireCandidateboolean autowireCandidate() default true; 该属性的作用与 @Autowired 有关，当我们使用 @Autowired 自动注入时，如 @Autowiredprivate DataSource dataSource; 容器会将其中的 dataSource 对象注入到成员变量中，但是如果 autowireCandidate 设置为 false，那么该对象就不能使用 @Autowired 自动注入，如 @Autowiredprivate DataSource dataSource;@Bean(autowireCandidate = false)public DataSource createDataSource() &#123; return new DriverManagerDataSource();&#125; 这时就不能将 dataSource 对象通过 @Autowired 注解自动注入到成员变量 dataSource 中，再次运行测试代码，会抛出异常。 @Import在实际的开发中，可能有多个配置类，比如数据库的配置类，那么主配置类就要导入数据库配置类的配置，这时就需要用到 @Import 注解。@Import 注解的定义如下 @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123; Class&lt;?&gt;[] value();&#125; @Import 注解的作用是导入 value 属性所指明的类，将这些类对象注入到容器中，如有下面的数据库配置类 package config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfiguration &#123; @Bean(\"dataSource\") public DataSource createDataSource() &#123; return new DriverManagerDataSource(); &#125; @Bean(\"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 我们在主配置类中导入该配置类 package config;import org.springframework.context.annotation.Import;@Configuration@Import(JdbcConfiguration.class)public class SpringConfiguration &#123;&#125; 我们在导入 JdbcConfiguration 时，会扫描 JdbcConfiguration 中的方法，将被 @Bean 注解的方法返回的对象注入到容器中，所以这时 DataSource 对象和 JdbcTemplate 对象会被注入到容器中，在测试类测试如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); DataSource dataSource = ac.getBean(\"dataSource\", DataSource.class); JdbcTemplate jdbcTemplate = ac.getBean(\"jdbcTemplate\", JdbcTemplate.class); assert dataSource != null; assert jdbcTemplate != null; &#125;&#125; 运行测试类顺利运行，没有报错 JdbcConfiguration 它也会被注入容器中，这时它的 id 为它的全限定类名，而不是类名首字母小写，即config.JdbcConfiguration ImportSelector当我们需要动态的决定导入哪些类时，或者需要大量导入类时，我们可以为 @Import 传入自定义导入类，该类需要实现 ImportSelector 接口。该接口中有一个方法 String[] selectImports(AnnotationMetadata annotationMetadata)，该方法返回一个字符串数组，这个数组包含的是要添加到容器中的类名。 因为我们过滤规则使用 AspectJ 表达式，所以需要导入相关坐标 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; 现在我们完成这么一个功能，读取配置文件中的过滤规则和要扫描的包，将扫描包中符合过滤规则的类对象添加到容器中，在 resources 下新建 customImport.properties 如下 custom.expression=com.xt.service.impl.*custom.basePackage=com.xt 过滤规则使用 ASPECTJ 格式的过滤规则，扫描的包为 com.xt，新建类 custom.CustomImport 如下 package custom;import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.io.support.PropertiesLoaderSupport;import org.springframework.core.io.support.PropertiesLoaderUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AspectJTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.HashSet;import java.util.Properties;import java.util.Set;public class CustomImport implements ImportSelector &#123; // 使用 AspectJ 表达式表示过滤规则 private String expression; // 扫描的包 private String basePackage; public CustomImport() &#123; // 读取配置文件 初始化 try &#123; // 根据配置文件获得过滤规则和扫描的包 Properties properties = PropertiesLoaderUtils.loadAllProperties(\"customImport.properties\"); expression = properties.getProperty(\"custom.expression\"); basePackage = properties.getProperty(\"custom.basePackage\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 实现的方法 public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false); // 根据 aspectj 表达式转换为对应的过滤器 TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImport.class.getClassLoader()); // 将过滤器添加到扫描器中 scanner.addIncludeFilter(typeFilter); // 创建 Set 集合保存扫描到的符合过滤规则的类 Set&lt;String&gt; classes = new HashSet&lt;String&gt;(); // 使用过滤器扫描指定包，得到符合过滤规则的类 并添加到 classes 中 scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName())); // 将 classes 转换为字符串数组返回 return classes.toArray(new String[classes.size()]); &#125;&#125; 根据上面的过滤规则，只有 UserServiceImpl 会被添加到容器中(除配置类)，在测试类中测试一番 import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); String[] names = ac.getBeanDefinitionNames(); for (String name: names) &#123; System.out.println(name); &#125; &#125;&#125; 测试类是获得容器所有对象的 id，并打印出来，如下 除了前面五个做初始化工作的对象以及配置类对象，只有 UserServiceImpl 被添加到容器中，这次我们修改过滤规则为 custom.expression=com.xt..*custom.basePackage=com.xt Aspectj 表达式为将 com.xt 包及其子孙包下的所有类都添加到容器中，再次运算测试类，输出为 这时 com.xt.utils.Logger 对象也被添加到容器中了。 注意：上面的 UserServiceImpl 和 Logger 都没有使用任何注解进行修饰，就是一个普通的 Java 类。 ImportBeanDefinitionRegistrarImportBeanDefinitionRegistrar 的功能同 ImportSelector，不过二者的返回值不同，ImportSelector 返回一个要添加到容器中类名名称组成的数组，而 ImportBeanDefinitionRegistrar 什么都不返回，说明在 ImportBeanDefinitionRegistrar 内部已经将扫描包下符合规则的类添加到容器中去了。现在我们要实现与上面相同的功能，新建 custom.CustomImportBeanDefinitionRegistrar，如下 package custom;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.io.support.PropertiesLoaderUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AspectJTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.Properties;public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; private String expression; private String basePackage; public CustomImportBeanDefinitionRegistrar() &#123; try &#123; Properties properties = PropertiesLoaderUtils.loadAllProperties(\"customImport.properties\"); expression = properties.getProperty(\"custom.expression\"); basePackage = properties.getProperty(\"custom.basePackage\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 得到扫描器 ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false); // 得到过滤器 TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader()); scanner.addIncludeFilter(typeFilter); // 扫描指定包 将符合过滤规则的类对象直接注入到容器中 scanner.scan(basePackage);&#125; 该类的大部分工作与 CustomImport 是一样的，就是最后使用了 ClassPathBeanDefinitionScanner 对象直接扫描包，将符合过滤规则的类对象注入到容器中。配置文件和配置类如下 custom.expression=com.xt..*custom.basePackage=com.xt package config;import custom.CustomImportBeanDefinitionRegistrar;import org.springframework.context.annotation.Import;@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125; 测试类与上面相同，运行测试类，结果如下 与 ImportSelector 实现的效果相同，不过有一点不同的是，ImportSelector 的 id 生成规则为全限定类名，而 ImportBeanDefinitionRegistrar 的 id 为类名首字母小写。 @PropertySource@PropertySource 注解的作用是用来读取资源文件，该注解的定义如下 @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource &#123; String name() default \"\"; String[] value(); boolean ignoreResourceNotFound() default false; String encoding() default \"\"; Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;&#125; 他不仅可以读取 properties 文件，还可以读取 xml 文件，甚至可以通过自定义 yml 文件解析器读取 yml 文件。 主配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.PropertySource;@Configuration@PropertySource(\"jdbc.properties\")@Import(&#123;JdbcConfig.class&#125;)public class SpringConfiguration &#123;&#125; 在主配置类中读取了配置文件 jdbc.properties，配置文件和 JDBC 配置类 JdbcConfig 如下所示 jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/sbjdbc.username=rootjdbc.password=root package config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(\"dataSource\") public DataSource createDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean(\"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 我们将通过 PropertySource 读取到的资源，通过 @Value 注解，以 Spring EL 表达式的形式注入到了成员变量中。同时也可以读取 xml 文件，我们新建 jdbc.xml， 内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;entry key=\"jdbc.driver\"&gt;com.mysql.jdbc.Driver&lt;/entry&gt; &lt;entry key=\"jdbc.url\"&gt;jdbc:mysql://localhost:3306/sb&lt;/entry&gt; &lt;entry key=\"jdbc.username\"&gt;root&lt;/entry&gt; &lt;entry key=\"jdbc.password\"&gt;root&lt;/entry&gt;&lt;/properties&gt; 修改 @PropertySource 的值 @PropertySource(\"jdbc.xml\") 由上面可以看出，xml 文件相对于 properties 有更加明显的层级关系，结构比较清楚，但是这种优点的代价就是冗余性性很高，为了表达真正有用的信息，加入很多无用的内容。为了整合 properties 和 xml 的优点，人们提出了一个新的格式的文件 YAML(文件后缀名为.yml)，它不仅书写简单，并且可以表达层级关系，新建 jdbc.yml 如下 jdbc: driver: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/sb username: root password: root 但是 @PropertySource 默认只支持 propeties 和 xml 文件的读取，如果要支持 yml 文件的读取，就需要自己定义解析类，我们可以借助第三方的类库来解析 yml 文件，在 pom.xml 中导入解析 yml 类库的坐标 &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.23&lt;/version&gt;&lt;/dependency&gt; 然后在配置类中修改如下 @PropertySource(value = \"jdbc.yml\", factory = CustomYAMLPropertySourceFactory.class) 新建 custom.CustomYAMLPropertySourceFactory 实现 PropertySourceFactory 接口，如下 package custom;import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.core.env.PropertiesPropertySource;import org.springframework.core.env.PropertySource;import org.springframework.core.io.support.EncodedResource;import org.springframework.core.io.support.PropertySourceFactory;import java.io.IOException;import java.util.Properties;public class CustomYAMLPropertySourceFactory implements PropertySourceFactory &#123; public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource encodedResource) throws IOException &#123; YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean(); // 解析 yaml 文件 factoryBean.setResources(encodedResource.getResource()); // 将解析的文件转换为 properties Properties properties = factoryBean.getObject(); // spring 默认能解析 properties，使用 spring 源码的类去解析 return name != null ? new PropertiesPropertySource(name, properties) : new PropertiesPropertySource(encodedResource.getResource().getFilename() ,properties); &#125;&#125; @DependsOn有的时候一个 Bean 对象需要在另一个 Bean 对象注入到容器之后才能注入到容器，比如 One 类对 Two 类有依赖关系，在逻辑上需要先注入 Two 对象，One, Two 的定义如下 package example;import org.springframework.stereotype.Component;@Componentpublic class One &#123; public One() &#123; System.out.println(\"one被创建了\"); &#125;&#125; package example;import org.springframework.stereotype.Component;@Componentpublic class Two &#123; public Two() &#123; System.out.println(\"Two被创建了\"); &#125;&#125; 主配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"example\")public class SpringConfiguration &#123;&#125; 测试类如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); &#125;&#125; 运行输出为 One 先于 Two 先注入容器中，如果需要 One 在 Two 后，可以加上 @DependsOn,如下 package example;import org.springframework.context.annotation.DependsOn;import org.springframework.stereotype.Component;@Component@DependsOn(\"two\")public class One &#123; public One() &#123; System.out.println(\"one被创建了\"); &#125;&#125; 再次运行测试类 这时 Two 类对象先被创建。 @Lazy@Lazy 是用来延迟加载时机的，一般我们在初始化容器时，就会将扫描到的类对象注入到容器中，如果对于一个大型的项目，可能会有成千上万个类，如果在一开始就将全部的对象注入到容器，会大大的延缓项目的启动时间，所以为了提高效率，我们可以在需要该类对象时才把对象注入到容器中，还是在上例中，新建 Three package example;import org.springframework.context.annotation.Lazy;import org.springframework.stereotype.Component;@Componentpublic class Three &#123; public Three() &#123; System.out.println(\"three被创建了\"); &#125;&#125; 运行测试类 import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); &#125;&#125; 输出为 我们只是在测试类中初始化了容器，但是 Three 类对象已经被注入到容器中了。这时我们对 Three 使用 @Lazy 注解，再次运行测试类 这时 Three 类对象并没有被创建，只有我们第一次向容器获取所需对象时，才会被注入到容器中，修改测试类如下 import example.Three;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); System.out.println(\"===========================\"); Three three = ac.getBean(\"three\", Three.class); &#125;&#125; 结果为 注意：@Lazy 注解对于范围为单例的类有效。 @Conditional@Conditional 注解是用来设定注入条件的，当扫描到某类或者方法时，是否将该类对象或返回对象注入到容器，根据 @Conditional 指定的条件决定。@Conditional 注解的定义如下 @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Conditional &#123; Class&lt;? extends Condition&gt;[] value();&#125; 该注解只有一个 value 属性，该属性的值是一个继承了 Condition 接口的字节码对象，Condition 接口有一个 match 方法，该方法返回一个布尔值，当返回 true 时，可以将对象注入到容器中，否则不行。 现在我们有两个数据源，一个是 Windows 下的数据源，一个是 Linux 下的数据源，现在我们的任务根据操作系统来决定使用哪个数据源注入到容器中，JdbcConfig 类定义如下 package config;import condition.LinuxCondition;import condition.WindowsCondition;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(\"dataSource\") @Conditional(WindowsCondition.class) public DataSource createWindowsDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); // 用以观察哪个数据源被注入到容器中 System.out.println(\"Windows Env\"); return dataSource; &#125; @Bean(\"dataSource\") @Conditional(LinuxCondition.class) public DataSource createLinuxDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); // 用以观察哪个数据源被注入到容器中 System.out.println(\"Linux Env\"); return dataSource; &#125;&#125; 在上面我们对 Windows 和 Linux 的数据源都使用了 Conditional 注解，分别使用 WindowsCondition 和 LinuxCondition 类来决定是否注入到容器中，二类的内容如下 package condition;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class WindowsCondition implements Condition &#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 获得环境对象 Environment environment = context.getEnvironment(); // 获得操作系统名称 String osName = environment.getProperty(\"os.name\"); System.out.println(osName); // 如果包含 Windows 则可以注入 if (osName.contains(\"Windows\")) &#123; return true; &#125; return false; &#125;&#125; package condition;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class LinuxCondition implements Condition &#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment environment = context.getEnvironment(); String osName = environment.getProperty(\"os.name\"); System.out.println(osName); if (osName.contains(\"Linux\")) &#123; return true; &#125; return false; &#125;&#125; 配置类和测试类如下所示 package config;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.PropertySource;@Configuration@PropertySource(\"classpath:jdbc.properties\")@Import(JdbcConfig.class)public class SpringConfiguration &#123;&#125; import org.springframework.context.annotation.AnnotationConfigApplicationContext;import javax.sql.DataSource;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); DataSource dataSource = ac.getBean(\"dataSource\", DataSource.class); &#125;&#125; 运行测试类，输出为 @Profile有的时候我们在不同的环境下注入到容器中的类是不同的，比如开发环境、测试环境和生产环境下三者注入的类是不同的，要实现这样的效果，我们可以使用上面提及的 @Conditional 注解，但是考虑到上述问题比较常见，所以 Spring 为我们提供了 @Profile 注解来实现这样的功能， @Profile 的定义如下 @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; 可以观察到 @Profile 的底层也是使用了 @Conditional 注解，@Profile 注解只有一个属性值 value，它是用来定义环境名称的，比如我们一般使用 dev 代表开发环境，test 代表测试环境，prod 代表生产环境。 在配置好类属于哪个环境后，可以通过容器对象中环境对象中的setActiveProfiles()方法来激活对应的环境，这样只有对应环境的类会被注入到容器中，我们新建三个测试类 package example;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;@Profile(\"dev\")@Componentpublic class Dev &#123; public Dev() &#123; System.out.println(\"开发环境\"); &#125;&#125; package example;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;@Profile(\"test\")@Componentpublic class Test &#123; public Test() &#123; System.out.println(\"测试环境\"); &#125;&#125; package example;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;@Profile(\"prod\")@Componentpublic class Prod &#123; public Prod() &#123; System.out.println(\"生产环境\"); &#125;&#125; 配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"example\")public class SpringConfiguration &#123;&#125; 测试类如下 import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; // 不能传入配置类的所在包 或者配置字节码对象 否则所有三个类都不会被注入 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(); // 设置激活的环境 ac.getEnvironment().setActiveProfiles(\"dev\"); // 设置配置类 ac.register(SpringConfiguration.class); // 刷新容器 ac.refresh(); &#125;&#125; 输出为 自动注入我们一般在 Service 层中会用到 Dao 层中的对象，所以在 Service 中一般会有一个 Dao 层的成员变量，这个对象一般是在容器中的，所以 Service 层需要向容器索取对象，我们可以使用注解使得容器中的对象自动注入到对应的成员变量中，下面就介绍几个常用的自动注入注解。 @Autowired和@Qualifier@Autowired 注解首先会根据成员变量的类型去容器中找对应类型的注解，如果有多个相同类型的对象，那么会使用成员变量的名称作为 id 去容器中寻找对应的对象。 JdbcConfig 类如下 package config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Bean(\"dataSource1\") public DataSource createDataSource1() &#123; return new DriverManagerDataSource(); &#125; @Bean(\"dataSource2\") public DataSource createDataSource2() &#123; return new DriverManagerDataSource(); &#125;&#125; 我们向容器中注入了两个 DataSource 对象，这时我们在 TestAutowired 中使用 @AutoWired 注解，如下 package test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.sql.DataSource;@Componentpublic class TestAutowired &#123; @Autowired DataSource dataSource;&#125; 由于在容器中有两个 DataSource 类型的对象，所以 @Autowired 无法根据类型自动注入，所以 @Autowired 会根据变量名 dataSource 作为 id 去容器中寻找对象注入，但是在容器中并没有 id 为 dataSource 的对象，所以不能够成功注入。 为了解决上面 @Autowired 注解存在的问题，我们可以通过 @Qualifier 注解指定自动注入的 id 名称，如 @Autowired@Qualifier(\"dataSource1\")DataSource dataSource; 注意： @Qualifier 注解不能单独使用，必须配合 @Autowired 注解或后面提到的 @Inject 注解使用 @Autowired 有一个属性为 required，该属性是规定是否要求一定要注入成功，默认为 true，即必须注入成功，否则抛出异常。 @Inject和@Named使用 @Inject 和 @Named 需要导入对象的坐标 &lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; @Inject 注解是 JSR330 规范规定的注解，它的作用也是实现自动注入注解，它的规则是根据类型自动注入，如果有多个相同类型的对象，那么会保错，与 @Autowired 注解不同，并不会以变量名作为 id 继续寻找。 @Named 注解也是 JSR330 规范规定的注解，它可以和 @Inject 注解配合使用，它是用来设置在容器中的 id 名称的，与 @Qualifier 注解一样，@Named 注解不能单独使用，必须配合 @Autowired 注解或 @Inject 使用 @Inject@Named(\"dataSource1\")DataSource dataSource; @Resource@Resource 注解是 JSR250 规范规定的注解，它有一个 name 属性，该属性是用来指定自动注入对象在容器中的 id，同 @Named 和 @Qualifier 不同，他可以单独使用，如 @Resource(name = \"dataSource1\")DataSource dataSource; @Primary当我们仅仅使用 Autowired 时，如果容器中有多个相同类型的对象且容器没有与成员变量名相同的对象，那么注入是会失败的，如 package config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Bean public DataSource createDataSource1() &#123; return new DriverManagerDataSource(); &#125; @Bean public DataSource createDataSource2() &#123; return new DriverManagerDataSource(); &#125;&#125; @AutowiredDataSource dataSource; 这时自动注入会失败，这时我们可以使用 @Primary 来表明那个对象时主要的，当有多个类型相同的对象时，优先注入该对象，如 @Bean@Primarypublic DataSource createDataSource1() &#123; return new DriverManagerDataSource();&#125; 这时使用 @Autowired 注解，会默认注入这个 DataSource 对象。 @PostConstruct和@PreDestroy在创建 Bean 后，可能需要做一些初始化的工作，这时我们可以使用 @PostConstruct 注解，在对象被销毁前，可能需要做一些资源的回收工作，这时我们可以使用 @PreDestroy，这两个注解只能放在方法上，新建一个 utils.Logger 类如下 package utils;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Componentpublic class Logger &#123; public Logger() &#123; System.out.println(\"对象创建\"); &#125; @PostConstruct public void init() &#123; System.out.println(\"初始化工作...\"); &#125; @PreDestroy public void destroy() &#123; System.out.println(\"资源回收工作...\"); &#125;&#125; 我们使用 @PostContruct 注解了 init 方法和使用 PreDestroy 注解了 destroy 方法，这意味着当创建Logger 对象后会执行 init 方法进行初始化，在 Logger 对象销毁前，会执行 destroy 执行资源回收工作。现进行验证，配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"utils\")public class SpringConfiguration &#123;&#125; 测试类如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; // 在创建容器时 会创建 Logger 对象并注入，创建对象后会执行 init 方法 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); // 销毁容器， Logger 对象会被一同销毁 在销毁前会执行 destroy 方法 ac.close(); &#125;&#125; 结果如下 参考资料 Spring高级之注解驱动开发 @Profile进行环境切换","tags":[{"name":"Java Spring 注解开发","slug":"Java-Spring-注解开发","permalink":"https://lastknightcoder.gitee.io/tags/Java-Spring-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"}]},{"title":"Ajax跨域","date":"2020-04-21T16:00:00.000Z","path":"/Ajax跨域/","text":"同源策略什么是同源策略：同 domain(或IP)，同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源，这种安全限制称为同源策略。我们看几个例子判断两个链接是否是同源 url1 url2 是否同源 原因 http://example.com:8080 http://example.com:80 否 端口不同 http://example.com:8080 https://example.com:8080 否 协议不同 http://www.baidu.com http://www.taobao.com 否 域名不同 http://127.0.0.1:8080 http://localhost:8080 否 域名与域名对应的IP地址不同源 http://example.com:8000/a.js http://example.com:8000/b.js 是 协议，域名，端口相同，子域名不同 我们首先启动一个 Node 程序作为服务端，启动在本地的 4000 端口，如下 const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; res.end('hello world');&#125;)server.listen(4000, function() &#123; console.log('服务启动在4000端口...');&#125;) 现在我们同时在本地的 5501 端口启动一个静态服务器显示网页，在网页中我们发起一个 ajax 请求，向本地的 4000 端口请求数据，即我们刚刚搭的 Node 程序 const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; xhr.onerror = function() &#123; console.error('出错了') &#125;xhr.open('get', 'http://127.0.0.1:4000');xhr.send(null); 这个时候我们打开控制台，发现给出这样的错误信息 因为网页的地址 http://127.0.0.1:5501 与服务器的地址 http://127.0.0.1:4000 它们的端口是不同的，所以它们是不同源的，所以这个请求是跨域的请求，而浏览器是不允许跨域请求的。那么浏览器为什么会提出同源策略，这是出于安全的考虑。同源策略包括两种： DOM 同源策略：禁止对不同源页面 DOM 进行操作，这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的 XMLHttpRequest 同源策略：禁止使用 xhr 对象向不同源的服务器地址发起 HTTP 请求 在这里我们只关注 Ajax 跨域，我们来看一下如果没有同源策略会有什么危害： 用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识 用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 Ajax 请求代码 http://evil.com 向 http://mybank.com 发起 Ajax HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据，此时数据就泄露了 而且由于 Ajax 在后台执行，用户无法感知这一过程 所以有了同源策略我们才能够安全的上网，但是很多时候我们还是有跨域的需求的，并且现在随着前后端分离的流行，前端与后端不同源是很有可能，所以迫切需要解决这个问题，下面就介绍两种跨域的方法。 JSONP同源策略提升了 Web 前端的安全性，但牺牲了 Web 拓展上的灵活性。设想若把 html、js、css、flash、image 等文件全部布置在一台服务器上，小网站这样凑活还行，大中网站如果这样做服务器根本受不了的。所以，现代浏览器在安全性和可用性之间选择了一个平衡点。在遵循同源策略的基础上，选择性地为同源策略开放了后门， 例如 img script style 等标签，都允许垮域引用资源，严格说这都是不符合同源要求的。 正是利用 script 标签引用的资源没有同源策略的限制，我们可以通过 script 向服务器发送请求，而服务器返回一个回调，将数据作为参数返回，这一样就可以拿到想要的数据。可能你现在不能明白是什么意思，看下面的代码，我们在页面中添加下面的内容 &lt;script&gt; function getData(data) &#123; console.log(data); &#125; // 创建一个 script 标签用以请求数据 let scriptElement = document.createElement('script'); // 设置请求的地址 并且设置了处理数据的回调函数名称 scriptElement.src = 'http://127.0.0.1:4000?callback=getData'; // 这一步很重要，不设置的话浏览器会报错 Uncaught SyntaxError: Unexpected identifier scriptElement.setAttribute('type', 'text/javascript'); // 将这个 script 标签添加到 body 中 document.getElementsByTagName('body')[0].appendChild(scriptElement);&lt;/script&gt; Node 服务端的代码 const http = require('http');const querystring = require('querystring');const server = http.createServer();server.on('request', function(req, res) &#123; let qs = querystring.parse(req.url.split('?')[1]); // 解析请求参数 let data = \"Hello World\"; // 返回的数据 // 一定要在 $&#123;data&#125; 两端加上双引号，否则浏览器得到的是 getData(Hello World)会报错 res.end(`$&#123;qs.callback&#125;(\"$&#123;data&#125;\")`); // 即getData(data)&#125;)server.listen(4000, function() &#123; console.log('服务启动在4000端口...');&#125;) 结果如下 我来理一下上面的步骤 首先创建了一个函数 getData，该函数的作用是用来处理数据的，接收的那个参数就是数据 function getData(data) &#123; console.log(data);&#125; 创建一个 script 标签，并且设置了请求的地址，以及将处理数据函数的名称即 getData 作为参数传入 script.src = 'http://127.0.0.1:4000?callback=getData'; 服务器接到请求，将要返回的数据作为传入的回调函数的参数传入 res.end(`$&#123;qs.callback&#125;(\"$&#123;data&#125;\")`); // 即getData(data) script 标签得到服务器返回的数据，即 getData(&quot;Hello World&quot;)，script 得到的数据是可执行的代码，所以会执行 getData() 方法，这样数据 Hello World 就作为参数传递给了 getData() 优点： 使用简便，没有兼容性问题，是目前最流行的跨域方法 缺点： 只支持 GET 请求，并且代码是从其他域得到的，不排除可能有恶意代码，所以使用该方法，服务端必须确保值得信任 要确定 JSONP 请求失败并不容易 CORSCORS(Cross-origin resource sharing，跨域资源共享) 是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 对于开发者来说，我们只要正常的发出 Ajax 请求即可，与之前没有任何区别，如 const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; xhr.onerror = function() &#123; console.error('出错了') &#125;xhr.open('get', 'http://127.0.0.1:4000');xhr.send(null); 但是在服务端，我们要设置一下信赖的请求来源，如下 const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; // 表示来自 http://127.0.0.1:5501 的请求可以拿到数据 res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5501') res.end('hello world');&#125;)server.listen(4000, function() &#123; console.log('服务启动在4000端口...');&#125;) 除了可以设置请求来源，还可以设置允许的方法，允许的头部等等 响应头 作用 Access-Control-Allow-Origin 设置允许的请求来源，如果允许任意来源，可以设置为 * Access-Control-Allow-Methods 允许的方法，多个以逗号分隔，如 GET, POST Access-Control-Allow-Headers 允许的请求头，多个以逗号分隔 浏览器将 CORS 请求分为两类，分别为简单请求和非简单请求。如果满足以下两类请求，就是简单请求 请求方法是以下三种方法之一： GET POST HEAD HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 如果不满足以上的两大条件，那么就是非简单请求，而浏览器对于简单请求和非简单请求的处理是不一样的。 简单请求 在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：Origin: http://127.0.0.1:5501 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息(如果是公共资源，可以回发 *)，例如：Access-Control-Allow-Origin：http://127.0.0.1:5501 没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，注意，请求和响应都不包含 cookie 信息 如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true 非简单请求 非简单请求可能对服务器数据产生副作用，浏览器必须首先使用 OPTIONS 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求， Origin：与简单的请求相同 Access-Control-Request-Method: 请求自身使用的方法 Access-Control-Request-Headers: (可选)自定义的头部信息，多个头部以逗号分隔 Origin: http://127.0.0.1:5501Access-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求，一旦服务器通过 Preflight 请求，允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。 优点： CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护 支持所有类型的 HTTP 请求 缺点： 存在兼容性问题，特别是 IE10 以下的浏览器 第一次发送非简单请求时会多一次请求 参考链接 跨域的那些事儿 浏览器同源策略及跨域的解决方法","tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://lastknightcoder.gitee.io/tags/Ajax/"}]},{"title":"JavaScript柯里化","date":"2020-04-20T16:00:00.000Z","path":"/JavaScript柯里化/","text":"柯里化介绍函数柯里化指的是函数处理一部分的参数，然后返回一个函数来处理剩余的参数，如比如有一个加法函数如下 function add(x, y) &#123; return x + y;&#125;add(1, 2); // 3 现在如果这个函数被柯里化，那么我们可以如下使用 const increment = add(1); // 接收第一个参数，返回一个函数处理第二个参数increment(2); // 3increment(4); // 5 柯里化实现现在怎么实现这种效果，如果只是针对上面的加法函数，那么可以如下实现 function add(x, y) &#123; return function(y) &#123; return x + y; &#125;&#125; 但是这种方法明显只对加法函数有效，我们现在是想设计一个函数，它接收一个函数为参数，作用就是把这个函数柯里化，并将这个柯里化的函数返回，比如 curryAdd = curry(add); // 接收add函数，将函数add柯里化const increment = curryAdd(1);increment(2); // 3increment(4); // 5 首先实现一个简单版本的 function curry(fn, ...args1) &#123; return function(...args2) &#123; fn(...args1, ...args2) &#125;&#125; 但是这个函数明显有一个缺陷，那就是只能传入两次参数，怎么解决，肯定使用递归了 function curry(fn, ...args1) &#123; if (fn.length == args1.length) &#123; return fn(...args1); &#125; else &#123; return function(...args2) &#123; return curry(fn, ...args1, ...args2) &#125; &#125;&#125; 上面的函数首先判断接收的参数的个数与函数要求参数的个数是否相同，如果相同则直接执行函数，否则返回一个函数来处理剩下的参数，这样就可以实现函数的柯里化。 柯里化应用举例现在来看一下柯里化有什么用处，假设有一个 ajax 请求的函数如下 function ajax(type, url, data) &#123; let xhr = new XMLHttpRequest(); xhr.onReadystateChange = function() &#123; // ... &#125; xhr.open(type, url); xhr.send(data);&#125; 现在我们将这个函数柯里化 let curriedAjax = curry(ajax);let post = curriedAjax('post'); 我们向 curriedAjax 传入一个参数 post，得到一个函数，这个函数的作用是用来发 post 请求的，我们每次发 post 请求时，只需要使用 post 方法即可，这样函数的复用性有了极大的增强，我们可以继续传入参数 let postGoogle = post('https://www.google.com'); 我们又得到了一个函数，该函数的作用是向 https://www.google.com 发送 post 请求，函数的复用性又进一步的提升。 使用过 jQuery 的都知道，可以使用 $.ajax() 这样的通用方法，但是也有 $.get() 和 $.post() 这样的语法糖，但是 jQuery 底部是不是这样实现的就不得而知了。 参考链接 大佬，JavaScript 柯里化，了解一下 JavaScript专题之函数柯里化","tags":[{"name":"JavaScript 柯里化","slug":"JavaScript-柯里化","permalink":"https://lastknightcoder.gitee.io/tags/JavaScript-%E6%9F%AF%E9%87%8C%E5%8C%96/"}]},{"title":"JavaScript闭包","date":"2020-04-17T16:00:00.000Z","path":"/JavaScript闭包/","text":"JavaScript的作用域JavaScript 的作用域有两种 全局作用域 函数作用域 与其他语言不同的是，JavaScript 没有块级作用域，参考以下程序 if (true) &#123; var x = 1;&#125;console.log(x); // 1 上面的变量 x 定义在 if 的语句块中，在其他的语言中，x 在语句块外是访问不到的，但是由于 JavaScript 没有块级作用域，所以变量 x 是全局变量，所以在语句块外也可以被访问到。 注意： 上面的讨论是基于 ES5 的，在 ES6 中，通过关键字 let 或 const 声明的变量，可以实现块级作用域的效果 if (true) &#123; let x = 1;&#125;console.log(x); // not defined JavaScript 作用域链JavaScript 作用域链指的是查找变量的顺序，比如下面的程序 var i = 1;function foo() &#123; var i = 2; function bar() &#123; var i = 3; console.log(i); &#125; bar();&#125;foo(); // 3 在上面的程序中，我们在 bar() 函数中访问了变量 i，这时 bar() 会先在 bar() 函数内部查找是否有变量 i，如果没有，则会去 bar() 函数的上一级作用域即 foo() 函数中寻找，如果还没有，则会去全局作用域寻找，如果没有找到，则会报错变量未定义，所以上述 bar() 函数的作用域链为 bar --&gt; foo --&gt; 全局作用域 编译器会根据作用域链去寻找变量，如果没有找到则会报错。 闭包介绍什么是闭包，简单的说就是允许函数访问并操作函数外部的变量，只要该变量处于该函数的作用域链中，比如 function foo() &#123; var x = 1; return function() &#123; console.log(x); &#125;&#125;var func = foo();func(); // 1 函数 foo() 返回了一个函数，返回的这个函数中访问了变量 x，根据我们的讲解，会根据这个函数的作用域链去寻找这个变量 x，该匿名函数定义时的作用域链 返回的匿名函数 --&gt; foo --&gt; 全局作用域 所以当执行该匿名函数时，会根据上述的作用域链去寻找变量 x，会在 foo 中找到变量 x，所以输出的结果是 1。 你可能会有这样的疑惑，当执行完函数 foo() 后，变量 x 不是应该已经被销毁了吗，为什么还能够被访问。之所以会有这样的想法，可能是受其他编程语言的影响，如 C，Java 等，但是要明白 JavaScript 与这些编程语言不同，至少 Java 不能够返回函数，因为返回的函数还保存着对变量 x 的引用，所以变量 x 在执行完 foo() 之后是不会被清除的，这就是还能够访问 x 的原因。 那接下来看一个例子，看看你是否明白了闭包 for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;, i * 100)&#125; 上面的程序的效果是延时 i * 100 ms 打印输出 i，你可能希望得到下面这样的输出 0123456789 但是真正的结果是 10101010101010101010 这是因为 setTimeout 是一个异步函数，当执行 setTimeout 时，并不会立即执行传入的回调函数，这些回调函数等到延迟时间到了以后，会将这些回调函数放入事件队列中，简单来说，当执行到 setTimeout 函数时，不会有任何的阻碍直接进入下一轮循环，等到循环执行完毕，编译器会取出事件队列中的函数执行(这些回调函数并不是执行到 setTimeout 方法时立即被添加到事件队列中的，而是等到设定的延迟时间后再添加到事件队列中的)，所以当执行这些回调函数时，循环已经执行完毕，变量 i 的值已经变为了 10，这些回调函数根据它的作用域链找到的变量 i 的值就全部是 10 了。 闭包实现私有变量在 JavaScript 中是没有关键字去声明私有变量的，但是我们可以通过闭包来实现这样的效果，如下 function Person () &#123; var name = 'ninja'; this.setName = function (value) &#123; name = value; &#125; this.getName = function () &#123; return name; &#125;&#125;var person = new Person();console.log(person.name); // 访问不到 undefinedconsole.log(person.getName()); // ninjaperson.setName('dummy');console.log(person.getName()); // dummy 通过闭包，setName 和 getName 可以对 name 进行访问和操作，但是却不能够被实例变量 person 访问到，因为 name 并不是 person 的属性，这样我们就实现了私有变量。 闭包处理回调函数假设有这么一个动画函数 var tick = 0;function animateIt(id) &#123; var element = document.getElementById(id); var timer = setInterval(function () &#123; if (tick &lt; 100) &#123; element.style.left = element.style.top = tick + \"px\"; tick++; &#125; else &#123; clearInterval(timer); &#125; &#125;, 10);&#125; 该函数实现在 1s 内将元素向下和向右平移 100px，如下 document.getElementById(\"box1\").addEventListener('click', function () &#123; animateIt(\"box1\");&#125;) 但是当我们同时对两个元素使用动画时，由于二者共享变量 tick，则会导致二者的动画状态发生冲突，所以我们改动如下 function animateIt(id) &#123; var tick = 0; var element = document.getElementById(id); var timer = setInterval(function () &#123; if (tick &lt; 100) &#123; element.style.left = element.style.top = tick + \"px\"; tick++; &#125; else &#123; clearInterval(timer); &#125; &#125;, 10);&#125;document.getElementById(\"box1\").addEventListener('click', function () &#123; animateIt(\"box1\");&#125;)document.getElementById(\"box2\").addEventListener('click', function () &#123; animateIt(\"box2\");&#125;) 我们将 tick 定义在函数内，由于闭包，setInteval 中的回调函数可以访问到tick，并且两个不同id 元素的tick是不同的，不会相互干扰","tags":[{"name":"JavaScript 闭包","slug":"JavaScript-闭包","permalink":"https://lastknightcoder.gitee.io/tags/JavaScript-%E9%97%AD%E5%8C%85/"}]},{"title":"从尾到头打印链表","date":"2020-04-14T16:00:00.000Z","path":"/从尾到头打印链表/","text":"题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下： private static class ListNode &#123; private int value; private ListNode next; public ListNode(int value) &#123; this.value = value; &#125;&#125; 如果只是反过来打印节点的值，那么很简单，只要遍历链表，将节点的值 push 到一个栈里面，因为栈的特点是后进先出，所以最后我们遍历栈，达到的效果就是将链表从尾到头打印，如下 public static void printListReverse(ListNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode cur = root; // 遍历链表 将值添加到栈中 while (cur != null) &#123; stack.push(cur.value); cur = cur.next; &#125; // 遍历栈 打印栈头的值 while (!stack.isEmpty()) &#123; System.out.println(stack.pop()); &#125;&#125; 另外一种方法就是使用递归，对于任意一个节点，反过来打印即先打印下一个节点，然后在打印当前节点，如下 public static void printListReverse2(ListNode root) &#123; // 既是递归退出的条件 也是对传入的链表进行检查 if (root == null) &#123; return; &#125; printListReverse2(root.next); System.out.println(root.value);&#125;","tags":[{"name":"剑指offer 链表","slug":"剑指offer-链表","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8/"}]},{"title":"二维数组中的查找","date":"2020-04-11T16:00:00.000Z","path":"/二维数组中的查找/","text":"题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 首先将这个二维数组看做是一个矩阵，考虑这么一个思路，首先在矩阵中选取一个数，如果要查找的数大于这个数，那么该数应该在选取数字的下方或者右方，如果该数小于选取的数，那么这个数应该在选取数字的上方或者左方，无论怎样，查找的数都会在选取位置的两个区域都出现，并且这两个区域有重叠的部分，这使得问题较为复杂， 现在不妨换一种思路，我们从右上角开始进行查找，如果查找的数比右上角的数小，那么该数只可能在左方，如果查找的数比右上角大，那么该数只可能在下方，查找的数都只会在一个区域出现，要么在左方，要么在下方，每一次查找都会使得查找的区域变小，下面以查找数字5为例 代码如下 public class Test &#123; public static boolean findInMatrix(int[][] matrix, int number) &#123; boolean found = false; // 获得矩阵的行数和列数 int rows = matrix.length; int columns = matrix[0].length; if (matrix != null &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0) &#123; // 从右上角开始查找 int row = 0; int column = columns - 1; // 继续查找的条件 while (row &lt; rows &amp;&amp; columns &gt;= 0) &#123; if (matrix[row][column] == number) &#123; // 找到退出while循环 found = true; break; &#125; else if (matrix[row][column] &gt; number) &#123; // 比右上角小 在左方 column--; &#125; else &#123; // 否则比右上角大 在下方 row++; &#125; &#125; &#125; return found; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;2, 4, 6&#125;, &#123;3, 6, 9&#125;&#125;; boolean found = findInMatrix(matrix, 2); System.out.println(found); &#125;&#125;","tags":[{"name":"数组查找","slug":"数组查找","permalink":"https://lastknightcoder.gitee.io/tags/%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"}]},{"title":"jQuery系统教程","date":"2020-04-07T15:00:00.000Z","path":"/jQuery系统教程/","text":"本篇文章是在完整学习 jQuery 以后，系统整理的教程，大纲如下 jQuery 的核心函数 $, jQuery 操作 jQuery 集合 操作 DOM 元素的属性和类属性 操作样式 操作 DOM 元素(添加，删除…) jQuery 事件 jQuery 显示与隐藏 jQuery 动画 jQuery 扩展及实用函数 Ajax jQuery核心函数jQuery 这个库中最重要的就是它提供的核心函数 jQuery() ，它提供了非常强大的功能，因为这个函数用的十分的频繁，所以提供了 jQuery() 的别名，那就是 $() ，在后面的演示中都将会以 $ 为例，现在我们来看一下该核心函数提供了哪些功能 选择多个 DOM 元素 将 HTML 字符串得解析为一个 DOM 元素 作为入口函数 将 DOM 元素转换为 jQuery 集合 上面有些名词可能没有听过，这里只是感性了解一下，下面就具体讲解。 选择元素考虑下面的 DOM 结构 &lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 如果使用原生的 JavaScript 选择上面的元素的写法如下 document.getElementById(\"box\");document.getElementsByClassName(\"container\")[0];document.getElementsByTagName(\"p\")[0]; 而现在使用 $() 函数，为其传入 CSS 的选择器即可选中元素 $(\"#box\");$(\".container\");$(\"p\"); 使用 $() 得到的是一个集合，即使使用了 id 选择器 #box ，得到也是一个只有一个元素的集合，如下 我们把它称为 jQuery 对象或者 jQuery 集合，在下面我将不会区分二者，可能会混合使用，请注意。由上可见， jQuery 对象的结构像是一个数组，但它不是真正的数组，因为他不是 Array 的实例，只是使用对象来模拟数组， jQuery 对象中的元素(借用数组的概念)是被选择的 DOM 元素。 jQuery 的核心函数支持几乎所有的 CSS 选择器，如 属性选择器 input[value] /* 选择有 value 属性的 input 标签 */input[type='text'] /* 选择 type 为 text 的 input 标签 */a[href^='http://'] /* 选择 href 以 http:// 开头的 a 标签 */a[href$='pdf'] /* 选择 href 以 pdf 结尾的 a 标签 */a[href*='jquery'] /* 选择 href 属性包含 jquery 的 a 标签 */ 伪类选择器 a:firstp:oddp:evenul li:last-child 过滤器 :animated /* 处于动画状态的元素 */:checkbox /* 相当于 input[type='chexkbox'] */:checked /* 选择处于选中状态的多选框或单选框 */:disabled... … 选择器十分的多，由于重点不在于选择器，另外这个也没有什么原理可讲，也就是 API 的使用，随着使用 jQuery 的增多，自然会掌握，所以这里就点到即止。 将 HTML 字符串转化为 jQuery 对象这里首先解释一下什么叫做 HTML 字符串，不给出具体的定义，很好理解，形如下面的字符串就叫做 HTML 字符串 \"&lt;p&gt;123&lt;/p&gt;\"\"&lt;h1&gt;一级标题&lt;/h1&gt;\" 当我们向 jQuery 的核心函数传递这样的字符串时，核心函数会将该字符串解析得到一个 jQuery 对象，如 作为入口函数因为我们一般会在 JavaScript 中操作 DOM ，所以我们一般会等到 DOM 树渲染完毕之后再去执行 JavaScript 代码，所以我们一般把 script 标签放在 body 元素的最后面，或者将代码放在 window.onload 中，如下 window.onload = function() &#123; // 要执行的代码&#125; onload 方法会在 DOM 树渲染完毕，并且外部资源如图片等等加载完毕后会执行，虽然能够满足我们的需求，但是在等待静态资源加载的时候，用户是不能与页面进行交互的，这时用户就会感觉页面卡死了，体验感十分不好。我们只是希望在 DOM 树渲染完毕后就执行代码，那么可以使用 ready() 函数，如下 $(document).ready(function() &#123; // 要执行的代码&#125;) 这里要执行的代码在 DOM 树渲染完毕后即可执行，而不必等到资源加载完毕。上面的写法可以简写为 $(function() &#123; // 要执行的代码&#125;) 将 DOM 元素转化为 jQuery 对象为核心函数传入 DOM 元素，会返回一个 jQuery对象，该对象包含了这个 DOM 元素，如下 将 DOM 元素转化为 jQuery 对象可以使用 jQuery 对象原型上的方法，这些方法想较于原生方法方便很多。 如何将 jQuery 对象转化为DOM元素呢? 我们知道 jQuery 对象的结构是类似于数组，其中的每一个元素都是 DOM 对象，我们可以使用下标的方式获取 DOM 元素，如下两种方法都是可以的 jQuery对象[index] jQuery对象.get(index)，该方法可以接受负数，表示倒数 操作 jQuery 集合在本节会使用 jQuery 集合这一叫法，因为往里面添加元素或者删除元素等等操作，集合的叫法比对象的叫法更加的符合。如果不做说明，下面操作的DOM为以下 &lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 添加元素使用 jQuery 集合调用 add 方法为集合添加元素， add 方法可以接收不同类型的参数，如下 jQuery 选择器：将与 jQuery 选择器匹配的所有 DOM 元素添加到集合中 DOM 元素或 DOM 元素组成的数组：将 DOM 元素或数组中的元素添加到集合中 HTML 字符串：将 HTML 字符串解析为 DOM 元素后添加到集合中 该方法会返回一个新的 jQuery 集合，例子如下 let collection = $(\"#box\");collection = collection.add(\".container\"); // 添加一个 jQuery 选择器collection = collection.add(document.getElementsByTagName(\"p\")[0]); // 添加一个 DOM 元素collection = collection.add(\"&lt;h1&gt;123&lt;/h1&gt;\"); // 添加一个 HTML 字符串console.dir(collection); 过滤元素过滤集合中的元素有两种方法，一个是 not，一个是 filter，两个方法的侧重点不同， not 方法会删除掉集合中符合条件的元素，返回新集合；而 filter 的语义是保留集合中符合条件的元素，返回一个新集合。二者接收的参数同 add 方法一样，除此之外，还可以接受一个函数，集合中的每一个元会素调用该函数，根据函数的返回值来决定元素的去留，比如对于 not 方法，如果函数返回 true，则删除此元素，对于 filter 则相反，如果返回 true，则保留此元素。这些传入的函数中的上下文(也就是 this)指向调用该函数的元素。 let collection = $(\"#box\");collection = collection.add(\".container\"); // 添加一个 jQuery 选择器collection = collection.add(document.getElementsByTagName(\"p\")[0]); // 添加一个 DOM 元素collection = collection.add(\"&lt;h1&gt;123&lt;/h1&gt;\"); // 添加一个 HTML 字符串collection = collection.not(function() &#123; return $(this).html() === \"123\"; // 删除掉 html 内容为 123 的，也就是 h1 标签&#125;)console.dir(collection); 根据上面的代码，此时集合中只有三个元素，将 h1 元素滤除了 let collection = $(\"#box\");collection = collection.add(\".container\"); // 添加一个 jQuery 选择器collection = collection.add(document.getElementsByTagName(\"p\")[0]); // 添加一个 DOM 元素collection = collection.add(\"&lt;h1&gt;123&lt;/h1&gt;\"); // 添加一个 HTML 字符串collection = collection.filter(function() &#123; return $(this).html() === \"123\"; // 保留 html 内容为 123 的，也就是 h1 标签&#125;)console.dir(collection); 将上面的 not 改为 filter，这时集合里面就只有一个元素，那就是 h1 元素 通过上面几个方法的学习，我们知道这些方法返回的都是一个新的 jQuery 集合，这意味着可以接着.，如下 let collection = $(\"#box\") .add(\".container\") .add(document.getElementsByTagName(\"p\")[0]) .add(\"&lt;h1&gt;123&lt;/h1&gt;\") .filter(function() &#123; return $(this).html() === \"123\"; &#125;); 这样写起来明显比上面写起来爽多了，这种写法叫做链式编程，像链子一样，一个接着一个。 遍历集合使用 each 方法遍历集合，该方法接收一个函数，集合中的每一个元素都会调用 each 中传入的函数，该函数的上下文会被设定为该元素，如 &lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt; $(\"div\").each(function() &#123; console.log($(this).html())&#125;) 集合查找 is(selector)：判断是否集合中是否包含与选择器匹配的元素，包含返回 true，否则返回 false has(test)：test 可以为选择器，也可以为 DOM 元素，它判断的是集合中的元素的后代中是否包含与 test 匹配的元素，如果集合中某元素 e 的后代包含与 test 匹配的元素，则将元素 e 添加到新的集合中，最后返回该集合，如 &lt;div&gt; &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; $(\"div\").has(\"ol\"); // $(\"div\")中有两个元素，只有第一个div元素的后代有ol元素，所以返回的新的集合中包含一个元素，是第一个div元素$(\"div\").has(\"li\"); // 两个元素的后代都有li元素，所以新集合中的元素与原集合相同 find(selector)：该方法会遍历集合中的所有元素，在这些元素的后代找到匹配 selector 的元素，然后将这些匹配的元素添加到一个新的集合中，并返回该新的集合 $(\"div\").find(\"img\") // 在所有div标签中找到img标签，返回这些img标签组成的集合 转换集合jQuery 对象有一个 map 方法，该方法与数组的 map 方法一样，接收一个回调函数，集合中的每一个元素都会调用该函数，该函数的返回值会被添加到新的集合中并返回(如果返回的是 null 或者 undefined 则不会添加到新的集合中)，该函数有两个参数，第一个参数是元素在集合中的下标，第二个参数是调用该函数的元素。 &lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt; $(\"div\").map(function(index, element) &#123; return index; // get()方法会将集合转变为一个真正的数组&#125;).get().join(\", \"); //\"0, 1, 2, 3, 4\" 操作 DOM 元素的属性和类属性操作属性我们可以使用attr()方法方便的操作 DOM 元素的属性 attr(name, value)：为名字为 name 的属性设置值为 value $(\"div\").attr(\"id\", \"box\"); // 将所有 div 标签的 id 设置为 box attr(name)：获取集合中第一个元素中属性名字为 name 的值 attr(attributes)：以对象的形式来设置属性值 $(\".attr\").attr(&#123; title: \"cat\", // 设置 title 属性为 cat id: \"cat\" // 设置 id 属性为 cat&#125;) removeAttr(name)：删除指定名称的属性 经过测试，发现 attr() 方法可以设置任意属性的值(我的意思是指即使这些属性是不存在的，比如 dog 也可以设置，而这些不存在的属性称为自定义属性)，比如 attr(\"dog\", \"dog\"); // 为 dog 属性设置值为 dog 上面的 dog 就是自定义的属性名。在 HTML5 中建议自定义属性名以 data- 开头，如 data-dog， HTML5 会将 data- 开头的属性名添加到 dataset 的对象中，我们可以通过 dataset[&quot;属性名&quot;] dataset.属性名 的方式访问，这时的属性名不需要加上 data- 前缀，如 dataset[&quot;dog&quot;] dataset.dog 如果属性名之间使用 - 连接，如 data-my-name，则访问时需要使用驼峰命名法访问，即 dataset[&quot;myName&quot;] dataset.myName 在新的页面打开标签现在使用 attr() 方法来做几个例子，第一个要求页面内的链接都要在新的页面打开，做法就是将 a 标签的 target 属性设置为 _blank ，这种事情当然可以在写的时候就写好，但是有两个问题 首先这个工作是重复性的工作，每写一个 a 都要重复同样的事情，既累又不够优雅 如果页面内的链接是用户加入的呢，比如百科，这时打开的链接就不一定是在新的页面打开了 所以我们可以使用 attr() 批量设置 a 标签的 target 属性为 _blank ，但是并不是所有的 a 标签，因为有的 a 标签是在页面内跳转的，我们并不需要在新的页面内打开，所以应该设置 href 属性以 http:// 开头的 a 标签在新的页面打开 $(\"a[href^='http://']\").attr(\"target\", \"_blank\") 解决双重提交在提交表单时，有的时候由于不能够及时给予用户反馈，导致用户不确定是否提交成功，用户会多次点击提交按钮，这样会给服务器端带来麻烦，我们在捕获 submit 事件时，当用户第一次提交时，我们接着将 disabled 属性设置为 true (或者为 disabled )，如下 // 绑定表单的提交事件$(\"form\").submit(function() &#123; // :submit 表示 type 为 submit 的元素 // 提交之后将submit按钮设置为disabled $(\":submit\", this).attr(\"disabled\", \"disabled\") &#125;) 在上面中设置 disabled 属性时，disabled 属性的值不重要，重点是设置了 disabled 这个属性，所以即使将它设置为空字符串 &quot;&quot;，它也是生效的，如果想 disabled 属性设置为不生效，那么就将它的值设置为 false (注意不要设置为字符串 &quot;false&quot; )，下面的写法作用是一样的，都是使得 disabled 生效 attr(&quot;disabled&quot;, &quot;disabled&quot;) attr(&quot;disabled&quot;, &quot;&quot;) attr(&quot;disabled&quot;, &quot;false&quot;) attr(&quot;disabled&quot;, true) 只有将 disabled 设置为布尔值 false 才会使得 disabled 失效 attr(&quot;disabled&quot;, false) 操作类属性为什么类属性要单独拿出来呢? 假设有这么一个需求，为所有的 div 标签添加一个类 box，那下面这样的写法对不对 $(\"div\").attr(\"class\", \"box\"); 上面的写法是错误的，因为上面的写法是为 class 属性赋值为 box，但是之前的类属性就会被覆盖掉，我们想做的仅仅是添加的操作，所以我们需要知道之前的类属性是什么，所以正确的写法如下 // 获得原来的类名列表 转化为数组const classList = $(\"div\").attr(\"class\").split(\" \");// 将要添加的类名添加到数组中classList.push(\"box\");// 将数组中的元素以空格拼接为一个字符串const newClassList = classList.join(\" \");// 设置class属性$(\"div\").attr(\"class\", newClassList); 经过千辛万苦终于添加了一个类，考虑到这样的操作很频繁，所以最好将上面的操作抽象为一个方法，而 jQuery 为我们做了这件事情： addClass(names) names 可以是单个类名，也可以是一个以空格分隔的字符串表示的多个类名 names 还可以是一个函数，函数的返回值作为单个类名或者多个类名，这个函数会传入两个参数，元素的下标(元素在 jQuery 集合中的下标)和当前类名的值 removeClass(names) 参数同 addClass ，作用是删除单个或多个类名 toggleClass(names) 该函数的作用是切换类名，什么意思呢? 比如如果该元素存在 names 指定的类，则删除掉指定的类，如果不存在指定的类，则添加指定的类 参数同上 addClass(\"box\"); // 为元素添加 box 类addClass(function(index, value) &#123; // index 是元素在 jQuery 中的下标 // value 是元素当前类名的值 // return \"active big\" return \"box\"; // 返回值将会被作为类名添加&#125;)removeClass(\"box\"); // 删除该元素 box 类toggleClass(\"box\"); // 如果存在 box 类，则删除 box 类，如果不存在 box 类，则添加 box 类 hasClass(name) 判断是否包含类名为 name 的类，包含则返回 true，否则返回 false HTML5 其实也提供了原生的操作类的方法，每个元素都有一个 classList 对象，它的原型对象提供了操作类名的方法 classList.add()：为元素添加一个类 classList.remove()：为元素删除指定的类 classList.toggle()：切换指定的类，存在则移除，不存在则添加 classList.contains()：判断是否存在指定的类，存在返回 true，反之返回 false 据我试验所知，上面的每次操作只能对一个类操作，意思就是不能同时添加多个类或删除。 操作样式使用 css() 方法来设置样式，使用的方法与 attr() 类似 css(name, value)：设置样式 name 为 value css(properties)：传入一个对象，通过对象来设置样式 css(name)：获得样式，如果是含有多个元素的 jQuery 集合调用此方法，那么返回的是第一个元素的计算样式值 看一个例子，有下面的 div 标签 &lt;div&gt;&lt;/div&gt; 现为它设置高度和宽度 $(\"div\").css(&#123; width: \"100px\", height: \"100px\"&#125;) css(name, value)：其中 value 可以是一个函数，该函数的返回值将作为 value 值，这个函数会接收两个参数，第一个参数是元素在 jQuery 集合中的位置，第二个参数是样式当前的值，同时函数的内部上下文 this 指向当前元素 获取元素宽度下面我们来获取某元素的 width 值 $(\"div\").css(\"width\"); // 100px 得到的结果是一个一个字符串，而不是数字，很多时候我们是希望得到数字用来计算或者其他用途，所以如果想得到数字的话就需要对字符串进行解析，但是 jQuery 有考虑这一方面，我们可以很方便的使用 width(), height() 方法获得数字的结果，如 $(\"div\").width(); // 100 这里的 width 的大小是设置样式时的大小吗? 比如 div&#123; width: 100px;&#125; 使用 width() 方法得到的数字是100吗? 为什么在这里我会提出这么一个疑问，因为这里设置的 width 不一定是标签的内容宽度，也可能包括 padding, border (当 box-sizing 设置为 border-box 时)，所以这里的 width 得到的是 content-width 还是在 style 标签中设置的 width ，我们设置 div 的样式为 div &#123; box-sizing: border-box; padding: 10px; width: 100px;&#125; 这个时候在 style 里面设置的 width 为 100 ，但是实际的 content-width 应该是 80 ，我们来看一下 width() 方法得到的结果是多少 $(\"div\").width(); // 80 上面得到的结果是 80 ，所以 width() 方法得到的宽度是 content-width ，即是实际内容的宽度， height() 方法也是同理。 除了可以使用 width() 方法获得元素的宽度以外，还可以设置元素的宽度 width(value) value 的值可以是一个数字，单位默认为 px 也可以是带单位的字符串(如果没有指定单位，则默认为 px) 还可以是一个函数，函数的返回值作为要设置的值，该函数的上下文(this)是该元素 这里又有一个疑问，如果我设定宽度，那么这里的宽度我设定的是内容宽度 conetnt-width 还是元素的 width 样式，这里我们还是以上面的 div 为例 div &#123; box-sizing: border-box; padding: 10px; width: 100px;&#125; 这里我们设定 width 为 200 ，然后通过 width() 方法获得宽度，如果得到的值是 200 ，那说明设定的是 content-width ，如果得到的是 180 ，说明设定的是 width 样式的值 $(\"div\").width(200);console.log($(\"div\").width()); // 200 得到的结果是 200 ，说明设定的是 content-width 。 在这里我突然又有一个想法，那就是 css(&quot;width&quot;) 与 width() 得到的结果是相同的吗，还是以上面的 div 为例 div &#123; box-sizing: border-box; padding: 10px; width: 100px;&#125; console.log($(\"div\").width()); // 80console.log($(\"div\").css(\"width\")); // 100px 惊讶的发现二者得到的结果是在数值上是不一样的，可见使用 css(&quot;width&quot;) 获得的是 width 样式的值，那么使用 css(&quot;width&quot;, 200) 设定的是 width 样式的值吗，测试一下 $(\"div\").css(\"width\", 200);console.log($(\"div\").width()); // 180console.log($(\"div\").css(\"width\")); // 200px 果然 css() 方法设置的值也是 width 样式的值，所以这里总结一下： width()(height())方法设定或者获取的值是指内容的宽度(高度) css() 设定或获取的宽度(高度)是指样式里面的 width 值的大小 在 box-sizing 为 content-box 下二者得到的数值结果是一样的，但是在 box-sizing 为 border-box 的情况下，由于 padding 和 border 的影响，二者的结果是不同的(在 padding 和 border 为 0 的情况下是相同的)。 经过一次实践，我发现上面的描述也不太准确，css(&quot;width&quot;)与width()方法获得的值符合上面情况的条件是，它的大小没有超过它父元素的大小，如果超过了，那么css(&quot;width&quot;)就是父元素的width样式的大小，而width()方法的大小我觉得很复杂，还不知道怎么计算，自己动手试试吧。 除了 width() 和 height() 方法，jQuery 还提供了特别的方法来获得特殊的宽度和高度 方法 描述 innerwidth() 内容宽度+内边距宽度 innerHeight() 同上 outerWidth(margin) margin为false时，内容宽度 + 内边距宽度 + 边框宽度margin为true时，再加上外边距的宽度 outerHeight(margin) 同上 获取元素位置offsetoffset()，获取元素离文档原点的距离，返回一个对象，里面有 left 和 top 两个属性，表示离文档原点经过测试，应该是元素的 border 的左上角离文档原点的距离，考虑下面的 html 和 css &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;offset&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; /* body有8px的margin */ padding: 0; &#125; div &#123; margin-top: 100px; margin-left: 100px; padding-left: 100px; padding-top: 100px; width: 100px; height: 100px; border: 100px solid red; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 来测试一下 console.log($(\"div\").offset()); // &#123;top: 100, left: 100&#125; position另一个获取位置有关信息的是 position() ，它是获得与它元素左上角之间的距离，这个父元素是它所有父元素中使用了定位 position 且离他最近的父元素，虽然有点拗口，不过使用过绝对定位的话，就会很容易明白，因为它与绝对定位的规则是一样的。 经过我的实验，发现这个距离不是边框与边框的距离，而是子元素 margin 离父元素 padding 之间的距离 考虑下面这么一个HTML &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;position&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; body &#123; font-size: 10px; &#125; .container &#123; margin: 100px; background-color: grey; width: 400px; height: 400px; position: relative; overflow: hidden; /* 防止外边距塌陷，下同 */ border: 2px solid #cccccc; padding: 10px; &#125; .outer &#123; width: 200px; height: 200px; margin: 60px; background-color: greenyellow; overflow: hidden; &#125; .inner &#123; width: 100px; height: 100px; background-color: pink; margin: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; console.log($(\".inner\").position()); // outer的margin + container的padding = 70 console.log($(\".outer\").position()); // container的padding = 10 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作 DOM 元素设置 html 内容以及文本内容 html()：获取jQuery集合中第一个元素的 html 内容 html(content)：将传入的 HTML 片段，设置 jQuery 集合中元素的 HTML 内容 text()：获得 jQuery 集合中所有元素的文本内容拼接的字符串 text(content)：将 jQuery 集合元素的文本内容设置为传入的值 content 可以为字符串，也可以是一个函数，函数的返回值作为要设置的内容，函数接受两个参数，第一个参数是元素在 jQuery 集合中的位置，第二个参数是当前html(text)的值。 追加元素 append(content)：将 content 追加元素内容的最后面(子元素级别) prepend(content)：将 content 追加元素内容的最前面 before(content)：将 content 追加到元素的前面(兄弟元素级别) after(content)：将 content 追加到元素的后面 content 的值可以为字符串，元素，jQuery集合，函数，函数的返回值将被添加，函数将接受两个参数，元素的下标和原先的内容。 如果选择现有的DOM元素添加到某元素的最后，那么这是一个移动操作，而不是一个复制操作，比如有这么一个结构 &lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 执行下面的语句 $(\"div\").append($(\"p\")); 得到的结果是 &lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 而不是 &lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 如果jQuery集合中有多个元素，那么被添加的元素会复制多份，添加到这些元素内容的后面(如果添加的是DOM中已有的元素，也是移动操作)，其它的操作(prepend…)也是同理。 appendTo(target) prependTo(target) insertBefore(target) insertAfter(target) 这些方法的作用同上面介绍的是个方法是一一对应的，不过是主动变为了被动，如 $(\"div\").append(content); // 向div中添加content$(\"div\").appendTo(target); // 将div添加到target中 target 只能为元素或者字符串 删除元素 remove(selector)：删除 jQuery 集合中的元素，selector 是一个可选的选择器，用来进一步筛选要删除的元素，被删除的元素会放入一个新的 jQuery 集合中返回，所以被删除的元素可以继续插入到 DOM 中，但是这个时候之前绑定的事件和数据全部被删除了。 empty()：删除 DOM 元素中的内容，与 remove 不同， remove 是删除这个 DOM 元素，包括这个元素包括的内容，但是 empty 只是清除该 DOM 元素的内容。 detach(selector)：该方法的作用与 remove 是一样的，但是保留绑定的事件和绑定的数据。 复制元素 clone(cloneHandler)：复制 jQuery 集合中的元素，生成一个新的 jQuery 集合返回。 cloneHandler 如果为 true，那么就会复制绑定的事件，如果为 false 就不会复制绑定的事件 替换元素 replaceWith(content)：使用 content 去替换 jQuery 集合中的元素，返回被替换的元素， content 可以是字符串，元素和函数，函数的返回值作为替换的内容，函数的上下文被设置为当前的元素，不传递任何的参数；如果 content 是已经在DOM中的元素，那么就相当于是移动到 jQuery 集合中元素的位置，如果 jQuery 集合中有多个元素，会复制多个 content 副本 replaceAll(selector)：使用 jQuery 集合中的所有元素去替换匹配 selector 的元素，如果jQuery集合中的元素是已经在 DOM 中的元素，那么就相当于将符合 selector 的元素删除，然后将 jQuery 集合中的元素移动到这里，如果符合 selector 的元素有多个，那么会复制多个 jQuery 集合的副本移动 处理表单元素 val()：获得集合中第一个元素的 value 值，如果该元素是一个可以多选的元素，那么返回所有选择项组成数组(比如&lt;select mupltiple=&quot;mupltiple&quot;&gt;&lt;/select&gt;) 如果第一个元素不是表单元素，则会返回空字符串 val(value)：设置集合中表单元素的 value 值 value值也可以是函数，函数的返回值作为被设置的内容，函数接收两个参数，元素的下标和当前的value值 val(values)：使得多选框，单选框，或者select元素中的可选项中，如果这些选项的值在values中，则它变为选中状态 jQuery 事件绑定事件jQuery 使用 on 方法绑定事件，如下 on(eventType, childSelector, data, listener) eventType，必需，要绑定的事件的类型，如 click childSelector，可选，规定把事件绑定到子元素上 data，可选，规定传递到函数的额外数据 listener，可选，规定事件发生时运行的函数 on 方法除了给已经存在于DOM中的元素绑定事件以外，还可以给现在还不存在于 DOM 中但是未来会添加到 DOM 中的元素绑定事件，如 &lt;div&gt;&lt;/div&gt; 此时 DOM 中只有 div 标签，这时我想给未来会被添加到 DOM 中的 p 标签绑定点击事件 $(\"p\").appendTo($(\"div\")); // 将p标签添加到div中// 为div标签中的p标签绑定事件，即使p标签一开始并不在DOM中，也可以绑定成功$(\"div\").on(\"click\", \"p\", function() &#123; &#125;) 使用 one() 绑定事件，该事件在执行完一次后会被删除 one(eventType, data, listener) 各参数的含义与 on 是一致的 除了可以使用上面的方法绑定事件以外，jQuery 还提供了十分方便的绑定特定事件方法，如 // 为div标签绑定点击事件$(\"div\").click(function() &#123; &#125;) 这样直接以事件的名字绑定事件，既方便，语义又明确，支持这种方式的 eventTypeName 如下 解绑事件 off(event, selector, listener)：移除通过 on 方法绑定的事件 触发事件 trigger(event, data) 这个方法是用来触发事件的，比如 $(&quot;#foo&quot;).trigger(&quot;click&quot;) 会触发 id 为 foo 的点击事件 data 是可选参数，是传递给事件处理的额外参数，它是一个数组或者对象 来解释一下 data，加入在绑定事件时需要额外的参数，如 // 需要额外的参数a, b$(\"#foo\").click(function(event, a, b) &#123; &#125;) 这时我们在触发事件时就需要传入额外的参数 $(\"#foo\").trigger(\"click\", [\"foo\", \"bar\"]) triggerHandler(event, data) triggerHandler 的作用与 trigger 类似，不过有几点不同 .triggerHandler() 方法并不会触发事件的默认行为(例如，表单提交)。 .trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素。 使用 .triggerHandler() 创建的事件，并不会在 DOM 树中向上冒泡。 .triggerHandler() 返回最后一个处理的事件的返回值，而不是 jQuery 集合，即不能进行链式调用 除了上述的方法外，jQuery 还提供了可以直接通过名字直接触发事件，如 $(\"#foo\").click() // 触发点击事件 其他事件 toggle(listener1, listener2, ...) 当点击元素时会依次触发事件 比如第一次点击触发 listener1 ，第二次点击触发 listener2 ，以此类推，如果 toggle 中的事件触发完了，那么会循环触发 hover(enterHandle, leaveHadnler) 当鼠标进入元素时触发 enterHandle ，离开元素时触发 leaveHadnler hover(handler) 当鼠标进入元素以及离开元素时均会触发 handler Event实例我们向元素绑定事件时，会向监听器(绑定的处理函数)传入一个 event 对象，那么 event 对象中有什么信息可以为我们所用呢? jQuery 显示与隐藏显示和隐藏元素 hide()：隐藏元素 show()：显示元素 隐藏元素是将元素的 display 属性设置为 none，而显示属性会将 display 属性设置为与隐藏前的 display 相同，比如在隐藏前某元素的 display 为 block， hide 会将 dispaly 设置为 none，show 会将 display 设置为与之前相同为 block。 toggle()：切换，如果为显示，则隐藏，如果隐藏，则显示 显示隐藏动画上面的方法其实还可以接受两个参数 hide(speed, callback) speed 用来规定隐藏的速度，默认是没有动画效果的，元素瞬间消失，可以传入数字，单位是毫秒，也可以传入以下预定义的字符串，slow, normal, fast callback 是动画执行完毕后会执行的回调函数 同理，show() 和toggle() 也由这两个参数，与hide() 的用法一模一样，所以不再赘述。 假设有一个 div 标签，当我们点击它时，它会先隐藏，会显示 $(\"div\").click(function() &#123; $(\"div\").hide(\"slow\").show(\"fast\")&#125;) 除了上面方法显示和隐藏元素以外，jQuery 还提供了很多的方法，如 淡入淡出(只改变元素的不透明度)： fadeIn(speed, callback) fadeOut(speed, callback) fadeTo(speed, opacity, callback)：逐渐改变元素的透明度到设定的opacity 我们在使用 hide 或者 show 时，除了改变透明度以外，还会改变高度和宽度，而 fade... 方法只会改变不透明度，当 opacity 为 0 时，将 display 设置为 none $(\"div\").click(function() &#123; $(\"div\").fadeOut(\"slow\").fadeIn(\"fast\")&#125;) 滑入滑出： slideDown(speed, callback)：改变元素的垂直尺寸，使元素逐渐显示出来 slideUp(speed, callback)：改变元素的垂直尺寸，使元素逐渐消失 slideToggle(speed, callback)：隐藏则显示，显示则隐藏 $(\"div\").click(function() &#123; $(\"div\").slideUp(\"slow\").slideDown(\"fast\")&#125;) jQuery 动画 animate(properties, duration, easing, callback) properties：元素最后达到的 CSS 状态 duration：持续时间 easing：动画曲线，jQuery 提供两个函数曲线 linear 和 swing callback：动画执行完毕后的会执行的回调函数 我们通过给定希望元素最后能够达到的 CSS 状态，比如位置的变化，宽高的变化，而 jQuery 会自动根据持续的时间以及初始的状态计算出中间的过程，也就是帧，如 $(\"div\").click(function() &#123; $(\"div\").animate(&#123; width: \"200px\" &#125;, 500, \"swing\")&#125;) 自定义缩放动画$(\"div\").hover(function() &#123; // 鼠标放上去时，放大两倍 $(\"div\").animate(&#123; width: $(this).width() * 2, height: $(this).height() * 2 &#125;)&#125;, function () &#123; // 离开时恢复原样 $(\"div\").animate(&#123; width: $(this).width() / 2, height: $(this).height() / 2 &#125;)&#125;) 自定义掉落动画$(\"div\").click(function() &#123; $(this).css(&#123; position: \"relative\" &#125;).animate(&#123; opacity: 0, // 计算要下降的高度 top: $(window).height() - $(this).height() - $(this).position().top &#125;, \"slow\", function() &#123; // 因为 opacity 为 0 只是不可见，但是仍然占据位置，所以最后要hide隐藏一下 // 可以将 opacity 最后的状态设置为 hide，那么这个回调函数可以省略 $(this).hide() &#125;)&#125;) 将 $.fx.off 设置为 true 会禁用动画 jQuery扩展及实用函数jQuery与其他库并存 $.noConflict()：将 $ 控制权给其他库，在执行该行代码后不能使用 $，只能使用 jQuery jQuery实用函数 $.trim(value)：去除字符串前后的空白字符(不仅仅是空格，还有回车等等) $.each(container, callback)：会为 container (数组|对象)中的每个元素调用 callback，callback 的参数就是 container 中的每个元素 $.grep(array, callback, invert)：为数组中的每个元素调用 callback，根据 callback 的返回值决定是否将元素添加到新的数组，如果 invert 为 true，那么 callback 返回 false 则将元素添加到新数组，反之若 invert 为 false，则 callback 返回 true 则将元素添加到新的数组，最后将新数组返回 $.map(array, callback)：这个方法不想多解释 $.inArray(value, array)：方法 value 在 array 中第一次出现的下标 $.makeArray(object)：将一个伪数组转换为一个真正的数组 $.unique(array)：返回 array 中不重复的元素组成的数组 $.merge(array1, array2)：将第二个数组合并到第一个数组中，并返回第一个数组 上面的方法大多数 JavaScript 已经有原生的实现了 扩展jQuery$.fn.xxx：该方法会被添加到 jQuery 对象的原型上，通过这种方法可以扩展 jQuery Ajax启动一个Node来进行服务端测试const http = require('http');const server = http.createServer();server.on('request', (req, res) =&gt; &#123; // 处理跨域 允许http://127.0.0.1:5500跨域请求 因为我在这个地址访问页面 res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); res.end(\"Hello World\");&#125;)server.listen(4000, () =&gt; &#123; console.log(\"服务启动在4000端口\");&#125;) 回顾Ajax&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;发送请求&lt;/button&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; $(\"button\").click(function () &#123; let xhr = new XMLHttpRequest(); // 设置请求方法和请求路径 xhr.open(\"GET\", \"http://localhost:4000\"); // 监听onreadystatechange，当readyState改变时会触发此函数 xhr.onreadystatechange = function () &#123; // readyState为4表示处理请求完成 if (this.readyState == 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; // 成功 $(\"ul\").append(`&lt;li&gt;$&#123;this.responseText&#125;&lt;/li&gt;`) &#125; else &#123; // 失败 alert(\"失败\"); &#125; &#125; &#125; // 发送的请求体数据 get方法不传参数，或者传入null xhr.send(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码是当点击button时发送一个ajax请求，并且获得的内容添加到ul中，效果如下 XMLHttpRequest 对象拥有的属性和方法为 jQuery 发起 Ajax 请求 get(url, parameters, callback, type) url：请求的路径 parameters：请求参数，会被拼接到 url 后 callback：请求成功后调用的函数 type：以何种方式处理响应数据，如 html，json getJSON(url, parameters, callback)：相当于是 get(url, parameters, callback, type) 中 type 为 json 的快捷写法 post(url, parameters, callback, type)：同 get，不过请求的方法是 POST，而且请求数据是放在请求体中的 ajax(options)： 用传入的选项来控制 ajax 请求，该方法可以控制发送 ajax 请求的各种细节 jQuery 的 ajax 方法为我们提供了这么多可选项，如果没有设置一些选项的话，就会使用默认值，使用 ajaxSetup 方法来设置默认值 ajaxSetup(options) $.ajaxSetup(&#123; type: 'POST', timeout: 5000, dataType: 'html'&#125;) 那么后面的每个 ajax 调用都会使用这些默认值($.get() 的 HTTP 方法不会被改为 POST)。","tags":[{"name":"jQuery JavaScript","slug":"jQuery-JavaScript","permalink":"https://lastknightcoder.gitee.io/tags/jQuery-JavaScript/"}]},{"title":"使用before和after实现一个hover遮罩效果","date":"2020-04-04T16:00:00.000Z","path":"/使用before和after实现一个hover遮罩效果/","text":"今天开始学习CSS效果，记录一下，成品如下 实现的思路很简单，使用到了::before和::after两个伪元素，默认两个伪元素的width为0，height与父元素的高度相同，当鼠标放上去时，伪元素的width变为100%，注意到两个伪元素变化的方向不一样，因为::before被设置为了 top: 0;left: 0; 而::after被设置为 bottom: 0;right: 0; talk is cheap, show me the code，直接上代码吧 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; width: 100%; height: 100%; background-color: #fff; &#125; a &#123; font-size: 50px; display: block; width: 300px; height: 100px; line-height: 100px; margin: auto; text-decoration: none; text-align: center; text-transform: uppercase; color: #666; border: 1px solid black; position: absolute; top: 0; left: 0; bottom: 0; right: 0; font-family: Arial, Helvetica, sans-serif; transition: all 0.5s; z-index: 1; &#125; a::before, a::after &#123; content: \"\"; display: block; width: 0; height: 100px; position: absolute; background: #333; transition: all 0.5s; z-index: -1; &#125; a::before &#123; top: 0; left: 0; &#125; a::after &#123; bottom: 0; right: 0; &#125; a:hover::before, a:hover::after &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#\"&gt;Move&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码不难理解，就一个地方需要注意的是，在a标签中设置了 margin: auto;position: absolute;top: 0;left: 0;bottom: 0;right: 0; 这样的写法，这样做的目的是使得a标签在body中居中显示，因为设置了定位的属性 top: 0;left: 0;bottom: 0;right: 0; 四个都为0，要达到这样的效果，设置margin为auto会为a元素四周充满外边距，如下 这样就可以到居中的效果。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://lastknightcoder.gitee.io/tags/CSS/"}]},{"title":"数组中的重复的数字","date":"2020-04-03T16:00:00.000Z","path":"/数组中的重复的数字/","text":"题目一：找出数组中重复的数字 在一个长度为n的数组里的所有数组都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数组2或者3。 考虑如果没有数组中没有重复的数字，那么排序后会有arr[i] = i(因为元素在 0~n-1 的范围内)，那么现在我们遍历数组，让第i个位置的元素的值为i(从0开始)，做法是当arr[i] != i的时候，与第arr[i]的位置进行交换，这样可以使得第arr[i]个位置上的数是arr[i]，即arr[arr[i]] = arr[i] int temp = arr[i];arr[i] = arr[temp];arr[temp] = temp; 如果有重复的数，由于arr[arr[i]]位置上的数已经被占了，所以这个时候我们就知道有重复的数，算法如下 public class Test01 &#123; public static boolean duplicate(int[] arr) &#123; if (arr.length &lt;= 0 || arr == null) &#123; return false; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; while(arr[i] != i) &#123; if (arr[arr[i]] == arr[i]) &#123; return true; &#125; swap(arr, i, arr[i]); printArr(arr); &#125; &#125; return false; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; private static void printArr(int[] arr) &#123; System.out.print(\"[\"); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]); if(i != arr.length - 1) &#123; System.out.print(\", \"); &#125; &#125; System.out.println(\"]\"); &#125; public static void main(String[] args) &#123; int[] arr = &#123;2, 3, 1, 0, 2, 3, 5&#125;; // int[] arr = &#123;7, 5, 6, 3, 4, 1, 0, 2&#125;; boolean duplicated = duplicate(arr); System.out.println(duplicated); &#125;&#125; 题目二：不修改数组找出重复的数字 在一个长度为 n+1 的数组里的所有数字都在 1~n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。 该算法有两种思路，第一种需要大小为 n+1 的辅助数组，我们遍历数组，将数组中的元素都复制到辅助数组中，原则如下，假设要复制的元素为m，那么将该数复制到辅助数组中下标为m的位置，这样很容易知道哪个元素重复了。 public class Test02 &#123; public static int duplicate(int[] arr) &#123; int N = arr.length; int[] helpArr = new int[N]; for(int i = 0; i &lt; N; i++) &#123; if (arr[i] == helpArr[arr[i]]) &#123; return arr[i]; &#125; else &#123; helpArr[arr[i]] = arr[i]; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] arr = &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;; int num = duplicate(arr); System.out.println(num); // 3 &#125;&#125; 另一种思路是二分查找，首先我们将数字分成两半，比如 1~m 和 m+1~n，接着我们在数组中统计数字在 1~m 区间中的个数，如果数量大于 m ，那么就说明在 1~m 中有重复的数字，否则在 m+1~n 中有重复的数字，假设在 1~m 中有重复的数字，那么继续分成两半，如此往复，直到两边只有一个元素，代码如下 public class Test03 &#123; public static int duplicate(int[] arr) &#123; int start = 1; int end = arr.length - 1; while (end &gt;= start) &#123; int middle = start + (end - start) / 2; // 获得数字范围在[start, middle]范围内的数目 int countNum = count(arr, start, middle); if (start == end) &#123; if(countNum &gt; 1) &#123; return start; &#125; else &#123; // 如果范围只剩最后一个元素，但是数目不大于1，说明没有重复的 break; &#125; &#125; if (countNum &gt; (middle - start + 1)) &#123; // 在[start, middle]中继续找 end = middle; &#125; else &#123; // 在[middle + 1, end]中继续找 start = middle + 1; &#125; &#125; return -1; &#125; // 统计数组中数字范围在[start, end]范围内的数目 private static int count(int[] arr, int start, int end) &#123; int count = 0; for(int i = 0; i &lt; arr.length; i++) &#123; if (start &lt;= arr[i] &amp;&amp; arr[i] &lt;= end) &#123; count++; &#125; &#125; return count; &#125; public static void main(String[] args) &#123; int[] arr = &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;; int num = duplicate(arr); System.out.println(num); // 3 &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"单例模式","date":"2020-04-02T16:00:00.000Z","path":"/单例模式/","text":"题目：设计一个类，我们只能生成该类的一个实例。 如果只能生成一个实例，这意味着构造方法必须为私有的，该类实例的创建不能由用户创建，一个容易想到的版本如下 public class Test01 &#123; private Test01() &#123; &#125; private static Test01 instance; public static Test01 getInstance() &#123; if (instance == null) &#123; instance = new Test01(); &#125; return instance; &#125; public static void main(String[] args) &#123; Test01 one = Test01.getInstance(); Test01 two = Test01.getInstance(); System.out.println(one == two); // true &#125;&#125; 我们在类里面声明了一个instance变量，它是该类的一个实例，用户通过getInstance()来获得该类的实例，在该方法中，首先判断instance是不是为null，如果是null说明还没有创建过该实例，那么创建一个实例，如果不为null，说明已经创建过该实例，将之前创建过的实例返回，从而达到创建的始终是一个实例的效果。 但是使用上面的方法有一个缺点，那就是在多线程的情况下可能创建出多个实例，考虑这么一种情况，第一个线程执行if (instance == null)时，这时是成功的，会进入到if语句中，但是这个时候它失去了执行权，这个时候第二个线程执行if (instance == null)时，由于instance还没有赋值，它的值还为null，它也能够进入到if语句中，这个时候第一个线程和第二个线程都会使用new关键字创建出一个实例，它们是不同的。 简单的解决上面的问题就是加锁，上面会出现问题的语句为 if (instance == null) &#123; instance = new Test01();&#125; 所以我们为这个语句块加上锁就行，这就出现了第二个版本 public class Test02 &#123; private static Test02 instance; private Test02() &#123; &#125; private static Test02 getInstance() &#123; synchronized(Test02.class) &#123; if (instance == null) &#123; instance = new Test02(); &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Test02 one = Test02.getInstance(); Test02 two = Test02.getInstance(); System.out.println(one == two); // true &#125;&#125; 但是这个方法还有一个小的缺点，那就是每次我们获取实例的时候，都需要加锁，这意味着性能的损失，当instance不为null的时候，已经不会由于多线程而产生问题了，也就不用加锁了，所以再次修改getInstance()，产生了第三个版本 public class Test03 &#123; private static Test03 instance; private Test03() &#123; &#125; private static Test03 getInstance() &#123; if (instance == null) &#123; synchronized(Test03.class) &#123; if (instance == null) &#123; instance = new Test03(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Test03 one = Test03.getInstance(); Test03 two = Test03.getInstance(); System.out.println(one == two); // true &#125;&#125; 在这个版本中，只有在instance为null的时候，我们才加锁。 上面的方法已经比较好了，这里再次推荐更好的办法，我们在instance声明的时候就为它赋值 public class Test04 &#123; // 在声明的时候就赋值 private static Test04 instance = new Test04(); private Test04() &#123; &#125; public static Test04 getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; Test04 one = Test04.getInstance(); Test04 two = Test04.getInstance(); System.out.println(one == two); // true &#125;&#125; 但是由于instance是静态变量，静态变量在类被主动使用时就会被初始化，而不是等我们需要创建类的实例时才被初始化，简单的说就是创建的时机过早，从而降低内存的使用效率，我们使用静态内部类来解决按需加载的问题 public class Test05 &#123; private Test05() &#123; &#125; private static final class InnerTest &#123; private static Test05 instance = new Test05(); &#125; public static Test05 getInstance() &#123; return InnerTest.instance; &#125; public static void main(String[] args) &#123; Test05 one = Test05.getInstance(); Test05 two = Test05.getInstance(); System.out.println(one == two); //true &#125;&#125; 这个时候，只有我们需要用到类的实例时，才会初始化instance。 在上面5种实现单例模式的方法中： 第一种方法在多线程的环境下不能工作 第二种模式虽然能够在多线程的环境下工作，但是效率很低 第三种方法通过两次判断确保能够在多线程的情况下高效的工作 第四种方法在声明时就初始化，且只会被初始化一次，确保只创建一个实例 第五种方法利用内部类，做到只要在真正需要的时候才会创建实例，提高空间使用效率","tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://lastknightcoder.gitee.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JavaScript中的冒泡与捕获","date":"2020-03-16T16:00:00.000Z","path":"/JavaScript中的冒泡与捕获/","text":"JavaScript中的冒泡与捕获首先来看一个例子来明白什么是冒泡和捕获，来看下面的一个html结构 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .outer &#123; width: 200px; height: 200px; background-color: black; margin: 100px auto; &#125; .inner &#123; width: 100px; height: 100px; background-color: greenyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 就是一个大盒子里面套着一个小盒子，为两个盒子设置了背景颜色以作区分，如下 现在为二者都添加一个点击方法 &lt;script&gt; let outer = document.querySelector('.outer'); let inner = document.querySelector('.inner'); outer.addEventListener('click', (e) =&gt; &#123; console.log('outer被点击了'); &#125;); inner.addEventListener('click', (e) =&gt; &#123; console.log('inner被点击了'); &#125;);&lt;/script&gt; 现在如果点击里面的盒子inner，那么outer的点击事件会不会触发，因为按道理也算是点击了outer的区域，所以outer的点击事件应该被触发。现在问题又来了，是先触发inner还是先触发outer的点击事件呢? 按照二者触发顺序的不同分为捕获和冒泡。 现在点击绿色的小盒子，看看输出是什么 当我们点击里面的盒子即 inner 时，触发了它的点击事件，随后触发了 outer 的点击事件，这样触发子元素事件之后触发父元素事件的行为就叫做冒泡；捕获就是随之相反了，先处理 outer，然后处理 inner 的事件。 要实现捕获的效果，首先我们为 addEventListener 方法的第三个参数设置为 true，如下 outer.addEventListener('click', (e) =&gt; &#123; console.log('outer被点击了');&#125;, true);inner.addEventListener('click', (e) =&gt; &#123; console.log('inner被点击了');&#125;, true); 这时我们在点击里面的盒子 这时是outer的点击事件先被执行，然后是inner的点击事件被执行。 冒泡和捕获的出现是因为以前的两大浏览器厂商 Netscape 和 Microsoft 对事件模型处理方法，Microsoft 采取的从目标元素(比如点击 inner，inner 就是目标元素)开始，按 DOM 树向上冒泡；而 Netscape 采取的是相反的原则，即从顶部元素开始，直到事件目标元素。通过上面的例子可以知道，可以通过设置 addEventListener 方法的第三个参数可以设置是冒泡还是捕获，当设置为 true 时，是捕获，当设置为 false 时，是冒泡，默认是 false。 现在考虑一个比较复杂的 DOM 结构，如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .one &#123; width: 200px; height: 200px; background-color: black; margin: 100px auto; &#125; .two &#123; width: 150px; height: 150px; background-color: aliceblue; &#125; .three &#123; width: 100px; height: 100px; background-color: greenyellow; &#125; .four &#123; width: 50px; height: 50px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt; &lt;div class=\"three\"&gt; &lt;div class=\"four\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let one = document.querySelector('.one'); let two = document.querySelector('.two'); let three = document.querySelector('.three'); let four = document.querySelector('.four'); one.addEventListener('click', (e) =&gt; &#123; console.log('one被点击了'); &#125;, true); two.addEventListener('click', (e) =&gt; &#123; console.log('two被点击了'); &#125;, false); three.addEventListener('click', (e) =&gt; &#123; console.log('three被点击了'); &#125;, true); four.addEventListener('click', (e) =&gt; &#123; console.log('four被点击了'); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面四个盒子套在一起，我们为one和three设定为捕获模式，为two和four设定为冒泡模式，如果我们点击four，这时的输出会是什么呢? 我们观察到输出的顺序为one -&gt; three -&gt; four -&gt; two，代码是怎么执行的呢? 首先事件处理器会从顶部开始即 one(严格的说是从 window)，一直到目标元素，在这个路径中，如果遇到设置为捕获模式的则执行，碰到冒泡模式的则跳过，达到目标元素后，开始转换为冒泡模式，向上冒泡到one，在这个路径中，如果碰到设置为冒泡模式的则执行，否则跳过。 现在我们来看看上面的执行流程： 首先从one开始向下捕获，one设置为捕获模式，执行 遇到two，two设置为冒泡模式，不执行跳过 遇到three，three设置为捕获模式，执行 遇到four，到达目标元素，执行(此时不管four是冒泡还是捕获都没有关系，都会执行的) 接着转变为冒泡模式，遇到three，three为捕获模式，跳过 遇到two，two为冒泡模式，执行 遇到one，one为捕获模式，不执行，此时已经到达顶部，结束 通过上面的流程，不难知道输出的顺序为什么是one -&gt; three -&gt; four -&gt; two。 在父元素上代理事件我们来看一个运用冒泡的小例子，假设有这个一个DOM结构 &lt;ul&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt;&lt;/ul&gt; 我们希望当点击 li 标签时，将 li 标签里面的文字变为红色，所以很有可能你会写出这样的代码 document.querySelectorAll(\"ul li\").forEach(item =&gt; &#123; item.addEventListener('click', (e) =&gt; &#123; e.target.style.color = 'red'; &#125;)&#125;) 这样写当然能达到效果，但是如果 ul 下面有成千上万个 li，这样写未免性能太低，我们可以利用冒泡的特性，为 ul 绑定点击事件，如下 document.querySelector('ul').addEventListener('click', (e) =&gt; &#123; e.target.style.color = 'red';&#125;); 这样不管 ul 下面有多少个 li 都没有关系。 解释： 这里可能有人不太懂 e.target 是什么，e.target 是指触发点击事件的元素，而不是 ul，因为我们点击的是 li 标签，所以这里的 e.target 是被点击的 li 元素。如果想在 addEventListener 里面访问 ul 元素，可以使用 this。 阻止事件冒泡有的时候我们不希望事件有冒泡操作，我们可以通过 event 对象的 stopPropagation 方法来阻止事件冒泡，以文章开头的 inner 和 outer 为例(outer 和 inner 都设置为冒泡模式)，我们给 inner 的 addEventListener 修改为 inner.addEventListener('click', (e) =&gt; &#123; e.stopPropagation(); console.log('inner被点击了');&#125;); 这时我们点击inner，这时只有inner的点击事件被执行了","tags":[{"name":"JavaScript 冒泡与捕获","slug":"JavaScript-冒泡与捕获","permalink":"https://lastknightcoder.gitee.io/tags/JavaScript-%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7/"}]},{"title":"SSM整合","date":"2020-03-01T16:00:00.000Z","path":"/SSM整合/","text":"在学习完Spring, SpringMVC, MyBatis三大框架后，现在将记录如何整合这三个框架。 准备工作首先新建一个Maven工程，在pom.xml中导入以下包 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 接着创建一个User表 use mybatis;drop table if exists user;create table user(username varchar(20), age int, sex varchar(10)) character set utf8;insert into user values(\"张三\", 18, \"male\");insert into user values(\"李四\", 19, \"male\"); 此时的user表为 +----------+------+------+| username | age | sex |+----------+------+------+| 张三 | 18 | male || 李四 | 19 | male |+----------+------+------+ Spring整合Dao层首先在包com.pojo下新建实体类User如下 package com.pojo;public class User &#123; private String userName; private Integer age; private String sex; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + \", sex='\" + sex + '\\'' + '&#125;'; &#125;&#125; 接下来在com.dao包下新建UserDao接口，如下 package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 接下来在resources目录下新建MyBatis的配置文件mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.pojo\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 只是在其中配置了别名，数据源的配置会在Spring配置文件中配置，现在在resources下新建database.properties文件，如下 jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=root 最后新建spring-dao.xml文件，这是Spring整合MyBatis的配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 读取数据库信息 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 配置连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 扫描com.dao下的包 动态生成实现类注册到Spring中 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;property name=\"basePackage\" value=\"com.dao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在resources下新建applicationContext.xml配置文件，将spring-dao.xml导入，该文件是Spring的主配置文件，主要的功能就是导入配置文件，如spring-dao.xml, spring-service.xml以及spring-mvc.xml，如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"classpath:spring-dao.xml\"/&gt;&lt;/beans&gt; 现在便是在test/java下新建TestSpringDao测试类，来验证Spring是否整合了MyBatis，如下 import com.dao.UserDao;import com.pojo.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class TestSpringDao &#123; @Autowired private UserDao userDao; @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for (User user: users) &#123; System.out.println(user); &#125; &#125;&#125; 输出为 User&#123;userName='张三', age=18, sex='male'&#125;User&#123;userName='李四', age=19, sex='male'&#125; 可见Spring以及整合MyBatis成功了。 Spring整合Service层简单的模拟业务层，在com.service下新建UserService接口如下 package com.com.service;import com.pojo.User;import java.util.List;public interface UserService &#123; List&lt;User&gt; findAll();&#125; 接着建立它的实现类UserServiceImpl，如下 package com.com.service;import com.dao.UserDao;import com.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125;&#125; 接着新建spring-service.xml，如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.service\"/&gt;&lt;/beans&gt; 在applicationContext.xml中导入该配置文件 &lt;import resource=\"classpath:spring-service.xml\"/&gt; 接着新建TestSpringService测试类 import com.pojo.User;import com.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class TestSpringService &#123; @Autowired private UserService userService; @Test public void testUserService() &#123; List&lt;User&gt; users = userService.findAll(); for (User user: users) &#123; System.out.println(user); &#125; &#125;&#125; 输出为 User&#123;userName='张三', age=18, sex='male'&#125;User&#123;userName='李四', age=19, sex='male'&#125; Spring Service层整合成功。 Spring整合Controller层首先点击项目，右键选择Add Framework Support…，并选择Web Application 这时的项目就成为了一个Web项目，我们在web.xml中配置如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在resources下新建spring-mvc.xml，内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;context:component-scan base-package=\"com.controller\"/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 并且在applicationContext.xml中导入该配置文件 &lt;import resource=\"classpath:spring-mvc.xml\"/&gt; 在com.controller包下新建UserController类，如下 package com.controller;import com.pojo.User;import com.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping(value = \"/users\", produces = \"text/html;charset=utf-8\") public String getUsers() &#123; List&lt;User&gt; users = userService.findAll(); return users.toString(); &#125;&#125; 接着启动Tomcat(在启动Tomcat之前记得添加依赖的包)，在地址栏后输入/users 至此，SSM整合结束。","tags":[{"name":"SSM Spring SpringMVC MyBatis","slug":"SSM-Spring-SpringMVC-MyBatis","permalink":"https://lastknightcoder.gitee.io/tags/SSM-Spring-SpringMVC-MyBatis/"}]},{"title":"Spring MVC笔记","date":"2020-02-29T16:00:00.000Z","path":"/Spring MVC笔记/","text":"本片文章是我记录学习Spring MVC的学习笔记，作为初学者，对于这个框架的理解可能并不深刻，所以这篇文章主要讲述的是Spring MVC框架的使用，所以对于有些内容为什么要这么做，这么做有什么好处，由于才疏学浅，却不是我能解释的，所以本篇文章以代码偏多，文字解释偏少。 Hello Spring MVC先简单的的把Spring MVC用起来，然后在解释一下Spring MVC的用法。首先在pom.xml中导入需要的包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-webmvc就是我们需要的包，而junit不用说，是用来测试用的。Java底层对浏览器做出响应是基于Servlet，所以Spring MVC也是基于Servlet的，所以我们还导入了Servlet的包，以及对JSP的支持和JSTL语言的支持的包。 由于我们建立的只是一个普通的Maven工程，我们要对项目添加支持，使其成为一个Web项目，单击项目右键选择Add Framework Support…，如下 接着勾选WebApplication，点击OK 这时会在你的项目中为你生成一个web目录，如下 这时我们配置web.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 我们知道JavaWeb的工作流程是根据浏览器的请求地址去找对应的Servlet去做处理，这里我们配置对所有的请求(/)都会使用Spring提供的DispatchServlet进行处理。具体的处理流程稍后会介绍，从上面的配置看出，DispatchServlet还需要一个配置文件地址的参数，这里我们写为了classpath:springmvc-config.xml，而这个文件还没有，所以我们在src/main/resources中新建springmvc-config.xml，内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;context:component-scan base-package=\"com.controller\"/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 我们在这个配置文件中对com.controller中的类开启了mvc注解支持。还配置了一个ServletHandler和ViewResolver，这两个东西与后面讲的Spring MVC执行流程有关，后面再说。 现在新建com.controller.HandleRequest.java，内容如下 package com.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HandleRequest &#123; @RequestMapping(\"/hello\") public String sayHello() &#123; return \"Hello Spring MVC\"; &#125;&#125; 该类的作用是当浏览器访问/hello时，会返回浏览器一个字符串”Hello Spring MVC”，现在使用tomcat服务器启动该项目，并且在地址栏后输入/hello，这时我们会得到一个错误如下 这是因为我们没有在项目中加入所依赖的包，这时我们在IDEA中的左上角找到File并点击，选择Project Structure，接着在Project Structure中选择Artifacts 这时选择你的项目，比如我的是mvc-hello，右键选择Put into Output Root 接下来重新启动Tomcat，然后在浏览器地址栏后输入/hello 就可以看到Hello Spring MVC在浏览器上显示了出来。 Spring MVC的执行流程 上图演示了Spring MVC执行的流程，在这里稍作解释 用户发送请求至前端控制器DispatcherServlet DispatcherServlet收到请求调用处理器映射器HandlerMapping 处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。 DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter，执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作 执行处理器Handler(Controller，也叫页面控制器) Handler执行完成返回ModelAndView HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ViewReslover解析后返回具体View DispatcherServlet对View进行渲染视图(即将模型数据model填充至视图中) DispatcherServlet响应用户 现在稍加解释上面牵涉到的组件： DispatcherServlet：前端控制器，用户请求到达前端控制器，它就相当于MVC模式中的C，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高 HandlerMapping：处理器映射器，HandlerMapping负责根据用户请求的url找到Handler即处理器，SpringMVC提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等 Handler：处理器,Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler HandlAdapter：处理器适配器,通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行 ModelAndView是SpringMVC的封装对象，将Model和View封装在一起。 ViewResolver：视图解析器,ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View:是SpringMVC的封装对象，是一个接口, SpringMVC框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 Spring MVC注解@Controller@Controller注解表明了一个类是作为控制器的角色而存在的。Spring不要求你去继承任何控制器基类，也不要求你去实现Servlet的那套API。当然，如果你需要的话也可以去使用任何与Servlet相关的特性和设施。 @Controller注解可以认为是被标注类的原型(stereotype)，表明了这个类所承担的角色。分派器(DispatcherServlet)会扫描所有注解了@Controller的类，检测其中通过@RequestMapping注解配置的方法(详见下一小节)。 当然，你也可以不使用@Controller注解而显式地去定义被注解的bean，这点通过标准的Spring bean的定义方式，在dispather的上下文属性下配置即可做到。但是@Controller原型是可以被框架自动检测的，Spring支持classpath路径下组件类的自动检测，以及对已定义bean的自动注册。 @RestController这里说的是与@Controller，被@Controller注解的类，如果在方法中方法字符串，则会被视图解析器解析，即如下 package com.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HandleRequest &#123; @RequestMapping(\"/hello\") public String sayHello() &#123; return \"hello\"; &#125;&#125; 当访问/hello时，会执行sayHello方法，这时返回的hello会被视图解析器解析，视图解析器会根据在springmvc-config.xml中的配置进行拼接 &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 所以上面方法的hello会被拼接成WEB-INF/jsp/hello.jsp，接着会返回该jsp页面。 而使用@RestController注解，则不会经过视图解析器，而是会将该结果直接返回，就像在前一节演示的例子一样。因为最近流行前后端分离，所以后端不需要写页面了，只需要将前端请求的数据返回，而前端负责渲染展示数据，所以@RestController类用的还是比较多的。 @RequestMapping你可以使用@RequestMapping注解来将请求URL，如/appointments等，映射到整个类上或某个特定的处理器方法上。一般来说，类级别的注解负责将一个特定(或符合某种模式)的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（”GET” “POST”方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。 现在来讲一下@RequestMapping中的属性，@RequestMapping的源码如下 public @interface RequestMapping &#123; String name() default \"\"; @AliasFor(\"path\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] path() default &#123;&#125;; RequestMethod[] method() default &#123;&#125;; String[] params() default &#123;&#125;; String[] headers() default &#123;&#125;; String[] consumes() default &#123;&#125;; String[] produces() default &#123;&#125;;&#125; name, value, path：是用来设置匹配的url路径的 method：指定请求的method类型, GET、POST、PUT、DELETE等 consumes：指定处理请求的提交内容类型(Content-Type)，例如application/json, text/html produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 params：指定request中必须包含某些参数值时，才让该方法处理 headers：指定request中必须包含某些指定的header值，才能让该方法处理请求 给个例子： @RequestMapping(value=\"/hello\", method = RequestMethod.GET, params = \"myParam=myValue\", headers=\"Referer=www.baidu.com\", consumes=\"application/json\", produces=\"application/json\") 除了可以使用method属性指定请求办法外，还可以使用注解： @GetMapping(“/hello”) @PostMapping(“/hello”) …… 这些注解与RequestMapping具有相同的属性，除了method属性。 @RequestParam该注解类型用于将指定的请求参数赋值给方法中的形参，那么@RequestParam注解有什么属性呢? 它有4种属性，下面将逐一介绍这四种属性： name属性：该属性的类型是String类型，它可以指定请求头绑定的名称 value属性：该属性的类型是String类型，它可以设置是name属性的别名 required属性：该属性的类型是boolean类型，它可以设置指定参数是否必须绑定 defalutValue属性：该属性的类型是String类型，它可以设置如果没有传递参数可以使用默认值 @RequestMapping(value=\"/hello\")public String hello( @RequestParam(\"loginname\") String loginname, @RequestParam(\"password\") String password) &#123; return \"hello\";&#125; @PathVaribale@PathVaribale注解，该注解类型可以非常方便的获得请求url中的动态参数。 @PathVaribale注解只支持一个属性value，类型String，表示绑定的名称，如果省略则默认绑定同名参数 @RequestMapping(value=\"/pathVariableTest/&#123;userId&#125;\")public void pathVariableTest(@PathVaribale Integer userId) @CookieValue绑定cookie的值到Controller方法参数 @RequestMapping ( \"/hello\" )public String testCookieValue( @CookieValue(\"hello\") String cookieValue) &#123; return \"cookieValue\" ;&#125; @RequestHeader@RequestHeader注解，该注解类型用于将请求的头的信息区域数据映射到功能处理方法的参数上。那么@RequestHeader注解有什么属性呢? 它和@RequestParam注解一样，也有4种属性，分别如下 name属性：该属性的类型是String类型，它可以指定请求头绑定的名称 value属性：该属性的类型是String类型，它可以设置是name属性的别名 required属性：该属性的类型是boolean类型，它可以设置指定参数是否必须绑定 defalutValue属性：该属性的类型是String类型，它可以设置如果没有传递参数可以使用默认值 @RequestMapping(value=\"/requestHeaderTest\")public void requestHeaderTest( @RequestHeader(\"User-Agent\") String userAgent, @RequestHeader(value=\"Accept\") String[] accepts) &#123;&#125; @RequestBody@RequestBody注解是将HTTP请求正文插入方法中 @RequestMapping(value = \"/login\")public String login(@RequestBody Person person) &#123; return \"...\"; &#125; @RequestBody注解常用来处理Content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。 对于前端使用而言，form表单的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded，所以在前端传输数据时，需要将Content-type显示指定为application/json。 总结： ReuqestBody主要是处理json串格式的请求参数，要求使用方指定header Content-type:application/json RequestBody通常要求调用方使用post请求 @ResponseBody@ResponseBody注解的作用是将Controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，它的效果等同于通过response对象输出指定格式的数据。 @RequestMapping(\"/login\")@ResponseBodypublic User login(User user)&#123; //User字段：userName pwd //那么在前台接收到的数据为：'&#123;\"userName\":\"xxx\",\"pwd\":\"xxx\"&#125;' return user;&#125;//效果等同于如下代码：@RequestMapping(\"/login\")public void login(User user, HttpServletResponse response)&#123; response.getWriter.write(JSONObject.fromObject(user).toString()); &#125;&#125; 参考资料 SpringMVC执行流程及工作原理 RequestMapping 属性解释 Spring之RequestBody的使用姿势小结 @responseBody注解的使用","tags":[{"name":"Java SpringMVC","slug":"Java-SpringMVC","permalink":"https://lastknightcoder.gitee.io/tags/Java-SpringMVC/"}]},{"title":"Hexo中数学公式问题","date":"2020-02-29T04:23:42.000Z","path":"/hexo博客中的数学问题/","text":"起因之前我的Hexo主题使用的是Next主题，Next主题因为对数学公式有进行处理，所以在用Next主题时写数学公式是十分的顺畅的，但是最近觉得Next主题颜色太淡了，所以就换了一个颜色比较鲜艳的Hexo主题，但是这一换，数学公式就有了麻烦。 首先我们要明白这个麻烦是怎么产生的，因为markdown的语法跟mathjax有重叠，比如_在mathjax中表示下标，但是在markdown中，被两个下划线_包裹起来的内容会被转为&lt;em&gt;标签，即其间的内容会被转为斜体，这就使得数学公式渲染不出来；另一个就是//在mathjax表示换行，但是在解析markdown时却会被转义。 解决这个时候我就去网上搜了解决办法，有好几种，比如第一种是修改marked.js(node_modules/marked/lib/marked.js)，修改两个关键字为excape和em的正则表达式，这个方法我试了，但是没有用；第二个办法是卸载hexo默认的markdown解析hexo-renderer-marked，然后安装hexo-renderer-pandoc(好像Next就是这么干的)，前提是要安装Pandoc，然后由于我的npm不知道出了什么原因，不能uninstall，只能寻求它法。(不过你们可以尝试，解决办法链接在这) 不过功夫不负有心人，经过几个小时折腾，还是被我找到了解决办法，我在hexo的issue中看到，将有问题的数学公式如下处理： 这样数学公式就不会被marked解析，但是会被mathjax解析。 上面的做法可以解决大部分的问题，但是我们数学公式里面包含一对&lt;&gt;的话，又会出现问题，通过F12检查元素，发现被&lt;&gt;包裹的内容被误认为是标签了，导致渲染不出来，要解决这个办法，把公式中所有的&lt;使用\\lt替代，所有的&gt;使用\\gt替代，这样就可以了。 Hexo的数学公式真的是折腾的我够呛，所以这次经历必须记录下来，为了下次遇到同样问题时能够迅速解决。 参考资料 关于数学公式的渲染问题 Hexo下mathjax转义问题","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lastknightcoder.gitee.io/tags/Hexo/"}]},{"title":"Spring笔记","date":"2020-02-26T16:00:00.000Z","path":"/Spring笔记/","text":"概述Spring是一个什么东西? 简单的理解就是一个容器。既然是容器，那就是装东西的，装什么的呢? 里面装的都是对象。以前对象都是由我们自己管理，比如我们在User类中使用Student对象，那么我们会直接new，比如 // User.javaStudent student = new Student(); 那如果使用Spring的话，会将Student对象放在Spring容器中，如果在User类中使用Student对象，那么就向Spring容器要。我们把这个称之为IOC(控制反转)，即控制权由程序员交给了Spring容器。 所以接下来就要讲如何将对象交给Spring容器，或者说Spring容器如何创建对象，主要是在创建对象时如何为对象里面的成员变量注入值。 入门首先新建一个Maven工程，在pom.xml中导入依赖。说实话Spring框架是一个大家族，它有非常多的包，这里我们导入spring-webmvc，该包依赖了很多其他Spring的包，这样我们需要的包都会被导入，所以我们只要导入这一个包就可以，如下 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在src/main/java下新建pojo.Hello.java，如下 package pojo;public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Hello&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 现在我们要将这个Hello对象交给Spring，首先在resources下新建Spring的配置文件beans.xml(名字随便，官方名字是applicationContext.xml)，内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hello\" class=\"pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Hello\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 其中 &lt;bean id=\"hello\" class=\"pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Hello\"/&gt;&lt;/bean&gt; 就是在Spring容器中注册Hello，其中id是我们向Spring容器获取Hello对象用的，class是Hello类的全限定类名。在bean标签中的peoperty标签的作用是设置在创建Hello对象时其成员变量的值。上面设置为成员变量name注入值Hello。 现在在test/java下新建TestHello.java，内容如下 import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Hello;public class TestHello &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Hello hello = (Hello) applicationContext.getBean(\"hello\"); System.out.println(hello); &#125;&#125; 运行结果为 Hello&#123;name='Hello'&#125; 其中 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); 是根据配置文件beans.xml得到Spring容器，接着我们根据在beans,xml中配置的id获取Hello对象 Hello hello = (Hello) applicationContext.getBean(\"hello\"); 接着我们打印出Hello对象，发现这个对象的成员变量name已经有值Hello，这是我们在beans.xml中注入的。 IOC创建对象IOC创建对象的过程，其实关键就是向对象的成员变量注入值，我们把这个东西叫做装配，而接下来就是介绍如何为成员变量注入值。 构造器注入第一种方法就是通过构造函数注入(初始化)，上面那个例子IOC在创建对象时是调用的是无参构造函数，所以上面那个例子的装配不是通过构造函数装配的，为了演示构造函数装配，首先新建一个User类 package pojo;public class User &#123; private String userName; private int age; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 接着在beans.xml注册该类(就是将它交给Spring容器)，如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"奥特曼\"/&gt; &lt;constructor-arg index=\"1\" value=\"1\"/&gt;&lt;/bean&gt; 其中constructor-arg标签就是通过构造函数注入值，这里是通过参数的位置注入值的，比如为第一个参数即index = 0的位置注入”奥特曼”，为第二个参数即index = 1的位置注入1。 接着我们可以在test/java中新建TestUser类，内容如下 import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.User;public class TestUser &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); System.out.println(user); &#125;&#125; 上面的代码想必无需解释，上面的结果为 User&#123;userName='奥特曼', age=1&#125; 可见是注入成功了。 通过构造器注入，还有两种方法，比如通过类型注入，修改上面的constructor-arg标签如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"奥特曼\"/&gt; &lt;constructor-arg type=\"int\" value=\"1\"/&gt;&lt;/bean&gt; 上面的配置就是根据构造函数参数类型进行配置，再次运行代码，得到的结果还是一样的。 注意: 如果有多个成员变量的类型是相同的，那么此方法就不适用了。 最后一种就是根据成员变量的名字进行配置，如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg name=\"userName\" value=\"奥特曼\"/&gt; &lt;constructor-arg name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; set方法注入set方法注入就是指通过无参构造函数创建对象以后，通过set方法将值注入到成员变量中，所以使用该方法注入就需要为每个成员变量写set方法，修改上面的User类如下 package pojo;public class User &#123; private String userName; private int age; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 现在在beans.xml中进行配置如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;property name=\"userName\" value=\"奥特曼\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; 我们通过property标签向对象注入值，这是通过成员变量的名字进行配置的。 其它配置方法p命名空间注入要使用p命名空间，就得导入约束，修改beans.xml的约束 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- ... ... --&gt;&lt;/beans&gt; 所谓p命名空间注入与set方法注入是相同的，只不过写法不同，写法如下 &lt;bean id=\"user\" class=\"pojo.User\" p:userName=\"奥特曼\" p:age=\"1\"/&gt; c命名空间注入要使用c命名空间同样要导入约束，再次修改beans.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- ... ... --&gt;&lt;/beans&gt; c命名空间注入与构造函数注入是相同的，写法同p命名空间注入，如下 &lt;bean id=\"user\" class=\"pojo.User\" c:userName=\"奥特曼\" c:age=\"1\"/&gt; 或者 &lt;bean id=\"user\" class=\"pojo.User\" c:_0=\"奥特曼\" c:_1=\"1\"/&gt; 上面的0和1代表的是构造函数中参数的位置。 各种类型成员变量的注入这里以set的方式讲解怎么注入各种类型成员变量，比如复杂类型，数组，List等集合，首先新建一个Student类如下 package pojo;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Student &#123; private String name; private Address address; private String[] hobbies; private List&lt;String&gt; games; private Set&lt;String&gt; toys; private Map&lt;String, Integer&gt; scores; private String wife; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getHobbies() &#123; return hobbies; &#125; public void setHobbies(String[] hobbies) &#123; this.hobbies = hobbies; &#125; public List&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(List&lt;String&gt; games) &#123; this.games = games; &#125; public Set&lt;String&gt; getToys() &#123; return toys; &#125; public void setToys(Set&lt;String&gt; toys) &#123; this.toys = toys; &#125; public Map&lt;String, Integer&gt; getScores() &#123; return scores; &#125; public void setScores(Map&lt;String, Integer&gt; scores) &#123; this.scores = scores; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address + \", hobbies=\" + Arrays.toString(hobbies) + \", games=\" + games + \", toys=\" + toys + \", scores=\" + scores + \", wife='\" + wife + '\\'' + '&#125;'; &#125;&#125; 上面的成员变量类型有String，复杂类型Address，数组，List, Map, Set集合，以及最后一个String类型的wife，我们将通过wife演示如果注入null。因为这里用到了复杂类型Address，所以新建类Address如下 package pojo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; 将Address注册到Spring容器中，在beans.xml中添加如下 &lt;bean id=\"address\" class=\"pojo.Address\"&gt; &lt;property name=\"address\" value=\"China\"/&gt;&lt;/bean&gt; 现在直接演示如果为Student中的成员变量注入 &lt;bean id=\"student\" class=\"pojo.Student\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"address\" ref=\"address\"/&gt; &lt;property name=\"hobbies\"&gt; &lt;array&gt; &lt;value&gt;打球&lt;/value&gt; &lt;value&gt;游泳&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;list&gt; &lt;value&gt;王者荣耀&lt;/value&gt; &lt;value&gt;吃鸡&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"toys\"&gt; &lt;set&gt; &lt;value&gt;飞机&lt;/value&gt; &lt;value&gt;大炮&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"scores\"&gt; &lt;map&gt; &lt;entry key=\"math\" value=\"20\"&gt;&lt;/entry&gt; &lt;entry key=\"english\" value=\"50\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt;&lt;/bean&gt; 对于Address复杂类型，我们使用ref属性引用已经在Spring中注册过的类，其值就是它注册时的id。剩下的应该很容易看懂，就不解释了。 Spring配置 标签 作用 alias 别名 bean 向Spring容器注册类 import 导入其它配置文件 Bean的作用域bean标签有一个scope属性，可以设置作用域，这里只介绍两种取值 singleton：单例模式，从Spring容器中得到的对象是同一对象，默认值 prototype：原型模式，从Spring容器中得到的对象是不同对象 &lt;bean id=\"user\" class=\"pojo.User\" c:userName=\"奥特曼\" c:age=\"1\" scope=\"singleton\"/&gt; 比如在TestUser中修改如下 import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.User;public class TestUser &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); // 第二个参数传了User.class就不用强转了 User user2 = applicationContext.getBean(\"user\", User.class); System.out.println(user == user2); // true &#125;&#125; 现在修改scope为prototype，再次运行打印出的结果就是false了。 自动装配Bean首先准备几个类，新建Man.java package com.pojo;public class Man &#123; private Dog dog; private Cat cat; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125;&#125; 其中Man有两个宠物，一个为Cat，一个为Dog，新建这两个类 package com.pojo;public class Cat &#123; public void shout() &#123; System.out.println(\"miao\"); &#125;&#125; package com.pojo;public class Dog &#123; public void shout() &#123; System.out.println(\"wang\"); &#125;&#125; 在beans.xml中注册Dog和Cat &lt;bean id=\"cat\" class=\"com.pojo.Cat\"/&gt;&lt;bean id=\"dog\" class=\"com.pojo.Dog\"/&gt; 现在考虑怎么向Man中注入Cat和Dog。 按名字自动注入在beans.xml添加如下 &lt;bean id=\"man\" class=\"com.pojo.Man\" autowire=\"byName\"/&gt; autowire就是用来设置自动注入的，这里设置为按名字自动注入(byName)。它会在Spring容器寻找到id与setXxx中Xxx名字相同的类注入，比如在Man中有setDog()方法，它会在Spring容器中找到id为dog的类(在Spring中注册的类，一般都称为bean)自动为它注入。 按类型注入修改Man的bean为 &lt;bean id=\"man\" class=\"com.pojo.Man\" autowire=\"byType\"/&gt; 这时会在Spring容器中寻找类型为Dog和Cat的bean为Man中的Dog和Cat自动注入，但是如果Spring容器中有多个类型相同的bean，那么就不能注入，比如我们向Spring容器中在注入一个Dog如下 &lt;bean id=\"dog2\" class=\"com.pojo.Dog\"/&gt; 这时我们发现在beans.xml中报错了 使用注解注入使用@AutoWired注解在成员变量上，会在Spring容器找到符合条件的，自动注入，首先在beans.xml中注册Man类 &lt;bean id=\"man\" class=\"com.pojo.Man\"/&gt; 在Man.java中为成员变量加上注解 @Autowiredprivate Dog dog;@Autowiredprivate Cat cat; 这时还是不行的，因为要在beans.xml中开启注解支持，首先导入约束，修改约束如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- ... ... --&gt;&lt;/beans&gt; 接着开启注解支持，在beans.xml中添加如下 &lt;context:annotation-config/&gt; @AutoWired注解首先通过byType即类型寻找符合条件的bean，如果找到多个类型相同的bean符合条件，那么接着在这些bean中byName寻找符合条件的。 我们可以给成员变量加上@Qualifier注解，这样就会按照@Qualifier规定的name取寻找符合条件的bean。 @Autowired@Qualifier(\"dog\")private Dog dog;@Autowired@Qualifier(\"cat\")private Cat cat; @AutoWired也可以在setXxx方法上使用，并且如果在成员变量上使用，则可以不写setter方法了。 除了使用@AutoWired注解，我们还可以使用@Resource注解，这个注解不是Spring的，是J2EE的，我们修改注解如下 @Resourceprivate Dog dog;@Resourceprivate Cat cat; @Resource是默认byName去寻找符合条件的bean的，如果找不到则byType。 Spring注解开发要使用注解，首先导入约束(在上面演示过了)，并且开启注解支持，最后设置要扫描的包(即哪些包下的类是使用注解的)，beans.xml的内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.pojo\"/&gt;&lt;/beans&gt; 在上面定义扫描com.pojo下的包，首先新建Student类和Address类 package com.pojo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;public class Student &#123; private String name; private Address address; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address + '&#125;'; &#125;&#125; package com.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;public class Address &#123; private String address; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; @Component接下来本应该是在beans.xml中注册，但是这次我们不使用xml配置了，而是使用注解，要向Spring容器中注册，我们只需要在类上面加入@Component注解，而注入则可以使用我们在上面介绍的@AutoWired，如下 package com.pojo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Student &#123; @Value(\"Alice\") private String name; @Autowired private Address address; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address + '&#125;'; &#125;&#125; package com.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Address &#123; @Value(\"American\") private String address; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; 其中@Value注解是向其中注入普通值的，如String，int等等，对于一些其他一些复杂类型，如数组，集合等，建议使用xml配置，更清晰。 接下来在test/java/TestStudent.java中进行测试 import com.pojo.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestStudent &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = applicationContext.getBean(\"student\", Student.class); System.out.println(student); &#125;&#125; 输出为 Student&#123;name='Alice', address=Address&#123;address='American'&#125;&#125; @Component衍生的注解:下面介绍@Component衍生的注解，这些注解的作用与@Component相同，只不过语义不同，如 @Controller：使用在Web层(servlet) @Service：使用在业务层(service) @Repository：使用在持久层(dao) 这些注解的功能相同，就是将类配置在Spring容器中。 @Scope@Scope是用来设置bean的范围的，上面我们介绍过两种取值，一种是singleton，另一种是prototype，如 @Component@Scope(\"singleton\") 通过JavaConfig实现配置新建工程并新建一个User类，如下 package com.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; @Value(\"biu\") private String name; @Value(\"1\") private int age; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 这其中的内容都不洗解释了。之前我们的配置都是通过xml文件配置的，这次我们将彻底不需要xml文件，而是通过Java类来进行配置，在com.config包下新建JavaConfig.java，内容如下 package com.config;import com.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.pojo\")public class JavaConfig &#123; @Bean public User getUser() &#123; return new User(); &#125;&#125; 在此类中我们使用了一个@Configuration注解，代表这是一个配置类。@ComponentScan定义了扫描包的范围。@Bean注解就是相当于bean标签，其方法名就相当于是id，返回值类型就是class。 接在我们在test/java/TestUser中进行使用如下 import com.config.JavaConfig;import com.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestUser &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class); User user = applicationContext.getBean(\"getUser\", User.class); System.out.println(user); &#125;&#125; 输出为 User&#123;name='biu', age=1&#125; 我们可以通过@Bean注解来设置id，比如上面JavaConfig中的@Bean修改如下 @Bean(\"user\") 那么我们就可以通过”user”去Spring容器中拿User对象 User user = applicationContext.getBean(\"user\", User.class); 注意: 这时不能通过方法名获得对象了。 AOP现在假设有这么一个需求，有下面这么一个dao类，如下 package com.dao;public class UserDao &#123; public void add() &#123; System.out.println(\"add\"); &#125; public void update() &#123; System.out.println(\"update\"); &#125; public void query() &#123; System.out.println(\"query\"); &#125; public void delete() &#123; System.out.println(\"delete\"); &#125;&#125; 我们希望每次在调用该类的方法的前后都打印出日志，我们当然不能在UserDao类中的每个方法中手动打印，如 public void add() &#123; System.out.println(\"add方法执行前\"); System.out.println(\"add\"); System.out.println(\"add方法执行后\");&#125; 这样将日志的代码与业务的代码揉在一起，不好；另一个对于每个方法都要写这样的代码，又累又low。 AOP概念Spring框架自诞生之日就拯救我等程序员于水火之中，它有两大法宝，一个是IoC控制反转，另一个便是AOP面向切面编程。AOP全名Aspect-oriented programming面向切面编程。 切面(Aspect)切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 目标对象(Target)目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。 连接点(JoinPoint)程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定： 方法(表示程序执行点，即在哪个目标方法) 相对点(表示方位，即目标方法的什么位置，比如调用前，后等) 简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。 切入点(PointCut)切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。 一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。 通知(Advice)通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。 织入(Weaving)织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。 增强器(Adviser)Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。 Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。 Spring AOP我们将使用AOP来实现上面的需求，要使用AOP，首先要导入一个包aspectj，如下 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 两个日志类分别表示在方法执行之前和执行之后 package com.log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class LogBefore implements MethodBeforeAdvice &#123; public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(\"在\" + method.getName() + \"之前执行\"); &#125;&#125; package com.log;import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class LogAfter implements AfterReturningAdvice &#123; public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123; System.out.println(\"在\" + method.getName() + \"执行后， 返回值为\" + o); &#125;&#125; 接着在beans.xml中注册这三个类，为了使用AOP，我们要导入约束，beans.xml全部内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.dao.UserDao\"/&gt; &lt;bean id=\"beforeLog\" class=\"com.log.LogBefore\"/&gt; &lt;bean id=\"afterLog\" class=\"com.log.LogAfter\"/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.dao.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"beforeLog\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 现在在TestUserDao中进行测试 import com.dao.UserDao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestUserDao &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserDao userDao = applicationContext.getBean(\"userDao\", UserDao.class); userDao.add(); &#125;&#125; 输出为 在add之前执行add在add执行后， 返回值为null 自定义类 AOP现在我们将使用另一种用法实现上面的效果，这次我们新建一个Log类，如下 package com.log;public class Log &#123; public void before() &#123; System.out.println(\"before\"); &#125; public void after() &#123; System.out.println(\"after\"); &#125;&#125; 修改beans.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.dao.UserDao\"/&gt; &lt;bean id=\"log\" class=\"com.log.Log\"/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"log\"&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.dao.*.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 再次运行TestUserDao类，输出为 beforeaddafter 注解 AOP修改beans.xml为 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com\"/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 修改Log.java为 package com.log;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Aspect@Componentpublic class Log &#123; @Before(\"execution(* com.dao.*.*(..))\") public void before() &#123; System.out.println(\"before\"); &#125; @After(\"execution(* com.dao.*.*(..))\") public void after() &#123; System.out.println(\"after\"); &#125;&#125; UserDao.java package com.dao;import org.springframework.stereotype.Component;@Componentpublic class UserDao &#123; public void add() &#123; System.out.println(\"add\"); &#125; public void update() &#123; System.out.println(\"update\"); &#125; public void query() &#123; System.out.println(\"query\"); &#125; public void delete() &#123; System.out.println(\"delete\"); &#125;&#125; 再次运行TestUserDao，输出如下 beforeaddafter","tags":[{"name":"Java Spring IOC AOP","slug":"Java-Spring-IOC-AOP","permalink":"https://lastknightcoder.gitee.io/tags/Java-Spring-IOC-AOP/"}]},{"title":"MyBatis学习笔记","date":"2020-02-13T16:00:00.000Z","path":"/MyBatis学习笔记/","text":"MyBatis入门新建Maven工程，在其中引入所需要的包，如mybatis, mysql-connector-java, junit。配置pom.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;xt.mybatis&lt;/groupId&gt; &lt;artifactId&gt;simple&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在MySQL中新建一个mybatis的库 CREATE DATABASE mybatis; 然后使用该数据库并建一个book表 USE mybatis;CREATE TABLE BOOK(ID INT AUTO_INCREMENT PRIMARY KEY,NAME VARCHAR(20),NUMBER int );insert into BOOK(NAME,NUMBER) VALUES('Java程序设计',10),('数据结构',10),('设计模式',10); 如果出现由于中文不能插入的问题，输入以下语句然后插入数据 alter table mybatis change name name varchar(20) character set utf8; 在src/java中新建包com.xt.entity，新建Book实体类，实体类是用来保存数据库中查询到的结果，在这里实体类的属性要保持和数据库中的列名一致(后续会讲解不一致会出现什么以及解决办法) package com.xt.entity;public class Book &#123; private int id; private String name; private int number; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; @Override public String toString() &#123; return \"Book&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", number=\" + number + '&#125;'; &#125;&#125; 在src/java中新建包com.xt.dao，新建一个接口BookDao package com.xt.dao;import com.xt.entity.Book;import java.util.List;public interface BookDao &#123; public List&lt;Book&gt; findAll();&#125; 在src/resources下新建mybatis-config.xml文件配置如下 &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/xt/dao/bookDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis-config.xml是mybatis的配置文件，我们在其中配置数据源，连接数据库的驱动，连接哪个数据库，以及用户和密码。 在src/resources下新建目录结构com/xt/dao，在dao文件夹中新建BookDao.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xt.mapper.BookMapper\"&gt; &lt;select id=\"findAll\" resultType=\"com.xt.entity.Book\"&gt; select * from book &lt;/select&gt;&lt;/mapper&gt; 在test/java下新建类MyBatisTest import com.xt.mapper.BookDao;import com.xt.entity.Book;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.*;import java.util.List;public class BookMapperTest &#123; @Test public void testFindAll() &#123; SqlSession sqlSession = null; SqlSessionFactory sqlSessionFactory = null; InputStream is = null; try &#123; String resource = \"mybatis-config.xml\"; is = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); sqlSession = sqlSessionFactory.openSession(); BookMapper bookMapper = sqlSession.getMapper(BookMapper.class); List&lt;Book&gt; list = bookMapper.findAll(); System.out.println(list); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 输出为 [Book&#123;id=1, name='Java程序设计', number=10&#125;, Book&#123;id=2, name='数据结构', number=10&#125;, Book&#123;id=3, name='设计模式', number=10&#125;] 如果能够顺利输出以上数据，说明配置没有问题了。 MyBatis的CRUD保存操作在BookDao中添加方法saveBook(Book book) void saveBook(Book book); 然后在BookDao.xml中添加下面的语句 &lt;insert id=\"saveBook\" parameterType=\"com.xt.entity.Book\"&gt; insert into book(name, number) values (#&#123;Book.name&#125;, #&#123;Book.number&#125;);&lt;/insert&gt; 上面的parameterType说明该方法传入的参数类型，需要写全类名。我们在下面一行sql语句中使用了传入Book对象的属性 #&#123;Book.name&#125;, #&#123;Book.number&#125; 由于已经指定了传入的是Book类，所以Book.可以不写，即 &lt;insert id=\"saveBook\" parameterType=\"com.xt.entity.Book\"&gt; insert into book(name, number) values (#&#123;name&#125;, #&#123;number&#125;);&lt;/insert&gt; 接在在test/java下的测试类MybatisTest.java，加入下面的代码 private SqlSession sqlSession;private BookDao bookDao;@Beforepublic void init() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\"mybatis-config.xml\")); sqlSession = sqlSessionFactory.openSession(); bookDao = sqlSession.getMapper(BookDao.class);&#125;@Afterpublic void destroy() &#123; sqlSession.close();&#125;@Testpublic void testSaveBook() &#123; Book book = new Book(); book.setName(\"C++\"); book.setNumber(5); bookDao.saveBook(book);&#125; 对以上的程序做几点声明： init()添加了@Before注解，表示该方法会在被@Test注解的方法执行前执行；destroy()添加了@After注解，表示在被@Test注解的方法后执行 init()中是一些初始化的代码，因为SqlSession和BookDao对象会在@Test注解的方法中用到，为了不每次都初始化，我们把SqlSession和BookDao抽离出来作为成员变量，然后在init()方法中初始化；destroy()中是释放资源的代码 在执行前我们先看数据库中的数据，以观察该保存操作是否执行成功 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 |+----+--------------+--------+ 执行程序之后，数据库中的数据为 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 |+----+--------------+--------+ 发现数据库中的数据并没有发现改变，难道是程序写错了。其实是因为autocommit被设置为false了，所以进行回滚操作了，我们在destroy中加入下面的语句 @Afterpublic void destroy() &#123; sqlSession.commit(); sqlSession.close();&#125; 再次执行程序观察数据库中的数据 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 || 5 | C++ | 5 |+----+--------------+--------+ 我们保存对象时并没有设置id的值，因为id是自增长的。如果我们在保存数据后希望获得自增长的id值，我们可以修改BookDao.xml为 &lt;insert id=\"saveBook\" parameterType=\"com.xt.entity.Book\"&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into book(name, number) values (#&#123;name&#125;, #&#123;number&#125;);&lt;/insert&gt; 接着修改测试类中的方法 @Testpublic void testSaveBook() &#123; Book book = new Book(); book.setName(\"C++\"); book.setNumber(5); System.out.println(\"更新前的Book对象\"); System.out.println(book); bookDao.saveBook(book); System.out.println(\"更新后的Book对象\"); System.out.println(book);&#125; 运行结果为 更新前的Book对象Book&#123;id=null, name='C++', number=5&#125;更新后的Book对象Book&#123;id=6, name='C++', number=5&#125; 可见已经获得了自增长的id。 更新操作在BookDao中添加updateBook(Book book)方法 void updateBook(Book book); 然后在BookDao.xml中添加如下 &lt;update id=\"updateBook\" parameterType=\"com.xt.entity.Book\"&gt; update book set name = #&#123;name&#125;, number = #&#123;number&#125; where id = #&#123;id&#125;;&lt;/update&gt; 现在在测试类中添加测试方法 @Testpublic void testUpdateBook() &#123; Book book = new Book(); book.setId(5); book.setName(\"PHP\"); book.setNumber(20); bookDao.updateBook(book);&#125; 执行并观察数据库中的数据 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 || 5 | PHP | 20 |+----+--------------+--------+ 删除操作在BookDao中添加deleteBook(Integer id)方法 void deleteBook(Integer id); 在BookDao.xml中添加如下 &lt;delete id=\"deleteBook\" parameterType=\"int\"&gt; delete from book where id = #&#123;id&#125;;&lt;/delete&gt; 这里的parameterType写为了int，其实这里可以写为INT,integer,Integer均可，在sql语句中使用了#{id}，其实这里可以随便写，如#{uid},#{bookId}，因为只传入一个值，不管写什么都会被认为是这个传入的值。现在在测试类中添加测试方法 @Testpublic void testDeleteBook() &#123; bookDao.deleteBook(5);&#125; 执行并且查看数据库中的数据如下 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 |+----+--------------+--------+ 查询操作查询一个在BookDao中添加findById(Integer id)方法 Book findById(Integer id); 在BookDao.xml中添加如下 &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.xt.entity.Book\"&gt; select * from book where id = #&#123;id&#125;;&lt;/select&gt; 上面的resultType声明了返回的数据类型，接下来在测试了中添加测试方法 @Testpublic void testFindById() &#123; Book book = bookDao.findById(1); System.out.println(book);&#125; 输出结果为 Book&#123;id=1, name='Java程序设计', number=10&#125; 模糊查询在BookDao中添加findByName(String name)方法 List&lt;Book&gt; findByName(String name); 在BookDao.xml中添加如下 &lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.xt.entity.Book\"&gt; select * from book where name like #&#123;name&#125;&lt;/select&gt; 接下来在测试了中添加测试方法 @Testpublic void testFindByName() &#123; List&lt;Book&gt; list = bookDao.findByName(\"%设计%\"); for(Book book:list) &#123; System.out.println(book); &#125;&#125; 输出为 Book&#123;id=1, name='Java程序设计', number=10&#125;Book&#123;id=3, name='设计模式', number=10&#125; 当初我在使用中文模糊查询时查询不出来，使用英文可以，去网上查了一下，解决办法是是在my.ini文件的最后加上 character-set-server = utf8 collation-server = utf8_general_ci 然后重启mysql服务器。具体可以参考这个链接中文模糊查询。 查询一个值比如我想查询数据库中有多少条数据，在BookDao中添加findTotal()方法 int findTotal(); 在BookDao.xml中添加如下 &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from book;&lt;/select&gt; 接下来在测试了中添加测试方法 @Testpublic void testFindTotal() &#123; int numbers = bookDao.findTotal(); System.out.println(numbers);&#125; 输出为 3 resultMap上面我们要求实体类Book的属性要与数据库中类的列名相同，如果列名不同呢? 我们修改Book的实体类 package com.xt.entity;import java.io.Serializable;public class Book implements Serializable &#123; private Integer bookId; private String bookName; private int bookNumber; //省略getter和setter以及toString方法&#125; 现在修改测试类中的Setxxx方法，以及BookDao.xml中的#{Xxx}，如修改#{name}为#{bookName}，接着运行findAll的测试方法，得到 nullnullnullnull 可见数据没有封装。这个时候有两种解决办法 起别名 resultMap 先介绍起别名，我们修改findAll的sql语句为 &lt;select id=\"findAll\" resultType=\"com.xt.entity.Book\"&gt; select id bookId, name bookName, number bookNumber from book&lt;/select&gt; 接着运行findAll的测试方法，结果为 Book&#123;bookId=1, bookName='Java程序设计', bookNumber=10&#125;Book&#123;bookId=2, bookName='数据结构', bookNumber=10&#125;Book&#123;bookId=3, bookName='设计模式', bookNumber=10&#125;Book&#123;bookId=6, bookName='C++', bookNumber=5&#125; 可见数据封装好了。这种方法执行效率很高，但是所有的select语句都需要起别名，这里介绍resultMap，只要将实体类的属性名与数据库列名对应好，下面只需要引用即可，只需要写一次，在 &lt;mapper namespace=\"com.xt.dao.BookDao\"&gt; &lt;!--id是resultMap唯一标识，方便下面引用 type是要对应的实体类名称--&gt; &lt;resultMap id=\"bookMap\" type=\"com.xt.entity.Book\"&gt; &lt;!--主键的对应规则 property是实体类的属性名 column是数据库的列名--&gt; &lt;id property=\"bookId\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"bookName\" column=\"name\"&gt;&lt;/result&gt; &lt;result property=\"bookNumber\" column=\"number\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--这里就不需要些resultType了，直接引用上面写的resultMap 下面同理--&gt; &lt;select id=\"findAll\" resultMap=\"bookMap\"&gt; select * from book &lt;/select&gt; &lt;select id=\"findById\" parameterType=\"int\" resultMap=\"bookMap\"&gt; select * from book where id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=\"findByName\" parameterType=\"string\" resultMap=\"bookMap\"&gt; select * from book where name like #&#123;bookName&#125; &lt;/select&gt; ... ...&lt;/mapper&gt; 再次运行findAll的测试方法，输出为 Book&#123;bookId=1, bookName='Java程序设计', bookNumber=10&#125;Book&#123;bookId=2, bookName='数据结构', bookNumber=10&#125;Book&#123;bookId=3, bookName='设计模式', bookNumber=10&#125;Book&#123;bookId=6, bookName='C++', bookNumber=5&#125; 动态SQL所谓的动态SQL指的是SQL语句不是不变的，比如根据是否传入age以决定是否加入age验证项，下面介绍三种动态SQL。 加入有下面User表 +-----------+------+| user_name | age |+-----------+------+| 张三 | 18 || 李四 | 19 |+-----------+------+ 实体类以及UserDao接口就不演示了。 if首先在UserDao中创建下面的方法 List&lt;User&gt; findByCondition(User user); 该方法根据传入的User对象去查询，主要是根据该User对象所包含的userName和age去查询，但是这个User对象不一定设置了这两个属性，如 User user = new User();user.setAge(18);userDao.findByCondition(user); 上面的Java代码只设置了age的值，这意味着我们在userDao.xml中的select语句不能写成这样 select user_name userName, age from user where user_name = #&#123;userName&#125; and age = #&#123;age&#125; 假设如果userName没有设置的话，那么where后面的结果永远是false，意味着查不到结果，而我们希望的是，如果存在什么，则根据什么是查，比如如果不存在userName，存在age，则相应的SQL语句应该是 select user_name userName, age from user where age = #&#123;age&#125; 如果存在userName而不存在age，则只根据userName查，如果都不存在，则得到所有的User，即 select user_name userName, age from user 这个时候仅仅靠我们上面的手段是得不到的，因为这时的SQL语句是动态的。明显，我们需要对userName和age进行判断，以决定是否加入到SQL语句中，而判断使用的就是if。满足上面要求的SQL语句如下 &lt;select id=\"findByCondition\" parameterType=\"com.xt.domain.User\" resultType=\"com.xt.domain.User\"&gt; select user_name userName, age from user where 1 = 1 &lt;if test=\"userName != null\"&gt; and user_name = #&#123;userName&#125; &lt;/if&gt; &lt;if test=\"age != null\"&gt; and age = #&#123;age&#125; &lt;/if&gt;&lt;/select&gt; 上面的if标签就是对User对象中的属性进行判断，判断语句要写在if标签的test属性中，如果为真，则if标签包含的内容则会添加到SQL语句后，否则不会添加。 where大家注意上面的SQL语句中有 where 1 = 1 那么为什么要加上1 = 1呢? 假设如果不加1 = 1，并且传过来的User对象的userName和age都为null，那么最后的SQL语句是什么样子? select user_name userName, age from user where 这明显是一个错误的SQL语句，但是如果加上1 = 1，即使userName和age都为null，SQL也是正确的SQL语句 select user_name userName, age from user where 1 = 1 但是这样未免有点hack的意味，像是一种奇淫技巧，那mybatis有没有提供比较好的写法，答案就是where标签了，现在我们将上面的sql语句改为 select user_name userName, age from user&lt;where&gt; &lt;if test=\"userName != null\"&gt; and user_name = #&#123;userName&#125; &lt;/if&gt; &lt;if test=\"age != null\"&gt; and age = #&#123;age&#125; &lt;/if&gt;&lt;/where&gt; 我们将所有的if标签都放到了where标签里面，如果所有的if都不满足的话，那么在SQL语句中就不会出现where，如果if至少有一个成立的话，则会去掉第一个成立if标签中包含的and。假设该User对象包含userName不包含age，则最后的SQL语句是 select user_name userName, age from user where user_name = #&#123;userName&#125; forEach现在有一种的新的情况，如果传过来的参数是一个集合或者数组，那怎么处理呢? 在UserDao接口中添加下面的方法 List&lt;User&gt; findByAges(List&lt;Integer&gt; ages); 该方法会接收一个List集合，我们的要求是去查询用户年龄在ages集合中的用户，相应的SQL语句如下 &lt;select id=\"findByAges\" resultType=\"com.xt.domain.User\" parameterType=\"java.util.List\"&gt; select user_name userName, age from user &lt;where&gt; &lt;if test=\"list != null\"&gt; &lt;foreach collection=\"list\" item=\"age\" open=\"and age in(\" close=\")\" separator=\",\"&gt; #&#123;age&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 上面的where和if标签想必不用再解释了，重点是forEach标签。forEach的作用就是遍历集合创建一个SQL语句。forEach中的collection标签的值就是传过来的list集合，item就是集合中的元素，forEach会遍历该集合拿到这些item，open是指创建的SQL语句以什么开头，close是以什么结尾，而separator是指分隔符是什么，而forEach中包含的内容即是分隔符分隔的一个个元素。所以假设传来这么一个List List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.append(15);list.append(18); 那么上面的SQL语句最后会被生成为 select user_name userName, age from user where age in (15, 18) sql片段在上面，我们发现上面的SQL语句都包含这么一条SQL语句 select user_name userName, age from user 既然这是重复的内容，那我们就可以将其抽离出来成一个SQL片段，然后在SQL语句中引用该片段，在userDao.xml中的mapper标签下，我们加入以下内容 &lt;sql id=\"default\"&gt; select user_name userName, age from user&lt;/sql&gt; 上面的id名可以任意的取，这里的id是为了在后面引用该SQL片段。接下来将所有select中的 select user_name userName, age from user 替换为 &lt;include refid=\"default\"&gt;&lt;/include&gt; 如 &lt;select id=\"findByAges\" resultType=\"com.xt.domain.User\" parameterType=\"java.util.List\"&gt; &lt;include refid=\"selectAll\"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=\"list != null\"&gt; &lt;foreach collection=\"list\" item=\"age\" open=\"and age in(\" close=\")\" separator=\",\"&gt; #&#123;age&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 多表查询一对多与多对一假设有两张表，用户表和账户表，二者之间的关系为 一个用户可以有多个账户 一个账户对应一个用户 现在我们的需求的是当我们查询用户时，同时查询它所包含的所有账户，当我们查询账户时，同时查询它所对应的用户。 现在创建两张表user和account。 DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime default NULL COMMENT '生日', `sex` char(1) default NULL COMMENT '性别', `address` varchar(256) default NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'), (42,'小王','2018-03-02 15:09:37','女','北京金燕龙'), (45,'张三','2018-03-07 17:37:26','男','北京'),(46,'超级玛丽','2018-03-08 11:44:00','女','北京修正');DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT '编号', `UID` int(11) default NULL COMMENT '用户编号', `MONEY` double default NULL COMMENT '金额', PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `account`(`ID`,`UID`,`MONEY`) values (1,46,1000),(2,45,1000),(3,46,2000); 现在这两张表的内容为 # user+----+----------+---------------------+------+------------+| id | username | birthday | sex | address |+----+----------+---------------------+------+------------+| 41 | 老王 | 2018-02-27 17:47:08 | 男 | 北京 || 42 | 小王 | 2018-03-02 15:09:37 | 女 | 北京金燕龙 || 45 | 张三 | 2018-03-07 17:37:26 | 男 | 北京 || 46 | 超级玛丽 | 2018-03-08 11:44:00 | 女 | 北京修正 |+----+----------+---------------------+------+------------+# account+----+------+-------+| ID | UID | MONEY |+----+------+-------+| 1 | 46 | 1000 || 2 | 45 | 1000 || 3 | 46 | 2000 |+----+------+-------+ 现在创建对应的实体类以及对应的接口以及相应的xml文件。二者的实体类如下 package entity;import java.util.Date;import java.util.List;public class User &#123; private Integer id; private String name; private String sex; private Date birthday; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", birthday=\" + birthday + \", address='\" + address + '\\'' + \", accounts=\" + accounts + '&#125;'; &#125;&#125; package entity;public class Account &#123; private Integer id; private Integer uid; private Double money; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", uid=\" + uid + \", money=\" + money + \", user=\" + user + '&#125;'; &#125;&#125; 仔细注意这两个实体类，发现在User实体类中有一个Account的List列表，因为一个用户可以有多个账户。而在Account中有一个User对象，因为一个账户对应一个用户。 现在我们来实现第一个需求，当查询所有用户时，同时显示每个用户下的所有账户信息，在UserDao中加入下面的方法 List&lt;User&gt; findAllUsers(); 下面在userDao.xml中加入下面的查询语句 &lt;mapper namespace=\"dao.UserDao\"&gt; &lt;resultMap id=\"users\" type=\"entity.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"userName\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;collection property=\"accounts\" ofType=\"entity.Account\"&gt; &lt;id column=\"aid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUsers\" resultMap=\"users\"&gt; select user.*, account.id aid, account.uid, account.money from user, account where user.id = account.uid &lt;/select&gt;&lt;/mapper&gt; 由于User中包含一个Account类型的List，所以要设置这个List的对应规则，正是上面collection标签的部分，property是User中List对象的名称，ofType是List集合的类型。collection包含的部分就是List元素对应的规则。 现在实现第二个需求，当查询账户时，同时查询出对应的User信息，在AccountDao中添加下面的方法 List&lt;Account&gt; findAllAccounts(); 在accountDao.xml添加内容如下 &lt;mapper namespace=\"dao.AccountDao\"&gt; &lt;resultMap id=\"accounts\" type=\"entity.Account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"entity.User\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"userName\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findAllAccounts\" resultMap=\"accounts\"&gt; select user.*, account.id aid, account.uid, account.money from account left join user on user.id = account.uid &lt;/select&gt;&lt;/mapper&gt; 在Account中有一个User对象，我们要设置这个的对应规则，使用的就是association，property就是Account中User对象的名称，javaType是指对应的实体类。 多对多其实多对多查询与一对多的查询是一样的，上述我们在User类中添加了一个类型为Account的List集合，已表示一对多，在Account中有一个User对象，已表示一对一。 那要如果表示多对多，假设一个账户对应多个用户，那么只要在Account中将一个User对象改为一个类型为User的List列表。 延迟加载延迟加载又称为懒加载，又称按需加载，指的就是在需要的时候才加载，比如上面查询所有的User，但是这时不需要立即加载对应的账户信息，而是等我们使用账户信息时在进行加载，比如 user.getAccounts(); 这时再向数据库发起查询。 MyBatis根据对关联对象查询的select语句的执行时机，分为三种类型：直接加载、侵入式加载与深度延迟加载 直接加载：执行完对主加载对象的select语句，马上执行对关联对象的select查询。 侵入式延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的某个属性（该属性不是关联对象的属性）时，就会马上执行关联对象的select查询。 深度延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的select查询。只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。 Mybatis的延迟加载，需要通过resultMap标签中的association和collection子标签才能演示成功。 要设置延迟加载，需要在mybatis-config.xml中设置，如下 &lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;/settings&gt; ... ...&lt;/configuration&gt; lazyLoadingEnabled是设置是否深度延迟，当设置为true，就是设置为深度延迟，即当访问关联对象的详细信息时才会进行查询。aggressiveLazyLoading是用来设置侵入式延迟，默认为false，这里本应不用设置，只是为了演示。 一对一延时加载这里演示当查询账户时，同时查询对应的用户信息。首先我们看原先的查询语句 select user.*, account.id aid, account.uid, account.money from account left join user on user.id = account.uid 如果这么写的话，会立即查询相应User的信息，所以必须更改上面的sql语句 select * from account 同时修改resultMap如下 &lt;resultMap id=\"accounts\" type=\"entity.Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"entity.User\" select=\"dao.UserDao.findById\" column=\"uid\"&gt; &lt;/association&gt;&lt;/resultMap&gt; 注意到我们将association中的对应规则删除了，因为在上面的sql语句中我们只查询了account的内容。但是我们增加了两个属性，一个是select属性，这个是当我们使用account对象访问其中的User属性时会调用的sql语句，比如 account.getUser(); 这时因为会访问Account关联对象User的具体信息，会调用userDao的findbyId(Integer id)进行查询，从而得到相应的User信息。 第二个参数是column，其值是上面findById方法所需要的id。 这里向UserDao中增加下面的方法 User findById(Integer id); 并且在userDao.xml中增加select标签 &lt;select id=\"findById\" resultType=\"entity.User\" parameterType=\"Integer\"&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 此刻万事大吉，这里贴出accountDao.xml中的内容 &lt;resultMap id=\"accounts\" type=\"entity.Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"entity.User\" select=\"dao.UserDao.findById\" column=\"uid\"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAllAccounts\" resultMap=\"accounts\"&gt; select * from account&lt;/select&gt; 一对多延时加载一对多延时加载与一对一延时加载是一样，只不过association换成了collection。 这里我们以查询User信息时，同时查询该用户包含的所有账户，这里修改findAllUsers对应的sql语句为 &lt;select id=\"findAllUsers\" resultMap=\"users\"&gt; select * from user&lt;/select&gt; 修改对应的resultMap为 &lt;resultMap id=\"users\" type=\"entity.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"userName\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;collection column=\"id\" property=\"accounts\" ofType=\"entity.Account\" select=\"dao.AccountDao.findByUid\"&gt; &lt;/collection&gt;&lt;/resultMap&gt; 这时上面的代码已经不需要解释了，在AccountDao中添加findByUid的方法 List&lt;Account&gt; findByUid(Integer uid); 同时在accountDao.xml中添加对应的select标签 &lt;select id=\"findByUid\" resultType=\"entity.Account\" parameterType=\"Integer\"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; 缓存所谓缓存，指的就是当我们向数据库查询数据时，将数据保存在内存中，当第二次查询时，不再向数据库进行查询，而是直接从内存拿数据，这就是缓存。由于数据在内存中，从内存中拿数据比从数据库中拿数据快很多，并且也可以减少数据库的压力。 一级缓存MyBatis中的一级缓存的范围是sqlSession，即相当于在sqlSession中有一个localCache，当sqlSession查询数据时会将数据保存在这个cache中，当该sqlSession再次查询数据时，会先在这个cache中查询数据，如果有，则会直接拿内存中的数据，如果没有，则会去数据库查询。 那怎么保证拿到的数据不会错呢? 比如当更新数据后，如果继续从缓存中拿数据，这时拿到的数据就会是错的，所以当发生更新、删除、commit()等操作时，就会将一级缓存清空，这就意味着当更新数据后，就得直接去数据库中拿数据了。当SqlSession对象调用clearCache()，也会清除sqlSession的缓存。 那么怎么开启一级缓存呢? 在mybatis-config.xml中添加下面的setting &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; localCacheScope有两种取值，一种是SESSION，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存；一种是STATEMENT级别，可以理解为缓存只对当前执行的这一个Statement有效。默认是SESSION级别，这就意味着一级缓存默认是开启的，上面的设置不用写。 二级缓存想象有两个sqlSession，暂且称之为sqlSession1和sqlSession2，二者连接了同一个表，假设sqlSession1对表进行了更新，sqlSession2向数据库查询数据，但是由于一级缓存的存在，并且sqlSession2没有进行增加、删除等等操作，意味着sqlSession2没有清楚缓存，所以sqlSession2拿到的是缓存中的数据，这种数据称之为脏数据。 那怎么解决这个问题? 这个时候就要使用二级缓存。二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。 当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。 那怎么开启二级缓存呢? 首先在mybatis-config.xml加入下面的设置 &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 接着在xxxDao.xml中的namespace(mapper标签内中)加入 &lt;cache/&gt; 如果希望局部关闭二级缓存时，比如某查询标签关闭二级缓存，则在标签的属性useCache设置为false，如 &lt;select id=\"findAllUsers\" resultMap=\"users\" useCache=\"false\"&gt; select * from user&lt;/select&gt; 二级缓存对于不同的命名空间namespace的数据是互不干扰的，倘若多个namespace中对一个表进行操作的话，就会导致这不同的namespace中的数据不一致的情况。例如，在单表上使用二级缓存 在做关联关系查询时，就会发生多表的操作，此时有可能这些表存在于多个namespace中，这就会出现上面出现的问题了。 总结: MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。 MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。 使用注解开发使用注解开发，不需要对应的xxxDao.xml文件，因为我们将sql语句写在XxxDao接口的注解中。 简单使用新建一个工程，配置好pom.xml文件以及mybatis-config.xml的主配置文件，在entity包下新建User实体类，在dao包下新建UserDao接口，内容如下 package dao;import entity.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 在test/java/TestUser类中进行单元测试 import dao.UserDao;import entity.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class TestUser &#123; private UserDao userDao; private SqlSession sqlSession; private InputStream inputStream; @Before public void init() throws Exception&#123; String resource = \"mybatis-config.xml\"; inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); userDao = sqlSession.getMapper(UserDao.class); &#125; @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); System.out.println(users); &#125; @After public void destroy() throws Exception&#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125;&#125; 输出为 [User&#123;id=41, userName='老王', sex='男', birthday=Tue Feb 27 17:47:08 CST 2018, address='北京'&#125;, User&#123;id=42, userName='小王', sex='女', birthday=Fri Mar 02 15:09:37 CST 2018, address='北京金燕龙'&#125;, User&#123;id=45, userName='张三', sex='男', birthday=Wed Mar 07 17:37:26 CST 2018, address='北京'&#125;, User&#123;id=46, userName='超级玛丽', sex='女', birthday=Thu Mar 08 11:44:00 CST 2018, address='北京修正'&#125;] 其他CRUD这里简单的演示实验其他的CRUD操作。 更新操作在UserDao中添加如下方法 @Update(\"update user set username = #&#123;userName&#125; where id = #&#123;id&#125;\")void updateUser(User user); 在测试类中进行测试 @Testpublic void testUpdateUser() &#123; User user = new User(); user.setId(45); user.setUserName(\"李四\"); userDao.updateUser(user); System.out.println(userDao.findAll());&#125; 输出为 [User&#123;id=41, userName='老王', sex='男', birthday=Tue Feb 27 17:47:08 CST 2018, address='北京'&#125;, User&#123;id=42, userName='小王', sex='女', birthday=Fri Mar 02 15:09:37 CST 2018, address='北京金燕龙'&#125;, User&#123;id=45, userName='李四', sex='男', birthday=Wed Mar 07 17:37:26 CST 2018, address='北京'&#125;, User&#123;id=46, userName='超级玛丽', sex='女', birthday=Thu Mar 08 11:44:00 CST 2018, address='北京修正'&#125;] 如果发现不能插入中文，则修改mybatis-config.xml中的dataSource中的url为 &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; 插入操作在UserDao中添加下面的方法 @Insert(\"insert into user(username, sex, address, birthday) values(#&#123;userName&#125;, #&#123;sex&#125;, #&#123;address&#125;, #&#123;birthday&#125;)\")void insertUser(User user); 在测试类中进行测试 @Testpublic void testInsertUser() &#123; User user = new User(); user.setUserName(\"奥特曼\"); user.setSex(\"男\"); user.setAddress(\"M78\"); user.setBirthday(new Date()); userDao.insertUser(user); System.out.println(userDao.findAll());&#125; 删除操作在UserDao中添加下面的方法 @Delete(\"delete from user where id = #&#123;id&#125;\")void deleteUserById(Integer id); 在测试类中进行测试 @Testpublic void testDeleteUserById() &#123; userDao.deleteUserById(48); for (User user: userDao.findAll()) &#123; System.out.println(user); &#125;&#125; 在注解中配置resultMap如下 @Select(\"select * from user\")@Results(value = &#123; @Result(id=true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"sex\", property = \"sex\"), @Result(column = \"birthday\", property = \"birthday\"), @Result(column = \"address\", property = \"address\")&#125;)List&lt;User&gt; findAll(); 如果直接将Results写在方法上，那就意味则如果还有方法需要些resultMap，那么就还需要在写一遍，我们希望就是只写一遍resultMap，然后通过id引用即可，我们给上面的Results添加id @Results(id = \"users\", value = &#123; @Result(id=true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"sex\", property = \"sex\"), @Result(column = \"birthday\", property = \"birthday\"), @Result(column = \"address\", property = \"address\")&#125;) 然后在需要resultMap的方法上添加如下的注解 @Results(value = &#123;\"users\"&#125;) 或者简写为 @Results(\"users\") 多表查询一对一@Select(\"select * from account\")@Results(id = \"accounts\", value = &#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"uid\", property = \"uid\"), @Result(column = \"money\", property = \"money\"), @Result(column = \"uid\", property = \"entity.User\", one = @One(select = \"dao.UserDao.findById\", fetchType = FetchType.EAGER)),&#125;)List&lt;Account&gt; findAll(); Result中的one就是用来设置一对一查询的，其值是一个One注解，其中的select不用解释，与在xml中association设置的select相同功能 fetchType是用来设置是立即加载还是延迟加载的 FetchType.EAGER：立即加载 FetchType.LAZY：延迟加载 注意，如果要使用延迟加载，得先在mybatis-config.xml中开启延迟加载(方法同xml配置方式)。 一对多@Select(\"select * from user\")@Results(value = &#123; @Result(id=true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"sex\", property = \"sex\"), @Result(column = \"birthday\", property = \"birthday\"), @Result(column = \"address\", property = \"address\"), @Result(column = \"id\", property = \"accounts\", many = @Many(select = \"dao.AccountDao.findByUid\", fetchType = FetchType.LAZY))&#125;)List&lt;User&gt; findAll(); 将one换成了many，对应的Many注解里面的内容不用多加解释。 缓存如何在注解中使用缓存，对于一级缓存来说，与xml相同，不用设置，默认是SESSION。 对于二级缓存，首先在mybatis-config.xml开启缓存，与在xml中相同。 &lt;setting name=\"cacheEnabled\" value=\"true\"&gt;&lt;/setting&gt; 在xml中，我们是在namespace中设置 &lt;cache/&gt; 但是在注解中，我们在UserDao接口上添加@CacheNameSpace注解，设置其blocking属性为true，如下 @CacheNamespace(blocking = true)public interface UserDao &#123; ...&#125; 这样就开启二级缓存了。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lastknightcoder.gitee.io/tags/MyBatis/"}]},{"title":"使用React搭建一个基于富文本编辑器的博客系统","date":"2020-02-10T16:00:00.000Z","path":"/使用React搭建一个基于富文本编辑器的博客系统/","text":"本文将从0开始搭建一个基于富文本编辑器的博客系统，包括的内容有 React的基础知识 富文本编辑器组件BraftEditor的使用及扩展 React Hooks Redux + React-Redux antd表单的介绍及使用 登录权限控制 项目前的准备首先需要下载Node.js和npm(下载Node.js自带npm)，下载完Node.js后，由于npm的速度较慢，可以考虑使用下面的命令下载cnpm npm install cnpm -g npm是什么，为什么会需要npm： 想要知道npm是什么，那就要先从共享代码说起，程序员自古以来就有社区文化，加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。 前端是怎么共享代码的呢? 在 GitHub 还没有兴起的年代，前端是通过网址来共享代码，比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用，GItHub 兴起之后，社区中也有人使用 GitHub 的下载功能。 当一个网站依赖的代码越来越多，程序员发现这是一件很麻烦的事情，比如你要下载BootStrap，你就必须下载jQuery，因为BootStrap依赖jQuery，所以你需要一个网站一个网站的去下代码。如果遇到依赖比较多的情况，这个库依赖另一个库，另一个库又依赖另一个库，如此当依赖关系十分复杂时，你根本不知道要下哪些库，这对程序员来说简直就是个灾难。 有些程序员就受不了了，一个程序员叫 Isaac Z. Schlueter(以下简称Isaaz)给出一个解决方案：用一个工具把这些代码集中到一起来管理吧!这个工具就是他用 JavaScript(运行在Node.js上)写的 npm，全称是 Node Package Manager。 NPM 的思路大概是这样的： 买个服务器作为代码仓库(registry)，在里面放所有需要被共享的代码 发邮件通知 jQuery、Bootstrap、Underscore等作者使用npm publish 把代码提交到registry上，分别取名 jquery、bootstrap和underscore(注意大小写) 社区里的其他人如果想使用这些代码，就把jquery、bootstrap和underscore写到package.json里，然后运行 npm install，npm就会帮他们下载代码 下载完的代码出现在 node_modules 目录里，可以随意使用了。 这些可以被使用的代码被叫做「包」(package)，这就是 NPM名字的由来：Node Package(包) Manager(管理器)。 但是npm叫别人这么干，别人不一定会这么干啊，所以npm是怎么火的呢?npm的发展是跟Node.js的发展相辅相成的。Node.js是由一个在德国工作的美国程序员Ryan Dahl写的。他写了Node.js，但是Node.js缺少一个包管理器，于是他和 npm的作者一拍即合、抱团取暖，最终Node.js内置了npm。 后来的事情大家都知道，Node.js火了。随着Node.js的火爆，大家开始用 npm来共享JS代码了，于是jQuery作者也将 jQuery发布到npm了。所以现在，你可以使用npm install jquery来下载jQuery代码。 现在用npm来分享代码已经成了前端的标配。 接下来下载搭建React项目的脚手架create-react-app cnpm install create-react-app -g 什么是脚手架：随着前端工程化的概念越来越深入人心，脚手架的出现就是为减少重复性工作而引入的命令行工具，摆脱ctrl + c, ctrl + v，此话zenjiang? 现在新建一个前端项目，已经不是在html头部引入css，尾部引入js那么简单的事了，css都是采用Sass或则Less编写，在js中引入，然后动态构建注入到html中；除了学习基本的js，css语法和热门框架，还需要学习构建工具webpack，babel这些怎么配置，怎么起前端服务，怎么热更新；为了在编写过程中让编辑器帮我们查错以及更加规范，我们还需要引入ESlint；甚至，有些项目还需要引入单元测试(Jest)。对于一个刚入门的人来说，这无疑会让人望而却步。而前端脚手架的出现，就让事情简单化，一键命令，新建一个工程，再执行两个npm命令，跑起一个项目。在入门时，无需关注配置什么的，只需要开心的写代码；另外，对于很多系统，他们的页面相似度非常高，所以就可以基于一套模板来搭建，虽然是不同的人开发，但用脚手架来搭建，相同的项目结构与代码书写规范，是很利于项目的后期维护的；以上就是为什么脚手架存在的意义， 让项目从”搭建-开发-部署”更加快速以及规范。 接着使用create-react-app搭建一个React项目，这里的项目名称就命名为blog create-react-app blog 使用该命令会在本地生成一个文件夹blog，里面的内容如下 其中src就是我们开发的文件夹，其中index.js是入口文件，里面的内容为 import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import * as serviceWorker from './serviceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: https://bit.ly/CRA-PWAserviceWorker.unregister(); 现在我们将里面的内容改为 import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;div&gt;Hello React&lt;/div&gt;, document.getElementById('root')); 然后npm start就可以看到下面的页面 这时可以将src下除index.js的文件全部都删掉了，因为没有用到他们。 React基础JSX语法可能现在你对上面的代码不太了解，特别是怎么在JavaScrpt里面写HTML ReactDOM.render(&lt;div&gt;Hello React&lt;/div&gt;, document.getElementById('root')); 这里的HTML就是JSX，JSX的全称是JavaScript XML，指的就是JavaScript中的XML。 上面这行语句的作用是什么呢? React会解析这个JSX语句为一个虚拟DOM，而ReactDOM会将这个虚拟DOM转变为真正的DOM，然后塞到页面某个特定的元素上面，这里是塞到一个id为root(该DOM元素在public/index.html中)的DOM对象中,我们查看index.html中的内容 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;!-- 省略head中的内容和所有注释 --&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 经过ReactDOM渲染后的index.html的页面应该为为 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;!-- 省略head中的内容和所有注释 --&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=\"root\"&gt; &lt;div&gt;Hello React&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 为了验证这个想法，可以在刚才的页面中按下F12检查元素 所以页面显示出来的就是Hello React。 为什么需要虚拟DOM： 原因很简单，那就是DOM很慢，我们先来看一下浏览器的渲染流程 用HTML分析器，分析HTML元素，构建一颗DOM树 用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表 将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树 有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值 Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来 当你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。 即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。 虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。 我们知道React中的JSX会被解析为一个React对象(或者说JavaScript对象)，所以我们在写JSX的过程中，就可以把JSX看做是一个对象(记住JSX的本质就是对象，每当在JavaScript代码中看到这种JSX结构的时候，脑子里面就可以自动做转化，这样对你理解React.js的组件写法很有好处)。这就意味着JSX只能有一个根元素，如下面的写法是错误的 &lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 因为上面的代码并不能被解析为一个对象，正确的写法应该是 &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 这样的JSX才会被解析为一个对象。 现在我们在来说一下文件开头的两行语句 import React from 'react';import ReactDOM from 'react-dom'; 在React中，我们使用import来导入npm下载的包，这里我们引入了React和ReactDOM，这里你可能有疑问，我们并没有使用npm下载react和react-dom，为什么能够引入，这是因为create-react-app为我们做了这件事情，打开package.json我们可以发现已经帮我们添加了react和react-dom 那么引入的React是做什么事情的呢? 首先在JavaScript中是不能写JSX的，在React中的JSX会被解析为JavaScript对象，就是通过React来做到的，而ReactDOM是将React渲染的JSX对象(有时我们也称之为组件)转变为真正的DOM对象并塞到某个特定的元素里面。所以记住只要你写React.js组件，都必须要引入React。 组件这里十分推荐React.js 小书，里面将React的内容讲的十分的深入浅出，每读一遍都有新的收获。 组件是什么? 如果你搭过积木的话，那么里面的积木就是组件，我们使用积木搭建出一个东西，在React中我们使用组件来搭建一个页面。组件的作用就是复用，这里的复用指的不仅仅是页面的复用，还有逻辑和样式；除此以外，有的组件并不是用来展现页面的，而是用来加载数据的，然后将数据传给子组件，这样会使得处理数据的逻辑和展示数据的逻辑分开，职责分明，逻辑清晰，以及便于后期的维护。另外，有的组件是做权限的认证，以决定展示某些页面与否。总而言之，有许多不同的组件，组件根据功能或写法或有无状态等等可以进行分类，在后面将详细讨论。 按照组件的写法可以分为函数组件和类组件。 类组件我们写一个类组件HelloReact See the Pen React类组件使用 by LastKnightCoder (@lastknightcoder) on CodePen. 使用类组件，里面必须有一个render函数，该方法是用来返回JSX代码。我们创建了一个HelloWorld组件 ReactDOM.render(&lt;HelloReact /&gt;, document.getElementById(\"root\")) 并且我们通过&lt;HelloReact /&gt;的方式使用了组件，此时的&lt;HelloReact /&gt;就相当于render函数的返回值 &lt;div&gt;Hello React&lt;/div&gt; 但&lt;HelloReact /&gt;不仅仅是HTML，虽然在这个组件中，我们并没有加上JavaScript的逻辑和CSS样式，但是我们知道一个组件是包括这些的，下面我们为这个类添加样式和点击函数 See the Pen abOzEWb by LastKnightCoder (@lastknightcoder) on CodePen. 两点说明： 由于class在React中是关键字，所以类名要写成className onClick={()=&gt; console.log(“click me”)}为div标签添加了点击事件，onClick={}并不是说onClick是一个对象，{}是React的插值语法，使用插值语法可以将组件的属性与变量(表达式)绑定起来，这样就不会写死，而是会根据变量取不同的值。这里就是将onClick这个React事件与{}里面的箭头函数绑定起来。在{}中的内容只能是JavaScript的表达式，不能是if，while等语句 React事件： 使用原生的JS为DOM元素添加事件，主要有下面三种方法 在HTML中直接事件绑定 &gt;&lt;p onclick=\"console.log('click')\"&gt;&lt;/p&gt; 直接绑定 &gt;let divObj = document.getElementById(\"root\");&gt;divObj.onclick = function() &#123;&#125; 对DOM对象进行事件监听处理,事件委托监听方式 &gt;let divObj = document.getElementById(\"root\");&gt;divObj.addEventListener('click', function()&#123;&#125;) 至于这三种方法的优缺点与及什么时候使用，这里却不在讨论。那么React中的事件是如何绑定的呢? 在React中事件的绑定是直接写在JSX元素上的,不需要通过addEventListener事件委托的方式进行监听，写法上: 在JSX元素上添加事件,通过on*EventType这种内联方式添加,命名采用小驼峰式(camelCase)的形式,而不是纯小写(原生HTML中对DOM元素绑定事件,事件类型是小写的),无需调用addEventListener进行事件监听,也无需考虑兼容性,React已经封装好了一些的事件类型属性(ps:onClick,onMouseMove,onChange,onFocus)等 使用JSX语法时,需要传入一个函数作为事件处理函数,而不是一个字符串,也就是props值应该是一个函数类型数据,事件函数方法外面得用一个双大括号包裹起来(也就是上面提到的插值语法) on*EventType的事件类型属性,只能用作在普通的原生html标签上(例如:div,input,a,p等,例如:&lt;div onClick={ 事件处理函数 }&gt;&lt;/div&gt;),无法直接用在自定义组件标签上,也就是说下面这么写是没有作用的 &gt;&lt;HelloReact onClick=&#123;()=&gt; console.log(\"click me\")&#125;&gt; 不能通过返回false的方式阻止默认行为,必须显示使用preventDefault 具体React事件有哪些，可以参照事件系统|React。 props组件最常用的作用就是用来展示数据，那么作为可复用的组件，不同人拿到这个组件所展示的数据也不会相同，那么数据从哪里来? 使用组件的人怎么将数据传给组件，而组件又怎么拿到数据。这就要用到props了。 假如有下面的组件 class DisplayData extends React.Component &#123; render() &#123; return ( &lt;div&gt;假设这里是要展示的数据&lt;/div&gt; ) &#125;&#125; 这个组件的作用就是展示数据，现在我要用DisplayData组件，我怎么把数据传过去，如下 &lt;DisplayData data=\"数据\" /&gt; 我们通过给DisplayData组件加上一个data属性，值是”数据”，就可以将数据传给DisplayData，现在怎么拿到数据呢? 每一个组件都有props属性，它是一个对象，通过上面方法传递给组件的属性都会以键值对的形式添加到props对象中，所以在DisplayData组件中，我们就可以通过this.props.data拿到数据 class DisplayData extends React.Component &#123; render() &#123; return ( &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; ) &#125;&#125; See the Pen React props父组件给子组件传递数据 by LastKnightCoder (@lastknightcoder) on CodePen. 以上我们把DisplayData称之为子组件，而使用DisplayData的组件称之为父组件，上面演示了如何将数据从父组件传给子组件，现在我们考虑一下，如何将子组件的数据传递到父组件呢? 完全是有这个需要的，比如子组件是一个登录组件，我们需要将用户输入的用户名和密码交由父组件进行处理(为什么要交给父组件处理，在子组件中处理不可以吗?如果你在子组件里面处理了数据，那么这个组件就与具体的业务相关了，就不能够被复用了，所以数据处理的工作需要交由父组件来做)。 其实也很简单，我们给子组件传递一个回调函数，那么在子组件的某个时刻(比如子组件的值改变了或者说点击提交)时调用此回调函数并传入数据，这样我们就可以在父组件中拿到数据了 See the Pen React子组件向父组件传递数据 by LastKnightCoder (@lastknightcoder) on CodePen. 上面的逻辑代码为当SonComponent中的input发生改变时(输入内容或删减内容等等)，会触发子组件中的handleValue回调函数(该回调函数bind了this，后面会进行解释)，在子组件的handleValue中，我们根据浏览器传入的event获得了input输入框的值，并且调用ParentComponent传入的handleValue回调函数将此值传入，这样就将子组件的数据传给了父组件，在父组件中，我们定义了这个回调函数接收这个值，并在控制台打印，你可以在上面的input中输入值并在控制台观察结果。 JavaScript函数里面的this是什么： 要想知道JavaScript函数里面的this是什么，就要知道函数调用的4种方式： 定义在全局作用域中函数 定义在全局作用域中的函数，根据是否是严格模式下，this的取值也不同，如果是在严格模式下，里面的this是undefined，如果是在非严格模式下，里面的this是window \"use strict\"function test() &#123; console.log(this); &#125;test(); //undefined function test() &#123; console.log(this); &#125;test(); //window 对象方法 对象中方法中的this如果是对象.的形式调用的，那么对象方法中的this就是该对象 let obj = &#123; test: function() &#123; console.log(this); &#125;&#125;obj.test(); // obj 如果以某种角度看的话，第一种情况的非严格模式下是第二种情况的特例，我们知道在全局作用域下声明的变量和函数都会成为window对象的属性，当我们在全局作用域下声明一个test函数，就相当于在window对象中添加了一个test方法(在对象中的函数我们一般称为方法)，而调用test()方法就相当于window.test()，按照第二种情况，test中的this就是应该指向window 作为构造函数被调用 当我们new一个方法的时候，里面的this是一个空对象 function Dog() &#123; console.log(this)&#125;new Dog(); // &#123;&#125; 使用call, apply, bind方法改变函数的上下文(this) 上面三者都可以改变函数执行时内部this的指向，下面来看一个例子 funtion printName(firstName, lastName) &#123; console.log(this.fullName) console.log(`$&#123;firstName&#125; $&#123;lastName&#125;`)&#125; 如果直接执行这个函数的话，那么this.fullName的结果就是undefined，因为window对象没有这个属性，但是如果有以下对象 let obj = &#123; fullName: \"David\"&#125; 下面我们将printName函数执行时内部的this指向obj let firstName = \"firstName\"let lastName = \"lastName\"// 将printName内部this指向obj， 后面是printName需要的参数printName.apply(obj, firstName, lastName) // 将printName内部this指向obj， 后面是printName需要的参数printName.call(obj, [firstName, lastName]) 这时this.fullName就是obj中的fullName了，因为apply和call方法改变了printName内的this指向。这里我们发现apply和call方法是极其的相似，除了传递参数时格式不一样；事实上也是如此，apply和call的功能是一样的。 说完apply和call，接下来讲一讲bind，bind与上面两者不同，上面改变函数内部的this指向时是立即执行这个函数的，而使用bind改变函数内部的this指向时，这个函数不会立即的执行，如 printName = printName.bind(obj) printNAme函数内部的this指向已经改变，当printName执行时，打印出的this.fullName就是obj里面的David。 了解完JavaScript中的this是什么，接下来就要解释 &lt;input type=\"text\" placeholder=\"Please Input\" onChange=&#123;this.handleValue.bind(this)&#125; /&gt; 中onChange={this.handleValue.bind(this)}，首先我们来看handleValue中的代码 handleValue(event) &#123; this.props.handleValue(event.target.value)&#125; 当input发生改变时便会执行这个函数，但是是谁执行这个函数呢? 是window，而React是运行在严格模式下的，所以这时的this就是undefined，所以我们拿不到我们想要的this，要使得我能拿到的使我们想拿到的this，就是改变函数执行时内部的this指向，考虑到这个函数是作为回调函数而不是立即执行，我们使用bind来绑定this。 机智的你已经发现，ParentComponent中的handleValue没有bind(this)，这是因为它在函数里面没有用到this啊，所以什么时候bind(this)是不是已经很清楚了呢! 到这里你有没有发现我们使用组件都是这样 &lt;HelloReact /&gt; 居然不是一开一闭的格式，那想必你有疑问，可不可以这样使用 &lt;HelloReact&gt;&lt;/HelloReact&gt; 答案是可以，那么问题来了? 二者又有什么不同? 使用后面的写法意味着可以在标签里面写子元素，如 &lt;HelloReact&gt; &lt;div&gt;inner&lt;/div&gt;&lt;/HelloReact&gt; 其实这也可以看做是一种传递数据的方式，标签里面的子元素会传给这个组件，传过去的数据会保存在props.children中，在HelloReact中可以通过this.props.children获得数据。 这两种写法都很常见，在写布局，路由，认证等组件时经常使用后面的写法，而在一些展示的组件中，通常只需要父组件传下来的数据，会使用前一种写法，当然这种情况下也可以使用第二种写法。 为了理解children的应用，我们来写简单的Layout组件。所谓的Layout，就是布局 我们简单的把页面上面三个部分，这就是一种布局，一个头部，一个侧边栏，一个内容区。很多时候我们发现一个网站的多个网页之间的布局是一样的，并且很有可能头部和侧边栏是相同，仅仅是内容区不同，作为一名优秀的程序员，当然要尽可能的抽离出这些重复的代码，我们把这个布局抽离为一个组件 See the Pen 尝试Layout by LastKnightCoder (@lastknightcoder) on CodePen. 首先希望不要关注样式，因为那不是重点，关注Layout的结构。注意我们将{this.props.children}放在了类名为content的div中，所以如果我们将Content内容区组件放到Layout里面，Content组件就会被放在Layout的内容区，放置不同的Content组件，就会得到多个布局一样，内容不同的页面，这就做到了复用。 整个网站当然不可能只会有一种布局，很多时候我们会写多个布局的组件，明白了布局组件的作用，这些对你来说应当不难。 stateReact中一个比较重要的思想就数据驱动视图，例如子组件根据props的内容进行展示，根据不同的props展示不同的内容，不同的props会展现不同的UI，所以可以认为是props决定了视图，每当props变化时，都会引起子组件的渲染，展现不同的视图，视图的改变完全在于数据，所以现在我们操作的重点不再是DOM，而是数据，我们通过操作数据来达到不同的UI效果。 但是仅仅靠props似乎是够的，因为props是只读的，它不能够更改。这意味着什么? 假设父组件传给子组件的props没有发生变化，那么子组件的视图就不会改变，因为数据没有改变。这意味着我们如何与这样一个组件进行交互呢? 这意味组件的内部需要数据来管理UI的变化，我们将组件内部的数据称之为state，state就是状态的意思。比如使用visible这个状态来控制某个对话框是否可见，用户通过改变visible这个状态从而影响组件UI的变化，每次state的变化都会引起组件UI的刷新，从而达到数据驱动视图的目的。从此，我们关心的再也不是DOM操作，而是props, state这些数据，我们操作这些数据来控制视图的更新。 定义一个合适的state，是正确创建组件的第一步。state必须能代表一个组件UI呈现的完整状态集，即组件的任何UI改变，都可以从state的变化中反映出来；同时，state还必须是代表一个组件UI呈现的最小状态集，即state中的所有状态都是用于反映组件UI的变化，没有任何多余的状态，也不需要通过其他状态计算而来的中间状态。 组件中用到的一个变量是不是应该作为组件state，可以通过下面的4条依据进行判断： 这个变量是否是通过props从父组件中获取? 如果是，那么它不是一个状态。 这个变量是否在组件的整个生命周期(后面讲到)中都保持不变? 如果是，那么它不是一个状态。 这个变量是否可以通过其他状态(state)或者属性(props)计算得到?如果是，那么它不是一个状态。 这个变量是否在组件的render方法中使用? 如果不是，那么它不是一个状态(因为state是用来驱动视图的，如果这个变量没有在render方法中使用，意味着该状态的改变并不能使得视图发生变化)。这种情况下，这个变量更适合定义为组件的一个普通属性，例如组件中用到的定时器，就应该直接定义为this.timer，而不是this.state.timer。 现在来写一个计数器，当点击按钮时页面上显示的数字+1，页面上的数字发生改变正是UI的改变，这个时候我们就要用state来管理页面上要展示的数据 See the Pen Counter演示state by LastKnightCoder (@lastknightcoder) on CodePen. 我们在constructor构造函数中初始化state为 this.state = &#123; number: 0&#125; state为一个对象，其中的number属性正是我们要展现的数据，我们将它初始化为0。当我们点击按钮时，触发状态的改变 increment() &#123; this.setState(&#123; number: ++this.state.number &#125;)&#125; 注意，状态的改变不能使用this.state.number = ++this.state.number使状态发生改变，要使得状态发生改变，必须使用setState()方法使状态发生改变。 上面的例子进一步验证了数据驱动视图的思想，在计数器的例子中，我们没有手动的更改视图(操作DOM)，而是通过改变state来使得视图得到刷新，因为每次state的改变都会引起render()方法的调用，从而使得视图得以刷新。 请务必牢记，并不是组件中用到的所有变量都是组件的状态! 当存在多个组件共同依赖一个状态时，一般的做法是状态上移，将这个状态放到这几个组件的公共父组件中。 所谓状态上移是怎么回事呢? 考虑下面这么一个评论组件 CommentInput用来输入评论，当提交之后会在CommentList中新增一个CommentItem来显示新增的评论，很明显我们需要一个comments数组，当CommentInput提交评论时，将comment添加到comments数组中，CommentList拿到comments数组，comments中的元素会交给其中的CommentItem显示。而作为关键的comments数组，它是多个组件都会用到的，所以它应该作为state保存在公共的父组件中，即Comment组件中。这就是状态上移，将多个组件都会用到的数据上移到共同父组件的state中，当更新父组件的state的时，会使得传到子组件的props相应的更新，从而达到视图 更新的目的。 生命周期函数一个人从出生到死亡会经历一些人生节点，孩童、青年、中年、老年。而一个组件从创建到销毁也要经历特殊的节点，在这些节点中，我们可以做一些操作，每一个节点都对应一个函数，我们将它们称为生命周期函数。 那React有哪些生命周期函数，这些生命周期函数对应的节点是什么呢? 或者说这些生命周期函数在React从创建到销毁的哪一个过程会被执行呢? 这里我们将生命周期分为三个阶段： 创建阶段 更新阶段 卸载阶段 在每一个阶段都包含数个生命周期函数。 创建阶段constructor(props)我们一般在构造函数中干两件事情： 初始化状态 为事件处理函数绑定this 注意： ES6子类的构造函数必须执行一次super()。React如果构造函数中要使用this.props，必须先执行super(props)。 static getDerivedStateFromProps(nextProps, prevState)当创建时、接收新的 props 时、setState时、forceUpdate时会执行这个方法。这是一个静态方法，参数nextProps是新接收的props，prevState是当前的state。返回值(对象)将用于更新state，如果不需要更新则需要返回null。 这个方法在建议尽量少用，只在必要的场景中使用，一般使用场景如下： 无条件的根据props更新state 当props和state的不匹配情况更新state componentWillMount()这个方法已经不推荐使用。因为在未来异步渲染机制下，该方法可能会多次调用。它所行使的功能也可以由 componentDidMount() 和 constructor() 代替： 之前有些人会把异步请求放在这个生命周期，其实大部分情况下都推荐把异步数据请求放在 componentDidMount() 中。 在服务端渲染时，通常使用 componentWillMount() 获取必要的同步数据，但是可以使用 constructor() 代替它。 有定义getDerivedStateFromProps时，会忽略componentWillMount() render()每个类组件中，render() 唯一必须的方法。render() 正如其名，作为渲染用，可以返回下面几种类型： React 元素（React elements） 数组（Arrays） 片段（fragments） 插槽（Portals） 字符串或数字（String and numbers） 布尔值或 null（Booleans or null） 里面不应该包含副作用，应该作为纯函数。不能使用 setState。 componentDidMount()组件完成装载（已经插入 DOM 树）时，触发该方法。这个阶段已经获取到真实的 DOM。一般用于下面的场景： 异步请求 ajax 添加事件绑定(注意在componentWillUnmount中取消，以免造成内存泄漏) 更新阶段componentWillReceiveProps()这个方法在接收新的 props 时触发，即使 props 没有变化也会触发。一般用这个方法来判断 props 的前后变化来更新 state，如下面的例子： class ExampleComponent extends React.Component &#123; state = &#123; isScrollingDown: false, &#125;; componentWillReceiveProps(nextProps) &#123; if (this.props.currentRow !== nextProps.currentRow) &#123; this.setState(&#123; isScrollingDown: nextProps.currentRow &gt; this.props.currentRow, &#125;); &#125; &#125;&#125; 这个方法将被弃用，推荐使用 getDerivedStateFromProps 代替。 static getDerivedStateFromProps()见创建阶段的描述 shouldComponentUpdate()在接收新的 props 或新的 state 时，在渲染前会触发该方法。该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。返回 false， 则不会触发后续的 componentWillUpdate()、render() 和 componentDidUpdate()（但是 state 变化还是可能引起子组件重新渲染）。 所以通常通过这个方法对 props 和 state 做比较，从而避免一些不必要的渲染。 componentWillUpdate()当接收到新的 props 或 state 时，在渲染前执行该方法。在以后异步渲染时，可能会出现某些组件暂缓更新，导致 componentWillUpdate 和 componentDidUpdate 之间的时间变长，这个过程中可能发生一些变化，比如用户行为导致 DOM 发生了新的变化，这时在 componentWillUpdate 获取的信息可能就不可靠了。这个方法将要弃用。 render()见创建阶段的描述 getSnapshotBeforeUpdate()这个方法在 render() 之后，componentDidUpdate() 之前调用。两个参数 prevProps 表示更新前的 props，prevState 表示更新前的 state。返回值称为一个快照（snapshot），如果不需要 snapshot，则必须显示的返回 null —— 因为返回值将作为 componentDidUpdate() 的第三个参数使用。所以这个函数必须要配合 componentDidUpdate() 一起使用。 这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如：在 getSnapShotBeforeUpdate 中获取滚动位置，然后作为参数传给 componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。 下面是官方文档给出的例子： class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // If we have a snapshot value, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; componentDidUpdate()这个方法是在更新完成之后调用，第三个参数 snapshot 就是 getSnapshotBeforeUpdate 的返回值。 正如前面所说，有 getSnapshotBeforeUpdate 时，必须要有 componentDidUpdate。所以这个方法的一个应用场景就是上面看到的例子，配合 getSnapshotBeforeUpdate 使用。 卸载阶段componentWillUnmount() 在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如： 取消定时器 取消事件绑定 取消网络请求 上面三个阶段是正常的生命周期，但是如果发生了异常，就需要进行错误处理，所以React也提供了发生异常时的函数 发生异常componentDidCatch(err, info) 任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。 错误边界不会捕获下面的错误： 事件处理(Event handlers)(因为事件处理不发生在 React 渲染时，报错不影响渲染) 异步代码(Asynchronous code)(e.g. setTimeout or requestAnimationFrame callbacks) 服务端渲染(Server side rendering) 错误边界本身(而不是子组件)抛出的错误 下面我们来看一张生命周期函数图来加深对上面描述的生命周期函数的理解 虽然React有做向下兼容，但是推荐尽量避免使用废弃的生命周期，而是拥抱未来，用新的生命周期替换它们。 函数式组件现在我们用函数式组件写一个HelloReact组件 See the Pen 函数式组件示例 by LastKnightCoder (@lastknightcoder) on CodePen. 其中函数式组件接收一个参数props，通我们在类组件中介绍的props相同。函数式组件与类组件不同的是，函数式组件没有state和生命周期函数，所以函数式组件又被称为无状态组件，从某种意义上说类组件具有更加强大的功能。 为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。其官方指出：在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。 无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点： 组件不会被实例化，整体渲染性能得到提升 因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。 组件不能访问this对象 无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件 组件无法访问生命周期的方法 因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用 无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。 组件分类组件按写法分可以分为类组件和函数式组件，在上面已经详细介绍过。按照组件有无状态又可以将组价分为有状态组件和无状态组件。按照组件的功能分又可以将组件分为容器组件和展示组件，又或者称为Smart组件和Dumb组件。这里主要介绍容器组件和展示组件。 展示组件： 只关注看起来怎么样 内部可能包含有展示组件或容器组件，并且通常有DOM标签和样式 不用指明数据是如何加载或者变化的 只通过props接收数据和回调函数 一般写为函数式组件，除非它们需要状态、生命周期函数或者性能优化 容器组件： 只关注如何工作的 内部也许包含展示组件或容器组件，但一般不会有DOM标签除非一个包装的div，不可能会有样式 为展示组件或其他容器组件提供数据和回调函数 一般是有状态的，被认为是数据源 一般是从高阶组件生成的 通过将组件分为这两种，可以有以下优点： 关注点更好的分离 更好的复用性 高阶组件高阶组件指的不是组件，而是一个函数，它可以增强组件，它接收一个组件，返回一个新组件，这个新组件是接收组件的加强版。假设有这样三个组件 class App1 extends React.Component &#123; state = &#123; data: null &#125;; componnetDidMount() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;; &#125;&#125;class App2 extends React.Component &#123; state = &#123; data: null &#125;; componnetDidMount() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;; &#125;&#125;class App3 extends React.Component &#123; state = &#123; data: null &#125;; componnetDidMount() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;; &#125;&#125; 观察这三个组件，它们都有一个共同的特点，那就是它们在挂载后都要从localStorage中获取数据，可见这样的代码是重复了的，我们如果每次要从localStorage获取数据，都要写一遍这样的代码，那怎么可以让这样的逻辑复用呢? 这就是高阶组件的作用，考虑下面这样的一个函数 function getDataFromLocalStorage(WrapComponent) &#123; class NewComponent extends React.Component &#123; state = &#123; data: null &#125;; componentDidComponent() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;WrapComponent data=&#123;this.state.data&#125; /&gt; &#125; &#125; return NewComponent&#125; 该函数接收一个组件，返回一个新组件。这个新组件在挂载后会用localStorage读取数据，并注入到传入的组件的props.data中。而这个传入的组件会作为新组件render函数的返回值，所以当我们使用这个新组件时，与使用传入的组件一致，不过此时新组件的props中已经有了从localStorage读取的数据。我们可以将上面的三个组件都可以改造为 class App1 extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125; App1 = getDataFromLocalStorage(App1)&#125; class App2 extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125; App2 = getDataFromLocalStorage(App2)&#125;class App3 extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125; App3 = getDataFromLocalStorage(App3)&#125; 我们使用高阶函数为三个组件的props.data中注入了数据，这样三个组件只要调用这个方法，就可以自动可以在props中获取到数据，从而达到了代码的复用。可能读到这里你还不能理解，没关系，多读几遍好好消化，或者写个几遍就习惯了。 render propsrender props的目的同样也是进行代码的复用。再次考虑上面代码的复用，不过这次使用render props实现代码的复用 class GetDataFromLocalStorage extends React.Component &#123; state = &#123;data: null&#125; componentDidMount() &#123; this.setState(localStorage.getItem(\"data\")) &#125; render() &#123; return &#123;this.props.render(this.state)&#125; &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;GetDataFromLocalStorage render = &#123;(&#123;data&#125;) =&gt; &#123; return &lt;div&gt;data&lt;/div&gt; &#125;&#125; /&gt; ) &#125;&#125; 仔细阅读上面的代码，想必还是比较容易读懂的。Render Props的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件。 React Redux假设有这么一棵组件树 Com4从App中获取数据，需要一层一层的传下来，有的中间组件可能只是用来传递数据用，同理，Com4向App传递数据，也要通过回调函数一层层往上传，再这样的情况下，代码实在是比较臃肿，不仅写出了很多不必要的代码，而且使得数据也比较难以理解。 假设有这么一个中央仓库，任何组件都可以直接存储和更改数据，而不需要一层层的传递 不管组件处于多深的层次，都可以从store中直接拿取数据。所以这个想法怎么做到呢? Context首先来介绍React中你可能永远不会用到的特性context。我们在父组件中它下面的子组件通过context的方式提供数据，其中的任意子组件均可以通过context访问数据，这就使得context相当于中央仓库，那怎么用呢(为了演示方便，就写父子两层)? See the Pen Context的使用 by LastKnightCoder (@lastknightcoder) on CodePen. 在上面用到了PropTypes，所以需要下载prop-types，使用npm下载 cnpm install prop-types --save 首先父组件提供context要声明提供的数据名称以及对应的类型 static childContextTypes = &#123; data: PropTypes.string&#125; 然后在getChildContext中返回数据 getChildContext () &#123; return &#123; data: \"data\" &#125;&#125; 而子组件要使用父组件提供的数据，首先要声明要使用的数据是什么以及类型 static contextTypes = &#123; data: PropTypes.string&#125; 只有这样才可以通过this.context获取想要的数据 &lt;div&gt;Child中获取Context：&#123;this.context.data&#125;&lt;/div&gt; context 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。 但是这种机制对于前端应用状态管理来说是很有帮助的，因为毕竟很多状态都会在组件之间进行共享，context 会给我们带来很大的方便。一些第三方的前端应用状态管理的库（例如 Redux）就是充分地利用了这种机制给我们提供便利的状态管理服务。但我们一般不需要手动写 context，也不要用它，只需要用好这些第三方的应用状态管理库就行了。 Redux + React Redux本来还想继续写Redux，React-Redux的，但是我发现React.js 小书写的实在是太好了，推荐仔细阅读其中的Redux和React-Redux的部分。 React Hooks使用React Hooks，使得在函数式组件可以有状态，也可以仿照生命周期函数，甚至可以替代React Redux。所谓的Hooks，就是指一些函数，通过这些函数可以在函数式组建中实现类组件的功能。 钩子函数一般是useXxx的形式，所有的钩子函数都只能写在函数式组件中。 useState我们来看一下如何在函数式组件中使用state See the Pen useState的使用 by LastKnightCoder (@lastknightcoder) on CodePen. 通过useState来创建一个状态，接收一个参数，这个参数就是状态的初始值，返回一个数组，数组包含两个元素，第一个元素就是状态，第二个元素是一个方法，该方法用来设置状态的，如上面 const [number, setNumber] = useState(0) 其中number就是状态，初始值为0，而setNumber是用来设置number的(二者的名字可以随便起，什么changeNumber随意)，每当我们点击+1按钮，都会将当前的number加一。 useEffectuseEffect主要是用来执行一些副作用的代码，比如拿数据 See the Pen useEffect by LastKnightCoder (@lastknightcoder) on CodePen. useEffect接收两个参数，第一个参数是回调函数，第二个参数是一个数组，它会监视数组中的元素，当数组中的元素发生改变时，就会执行回调函数，所以当我们点击按钮改变data时，由于data发生改变，useEffect中的回调函数会被执行。如果希望是componentDidMount生命周期函数的特点，即只在组件挂载是执行一次，那么可以为第二个参数传入一个空数组。 useContextuseContext的作用正如在React Redux中介绍的Context中一样，可以使得子组件无论在什么深度都可以直接访问父组件提供的Context，这个给个例子大家就可以明白 See the Pen useContext的使用 by LastKnightCoder (@lastknightcoder) on CodePen. useReducer如何仔细阅读过React.js小书，那么想必你已经理解了reducer的作用，useReducer接收一个reducer和初始状态initState，返回state和dispatch，如下 See the Pen useReducer by LastKnightCoder (@lastknightcoder) on CodePen. 结合useContext和useReducer我们可以将useContext和useReducer结合，来达到React-Redux的效果，具体就是将useReducer产生的state和dispatch作为Context传下去，如下 See the Pen useContext与useReducer结合 by LastKnightCoder (@lastknightcoder) on CodePen. 富文本编辑器既然是搭建一个基于富文本编辑器的博客系统，那么就要用到富文本编辑器组件，这里我们选择BraftEditor。 使用npm安装到你的项目 cnpm install braft-editor --save 新建pages文件夹，并且在pages中新建文件夹RichText，在RichText中新建index.jsx，内容如下 import React, &#123;useState&#125; from 'react'import BraftEditor from 'braft-editor'import 'braft-editor/dist/index.css'function RichText(props) &#123; const [editorState, setEditorState] = useState(BraftEditor.createEditorState(\"&lt;p&gt;123&lt;/p&gt;\")) const handleEditorChange = (editorState) =&gt; &#123; &#125; const handleEditorSave = (editorState) =&gt; &#123; &#125; return ( &lt;BraftEditor value=&#123;editorState&#125; onChange=&#123;handleEditorChange&#125; onSave=&#123;handleEditorSave&#125; /&gt; )&#125;export default RichText 我们在src下的index.js中引入该组件，并渲染到dom中 import React from 'react';import ReactDOM from 'react-dom';import RichText from './pages/RichText';ReactDOM.render(&lt;RichText /&gt;, document.getElementById(\"root\")); 这时你使用yarn start或者npm start启动项目，在端口3000看到的页面应该是这样的 现在我们来看BraftEditor组件接收的三个props，分别是 value onChange onSave 我们一个个来看。 首先看value，它是BraftEditor组件要显示的内容，它的值是一个editorState对象，我们可以通过BraftEditor.createEditorState()创建editorState对象，它接收html字符串或者一个raw对象(raw对象是它自定义的对象，一般我们保存富文本的内容就是保存raw对象)，也可以通过editorState实例转化为html字符串或者raw对象，如 // 创建edirorState对象const editorState = BraftEditor.createEditor(\"&lt;p&gt;123&lt;/p&gt;\");const htmlContent = editorState.toHTML();const rawContent = editorState.toRAW(); 再者来看onChange，它是当BraftEditor发生改变时调用的回调函数，它会传入一个editorState对象，这个editorState对象代表的就是当前的文本内容。 最后看onSave，它是当按下Ctrl + S保存时会调用的方法，也会将代表当前文本内容的editorState传入。 我们来做一个简单的案例，当按下Ctrl + S时，将数据以raw对象的格式保存在localStorage中，当富文本加载时，从localStorage中读取数据 import React, &#123;useState, useEffect&#125; from 'react'import BraftEditor from 'braft-editor'import 'braft-editor/dist/index.css'function RichText(props) &#123; const [editorState, setEditorState] = useState(BraftEditor.createEditorState(null)) useEffect(() =&gt; &#123; const rawContent = localStorage.getItem(\"rawContent\") || null; setEditorState(BraftEditor.createEditorState(rawContent)) &#125;, []) const handleEditorChange = (editorState) =&gt; &#123; &#125; const handleEditorSave = (editorState) =&gt; &#123; const rawContent = editorState.toRAW(); localStorage.setItem(\"rawContent\", rawContent) &#125; return ( &lt;BraftEditor value=&#123;editorState&#125; onChange=&#123;handleEditorChange&#125; onSave=&#123;handleEditorSave&#125; /&gt; )&#125;export default RichText 这里就增加了两个地方，第一个是增加了useEffect，作用是当组件挂载后从localStorage中读取数据(既然从localStorage初始化，那么原来的”&lt;p&gt;123&lt;/p&gt;“就换为了null)，第二个是更改了handleEditorSave，当保存时将数据保存在localStorage中，上面的代码都很容易理解，不再解释。如果成功了的话，在富文本编辑器中输入并按Ctrl + S保存，然后刷新，数据会原样的重现。 页面布局我们来看一下项目的每个页面的布局 Home Edit Display Login 其中Home, Display, Edit都是下面这样的布局 而Login的布局是 所以我们抽离出布局组件，Home，Edit,Display三者的布局抽离为BasicLayout，而Login的布局抽离为LoginLayout组件，注意到他们的Heder都是相同的，所以我们把Header抽离为一个公共的组件。 Header在src下新建components目录，在其中新建Header文件夹，在其中新建index.jsx和index.module.css。index.jsx的内容如下 import React from 'react'import styles from './index.module.css'function Header(props) &#123; const toEdit = (e) =&gt; &#123; e.preventDefault() &#125; const toHome = (e) =&gt; &#123; e.preventDefault() &#125; return ( &lt;div className=&#123;styles.header&#125;&gt; &lt;div className=&#123;styles.nav&#125;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/home\" onClick=&#123;toHome&#125;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/edit\" onClick=&#123;toEdit&#125;&gt;写博客&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div className=&#123;styles.desc&#125;&gt; Coder &lt;/div&gt; &lt;/div&gt; )&#125;export default Header index.module.css中的内容为 .nav &#123; width: 100%; height: 100px; position: relative;&#125;.nav ul &#123; position: absolute; top: 0; right: 0; padding: 0; margin: 0;&#125;.nav ul li &#123; list-style: none; float: left; width: 80px; height: 30px; line-height: 30px; text-align: center; padding-top: 5px;&#125;.nav ul li a &#123; text-decoration: none; color: white; font-family: Consolas, \"楷体\";&#125;.nav ul li:hover &#123; border-bottom: 1px solid #FFF; box-shadow: 0 0 10px #FFF inset;&#125;.desc &#123; width: 100%; height: 100px; font-size: 40px; line-height: 100px; color: white; font-family: Consolas, \"楷体\";&#125; 上面的内容想必还是很容易理解的，其中Header中的两个a标签的点击事件均没有处理，这两个a标签是用于做路由跳转用的，等用到在回过头来补充。 BasicLayout在src下新建layouts文件夹，在其中新建文件夹BasicLayout，在BasicLayout中新建index.jsx和index.module.css，其中index.jsx的内容为 import React from 'react'import styles from './index.module.css'import Header from './../../components/Header'function BasicLayout(props) &#123; const &#123; children &#125; = props; return ( &lt;div className=&#123;styles.box&#125;&gt; &lt;div className=&#123;styles.container&#125;&gt; &lt;Header /&gt; &lt;div className=&#123;styles.main&#125;&gt; &lt;div className=&#123;styles.content&#125;&gt; &#123;children&#125; &lt;/div&gt; &lt;div className=&#123;styles.aside&#125;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default BasicLayout 其中index.module.css中的内容为 .box &#123; width: 100%; background: #d8e2eb url(./../../assets/img/bg.jpg) no-repeat top center; min-height: 100vh;&#125;.container &#123; max-width: 1200px; margin: 0 auto; padding: 0 50px;&#125;.main &#123; display: flex;&#125;.content &#123; flex: 3; margin-right: 20px;&#125;.aside &#123; flex: 1;&#125; 这里要用到背景图片，我们在src下新建assets文件夹，然后新建img，在其中放入背景图片，背景图片在这里 接在src下新建common.css，以消除内外边距，设置字体 * &#123; margin: 0; padding: 0;&#125;div &#123; font-family: Consolas, \"楷体\"; box-sizing: border-box;&#125; 现在我们在src/index.js中引用该布局看看效果 import React from 'react';import ReactDOM from 'react-dom';import RichText from './pages/RichText';import BasicLayout from './layouts/BasicLayout'import './common.css'ReactDOM.render(&lt;BasicLayout&gt; &lt;RichText /&gt; &lt;/BasicLayout&gt;, document.getElementById(\"root\")); 如下： LoginLayout在layouts下新建LoginLayout文件夹，在LoginLayout中新建index.jsx和index.module.css。有了BasicLayout的经验，代码的内容不必解释，直接上代码。index.jsx import React from 'react'import styles from './index.module.css'import Header from './../../components/Header'function LoginLayout(props) &#123; const &#123; children &#125; = props; return ( &lt;div className=&#123;styles.box&#125;&gt; &lt;div className=&#123;styles.container&#125;&gt; &lt;Header /&gt; &lt;div className=&#123;styles.main&#125;&gt; &#123;children&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default LoginLayout index.module.css .box &#123; width: 100%; background: #d8e2eb url(./../../assets/img/bg.jpg) no-repeat top center; min-height: 100vh;&#125;.container &#123; max-width: 1200px; margin: 0 auto; padding: 0 50px;&#125;.main &#123; width : 300px; margin: 0 auto;&#125; 页面路由为了使用路由，先下好react-router-dom cnpm install react-router-dom --save 该blog项目总共有四个页面 Home：页面主页 Display：阅读文章的页面 Edit：编辑文章的页面 Login：登录页面 为了演示路由，在pages中分别新建Home, Display, Edit, Login四个文件夹，并在每个文件夹中新建index.jsx，同时在Edit文件夹了新建components文件夹，将RichText文件夹全部移入到这个文件夹中(因为RichText富文本编辑器属于编辑文章页面的一部分)，简单的在每个文件的index.jsx写下一些内容，具体的内容在后面添加。 // Home/index.jsximport React from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'function Home(props) &#123; return ( &lt;BasicLayout&gt; Home &lt;/BasicLayout&gt; )&#125;export default withRouter(Home) // Display/index.jsximport React from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'function Display(props) &#123; return ( &lt;BasicLayout&gt; Display &lt;/BasicLayout&gt; )&#125;export default withRouter(Display) // Edit/index.jsximport React from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'import RichText from './components/RichText'function Edit() &#123; return ( &lt;BasicLayout&gt; &lt;RichText /&gt; &lt;/BasicLayout&gt; )&#125;export default withRouter(Edit) // Login/index.jsximport React from 'react'import &#123;withRouter&#125; from 'react-router-dom'import LoginLayout from './../../layouts/LoginLayout'function Login(props) &#123; return ( &lt;LoginLayout&gt; login &lt;/LoginLayout&gt; )&#125;export default withRouter(Login) 设计页面路由如下 path component redirect /home Home /display/:id Display /edit Edit /edit:id Edit /login Login / /home 注意到Edit组件对应两个路径，因为编辑文章有两种情况，第一种是添加文章，这时是/edit路径，第二种是编辑文章，这时需要传入文章的id，所以这时是/edit/:id路径。 在src下新建文件夹config，在config新建routes.js，里面设置路由信息，如下 import Home from './../pages/Home/index'import Display from './../pages/Display/index'import Edit from './../pages/Edit/index'import Login from './../pages/Login/index'export default [ &#123; path: \"/login\", component: Login &#125;, &#123; path: \"/home\", component: Home &#125;, &#123; path: \"/display/:id\", component: Display &#125;, &#123; path: \"/edit\", component: Edit &#125;, &#123; path: \"/edit/:id\", component: Edit &#125;, &#123; path: \"/\", redirect: \"/home\", exact: true &#125;,] 在src下新建router.js，用来渲染路由，内容如下 import React from 'react'import routes from './config/routes'import &#123;Switch, BrowserRouter as Router, Route, Redirect &#125; from 'react-router-dom'import &#123; createBrowserHistory &#125; from 'history';const history = createBrowserHistory();// 返回可能是Redirect 也可能是Route 所以使用RouteItem封装const RouteItem = (props) =&gt; &#123; const &#123; path, component: Component, redirect, key, exact &#125; = props; if (redirect) &#123; return &lt;Redirect from=&#123;path&#125; to=&#123;redirect&#125; key=&#123;key&#125; /&gt; &#125; return ( &lt;Route key=&#123;key&#125; exact=&#123;exact&#125; path=&#123;path&#125; render=&#123;componentProps =&gt; &#123; return ( &lt;Component &#123;...componentProps&#125; /&gt; ) &#125;&#125; /&gt; );&#125;;const router = () =&gt; &#123; return ( &lt;Router&gt; &#123;/* Switch 唯一匹配 */&#125; &lt;Switch&gt; &#123;routes.map((item, id) =&gt; &#123; return RouteItem(&#123; key: id, ...item &#125;) &#125;)&#125; &lt;/Switch&gt; &lt;/Router&gt; );&#125;;export default router; 接着在src/index.js中渲染出来 import ReactDOM from 'react-dom';import router from './router'import './common.css';ReactDOM.render(router(), document.getElementById(\"root\")); 接着启动项目(npm start或yarn start)，改变浏览的url(如localhost:3000/display)看看页面是否能成功跳转(我这里是没有问题的，如果你不能的话，回过头仔细看看吧)。 页面编写antd表单的使用要使用antd，先下载antd cnpm install antd --save 首先看一个表单的例子，在src下新建一个test文件夹，新建TextAntdForm.jsx，内容如下(先不管看得懂看不懂，后面解释) import React from 'react'import &#123;Form, Input, Button&#125; from 'antd'function TextAntdForm(props) &#123; const &#123;getFieldDecorator, validateFields&#125; = props.form const handleSubmit = (event) =&gt; &#123; event.preventDefault(); validateFields((error, values) =&gt; &#123; if (!error) &#123; console.log(values); &#125; &#125;) &#125; return( &lt;div style=&#123;&#123;width: \"300px\", margin: \"100px auto\", fontFamily: \"Consolas, '楷体'\"&#125;&#125;&gt; &lt;Form onSubmit=&#123;handleSubmit&#125;&gt; &lt;Form.Item label=\"用户名\"&gt; &#123;getFieldDecorator('title', &#123; rules: [&#123; required: true, message: '请输入用户名', &#125;], &#125;)( &lt;Input size=\"large\" placeholder=\"请输入用户名\"/&gt; )&#125; &lt;/Form.Item&gt; &lt;Form.Item label=\"密码\"&gt; &#123;getFieldDecorator('password', &#123; rules: [&#123; required: true, message: '请输入密码', &#125;], &#125;)( &lt;Input.Password size=\"large\" placeholder=\"请输入密码\"/&gt; )&#125; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button size=\"large\" type=\"primary\" htmlType=\"submit\"&gt;提交&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/div&gt; )&#125;export default Form.create()(TextAntdForm) 修改src/index.js渲染该组件(记得引入antd/dits/antd.css，否则antd组件没有样式) import React from 'react'import ReactDOM from 'react-dom';// import router from './router'import TestAntdForm from './test/TestAntdForm'import 'antd/dist/antd.css'import './common.css';// ReactDOM.render(router(), document.getElementById(\"root\"));ReactDOM.render(&lt;TestAntdForm /&gt;, document.getElementById(\"root\")); 现在来解释上面的代码，首先看最后一行 Form.create()(TextAntdForm) 还记得高阶组件吗，Form.create()就是一个高阶组件，他会向组件的props中注入form，form提供了一些API，这里使用了两个： getFieldDecorator：用于和表单进行双向绑定 getFieldDecorator('title', &#123; rules: [&#123; required: true, message: '请输入用户名', &#125;],&#125;)( &lt;Input size=\"large\" placeholder=\"请输入用户名\"/&gt;) 上面将Input与表单项进行了绑定，getFieldDecorator接收两个参数，第一个参数是id，根据它可以获取输入控件的值或者设置输入控件的值，是必填项；第二个参数是options，里面可以有很多属性，这里使用了rules，定义了校验的规则，required表示是否必填，message表示未填时显示的消息文字。 validateFields：校验 里面接受一个回调函数，回调函数接收两个参数，第一个参数为error，当不满足校验规则时error的值非空，第二个参数是values，会将绑定表单的值以对象的形式传给values，键就是在getFieldDecorator传入的id。 上面在提交表单后，会调用Form的onSubmit回调函数，在回调函数，我们对数据进行了校验，如果没有问题的话，我们可以将输入表单的键值对以对象的形式获取到values，并打印出来 页面数据我们将数据设置为一个数组datas，它的格式如下 datas = [ &#123;title: , brief: , isTop: , content: &#125; &#123;title: , brief: , isTop: , content: &#125;] Home组件根据datas展示数据，Edit和Display组件根据id和datas获取要展示的数据，由于多个组件都要用到数据，所以这里使用useContext和useReducer来分发数据。 在src下新建Provider.jsx，用来提供state和dispatch，内容如下 import React, &#123;useReducer&#125; from 'react'export const Context = React.createContext();const reducer = (state, action) =&gt; &#123; const tempDatas = state.datas // 按道理case后面跟的都是常量，我这里为了简单 switch(action.type) &#123; case 'insertData': tempDatas[tempDatas.length] = action.data; return &#123;...state, datas: tempDatas&#125; case 'updateData': tempDatas[action.id] = action.data return &#123;...state, datas: tempDatas&#125; case 'deleteData': tempDatas.splice(action.id, 1) return &#123;...state, datas: tempDatas&#125; case 'changeOperation': return &#123;...state, operation: action.operation&#125; default: return state &#125;&#125;const initState = &#123; // 随便写的数据用来实验 随后会删掉 datas: [&#123;title: 'aaa', isTop: true, brief: 'hahah'&#125;, content: '&lt;p&gt;123&lt;/p&gt;'], // 用来判断是添加文章还是编辑文章 operation: 'ADD'&#125;function Provider(props) &#123; const [state, dispatch] = useReducer(reducer, initState) const &#123;children&#125; = props return ( &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt; &#123;children&#125; &lt;/Context.Provider&gt; )&#125;export default Provider 更改router.js，在最上面加上Provider import Provider from './Provider'// 上面没有变化，除了import Provider，故此省略const router = () =&gt; &#123; return ( &lt;Provider&gt; &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &#123;routes.map((item, id) =&gt; &#123; return RouteItem(&#123; key: id, ...item, history: history &#125;) &#125;)&#125; &lt;/Switch&gt; &lt;/Router&gt; &lt;/Provider&gt; );&#125;;export default router Home观察Home页面 发现Home是由这一个个Item组成，Item中的数据正是datas数组中每一个元素的内容，在Home中新建文件夹Item，并在Item中新建index.jsx和index.module.css。index.jsx: import React from 'react'import styles from './index.module.css'import &#123;Modal&#125; from 'antd'const &#123;confirm&#125; = Modalfunction Item(props) &#123; const &#123; data, login, handleDelete, index, handleToEdit, handleToDisplay &#125; = props; const toDisplay = (event) =&gt; &#123; event.preventDefault(); handleToDisplay(index) &#125; const toEdit = (event) =&gt; &#123; event.preventDefault(); handleToEdit(index) &#125; const toDelete = (event) =&gt; &#123; event.preventDefault(); confirm(&#123; title: `你确定要删除$&#123;data.title&#125;`, content: '删除后内容不可恢复', onOk() &#123; handleDelete(index) &#125;, onCancel() &#123; &#125;, &#125;); &#125; return ( &lt;div className=&#123;styles.item&#125;&gt; &lt;h2&gt;&lt;a href=&#123;`/display/$&#123;data.id&#125;`&#125; onClick=&#123;toDisplay&#125;&gt;&#123;data.title&#125;&lt;/a&gt;&lt;/h2&gt; &lt;hr /&gt; &lt;div className=&#123;styles.abstract&#125;&gt; &#123;data.brief&#125; &lt;/div&gt; &lt;div className=&#123;styles.readmore&#125;&gt; &lt;a href=&#123;`/display/$&#123;data.id&#125;`&#125; onClick=&#123;toDisplay&#125;&gt;阅读更多&lt;/a&gt; &lt;/div&gt; &#123;/* 当登录失显示编辑本文和删除本文 */&#125; &#123;login ? &lt;div className=&#123;styles.edit&#125;&gt; &lt;a href=&#123;`/edit/$&#123;data.id&#125;`&#125; onClick=&#123;toEdit&#125;&gt;编辑本文&lt;/a&gt; &lt;/div&gt; : \"\"&#125; &#123;login ? &lt;div className=&#123;styles.delete&#125;&gt; &lt;a href=\"/delete\" onClick=&#123;toDelete&#125;&gt;删除本文&lt;/a&gt; &lt;/div&gt;: \"\"&#125; &#123;/* 当isTop为1时显示置顶图标 */&#125; &#123;data.isTop ? &lt;div className=&#123;styles.isTop&#125;&gt; &lt;svg viewBox=\"0 0 1024 1024\"&gt; &lt;path d=\"M0 0h1024v1024z\" fill=\"#7ED321\"&gt;&lt;/path&gt; &lt;path d=\"M571.733333 157.866667l17.066667-12.8-83.2-83.2L552.533333 14.933333l183.466667 183.466667-46.933333 46.933333-81.066667-81.066666-17.066667 12.8 100.266667 100.266666-14.933333 14.933334-102.4-102.4c-6.4 4.266667-10.666667 8.533333-17.066667 10.666666l72.533333 72.533334-110.933333 110.933333 36.266667 36.266667-14.933334 14.933333L313.6 209.066667l14.933333-14.933334 36.266667 36.266667 110.933333-110.933333 61.866667 61.866666c6.4-4.266667 10.666667-8.533333 17.066667-10.666666l-96-96 14.933333-14.933334 98.133333 98.133334z m-72.533333 209.066666l17.066667-17.066666-117.333334-117.333334-17.066666 17.066667 117.333333 117.333333z m27.733333-29.866666l14.933334-14.933334L426.666667 204.8l-14.933334 14.933333 115.2 117.333334z m27.733334-27.733334l17.066666-14.933333-117.333333-117.333333-17.066667 14.933333 117.333334 117.333333z m27.733333-25.6l14.933333-14.933333L482.133333 149.333333l-14.933333 14.933334 115.2 119.466666z m10.666667-202.666666L554.666667 44.8l-21.333334 21.333333 38.4 38.4 21.333334-23.466666z m57.6 57.6l-40.533334-40.533334-21.333333 21.333334 40.533333 40.533333 21.333334-21.333333zM704 192l-38.4-38.4-21.333333 21.333333L682.666667 213.333333l21.333333-21.333333zM571.733333 471.466667l12.8-21.333334c8.533333 10.666667 17.066667 19.2 25.6 27.733334 6.4 6.4 12.8 6.4 21.333334-2.133334l172.8-172.8-38.4-38.4 17.066666-17.066666 87.466667 87.466666-17.066667 17.066667-29.866666-29.866667-177.066667 177.066667c-14.933333 14.933333-29.866667 14.933333-44.8 0l-29.866667-27.733333z m302.933334 21.333333l-44.8 44.8c-27.733333 25.6-55.466667 40.533333-83.2 44.8-27.733333 2.133333-59.733333-6.4-96-25.6l6.4-25.6c34.133333 19.2 64 27.733333 87.466666 25.6 23.466667-4.266667 46.933333-14.933333 68.266667-36.266667l44.8-44.8 17.066667 17.066667z m132.266666-21.333333l-17.066666 19.2-55.466667-55.466667c-10.666667 8.533333-19.2 17.066667-29.866667 23.466667l51.2 51.2-119.466666 119.466666-17.066667-17.066666 102.4-102.4-76.8-76.8-104.533333 100.266666-17.066667-17.066666 121.6-121.6 42.666667 42.666666c10.666667-6.4 19.2-14.933333 29.866666-23.466666L861.866667 362.666667l17.066666-17.066667 128 125.866667zM802.133333 682.666667h-25.6c2.133333-25.6 2.133333-55.466667-2.133333-89.6h23.466667c4.266667 34.133333 4.266667 64 4.266666 89.6z\" fill=\"#FFFFFF\"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/div&gt; : \"\"&#125; &lt;/div&gt; )&#125;export default Item 注意到Item为展示组件，只负责数据的展示，而不负责数据的处理、获取，Item的数据、数据的操作都是从props中获取的，这些操作都由Item的容器组件Home来完成。 我们会将login保存在sessionStorage，login是一个布尔值，保存了是否登录的信息，true表示登录，false表示未登录，根据是否登录，决定是否将删除和编辑的操作暴露出来。同时我们也将根据data的isTop是否为true来显示是否置顶的svg图样(该图样来自CSDN的置顶图样)。 index.module.css .item &#123; width: 100%; height: 150px; background-color: white; margin-bottom: 40px; border-radius: 4px; padding-left: 25px; padding-right: 20px; padding-top: 20px; position: relative; box-shadow:0px 0px 6px 6px #FFF;&#125;.item a &#123; text-decoration: none; color: #40759b;&#125;.item a:hover &#123; text-decoration: underline;&#125;.abstract &#123; width: 100%; padding-top: 30px;&#125;.readmore &#123; position: absolute; font-size: 14px; bottom: 10px; right: 10px;&#125;.edit &#123; position: absolute; font-size: 14px; bottom: 10px; right: 75px;&#125;.delete &#123; position: absolute; font-size: 14px; bottom: 10px; right: 140px;&#125;.isTop &#123; position: absolute; width: 50px; top: 0; right: 0;&#125; 现在进入Home组件，修改Home/index.jsx如下 import React, &#123; useContext &#125; from 'react'import BasicLayout from './../../layouts/BasicLayout'import Item from './components/Item'import &#123;withRouter&#125; from 'react-router-dom'import &#123;Context&#125; from './../../router'import &#123; message &#125; from 'antd'function Home(props) &#123; const &#123;history&#125; = props // 使用useContext获取Provider提供的数据 const &#123;state, dispatch&#125; = useContext(Context); const login = sessionStorage.getItem(\"login\"); const datas = state.datas; const handleDelete = (id) =&gt; &#123; dispatch(&#123;type: \"deleteData\", id&#125;); message.success('删除成功'); &#125; const handleToEdit = (id) =&gt; &#123; dispatch(&#123;type: \"changeOperation\", operation: \"EDIT\"&#125;) history.push(`/edit/$&#123;id&#125;`); &#125; const handleToDisplay = (id) =&gt; &#123; history.push(`display/$&#123;id&#125;`); &#125; return ( &lt;div&gt; &lt;BasicLayout&gt; &#123;datas.map((data, index) =&gt; &#123; return &lt;Item index=&#123;index&#125; data=&#123;data&#125; key=&#123;index&#125; login=&#123;login&#125; handleDelete=&#123;handleDelete&#125; handleToEdit=&#123;handleToEdit&#125; handleToDisplay=&#123;handleToDisplay&#125; /&gt; &#125;)&#125; &lt;/BasicLayout&gt; &lt;/div&gt; )&#125;export default withRouter(Home) 现在启动项目(npm start)，观察到页面如下 说明Home页面已经成功了(由于在sessionStorage中没有login，所以删除本文和编辑本文均显示不出来，当点击阅读更多时，会跳转到Display的页面)。 Display我们来观察Display的页面 发现Display页面有一个背景为白色的内容区和一个按钮，这个按钮根据是否有登录来决定是否暴露出来，所以我们在Display中新建一个components文件夹，在里面新建一个Content文件夹，在Content文件夹中新建index.jsx和index.module.css。首先Content是一个展示组件，所以它的数据全部都由Display提供，所有的数据操作也由Display传入回调函数进行处理。 index.jsx如下 import React from 'react'import &#123; Button &#125; from 'antd'import styles from './index.module.css'function Content(props) &#123; const &#123;login, htmlContent, handleToEdit&#125; = props const toEdit = () =&gt; &#123; handleToEdit(); &#125; return( &lt;div className=&#123;styles.display&#125;&gt; &lt;div className=\"braft-output-content\" style=&#123;&#123;minHeight: \"425px\", backgroundColor: \"#FFF\", padding: \"50px 25px\", fontSize: \"16px\", maxWidth: \"850px\"&#125;&#125; dangerouslySetInnerHTML=&#123;&#123;__html: htmlContent&#125;&#125; &gt; &lt;/div&gt; &#123;login &amp;&amp; &lt;div className=&#123;styles.edit&#125;&gt; &lt;Button type=\"primary\" onClick=&#123;toEdit&#125;&gt;编辑文章&lt;/Button&gt; &lt;/div&gt; &#125; &lt;/div&gt; )&#125;export default Content 想必上面的代码还是比较容易理解的，index.module.css的内容如下 .display &#123; position: relative;&#125;.display ul, .display ol &#123; padding-left: 30px;&#125;.edit &#123; position: absolute; top: 10px; right: 10px;&#125; 所以Display中的内容如下 import React, &#123;useContext&#125; from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'import Content from './components/Content'import &#123;Context&#125; from './../../Provider'import BraftEditor from 'braft-editor'function Display(props) &#123; const &#123;history&#125; = props // 获取传过来的id const index = Number(history.location.pathname.split(\"/\")[2]) const &#123;state, dispatch&#125; = useContext(Context) const htmlContent = BraftEditor.createEditorState(state.datas[index].content).toHTML() const login = sessionStorage.getItem(\"login\") const handleToEdit = () =&gt; &#123; dispatch(&#123;type: \"changeOperation\", operation: \"EDIT\"&#125;); history.push(`/edit/$&#123;index&#125;`); &#125; return ( &lt;BasicLayout&gt; &lt;Content htmlContent=&#123;htmlContent&#125; login = &#123;login&#125; handleToEdit = &#123;handleToEdit&#125; /&gt; &lt;/BasicLayout&gt; )&#125;export default withRouter(Display) 至此Display页面设计完毕。 Edit在写Edit页面之前，来改造一下RichText组件，我们要将RichText做成展示组件，所有的数据都由Edit提供，所有的数据处理也由Edit处理，修改如下 import React from 'react'import BraftEditor from 'braft-editor'import 'braft-editor/dist/index.css'function RichText(props) &#123; const &#123;value, onChange&#125; = props const handleEditorChange = (editorState) =&gt; &#123; onChange(editorState) &#125; return ( &lt;BraftEditor value=&#123;value&#125; onChange=&#123;handleEditorChange&#125; /&gt; )&#125;export default RichText 现在我们来看一下Edit页面的结构 我们使用antd的表单来做成这件事情，在前面已经介绍过antd表单的使用，所以这里不多加介绍，直接上代码 import React, &#123;useEffect, useContext&#125; from 'react'import RichText from './components/RichText'import &#123; withRouter &#125; from 'react-router-dom'import &#123; Form, Input, Button, message, Checkbox &#125; from 'antd'import BasicLayout from './../../layouts/BasicLayout'import BraftEditor from 'braft-editor'import &#123;Context&#125; from './../../Provider'function Edit(props) &#123; const &#123;history&#125; = props const FormItem = Form.Item; const &#123; getFieldDecorator, validateFieldsAndScroll &#125; = props.form; const &#123;state, dispatch&#125; = useContext(Context) useEffect(() =&gt; &#123; // 当组件加载后 如果是编辑文章 根据id获取数据 然后显示 // 如果是添加操作，则不加载数据 直接显示空白内容 if(state.operation === 'EDIT') &#123; const index = Number(history.location.pathname.split(\"/\")[2]) const data = state.datas[index] // setFieldsValue为表单设置内容 props.form.setFieldsValue(&#123; ...data, content: BraftEditor.createEditorState(data.content) &#125;) &#125; &#125;, []) const handleSubmit = (event) =&gt; &#123; event.preventDefault(); validateFieldsAndScroll((err, values) =&gt; &#123; if(!err) &#123; // 如果是通过添加按钮进来的 那么拿到数据保存 然后跳转到home页面 if(state.operation === 'ADD') &#123; dispatch(&#123;type: 'insertData', data: &#123; ...values, content: values.content.toRAW() &#125;&#125;); message.success(\"添加成功\"); history.push(\"/home\"); //如果是编辑文章进来的，更新数据 然后跳转到home &#125; else if (state.operation === \"EDIT\") &#123; const id = Number(history.location.pathname.split(\"/\")[2]); dispatch(&#123;type: \"updateData\", id, data: &#123; ...values, content: values.content.toRAW(), &#125;&#125;); message.success(\"更新成功\"); history.push(\"/home\"); &#125; &#125; &#125;) &#125; return ( &lt;BasicLayout&gt; &lt;div&gt; &lt;Form onSubmit=&#123;handleSubmit&#125;&gt; &lt;FormItem labelAlign=\"left\" label=\"文章标题\"&gt; &#123;getFieldDecorator('title', &#123; rules: [&#123; required: true, message: '请输入标题', &#125;], &#125;)( &lt;Input size=\"large\" placeholder=\"请输入标题\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem size=\"large\" label=\"文章摘要\"&gt; &#123;getFieldDecorator('brief', &#123; rules: [&#123; required: true, message: '请输入摘要', &#125;], &#125;)( &lt;Input.TextArea style=&#123;&#123;fontSize: \"16px\"&#125;&#125; placeholder=\"请输入摘要\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem&gt; &#123;getFieldDecorator('isTop', &#123; valuePropName: 'checked', &#125;)( &lt;Checkbox&gt; 是否置顶 &lt;/Checkbox&gt;, )&#125; &lt;/FormItem&gt; &lt;FormItem label=\"文章正文\"&gt; &#123;getFieldDecorator('content', &#123; validateTrigger: 'onBlur', rules: [&#123; required: true, message: \"请输入正文\" &#125;], &#125;)( &lt;RichText /&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button size=\"large\" type=\"primary\" htmlType=\"submit\"&gt;提交&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/div&gt; &lt;/BasicLayout&gt; )&#125;// 为Edit注入formexport default withRouter(Form.create()(Edit)) 上面的代码虽然有点长，但是都是比较容易理解的。注意，虽然我们没有为RichText传入value和onChange，但是由于RichText和表单项进行了双向绑定，所以表单会注入value和onChange。 LoginLogin页面应该是最简单的，只要用我们在前面antd表单示例里面的表单就可以完成，所以直接上代码如下 import React from 'react'import &#123;withRouter&#125; from 'react-router-dom'import &#123;Form, Button, Input, message &#125; from 'antd'import LoginLayout from './../../layouts/LoginLayout'function Login(props) &#123; const &#123; form, history &#125; = props; const FormItem = Form.Item; const &#123;getFieldDecorator, validateFields&#125; = form const handleSubmit = (event) =&gt; &#123; event.preventDefault(); validateFields((err, values) =&gt; &#123; if (!err) &#123; if (values.adminId === \"123\" &amp;&amp; values.password === \"123\") &#123; sessionStorage.setItem(\"login\", true); message.success(\"登录成功\"); history.push(\"/home\") &#125; else &#123; message.error(\"用户名或密码错误\") &#125; &#125; &#125;) &#125; return ( &lt;LoginLayout&gt; &lt;Form onSubmit=&#123;handleSubmit&#125;&gt; &lt;FormItem labelAlign=\"left\" label=\"用户名\"&gt; &#123;getFieldDecorator('adminId', &#123; rules: [&#123; required: true, message: '请输入用户名', &#125;], &#125;)( &lt;Input size=\"large\" placeholder=\"请输入用户名\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem size=\"large\" label=\"密码\"&gt; &#123;getFieldDecorator('password', &#123; rules: [&#123; required: true, message: '请输入密码', &#125;], &#125;)( &lt;Input.Password size=\"large\" placeholder=\"请输入密码\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button size=\"large\" type=\"primary\" htmlType=\"submit\"&gt;提交&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/LoginLayout&gt; )&#125;export default withRouter(Form.create()(Login)) 收尾在这里还有一个小地方没有处理，那就是Header，里面的a标签的点击事件没有处理，并且我们希望在登录的情况下显示”写博客”，以及在登录的情况下显示”退出登录”，在未登录的情况下显示”登录”，所以修改Header如下(由于要用到history，所以要在Layout里给Header传入history，但是Layout也没有history，所以要在Home, Edit, Display, Login中给用到的Layout传入history，这里的代码就不贴出了，想必这样的事情对现在的你应该已经很简单了) import React, &#123;useContext&#125; from 'react'import styles from './index.module.css'import &#123;Context&#125; from './../../Provider'function Header(props) &#123; const &#123;history&#125; = props; const &#123;dispatch&#125; = useContext(Context); const login = sessionStorage.getItem(\"login\"); const toEdit = (e) =&gt; &#123; e.preventDefault(); dispatch(&#123;type: \"changeOperation\", operation: \"ADD\"&#125;); history.push(\"/edit\"); &#125; const toHome = (e) =&gt; &#123; e.preventDefault() history.push(\"/home\") &#125; const logout = (e) =&gt; &#123; e.preventDefault() sessionStorage.removeItem(\"login\"); history.push(\"/login\"); &#125; const login_ = (e) =&gt; &#123; e.preventDefault() history.push(\"/login\"); &#125; return ( &lt;div className=&#123;styles.header&#125;&gt; &lt;div className=&#123;styles.nav&#125;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/home\" onClick=&#123;toHome&#125;&gt;首页&lt;/a&gt;&lt;/li&gt; &#123;login &amp;&amp; &lt;li&gt;&lt;a href=\"/edit\" onClick=&#123;toEdit&#125;&gt;写博客&lt;/a&gt;&lt;/li&gt;&#125; &#123;login ? &lt;li&gt;&lt;a href=\"/login\" onClick=&#123;logout&#125;&gt;退出登录&lt;/a&gt;&lt;/li&gt; : &lt;li&gt;&lt;a href=\"/login\" onClick=&#123;login_&#125;&gt;登录&lt;/a&gt;&lt;/li&gt;&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div className=&#123;styles.desc&#125;&gt; Coder &lt;/div&gt; &lt;/div&gt; )&#125;export default Header 接下来就是数据的持久化，我们希望将数据能够保存到localStorage，这样当页面刷新，关闭页面、浏览器,关机数据都能够保存。修改Provider.jsx import React, &#123;useReducer&#125; from 'react'export const Context = React.createContext();const saveData = (datas) =&gt; &#123; localStorage.setItem(\"datas\",JSON.stringify(datas) || [])&#125;const loadData = () =&gt; &#123; // 如果datas没有内容，则为空数组，因为后面用到datas.map，放止报错 return JSON.parse(localStorage.getItem(\"datas\")) || []&#125;const reducer = (state, action) =&gt; &#123; const tempDatas = state.datas // 每次对数据进行操作后都保存数据 switch(action.type) &#123; case 'insertData': tempDatas[tempDatas.length] = action.data; saveData(tempDatas) return &#123;...state, datas: tempDatas&#125; case 'updateData': tempDatas[action.id] = action.data saveData(tempDatas) return &#123;...state, datas: tempDatas&#125; case 'deleteData': tempDatas.splice(action.id, 1) saveData(tempDatas) return &#123;...state, datas: tempDatas&#125; case 'changeOperation': return &#123;...state, operation: action.operation&#125; default: return state &#125;&#125;const initState = &#123; // 初始化从localStorage中读取数据 datas: loadData(), operation: 'ADD'&#125;function Provider(props) &#123; const [state, dispatch] = useReducer(reducer, initState) const &#123;children&#125; = props return ( &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt; &#123;children&#125; &lt;/Context.Provider&gt; )&#125;export default Provider 登录权限控制如果用户没有登录的话，是没有权利访问某些页面的，比如编辑页面，它不能够添加文章，也不能够编辑文章(虽然我们在未登录的情况下没有暴露这样的途径，如Display页面未登录没有编辑文章的按钮，Header未登录没有写文章的连接，但是可以通过url直接访问)，所以我们要做一些权限控制。 所以在访问路由时，我们要做权限的检查，修改router.js中的RouteItem方法，不能直接的返回Route，而是要给Route加一层验证，以决定是否返回，如下 import Auth from './components/Auth'// ...const RouteItem = (props) =&gt; &#123; const &#123; path, component: Component, redirect, key, exact &#125; = props; if (redirect) &#123; return &lt;Redirect from=&#123;path&#125; to=&#123;redirect&#125; key=&#123;key&#125; /&gt; &#125; return ( &lt;Route key=&#123;key&#125; exact=&#123;exact&#125; path=&#123;path&#125; render=&#123;componentProps =&gt; &#123; return ( // 对Component加以验证 &lt;Auth history=&#123;history&#125;&gt; &lt;Component &#123;...componentProps&#125; /&gt; &lt;/Auth&gt; ) &#125;&#125; /&gt; );&#125;;// ... Auth组件正是用来做权限控制的，在src/components下新建Auth文件夹，并在其中新建index.jsx，如下 function Auth(props) &#123; const &#123;children, history&#125; = props const login = sessionStorage.getItem(\"login\") // Edit页面不能直接访问 需要登录 if (children.type.WrappedComponent.name !== \"Edit\") &#123; return children &#125; else &#123; if (login) &#123; return children &#125; history.replace(\"/login\") return null &#125;&#125;export default Auth 验证的逻辑也是十分的简单，如果不是Edit组件，则可以访问直接返回，如果是，则进一步判断是否登录，如果登录，则可以访问，否则来到登录页面。 至此，整个项目的工作已经大致完成了，可能有的地方还需要美化，比如富文本编辑器的代码美化，或者将数据保存在后台服务器等等。这一路走来可能你会感到有点不轻松，那么恭喜你，你获得了进步，如果你十分的轻松，那么这个项目对你来说还是有点容易。不过不管怎么样，希望你能够完全靠自己做一遍，也许你跟着我一路走来十分的顺利，这是因为一些坑我给你跳过去了，说实话，在我第一次做时，遇到到许许多多的坑，有很多不明白的点，有的地方明明十分的简单，可是我能卡几个小时甚至一两天，虽然辛苦，但是收获十分的巨大。所以我希望你能够独立的完成，去遇到一些坑，然后去找解决办法，在这个过程你会收获巨大，索性你已经完成了这个项目，所以对于这个项目要做出什么样的效果以及功能已经有了把握，所以在做一遍会简单很多，总之，加油。 参考资料 npm是干什么的? 前端脚手架，听起来玄乎，实际呢? 虚拟DOM介绍 React.js 小书 React中的事件处理 深入理解React组件状态(State) 重新认识生命周期函数 React中类组件和函数式组件 Presentational and Container Components 使用Render Props吧 Hook BraftEditor","tags":[{"name":"React antd React-Hooks","slug":"React-antd-React-Hooks","permalink":"https://lastknightcoder.gitee.io/tags/React-antd-React-Hooks/"}]},{"title":"CSS3 新特性","date":"2019-12-24T16:00:00.000Z","path":"/CSS3/","text":"CSS3新特性样式背景background-origin我们知道盒子的大小有三部分组成：border, padding, content，当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的，它有三个可选值 border-box padding-box content-box 其中意思不必解释就可以明白。如果不进行设置的话，默认是padding-box，即以padding的左上角为原点。 background-clip该属性是用来设置背景(背景图片、背景颜色)延伸的范围，有4个值可选 border-box：背景延伸至边框外沿(但是在边框下层) padding-box：背景延伸至内边距(padding)外沿,不会绘制到边框处 content-box：背景被裁剪至内容区(content box)外沿 text：背景被裁剪成文字的前景色 具体可以参考网站background-clip，这里演示一下上面的效果 background-sizebackground-size用以设置背景图片大小。单张图片的背景大小可以使用以下三种方法中的一种来规定： 使用关键词 contain 使用关键词 cover 设定宽度和高度值 设定指定的宽度和高度值想必不用多加介绍。contain和cover会等比例的缩放图片，以使得图片能够最大的被完整包含或者最小的覆盖背景区。 如果背景区(由background-origin决定)的宽高比和图片的宽高比是一样的，那么cover和contain的结果是一样的，会完全的覆盖背景区并完整的显示。 边框边框圆角使用border-radius可以设置边框为圆角的，border-radius的值就是圆角边框的半径。 width: 100px;height: 100px;margin: 0 auto;border-radius: 20px;background-color: pink; 与padding一样，取不同个数的值，代表设置不同地方的圆角半径，如 取值个数 设置 1个，如border-radius: 20px 设置四个角的圆角半径都为20px 2个，如border-radius: 10px 20px 设置左上角和右下角这条对角线为10px,另一条对角线为20px 3个，如border-radius: 10px 20px 30px 设置左上角为10px,右上角和左下角这条对角线为20px,右下角为30px 4个，如border-radius: 5px 10px 15px 20px 从左上角开始设置，按顺时针来，即左上角为5px,右上角为10px, … 由第一张图，我们发现半径也分为水平半径和垂直半径，这两个也可以分别设置，用/分开当做两组，第一个用来设置水平半径，第二个设置垂直半径，如 width: 100px;height: 120px;margin: 0 auto;border-radius: 50px / 60px; background-color: pink; 我们设置四个角的水平半径为50px,四个角的水平半径为60px,得到效果如下 如果不分开设置，则默认水平半径和垂直半径是相同的。 如果想要更加详细的了解，这里推荐一篇阮一峰的网络日志CSS3圆角边框。 边框图片找到一篇写的很好的博文border-image的正确用法，所以这里就不自己写了。 阴影盒子阴影为了知道什么是盒子阴影，观看如下效果 这里选取了小米的做法，由于设置阴影的颜色比较淡，所以可能比较难看出来。 用以设置盒子阴影的属性是box-shadow,它的值比较多，需要设置的值如下， 水平阴影 垂直阴影 模糊距离(虚实) 阴影尺寸(影子大小) 阴影颜色 内/外阴影(这个我也不懂，不做介绍) 其中水平阴影h-shadow和垂直阴影v-shadow是必须设置的。 为了观看设置这些值的效果，我们首先创建一个盒子 width: 200px;height: 200px;border: 1px solid #CCC;margin: 100px auto; 为盒子添加阴影 box-shadow: 1px 1px 1px 1px red; 水平阴影大小的影响(正值，阴影向右移动，负值，阴影向左移动) 垂直阴影大小的影响(正值，阴影向下移动，负值，阴影向上移动) 模糊距离大小的影响 阴影尺寸大小的影响 文本阴影使用text-shadow来设置文本阴影。使用与box-shadow差不多，具体可以参照text-shadow。 CSS3选择器CSS3新增了许多的选择器，为我们选择元素提供了更加灵活的选择。 属性选择器 [attr]：选择包含attr属性的标签 [attr=value]：选择attr属性值为value的标签 [attr^=value]：选择attr属性值以value开头的标签 [attr*=value]：选择attr属性值包含value的标签 [attr$=value]：选择attr属性值以value的标签 如 div[class] &#123; /* 会选择包含class属性的div标签 */&#125;div[class=\"active\"] &#123; /* 会选择class属性值为active的div标签 */&#125;div[class^=\"header\"] &#123; /* 会选择class属性以header开头的div标签 */&#125;... ... 结构伪类选择器 E:first-child E:last-child E:nth-child(n) E:nth-last-child(n) E:first-of-type E:last-of-type E:nth-of-type(n) E:nth-last-of-type(n) 上面的选择器是比较常见的结构伪类选择器，下面具体讲解其表达的意思。 E:first-child指的是，选择E，这个E满足的条件是：它是其父元素第一个子元素。听起来有点绕，来看一个例子 &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; span:first-child &#123; /* 它会选择span，条件是这个span必须是它父元素的第一个子元素 */&#125; 由于第一个div里面的span是其父元素(第一个div)的第一个子元素，所以第一个div里面的span会被选中。而第二个div里面的span不是其父元素(第二个div)的第一个子元素，所以这个span不会被选中。 E:last-child的与E:first-child相似，不过第一个改为最后一个。 E:nth-child(n)指的是选择E，E需要满足条件，是其父元素的第n个元素(n是从1开始的)，E:first-child就相当于是E:nth-child(1)。E:nth-child(n)中这个”n”除了可以是具体的数字以外，还可以是odd和even，表示选择所有的E，这些E是其父元素的第奇数或第偶数个。除此之外”n”还可以是表达式，如2n+1, 3n(n从1开始)。 而E:nth-last-child(n)则是倒着数的，用法同E:nth-child(n)相似，这里不多介绍。 E:first-of-type与E:first-child不同，其意思是选择器父元素下的第一个E元素。还是以上面两个div为例 &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; span:first-of-type &#123; /* 选择span父元素下的第一个span元素 */&#125; 这个时候两个span都可以被选择到，first-of-type相当于只是将E的父元素所包含的E全部抽离出来，然后进行选择。现在我们将div包含的span全部抽离出来，相当于 &lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 然后选择第一个span，所以这两个span都可以被选择到。其余的first-last-type, nth-of-type(n), nth-last-of-type同上面介绍的last-child, …相似，其不同之处在fitst-child与first-of-type处已详细阐述。 CSS3颜色渐变颜色渐变是指在两个颜色之间平稳的过渡。以往我们如果希望有颜色渐变的效果，会在绘图工具(如PS)设计出希望的效果，然后作为图片来实现这种效果。现在通过浏览器可以渲染而成，这样可以减少下载的时间和带宽的使用，以及在放大时看起来效果更好，因为这是浏览器自动生成的。 线性渐变线性渐变指的是颜色在一条线上平稳的变化，为了实现线性渐变，我们要规定线的方向，起点颜色和终止颜色。它的语法为 background-image: linear-gradient(direction, color-stop1, color-stop2, ...); 如 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box &#123; width:100%; height:100px; background-image: linear-gradient(to right, red, green); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果为 其中 linear-gradient(to right, red, green); 其中第一个参数to right是用来设置方向的，设置方向的值有 to right：从左往右 to left：从右往左 to top：从下往上 to bottom：从上往下，默认值 to right bottom：从左上角往右下角 … … 除了可以设置这些值之外，还可以设置角度，如 linear-gradient(0deg, red, green); 其中角度所代表的的方向如下所示 即0deg代表的方向是从下往上。 除此之外，除了设置起点颜色和终点颜色之外，还可以在之间设置多个颜色节点，如下面设置了一个彩虹渐变色 background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); 除此之外，还可以在颜色后面加上数值或者百分比，如 background-image: linear-gradient(to right, red, blue 10%, violet); blue 10%表示blue颜色节点在该线性方向10%的位置，所以从0%-10%是红色到蓝色的渐变，10%-100%是蓝色到紫色的渐变。 接下来介绍渐变的最后一个特性：渐变重复。看下面一个例子 /* 设置为23%而没有设置为能被100%整除的数 就是想看一下这种情况是怎么处理的 */repeating-linear-gradient(to right, red,yellow 23%); 上面的意思是从0%-23%实现红色到黄色的渐变，然后重复直至100%。 径向渐变径向渐变是指以某点为圆心，向外进行颜色渐变。所以为了实现径向渐变，我们要规定圆心的位置和起点颜色和终点颜色。径向渐变的语法为 background-image: radial-gradient(shape size at position, start-color, ..., last-color); 其中shape为渐变的形状，有两种取值 circle(圆形) ellipse(椭圆, 默认值) size是指100%所代表的的长度，有四种取值 closest-side(离最近的边的距离) farthest-side(离最远的边的距离) cloest-corner(离最近的角的距离) farthest-corber(离最远的角的距离，默认值) position是指圆心的位置，默认为center，即中心位置，也可以通过at 100px 100px形式进行设置，左上角的坐标的为(0px, 0px)。 .box &#123; width:400px; height:200px; /* 设置size大小为离最近的边的距离 */ background-image: repeating-radial-gradient(circle closest-side at 200px 100px, red, red 10%,green 12.5%, green 25%)&#125; 可见离最近的边有4个完整的重复。 /* 设置size大小为离最远的边的距离 */background-image: repeating-radial-gradient(circle farthest-side at 200px 100px, red, red 10%,green 12.5%, green 25%) 可见离最远的边有4个完整的重复。 /*为了使最远的角和最近的角的距离不同 position不能设置在中心 *//* 设置size大小为离最近的角的距离 */background-image: repeating-radial-gradient(circle closest-corner at 100px 100px, red, red 10%,green 12.5%, green 25%) 可见离最近的角有4个完整的重复。 /* 设置size大小为离最远的角的距离 */background-image: repeating-radial-gradient(circle farthest-corner at 100px 100px, red, red 10%,green 12.5%, green 25%) 可见离最远的角有4个完整的重复。 CSS3 2D变换CSS3 2D变换包括对元素进行移动、缩放、转动、拉长或拉伸。 translate()：对元素进行进行移动 translate(100px)：对元素向x正方向移动100px(负值向负方向移动) translate(100px, 100px)：对元素向x, y正方向方向移动100px scale()：对元素进行缩放 scale(n)：对元素进行缩放，传入的参数大于1，进行放大，小于1，进行缩小 scale(x, y)：第一个参数对宽度进行缩放，第二个值对高度进行缩放 rotate()：围绕中心旋转，正值顺时针，负值逆时针 transform-origin：可以改变旋转的中心，如 /* 围绕左上角进行旋转 */transform-origin: left top; /* 围绕中心旋转 为默认值 */transform-origin: 50% 50%; skew()：对元素进行倾斜 skew(angle)：向x轴负方向倾斜angle(负值沿正方向) skew(anglex, angley)：第一个参数对x方向，第二个参数对y方向 除了可以使用上述属性进行设置，还可以使用translateX(), translateY()等进行设置。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; &#125; /* 为每个div设置颜色 */ .box1 &#123; background-color: red; &#125; .box2 &#123; background-color: aqua; &#125; .box3 &#123; background-color: chocolate; &#125; .box4 &#123; background-color: darkcyan; &#125; /* 为每个盒子设置不同的2D变换效果 */ .box1:hover &#123; transform: translateX(100px); &#125; .box2:hover &#123; transform: scale(0.5); &#125; .box3:hover &#123; transform: rotate(-30deg); &#125; .box4:hover &#123; transform: skew(30deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt; &lt;div class=\"box4\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS3 3D3D变换的操作同2D相同，只是多了一个对Z轴的操作，如translateZ()，而rotate也分为rotateX(), rotateY(), rotateZ()，分别表示绕着X轴，Y轴，Z轴旋转。2D变换的rotate()其实就相当于rotateZ()。 CSS3动画transition首先我们来看一个例子 .box &#123; height: 100px; width: 100px; background-color: black;&#125;.box:hover &#123; transform: translateX(600px);&#125; 当我们把鼠标放在盒子上时，盒子向右移动了600px，但是这个过程是在瞬间完成的，十分的突兀，我们希望是缓慢由一个转态转变到另一个状态的，这种效果又叫做过渡，这时就需要用到transition属性了。 为某个元素添加过渡效果，必须规定两项内容： transition-property：指定要添加效果的CSS属性 例如上面就要为transform添加过渡效果，所以就可以写为 /* 值可以为all 表示为所有的属性添加过渡效果 默认值为all*/transition-property: transform; transition-duration：添加过渡的总时间 /* 默认值为0s */transition-duration: 1s; /* 单位可以为s */transition-duration: 100ms; /* 单位也可以为ms */ 除了上面必须设置的两个属性，还可以设置下面的属性 transition-timing-function：时间函数，设置过渡的变化速度 ease：开始和结束慢，中间快，默认值。 linear：匀速。 ease-in：开始慢。 ease-out：结束慢。 ease-in-out：和ease类似，但比ease幅度大。 除了可以设置以上关键字，还可以设置steps()函数，语法如下： steps(&lt;integer&gt;[,start | end]?) 第一个参数传入一个整数值，steps步进函数将过渡时间划分成大小相等的时间时隔来运行，这个整数值就是分成的份数。第二个值是可选的，默认值为end。如果是start，则不保留开始值，如果是end，则保留开始值。 这里给出一个利用steps()函数做动画效果的例子。 transition-delay：延时时间，默认值为0s animation与transition一样，animation也有很多的属性 animation-name：动画名称 animation-duration：动画持续时间 animation-timing-function：动画时间函数 animation-delay：动画延迟时间 animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环 animation-direction：动画执行方向 animation-paly-state：动画播放状态 animation-fill-mode：动画填充模式 过渡是指在两个状态之间，而动画则是指在多个状态之间变化，这些状态我们称之为关键帧，因此动画又称之为关键帧动画。使用动画首先要创建关键帧，然后使用animation-name去调用该动画，如 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; background-color: aqua; &#125; .box:hover &#123; animation-name: move; animation-duration: 1s; &#125; /* 创建一个关键帧动画 动画名为move */ /* 调用时使用animation-name: move调用 */ @keyframes move &#123; /* 第一个状态 0% 时的状态 可以使用from代替 */ /* 这里的百分比是指 总时间 * 百分比 得到的某个时刻的状态*/ 0% &#123; transform: translateX(0px); &#125; 50% &#123; transform: translateX(100px); &#125; /* 100% 可以使用 to 代替 */ 100% &#123; transform: translateY(100px); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们还可以设置动画的执行次数，修改上面的样式为 .box &#123; width: 100px; height: 100px; background-color: aqua; animation-name: move; animation-duration: 1s; /* 播放次数默认值为 1 */ animation-iteration-count: infinite;&#125; 我们发现动画执行完毕后，盒子突然就回到了原位置，这个过程有点突兀，我们希望这个过程也是慢慢过渡的，那么我们可以设置animation-direction，animation-direction有四种取值 normal：默认值，正常播放 reverse：反向播放 alternate：如果动画次数在两次或两次以上，那么第偶数次为反向播放，就可以达到回到原位置时也有过渡的效果。若动画只播放一次，则和正向播放一样。 alternate-reverse：若动画只播放一次，则和反向播放一样。若播放两次以上，偶数次效果为正向播放 .box:hover &#123; animation-name: move; animation-duration: 1s; animation-iteration-count: 2; animation-direction: alternate;&#125; animation-play-state用来设置动画的播放状态，有两种取值 running：默认值，动画运行 paused：动画暂停 将样式修改为 .box &#123; width: 100px; height: 100px; background-color: aqua; animation-name: move; animation-duration: 1s; animation-iteration-count: infinite; animation-direction: alternate;&#125; .box:hover &#123; /* 当鼠标放上去时 动画暂停 */ animation-play-state: paused;&#125; animation-fill-mode用来定义动画开始帧之前和结束帧之后的动作，有以下四种取值 none：默认值。动画结束后，元素移动到初始状态(不一定0%的状态，是元素自身的属性值) forwards：元素停在动画结束时的位置(不一定是100%的位置，有可能反向运动) backwards：在animation-delay的时间内，元素立刻移动到动画开始时(不一定是0%，有可能反向运动)的位置。若元素无animation-delay时，与none的效果相同 both：同时具有forwards和backwards 修改样式如下 .box &#123; width: 100px; height: 100px; background-color: aqua;&#125; .box:hover &#123; animation-name: move; animation-duration: 1s; /* 动画结束后，停留在动画结束的位置 */ animation-fill-mode: forwards;&#125; CSS3 flex布局当一个父元素被设置为display:flex时，它就是弹性布局，子元素的float、clear和vertical-align属性将失效。此时我们把父元素称之为container(容器)，把子元素称之为item(项目)。当父元素被设置为弹性布局后，对子元素有什么影响? 先来感受一下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .container &#123; display: flex; width: 500px; height: 400px; background-color: crimson; &#125; .item &#123; width: 100px; height: 100px; background-color: aqua; position: relative; &#125; /* 这个是为了演示方便 样式不重要 不必细看 */ .item div&#123; width: 50%; height: 50%; position: absolute; /* 下面三行语句是为了设置居中对齐 */ top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: brown; /* 圆角边框 */ border-radius: 50%; /* 下面两行设置文字居中对齐 */ text-align: center; line-height: 50px; /* 设置字体样式 */ font-size: 30px; font-weight: 700; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;3&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当父元素设置为flex布局后，其子元素item会在父元素container的主轴上排列。 这里又牵涉到新的概念，主轴(main axis)，flex容器的主轴默认为X轴，即从左向右，既然有主轴，那么就会有侧轴(cross axis)，默认的侧轴为Y轴，即从上往下。 container上的属性直观的感受了一下flex的效果，现在我们来看看flex要设置哪些属性，首先设置在container的flex属性有 flex-direction flex-wrap flex-flow justify-content align-items align-content 下面来一一介绍。 flex-direction是用来设置主轴的，它有以下四个值可选 row：默认值，主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 现在我们分别修改container里面的样式 flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; 为了演示flex-wrap，我们添加9个item(此时flex-direction为默认值row，除非特别声明，否则我们在演示其一个flex属性时，会将其他flex属性设置为默认值) &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;3&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;4&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;5&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;6&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;7&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;8&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;9&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 效果为 我们发现9个item排成了一排，没有换行。为了使得item能够换行，我们需要设置flex-wrap，它有三个值可选 nowrap：默认值，不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-wrap: wrap; flex-wrap: wrap-reverse; flex-flow是flex-direction和flex-wrap两个属性的简写，默认值为row wrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content是用来设置item在container在主轴上的对齐方式的，具体对齐方式与轴的方向有关,下面假设主轴为从左到右(row)。有下面几种值可选 flex-start：左对齐 flex-end：右对齐 center：居中对齐 space-between：两端对齐，项目之间间隔相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 这里演示一下space-between和space-around justify-content: space-between; justify-content: space-around; align-items定义了在侧轴上的对齐方式(以从上往下的侧轴为例) first-start：往上对齐 first-end：往下对齐 center：居中对齐 baseline：item的第一行文字的基线对齐。 stretch：默认值，如果没有设置height或者height设置为auto，将占满整个容器的高度 这里演示一下stretch，不设置height .container &#123; display: flex; width: 500px; height: 400px; background-color: crimson; align-items: stretch;&#125;.item &#123; width: 100px; /* height: 100px; */ background-color: aqua; position: relative;&#125;.item div &#123; /* 修改line-height为200px使文字居中 */&#125; align-content，当我们设置flex-wrap为wrap或者wrap-reverse时，item会占据多行，这个属性是用来设置占据多行item在侧轴上的对齐方式，如果没有多行，这个属性无效。有下列值可选(以侧轴为从上往下为例) first-start：往上对齐 first-end：往下对齐 center：居中对齐 stretch：默认值，轴线占据整个侧轴 space-between：两端对齐，轴线之间平均分布 space-around item上的属性下面6个属性是设置在item上的 order flex-grow flex-shrink flex-basis flex self-align order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0，现在设置第2个item的order为1 .item:nth-child(2)&#123; order: 1;&#125; 如果存在剩余空间，那么flex-grow可以用来设置item占据剩余空间的份数(这会导致item增大)，默认值为0，意味着即使有剩余空间，也不增大，现在设置各自的flex-grow .item:first-child &#123; /* 第一个item占 1 / (1 + 2 + 1) = 1/4 的剩余间 */ flex-grow: 1;&#125;.item:nth-child(2) &#123; /* 第二个item占 2/4 的剩余空间*/ flex-grow: 2;&#125;.item:last-child &#123; /* 第三个item占 1/4 的剩余空间 */ flex-grow: 1;&#125; flex-shrink与flex-grow相反，当空间不足时，item缩小的以使得所有item被包含在container中。默认值是1，即每个item会等比例缩小 .item:first-child &#123; flex-shrink: 2;&#125;.item:nth-child(2) &#123; flex-shrink: 2;&#125;.item:last-child &#123; flex-shrink: 2;&#125; 可见第一个、第二个和最后一个缩小的更多。 flex-basis的含义是item在被放进container之前的大小。也就是item理想或假设的大小。默认值为auto，如果不设置这个值，并且主轴是row的话，那么flex-basis就是width的大小，如果主轴是column的话，那么flex-basis就是height的大小，如果width或height也没有设置的话，flex-basis是content的大小。item的宽度是最终的flex-basis，最佳的方法是只使用flex-basis而不是width或height属性。 但是flex-basis不能保证其大小! 一旦将items放入flex容器中，flex-basis的值就无法保证了。这是因为有flex-grow和flex-shrink，可能会被放大或者缩小item的大小。 除此之外，flex-basis还受到min-width, max-width, min-height, max-height的约束。具体见The Difference Between Width and Flex Basis这篇文章，有着十分详细的阐述，绝对让你物超所值。 slef-align属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .container &#123; ... ... align-items: center; flex-wrap: wrap;&#125;.item:first-child &#123; align-self: flex-start;&#125;","tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://lastknightcoder.gitee.io/tags/CSS3/"}]},{"title":"HTML5超详细了解","date":"2019-12-22T16:00:00.000Z","path":"/HTML5入门/","text":"HTML5属于上一代HTML的新迭代语言，设计HTML5最主要的目的是为了在移动设备上支持多媒体，例如：video标签和audio及canvas标记。 HTML5中语义化标签在HTML5中新增了很多的语义标签，如 header footer nav article aside section … … 比如以前我们使用以下方式来布局 &lt;div class=\"header\"&gt;&lt;/div&gt; 现在可以替换为 &lt;header&gt;&lt;/header&gt; HTML5可以让很多更语义化的结构化代码标签代替大量无意义的div标签 这种语义化的特性提升了网页的质量和语义 减少了以前用于CSS 调用的class和id属性 并且对搜索引擎的友好，新的结构标签带来的是网页布局的改变及提升对搜索引擎的友好。 但是现在碰到一个问题，由于这些具有语义的标签是HTML5新增的，这就意味着在IE8及以下版本的IE浏览器中不支持，如下面的样式在IE8中就不能够正常的显示 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; header &#123; background-color: red; height: 400px; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 解决办法： 在script中创建语义标签header，并且将header的display设置为block &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; header &#123; background-color: red; height: 400px; width: 100%; display: block; &#125; &lt;/style&gt; &lt;script&gt; document.createElement(\"header\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 使用1的方法，意味着对每个语义标签都要创建元素，这样未免比较麻烦，更好的办法是使用插件，引入html5shiv.js文件，该插件的实质还是创建了语义元素 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; header &#123; background-color: red; height: 400px; width: 100%; &#125; &lt;/style&gt; &lt;script src=\"html5shiv.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 上面的方法还有需要改进的地方，比如在谷歌浏览器中完全支持HTML5，这就意味着在渲染HTML网页时不需要下载html5shiv.js文件，但是上面的方法是在任何的浏览器中都会下载的，所以再次改进如下 &lt;!--[if lte IE 8]&gt; &lt;script src=\"html5shiv.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上面的代码只有IE浏览器才会识别，意思是如果IE浏览器的版本是IE8及以下的版本，才会下载这个js文件，在其他浏览器中会认为这时注释，自动忽略。 video和audio在浏览器中插入视频和音频文件，以往是使用flash来实现，但是在移动端使用flash就会比较慢，HTML5给了两个新的标签，用来插入视频和音频文件。二者的使用相似，现以video为例介绍该标签的属性 属性 作用 src 值为视频文件的路径 controls 显示控制台 autoplay 自动播放 loop 循环播放 … … … … 还有一些属性没有介绍，以上是较为常用的，剩余的请参考网站HTML5视频。这里给出一个实例 &lt;video src=\"resources/video.mp4\" controls autoplay loop&gt;&lt;/video&gt; 另一个需要注意的是，目前只支持三种格式的视频 Ogg MPEG 4(mp4) WebM 并且不同的浏览器支持的程度也不一样，具体的可以参考上面的链接。那么这个时候怎么办? 我们不能这么写 &lt;video src=\"test.mp4\"&gt;&lt;/video&gt;&lt;video src=\"test.ogg\"&gt;&lt;/video&gt;&lt;video src=\"test.WebM\"&gt;&lt;/video&gt; 虽然我们的本意是：如果支持.mp4，那么就使用.mp4，否则如果支持.ogg，则用.ogg，以此类推。但是上面的效果是出现3个video，而不是一个，这个时候的解决办法是使用source标签，如下 &lt;video&gt; &lt;source src=\"test.mp4\"&gt; &lt;source src=\"test.ogg\"&gt; &lt;source src=\"test.WebM\"&gt;&lt;/video&gt; 这个时候达到的效果就是我们想要的。 表单HTML5在表单这里也做了很多的改进，比如新增了一些属性以进行表单验证(以往这些工作我们都是使用JavaScript进行正则表达式的验证)，以及新的标签和方法。 智能表单控件 emial url number range color date month week time 首先用法如下 &lt;form action=\"test\" method=\"get\"&gt; email: &lt;input type=\"email\"&gt; &lt;br&gt; url: &lt;input type=\"url\"&gt; &lt;br&gt; number: &lt;input type=\"number\"&gt; &lt;br&gt; range: &lt;input type=\"range\"&gt; &lt;br&gt; color: &lt;input type=\"color\"&gt; &lt;br&gt; date: &lt;input type=\"date\"&gt; &lt;br&gt; week: &lt;input type=\"week\"&gt; &lt;br&gt; time: &lt;input type=\"time\"&gt; &lt;br&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; 当type设置为emial时，如果输入的不是电子邮箱，当点击提交按钮时，不能提交成功，并给出提示信息 当type设置为url时，如果输入的不是url地址，那么当点击提交按钮时，也不能提交成功，并给出提示信息 正确的url地址应该以http或者https开头，如http://www.baidu.com。 当type设置为number时，这时在控件里面只能输入数字，当你按其他键时没有反应，可以自行实验看看效果。 当type设置为color时，点击color后的颜色，会出现拾色器，可以选择颜色，如下 设置type设置为date, week, time时，显示的是各种格式的时间，这里不多加解释想必可以明白。 表单属性form表单的属性 autocomplete 直译过来就是自动完成，当我们提交表单后，表单会记录我们提交的内容，当我们再次填写时，它会给出我们已经提交过的内容作为提示信息。有时这种情况下可能会造成信息的泄漏，不安全，我们可以将autocomplete设置为off，这时就不会出现上面的情况。默认情况下autocomplete为on &lt;form action=\"test\" method=\"get\" autocomplete=\"off\"&gt; ... ...&lt;/form&gt; novadilate 上面我们提到，当我们使用智能表单控件时，如果不能满足格式的要求，如email，则不能提交成功，当表单添加novadilate属性时，那么这时即使所填写的格式不满足要求，那么也可以提交成功。 &lt;form action=\"test\" method=\"get\" autocomplete=\"off\" novalidate&gt; ... ...&lt;/form&gt; input的属性 autofocus 自动获得焦点，我们先来看一个淘宝的案例 当我们进入淘宝，搜索框会自动的获得焦点，用户可以直接输入，不需要用鼠标先点击搜索框获得焦点才能输入。input添加autofocus的属性即可有这种效果。 form 先来看这么一个结构 &lt;form action=\"test\" method=\"get\"&gt; &lt;input type=\"text\" name=\"one\"&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;input type=\"text\" name=\"two\"&gt; 我们可以知道当提交form表单时，只会提交表单域里面的表单，表单域外的表单不会提交，所以当我们提交时，只会有one的数据才会提交 但是如果希望当提交时，two的数据也能进行提交(别奇怪，真的有这种需求)，这个时候就需要用到form属性了 &lt;form id=\"data\" action=\"test\" method=\"get\"&gt; &lt;input type=\"text\" name=\"one\"&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;input type=\"text\" name=\"two\" form=\"data\"&gt; form属性的值为form表单的id值。这时再次进行提交 这时two的数据也得到了提交。 list list属性要配合HTML5新添加的表单标签&lt;datalist&gt;使用，如下 &lt;input type=\"text\" list=\"list\"&gt;&lt;datalist id=\"list\"&gt; &lt;option value=\"One\"&gt;&lt;/option&gt; &lt;option value=\"Two\"&gt;&lt;/option&gt; &lt;option value=\"Three\"&gt;&lt;/option&gt;&lt;/datalist&gt; list属性的值为datalist标签的id值。当我们在text中输入时，会有datalist中option值的提示 multiple multiple可以实现多选的效果，比如选择多个文件，假设有下面的input标签 &lt;input type=\"file\"&gt; 这时只能选择一个文件，为了选择多个文件，我们为input标签添加multiple属性 &lt;input type=\"file\" multiple&gt; 这时就可以选择多个文件了。 placeholder 使用placeholder作为提示信息，假设有如下标签 &lt;input type=\"text\" placeholder=\"请输入信息\"&gt; 当我们输入文字时，提示信息会消失，当我们将文字消失时，文字又会出现。 required 当input使用该属性时，表示该input控件是必填项，否则无法提交，具体可以自己试验一下，这里就不演示了。 HTML5 API获取DOM元素假设有如下的html结构 &lt;ul&gt; &lt;li&gt; &lt;span&gt;span1&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;span&gt;span2&lt;/span&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 如果我们要改变span的样式(通过JS)，我们我们一般要为span标签添加id属性或者class属性，这样才能获取要对应的DOM元素，HTML5新增了两个方法 querySelector()：只能选择一个元素 querySelectorAll()：可以选择所有符合条件的元素 可以向其中传入选择器(任何CSS支持的选择器)，从而来选择DOM元素，如 //使用子代选择器选择span元素document.querySelector(\"li&gt;span\").style.color = \"red\"; 类名操作有时候我们需要为某个标签添加或者移除类样式，HTML5为我们提供了API接口 classList.add()：为DOM元素添加指定的类样式 classList.remove()：为DOM元素移除指定的类样式 classList.toggle()：切换，意思即如果DOM元素有这个类样式，则移除这个类样式，如果没有这个类样式，这添加这个类样式 classList.contains()：判断该DOM元素是否包含这个类样式，包含则返回true，否则返回false。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active &#123; width: 100%; height: 100px; background-color: darkred; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;button class=\"add\"&gt;添加类名&lt;/button&gt; &lt;button class=\"remove\"&gt;移除类名&lt;/button&gt; &lt;button class=\"toggle\"&gt;切换类名&lt;/button&gt; &lt;button class=\"contains\"&gt;是否包含类名&lt;/button&gt; &lt;script&gt; document.querySelector(\".add\").onclick = function () &#123; document.querySelector(\"div\").classList.add(\"active\"); &#125; document.querySelector(\".remove\").onclick = function () &#123; document.querySelector(\"div\").classList.remove(\"active\"); &#125; document.querySelector(\".toggle\").onclick = function () &#123; document.querySelector(\"div\").classList.toggle(\"active\"); &#125; document.querySelector(\".contains\").onclick = function () &#123; console.log(document.querySelector(\"div\").classList.contains(\"active\")); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义属性HTML5规定自定义属性需要以data-开头，如 &lt;div data-test=\"one\"&gt;&lt;/div&gt; 上面自定义了一个叫test的属性，我们可以通过DOM元素的dataset来访问或者修改自定义属性的值，有两种方式 dataset.属性名 dataset[“属性名”] &lt;div data-test=\"one\"&gt;&lt;/div&gt;&lt;script&gt; console.log(document.querySelector(\"div\").dataset.test); document.querySelector(\"div\").dataset[\"test\"] = \"two\";&lt;/script&gt; 如果属性名之间使用-之间连接，如下 &lt;div data-test-name=\"one\"&gt;&lt;/div&gt; 那么使用dataset访问或修改时要使用驼峰命名法获取，如下 console.log(document.querySelector(\"div\").dataset.testName);document.querySelector(\"div\").dataset[\"testName\"] = \"two\"; 文件读取FileReader是用来读取上传的文件的，它有3个读取的方法 readAsText()：读取文本文件，返回文本字符串(utf-8) readAsBinaryString()：读取任意文件，返回二进制文件 readAsDataURL()：读取任意文件，得到包含一个data:URL格式的字符串(base64编码)，以表示所读取文件的内容 上面三个方法读取的内容都会放在FileReader对象的result属性中。 现在演示一个案例，选择上传的图片，在上传之后希望有预览的效果 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\"&gt;&lt;br&gt; &lt;br&gt; &lt;img src=\"\" width=\"800\"&gt;&lt;/img&gt; &lt;script&gt; //获得input DOM元素 let input = document.querySelector(\"input\"); //获得img DOM元素 let image = document.querySelector(\"img\"); //当input发生改变时即有文件上传时触发该事件 input.onchange = function () &#123; //获得上传的文件对象 let file = input.files[0]; //获得FileReader对象 let reader = new FileReader(); //使用FileReader读取该图片，得到一个base64格式的编码 reader.readAsDataURL(file); //reader读取完毕后触发该事件 reader.onload = function() &#123; //将读取到的base64编码格式的URL赋值给img标签的src属性 image.src = reader.result; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，我们用到了FileReader对象的onload事件，这里列出FileReader提供的事件 onabort：中断时触发 onerror：出错时触发 onload：文件读取成功完成时触发 onloadend：读取完成触发，无论成功或失败 onloadstart：读取开始时触发 onprogress：在读取过程中持续触发 获取网络状态HTML5提供了有关网络状态的API，使用window.navigator.onLine可以获取当前的网络状态，返回一个布尔值。除此之外，还提供了两个网络事件 ononline()：连上网络的时候触发 onoffline()：断开网络的时候触发 window.ononline = function () &#123; console.log(\"online\");&#125;window.onoffline = function () &#123; console.log(\"offline\");&#125; 本地存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案，使用sessionStorage和localStorage存储数据。 sessionStorage的大小大约为5M左右，它的生命周期为当前页面，即当关闭当前页面时，存储在本地的数据会被清除。并且不同页面之间的sessionStorage是独立的，不能互相访问。sessionStorage的方法有 setItem(key, value)：存储键值对 getItem(key)：根据key获取对应的value removeItem(key)：删除key所对应的键值对 clear()：清除sessionStorage本地缓存 localStorage的大小为20M左右，它的生命周期为当前浏览器。关闭浏览器不会清除数据，数据存储在硬盘上，只能手动清除。localStorage的方法同sessionStorage。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://lastknightcoder.gitee.io/tags/HTML5/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Maven安装及配置","date":"2019-11-12T16:00:00.000Z","path":"/Maven安装及配置/","text":"下载Maven 解压文件夹 将下载好的压缩包解压到一个不含中文路径的目录下，如我的解压路径为G:\\apache-maven-3.6.2，解压后的文件目录应如下所示 配置环境变量 新建环境变量MAVEN_HOME，内容为Maven的解压目录 编辑Path变量，内容如下 配置setting.xml 打开解压目录下的conf/setting.xml，设置本地仓库的路径 配置IDEA 打开IDEA并打开setting，搜索maven如下所示 新建Maven项目 标准的Maven目录结构应该是这样的 在添加依赖包的坐标后，记得进行Update","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://lastknightcoder.gitee.io/tags/Maven/"}]},{"title":"常见排序算法","date":"2019-10-01T16:00:00.000Z","path":"/排序算法/","text":"由于近期在学习排序算法，决定将自己的学习过程记录下来，一是为了自己能够方便的复习，另一个是将这个知识分享给大家。我将使用Java语言实现下列排序算法 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 准备工作为了对实现的算法进行测试，我们准备一个工具类Helper，里面包括我们由于测试算法正确与否的方法以及性能测试的代码，包括交换数组中的两个元素(这个操作在排序时经常用到，所以抽象出一个方法)，还有产生一个指定容量和范围的随机数组，还有判断数组是否有序的函数以及性能测试的函数 import java.util.Arrays;import java.util.Random;public class Helper &#123; //交换arr[i]和arr[j] public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //产生一个范围在rangeL-rangeR，容量为n的数组 public static int[] generateArray(int n, int rangeL, int rangeR) &#123; Random random = new Random(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = random.nextInt(rangeR - rangeL + 1) + rangeL; &#125; return arr; &#125; //判断数组是否有序(从小到大) public static boolean isSorted(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; return false; &#125; &#125; return true; &#125; //测试排序需要的时间 需要传入一个函数接口Sort public static double testTime(int[] arr, Sort sort) &#123; long startTime = System.nanoTime(); sort.sort(arr); long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; &#125;&#125; 其中testTime需要传入一个函数式接口Sort，该接口定义如下 public interface Sort &#123; public void sort(int[] arr);&#125; 我们在调用该方法时，只要将我们的排序算法的方法引用传入即可。 选择排序为了描述的精确性，我们把数组分为两部分，一部分是已经排好序的区域，一部分是未排序的区域 选择排序的策略就是在未排序的区域找出最小元素的位置，然后将它交换到未排序区域的最前方，然后已排序区域向前扩大一位，然后接着上面策略，直至未排序的区域为空，排序结束。下面以一个例子进行说明，我们默认蓝色区域代表已排序区域，白色区域代表未排序区域 代码如下 public class SelectionSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; Helper.swap(arr,minIndex,i); minIndex = i + 1; &#125; &#125; public static void main(String[] args) &#123; //对100000个数进行排序 int n = 100000; //产生随机数组 int[] arr = Helper.generateArray(n, 0, n); //传入排序算法的引用，得到排序所需时间 double time = Helper.testTime(arr,SelectionSort::sort); //确定算法是否排好序 System.out.println(\"isSorted: \" + Helper.isSorted(arr)); //打印排序所需时间 System.out.println(time + \"s\"); &#125;&#125; 输出为 isSorted: true7.319637673s 可见算法已经排好序，并且选择排序对100000个数据排序所需的时间为7.32s左右。 插入排序插入排序就像是你在打斗地主，当你摸牌时你对牌的排序。向上面一样，我们将数组分为已排序的部分和未排序的部分，以排序的部分就是你已经排好序的牌，现在你又摸到了一张牌，那么你是不是会将这张牌与排好序的牌进行比较，插入到合适的位置，然后继续摸下一张牌，然后又进行插入排序，直到牌已经摸完了(未排序的部分为空)，那么你就已经拍好序了，下面看一个例子 代码为 public class InsertSort &#123; public static void sort(int[] arr) &#123; //i = 1开始，因为默认第一张牌是排好序的 for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; //如果后面比前面小，进行交换 if (arr[j - 1] &gt; arr[j]) &#123; Helper.swap(arr,j - 1, j); &#125; else &#123; //如果后面比前面大，结束交换 break; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int n = 100000; int[] arr = Helper.generateArray(n, 0, n); double time = Helper.testTime(arr,InsertSort::sort); System.out.println(\"isSorted: \" + Helper.isSorted(arr)); System.out.println(time + \"s\"); &#125;&#125; 输出为 isSorted: true8.863959818s 这表明插入排序对100000个数据排序所需的时间为8.86s左右。它的速度比选择排序还要慢一些，这时因为插入排序中含有大量的交换操作，如果我们将上面的交换操作替换为赋值操作 public static void sort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int e = arr[i]; //保存要插入的元素 int j; //记录要插入的位置 for (j = i; j &gt; 0; j--) &#123; if (arr[j - 1] &gt; e) &#123; //向后移动 arr[j] = arr[j - 1]; &#125; else &#123; break; &#125; &#125; arr[j] = e; &#125;&#125; 这时需要的时间为 isSorted: true2.293106947s 并且对于近乎有序的数组，插入排序的速度非常的快，甚至比后面要介绍的O(NlogN)的速度还要快。 希尔排序希尔排序是对插入排序的改进。既然是改进，那么我们就要知道插入排序有什么问题：如果有一个很小的数在数组的后方，那么这个数就会进行很长时间的交换才能插入到合适的位置，这明显是一个比较慢的过程 而希尔排序将解决这一个问题，希尔排序首先将数组分组，比如 上面的示例中，我们从每隔3个一组到每隔2个一组最后每隔1个一组，我们把上面的”3,2,1”称之为增幅序列h，不同的递增序列对算法的性能也有影响，有很多的论文研究了不同的递增序列，但都无法证明某个递增序列是最好的，下面的程序考虑使用”1, 4, 13, …”这个递增序列(h = 1, h = 3 * h + 1)，代码如下 public class ShellSort &#123; public static void sort(int[] arr) &#123; int N = arr.length; int h = 1; while (h &lt; N / 3) &#123; h = 3*h + 1; // 1 4 13 40 121 ... &#125; // h = 1的时候就是对整个数组进行插入排序 while (h &gt;= 1) &#123; //每隔h个元素(将数组分成了h组)进行插入排序 for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j - h] &gt; arr[j]) &#123; Helper.swap(arr, j, j-h); &#125; else &#123; break; &#125; &#125; &#125; h = h/3; &#125; &#125; public static void main(String[] args) &#123; int n = 100000; int m = 10; double time = 0; for (int i = 0; i &lt; m; i++) &#123; int[] arr = Helper.generateArray(n, 0, n); time += Helper.testTime(arr, ShellSort::sort); System.out.println(\"isSorted: \" + Helper.isSorted(arr)); &#125; time = time / m; System.out.println(time + \"s\"); &#125;&#125; 输出为 isSorted: true0.0292856418s 希尔排序10次平均所需的时间只有0.03s，与选择排序和插入排序不是一个等级上的。 归并排序自顶向下的归并排序归并排序的思想是将数组一分为二，然后对左、右两边的数组进行排序，然后将左右两边的已经有序数组进行融合成一个有序的数组，而左右两边的排序问题也可以按照上面的思想进行，直到数组只剩下一个元素，我们认为已经是有序的了，然后向上进行融合 下面的代码简要的简述了上面的过程 import java.util.Arrays;public class MergeSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return ; &#125; mergeSort(arr,0, arr.length-1); &#125; private static void mergeSort(int[] arr, int left, int right) &#123; //如果只有一个元素，可认为是有序的了 if (left == right) &#123; return ; &#125; int mid = left + (right - left) / 2; //对左右两边进行排序 mergeSort(arr,left,mid); mergeSort(arr,mid + 1, right); //融合左右两边的数组 merge(arr,left,right); &#125;&#125; 现在的关键是如何融合左右两个有序的数组为一个有序的数组，来看下面这个例子 private static void merge(int[] arr, int left, int right) &#123; //要融合的数组 int[] help = new int[right - left + 1]; int mid = left + (right - left) / 2; //左右数组的首部 int p1 = left; int p2 = mid + 1; //要融合数组的首部 int i = 0; //如果两个数组都没有遍历完毕 while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; if (arr[p1] &lt;= arr[p2]) &#123; help[i++] = arr[p1++]; &#125; else &#123; help[i++] = arr[p2++]; &#125; &#125; //如果p2遍历完毕了，将p1中剩下的元素复制到融合的数组中 while (p1 &lt;= mid) &#123; help[i++] = arr[p1++]; &#125; //同上 while (p2 &lt;= right) &#123; help[i++] = arr[p2++]; &#125; //将融合的数组按序赋值给我们要排序的数组 for (int j = left; j &lt;= right; j++) &#123; arr[j] = help[j - left]; &#125;&#125; 我们来测试一下10次平均所需时间为 isSorted: true0.0334043239s 归并排序是O(NlogN)级别的算法，比选择排序和插入排序要快很多。 优化上面我们在对左右两个数组排好序之后，直接进行了merge操作 mergeSort(arr,left,mid);mergeSort(arr,mid + 1, right);merge(arr,left,right); 但是如果考虑到如下情况 mergeSort(arr,left,mid);mergeSort(arr,mid + 1, right);if (arr[mid] &gt; arr[mid + 1]) merge(arr,left,right); 我们还可以进行优化，在上面我们提到，插入排序在数组近乎有序的情况下排序的速度非常的快，所以我们可以考虑当数组被划分到小于一定的规模(当数组小于一定规模时，近乎有序的概率很大)时我们不在向下划分，而是转而用插入排序，所以我们在Helper中添加一个方法 public static void insertSort(int[] arr, int l, int r) &#123; for (int i = l + 1; i &lt;= r; i++) &#123; int e = arr[i]; //保存要插入的元素 int j; //记录要插入的位置 for (j = i; j &gt; l; j--) &#123; if (arr[j - 1] &gt; e) &#123; arr[j] = arr[j - 1]; &#125; else &#123; break; &#125; &#125; arr[j] = e; &#125;&#125; 这个方法与插入排序的算法很相似，不过规定了对什么范围的数组进行排序，所以归并排序的算法可以修改如下 private static void mergeSort(int[] arr, int left, int right) &#123; //当数组小于15时，使用插入排序 if (right - left &lt; 15) &#123; Helper.insertSort(arr, left, right); return; &#125; int mid = left + (right - left) / 2; mergeSort(arr,left,mid); mergeSort(arr,mid + 1, right); if (arr[mid] &gt; arr[mid + 1]) merge(arr,left,right);&#125; 再次测试10次平均所需时间 isSorted: true0.028484280499999997s 自底向上的归并排序我们在上面使用的归并排序是自顶向下使用递归来完成的，但是我们不一定要自顶向下的完成这个排序过程，而是可以自底向上进行排序，首先将底层的序拍好，然后进行merge一路向上完成排序 public static void sortBU(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return ; &#125; //每轮2*sz个元素，为什么不直接sz = 2, 因为我们后面传入mid是要/2，所以这里的粒度就为sz for (int sz = 1; sz &lt;= arr.length; sz += sz) &#123; //mid &lt;= arr.length - 1 for (int i = 0; i + sz &lt; arr.length; i += (sz + sz)) &#123; //小数组使用插入排序 if (2 * sz &lt; 15) &#123; Helper.insertSort(arr,i, i + sz + sz - 1); continue; &#125; //只有当右边最小比左边最大还大时才需要merge if (arr[i + sz -1] &gt; arr[Math.min(i + sz, arr.length - 1)]) //防止越界 merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, arr.length - 1)); //防止越界 &#125; &#125;&#125;private static void merge(int[] arr, int left, int mid, int right) &#123; int[] help = new int[right - left + 1]; int p1 = left; int p2 = mid + 1; int i = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; if (arr[p1] &lt;= arr[p2]) &#123; help[i++] = arr[p1++]; &#125; else &#123; help[i++] = arr[p2++]; &#125; &#125; while (p1 &lt;= mid) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= right) &#123; help[i++] = arr[p2++]; &#125; for (int j = left; j &lt;= right; j++) &#123; arr[j] = help[j - left]; &#125;&#125; 你可能发现这次的merge需要自己传入mid值，而不是自己计算。可以思考一下为什么? 现在我们测试一下自底向上排序所需要的时间 isSorted: true0.031012182500000006s 自底向上的排序会比自顶向下的排序慢，但是自底向上的排序有一个非常重要的特点，它没有利用数组随机访问的特点，即数组通过下标对元素访问(插入排序中有，但是你可以不优化这里)，这意味着我们可以对链表使用自底向上的排序。 快速排序基本算法在看快速排序算法前我们先来看一个问题，给定一个数，要求数组左边的数都小于等于这个数，数组右边的数都大于这个数，请问这个算法怎么写。首先我们将数组标记为小于等于区和大于区，并用less和more标记区域的范围，所有index &lt;= less的元素都小于指定数，所有index &gt;= more的都大于指定数，下图将讲解具体的算法 上面的过程我们称为partition，对应的代码如下 int e = 6;public static int partition(int[] arr, int L, int R) &#123; int less = L - 1; int more = R + 1; int cur = L; while (cur &lt; more) &#123; if (arr[cur] &lt;= e) &#123; //如果当前元素小于指定元素 less和cur向前移动 less++; cur++; &#125; else if (arr[cur] &gt; e) &#123; Helper.swap(arr,--more,cur); &#125; else &#123; cur++; &#125; &#125; //返回两个数组的分界处 return less;&#125; 那么快速排序的思想就是选定一个数(一般我们选择要排序范围内的最后一个数arr[R])，要求左边的数比这个数小(或等于)，右边的数比这个数大。然后又接着对左右两边的数进行上述的分割(partition)，直至分割后的数组只剩下一个元素，可认为是有序的，这时数组就是有序的了 public class QuickSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr,0,arr.length-1); &#125; public static void quickSort(int[] arr, int l, int r) &#123; //当数组较小时，使用插入排序 if (r - l &lt; 15) &#123; Helper.insertSort(arr, l, r); return; &#125; if (l &lt; r) &#123; int p = partition(arr, l, r); quickSort(arr, l, p); quickSort(arr, p + 1, r); &#125; &#125; public static int partition(int[] arr, int L, int R) &#123; int less = L - 1; int more = R + 1; int cur = L; while (cur &lt; more) &#123; if (arr[cur] &lt;= arr[R]) &#123; less++; cur++; &#125; else if (arr[cur] &gt; arr[R]) &#123; Helper.swap(arr,--more,cur); &#125; &#125; return less; &#125;&#125; 测试此时10次平均所需的时间 isSorted: true0.023240137399999996s 随机快排但是此时有一个问题，如果此时数组是近乎有序的，那么我们根据最后一个元素划分元素会划分出左右两边的数组失衡 所以我们不能选择最后一个元素，而是选择一个随机的元素，我们只要在上面的程序中加入下面的一行代码即可 if (l &lt; r) &#123; //随机一个下标和最后一个元素交换 Helper.swap(arr, (int)Math.random() * (r - l + 1) + l, r); // 随机快排 int p = partition(arr, l, r); quickSort(arr, l, p); quickSort(arr, p + 1, r);&#125; 三路快排这时需要考虑这么一种情况，如果数组中有十分多的重复元素，那么就会有元素重复的子数组，这时应该就不应该排序了，但是我们的算法还是会把数组继续切分为更小的数组进行排序，这就有很大的改进潜力。所以我们考虑我们的partition算法不再划分为两部分，而是划分为三部分，小于，等于和大于三个区域 所以我们修改上面的排序算法如下 public static void quickSort(int[] arr, int l, int r) &#123; if (r - l &lt; 15) &#123; Helper.insertSort(arr, l, r); return; &#125; if (l &lt; r) &#123; Helper.swap(arr, (int)Math.random() * (r - l + 1) + l, r); // 随机快排 //p得到的是等于区的范围 int[] p = partition(arr,l,r); //对等于区不用排序 quickSort(arr,l,p[0] - 1); quickSort(arr,p[1] + 1, r); &#125;&#125;public static int[] partition(int[] arr, int L, int R) &#123; int less = L - 1; int more = R; int cur = L; while (cur &lt; more) &#123; if (arr[cur] &lt; arr[R]) &#123; //与less的前一个元素进行交换 并且less和cur向前移动 Helper.swap(arr,++less,cur++); &#125; else if (arr[cur] &gt; arr[R]) &#123; //与more的后一个元素进行交换 并且more向后移动，并且cur和less都不移动 Helper.swap(arr,--more,cur); &#125; else &#123; //如果等于，将cur向前移动即可 cur++; &#125; &#125; //最后将最后一个元素与more位置的元素进行交换 Helper.swap(arr,R,more); //返回等于区的左右下标 return new int[]&#123;less+1,more&#125;;&#125; 堆排序堆的有关知识可以参考数据结构–Java描述中优先队列与堆的内容，如果你已经仔细的阅读了话，相比你已经熟悉了堆的性质了，那么下面就直接上代码了 import java.util.Arrays;public class HeapSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; //将数组变成堆结构 for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr,i); &#125; int heapSize = arr.length; while (heapSize &gt; 0) &#123; Helper.swap(arr,0,--heapSize); heapify(arr,0,heapSize); &#125; &#125; public static void heapInsert(int[] arr, int index) &#123; while (arr[index] &gt; arr[(index-1)/2]) &#123; Helper.swap(arr,index,(index-1)/2); index = (index - 1)/2; &#125; &#125; public static void heapify(int[] arr, int index, int heapSize) &#123; int left = 2 * index + 1; while (left &lt; heapSize) &#123; int right = left + 1; //假设左更大 int larger = left; //如果右比左大 改变larger为右 if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[left]) &#123; larger = right; &#125; //如果父比左右子节点都大，说明还是堆，直接退出循环 if (arr[larger] &lt; arr[index]) &#123; break; &#125; //如果不是，那么就和比较大的交换交换 Helper.swap(arr,larger,index); index = larger; left = index * 2 + 1; &#125; &#125; public static void main(String[] args) &#123; int n = 100000; int m = 10; double time = 0; for (int i = 0; i &lt; m; i++) &#123; int[] arr = Helper.generateArray(n, 0, n); time += Helper.testTime(arr, HeapSort::sort); System.out.println(\"isSorted: \" + Helper.isSorted(arr)); &#125; time = time / m; System.out.println(time + \"s\"); &#125;&#125; 测试10次平均所需时间为 isSorted: true0.060118443099999995s","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"排序","slug":"排序","permalink":"https://lastknightcoder.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"数据结构--Java描述","date":"2019-09-23T16:00:00.000Z","path":"/数据结构--Java描述/","text":"本篇文章是为了记录自己在学习数据结构时的笔记，会对常见的数据结构做基本的介绍以及使用Java语言进行实现。包括 动态数组 栈 队列 链表 二分搜索树 优先队列和堆 线段树 Trie 并查集 AVL 树 红黑树 哈希表 动态数组API介绍数组是一种根据下标操作的数据结构，它的查询速度很快，但是它有缺点，那就是数组的容量一旦在创建时确定，就不能进行更改，所以为了克服这一缺点，我们实现一个自己的数组，并除此以外，还会实现一些方法，包括以下 add(int index, E e) 向指定 index 添加元素 e get(int index) 获得指定 index 的元素 remove(int index) 删除指定 index 的元素并返回该元素 set(int index, E e) 更改 index 处的元素为 e getSize() 返回数组中元素的个数 contains(E e) 查询数组是否包含元素 e isEmpty() 查看数组是否为空(是否有元素) find(E e) 返回数组中元素 e 第一次出现的 index，若没有元素 e，则返回 -1 新建一个 Array 类，它含有两个私有成员变量 E[] data 用以保存数据 int size 用以记录数组中元素的个数 除此以外还有两个构造方法 Array(int capacity) 设定数组的容量 Array() 容量默认为 10 public class Array&lt;E&gt; &#123; private E[] data; private int size; public Array(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; &#125; public Array() &#123; this(10); &#125;&#125; 现在我们来实现上面提到的方法。 方法实现首先来实现 getSize() 方法，这个是返回数组元素的个数的，我们直接返回 size 即可 public int getSize() &#123; return size;&#125; isEmpty() 是为了查看数组中是否还有元素，如果 size 为 0 的话说明数组为空，所以我们返回 size == 0 即可 public boolean isEmpty() &#123; return size == 0;&#125; 现在来实现 add(int index, E e) 方法，该方法的实现是将 index 后面的元素都向后移动一位，然后在 index 处插入元素 e public void add(int index, E e) &#123; //对inex进行验证 如果不符合规范则抛出异常 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //将元素向后移动 for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; //在index处插入元素e data[index] = e; //数组中元素个数+1 size++;&#125; 根据这个方法，我们可以很快的实现 addFirst(E e) 和 addLast(E e) 方法，这两个方法一个是在数组头添加元素，一个是在数组的末尾添加一个元素 public void addLast(E e) &#123; //在index = size处添加元素 即在数组末尾添加一个元素 add(size,e);&#125;public void addFirst(E e) &#123; //在index = 0处添加一个元素 即在数组头添加一个元素 add(0,e);&#125; 下面来实现 remove(int index) 方法，该方法是删除 index 处的元素，并将该元素返回，以添加的操作相反，删除是将后面的元素向前移动，覆盖掉 index 处的元素即可删除 public E remove(int index) &#123; //参数检查 if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //获得index处的元素用以返回 E e = data[index]; //将元素从后向前移一个 for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i+1]; &#125; //数组中元素个数-1 size --; //返回删除的元素 return e;&#125; 同理，根据这个方法我们可以快速的实现 removeLast() 和 removeFirst() 方法 public E removeLast() &#123; return remove(size -1);&#125;public E removeFirst() &#123; return remove(0);&#125; 我们可以添加一个删除指定元素的方法 removeElement(E e)，我们会遍历数组，如果发现有元素等于该元素，那么删除该元素并退出方法，所以这个方法只删除第一个元素 e，并不是数组所有的元素 e public void removeElement(E e) &#123; //遍历数组 for (int i = 0; i &lt; size; i++) &#123; //如果找到等于该元素的元素 if (e.equals(data[i])) &#123; //删除该元素 remove(i); //退出方法 return; &#125; &#125;&#125; 下面实现 contains(E e) 方法，这个方法的思路同删除指定元素相似，遍历数组，如果找到元素与指定元素相同，那么返回 true，如果遍历完数组还没有找到与之相等的元素，那么返回 false public boolean contains(E e) &#123; //遍历数组 for (int i = 0; i &lt; size; i++) &#123; //如果找到元素，那么返回true if (data[i].equals(e)) &#123; return true; &#125; &#125; //如果遍历完所有数组没有找到，那么返回false return false;&#125; find(E e) 方法的实现也是遍历数组，如果找到了元素，那么返回下标，如果遍历完数组都没有找到，那么返回 -1 public int find(E e) &#123; //遍历数组 for (int i = 0; i &lt; size; i++) &#123; //找到元素则返回下标 if (data[i].equals(e)) &#123; return i; &#125; &#125; //如果遍历完数组都没有找到，返回-1 return -1;&#125; 下面实现 get(int index) 和 set(int index, E e)，这两个方法的实现及其简单，直接上代码 public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index];&#125;public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; data[index] = e;&#125; 我们可以根据 get 方法实现 getLast()和 getFirst() 方法 public E getFirst() &#123; return get(0);&#125;public E getLast() &#123; return get(size - 1);&#125; 现在我们已经实现了 API 中提到的所有的方法，但是我们还是没有解决数组容量固定的问题，为了解决这个问题，我们需要实现一个 resize(int newCapacity)，它的作用是改变数组的容量大小，这样当数组的容量不足时，我们调用该方法就可以将数组进行扩容，或者当数组中有大量空间空闲时，我们可以缩小数组的容量，代码如下 private void resize(int newCapacity) &#123; //创建一个新容量的数组 E[] temp = (E[]) new Object[newCapacity]; //将数组中的数据全部放入新数组中 for (int i =0; i &lt; size; i++) &#123; temp[i] = data[i]; &#125; //改变数组指针指向 data = temp;&#125; 现在我们改变 add(int index, E e)和remove(int index) 方法，我们会在添加元素和删除元素时检查数组的容量，以便对数组进行扩容或者缩容 public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //如果数组容量满了 那么将数组的容量扩为原来的两倍 if (size == data.length) &#123; resize(data.length * 2); &#125; for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; data[index] = e; size++;&#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E e = data[index]; for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i+1]; &#125; size --; //如果数组中的元素个数为数组容量的1/4，那么容量变为原来的1/2 //思考一下为什么是1/4 提示：复杂度震荡 if (size == data.length/4) &#123; resize(data.length/2); &#125; return e;&#125; 为了方便的打印 Array 类，我们重写 toString() 方法如下 public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(\"size \" + size); str.append(\" capacity \" + data.length); str.append(\"\\n[\"); for (int i = 0; i &lt; size; i++) &#123; if (i == size - 1) &#123; str.append(data[i].toString()); &#125; else &#123; str.append(data[i].toString() + \", \"); &#125; &#125; str.append(\"]\"); return str.toString();&#125; 至此，我们已经完全实现了 Array，它的容量没有限制，并且提供了很多的方法供用户调用，我们将使用该类来实现其它的基本的数据结构。下面贴出完整的代码 public class Array&lt;E&gt; &#123; private E[] data; private int size; public Array(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; &#125; public Array() &#123; this(10); &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void addLast(E e) &#123; add(size,e); &#125; public void addFirst(E e) &#123; add(0,e); &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; if (size == data.length) &#123; resize(data.length * 2); &#125; for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; data[index] = e; size++; &#125; public E removeLast() &#123; return remove(size -1); &#125; public E removeFirst() &#123; return remove(0); &#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E e = data[index]; for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i+1]; &#125; size --; if (size == data.length/4) &#123; resize(data.length/2); &#125; return e; &#125; public void removeElement(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(data[i])) &#123; remove(i); return; &#125; &#125; &#125; public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; public int find(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; private void resize(int newCapacity) &#123; E[] temp = (E[]) new Object[newCapacity]; for (int i =0; i &lt; size; i++) &#123; temp[i] = data[i]; &#125; data = temp; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index]; &#125; public E getFirst() &#123; return get(0); &#125; public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; data[index] = e; &#125; public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(\"size \" + size); str.append(\" capacity \" + data.length); str.append(\"\\n[\"); for (int i = 0; i &lt; size; i++) &#123; if (i == size - 1) &#123; str.append(data[i].toString()); &#125; else &#123; str.append(data[i].toString() + \", \"); &#125; &#125; str.append(\"]\"); return str.toString(); &#125;&#125; 栈栈是一种先进后出的结构，比如你放书会把书放在最上面，最先放的书在最下面，而你拿书却是从最上面拿，最后放的最先拿到，栈正是怎么一种结构，我们规定最上面的位置叫做栈顶，我们向栈中添加元素是添加到栈顶，向栈中取出元素是从栈顶取出的，我们先来定义一个 Stack 接口，里面规定了一个栈包含的操作 public interface Stack&lt;E&gt; &#123; //向栈中压入一个元素 void push(E e); //将栈顶元素弹出 E pop(); //栈是否为空 boolean isEmpty(); //获得栈中元素的个数 int getSize(); //获得栈顶元素 E peek();&#125; 下面我们将使用上面实现的 Array 来实现一个 ArrayStack，我们把数组的最后位置定义为栈顶 public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private Array&lt;E&gt; data; public ArrayStack(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public ArrayStack() &#123; data = new Array&lt;&gt;(); &#125; @Override public void push(E e) &#123; data.addLast(e); &#125; @Override public E pop() &#123; return data.removeLast(); &#125; @Override public boolean isEmpty() &#123; return data.isEmpty(); &#125; @Override public int getSize() &#123; return data.getSize(); &#125; @Override public E peek() &#123; return data.getLast(); &#125; public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Stack: \"); res.append(\"[\"); for (int i = 0; i &lt; data.getSize(); i++) &#123; res.append(data.get(i)); if (i != data.getSize()-1) &#123; res.append(\", \"); &#125; &#125; res.append(\"] top\"); return res.toString(); &#125;&#125; 上面的代码极其的简单，只要仔细的阅读就可以完全的理解，这里不多做解释。 下面介绍一个有关于栈的题目，此题来自于LeetCode第20题 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 这道题的解题思路是，如果遇到左括号&#39;(&#39;, &#39;[&#39;, &#39;{&#39;，那么将左括号压入栈中，如果遇到右括号，那么将栈顶的左括号弹出，判断两个括号是否匹配，如果不匹配返回 fasle，如果匹配进行下一轮，最后如果字符串遍历完毕，如果栈为空说明匹配成功，如果栈不为空，所以左边的括号多匹配失败，代码如下 import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; //创建一个空栈 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //遍历字符串 for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); //如果是左括号，则压入栈中 if (c == '(' || c == '[' || c == '&#123;') &#123; stack.push(c); &#125; else &#123; //如果是右括号 先判断栈是否为空 if (stack.isEmpty()) &#123; return false; &#125; //获得栈顶的左括号 char charTop = stack.pop(); //下面三种皆为不匹配的情况 if (c == ')' &amp;&amp; charTop != '(') &#123; return false; &#125; if (c == ']' &amp;&amp; charTop != '[') &#123; return false; &#125; if (c == '&#125;' &amp;&amp; charTop != '&#123;') &#123; return false; &#125; &#125; &#125; //这里不能直接返回true 要根据栈是否为空决定返回值 return stack.isEmpty(); &#125;&#125; 队列队列是一种先进先出的结构，假设你在排队，那么最先排队的人最先得到服务。我们只能从队尾添加元素，从队首取出元素。老规矩，我们首先规定一下队列 Queue 的 API public interface Queue&lt;E&gt; &#123; //向队列中添加一个元素 void enqueue(E e); //从队列中取出一个元素 E dequeue(); //获得队首的元素 E getFront(); //获取队列中元素的个数 int getSize(); //判断队列是否为空 boolean isEmpty();&#125; 数组队列 现在我们将使用动态数组 Array 类来实现队列，实现的逻辑也十分的简单，如下 public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayQueue() &#123; array = new Array&lt;&gt;(); &#125; public ArrayQueue(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public E getFront() &#123; return array.getFirst(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Queue: \"); res.append(\"front [\"); for (int i = 0; i &lt; array.getSize(); i++) &#123; res.append(array.get(i)); if (i != array.getSize()-1) &#123; res.append(\", \"); &#125; &#125; res.append(\"] tail\"); return res.toString(); &#125;&#125; 注意上面我们的 dequeue 操作是调用了动态数组的 removeFirst 操作，这个操作需要遍历整个数组将元素向前移动，所以该操作是 O(n) 的。 循环队列上面队列的 dequeue 操作是 O(n) 级别的，这是因为上面会将数组整体向前移一位，但是如果我们不这么做，而是增加一个变量 front 来记录队首的位置，这样我们只要将 front 向前移一位即可，这样的操作就是 O(1) 级别的 这样做的同时，我们发现，如果当 tail 来到数组的末尾，按道理应该将数组进行扩容，但是 front 前面还有空间 这个时候我们应当将 tail 移动到数组头去 这时 tail 的计算公式不再是简单的 tail = tail + 1，而是 tail = (tail + 1) % data.length，如果不理解这个式子，就想象一下时钟，11 点向前一步就是 12 点，也可以称为是 0 点，这个时候时钟的计算公式为 (11 + 1) % 12。因为这种循环的特性，我们把这种实现方式称为循环队列。这次我们实现队列不在使用上面的动态数组，有了上面实现栈和队列的经验，想必可以容易理解下面的代码(在关键的步骤给予注释) public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private int front; private int tail; //队列中元素的个数 private int size; //底层实现的数组 private E[] data; //构造方法初始化 public LoopQueue(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; front = 0; tail = 0; &#125; //默认容量为10 public LoopQueue() &#123; this(10); &#125; @Override public void enqueue(E e) &#123; //首先判断数组是不是满了，如果是那么就进行扩容 if (size == data.length) &#123; resize(2 * data.length); &#125; //向队尾添加元素 data[tail] = e; //tail向后移动 不是简单的+1 上面已有解释 tail = (tail +1) % data.length; size++; &#125; //数组伸缩操作，已接触过 private void resize(int newCapacity) &#123; E[] temp = (E[]) new Object[newCapacity]; for (int i =0; i &lt; size; i++) &#123; //这里我们将队列的头对应到新数组的开头 temp[i] = data[(front + i)%data.length]; &#125; //重新记录front和tail的位置 front = 0; tail = size; data = temp; &#125; @Override public E dequeue() &#123; //如果队列为空，抛出异常 if (size == 0) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; //获得出队的元素 E e = data[front]; data[front] = null; //front向前移动(带循环) front = (front + 1) % data.length; size--; //缩容操作，不做解释 if (size == data.length / 4) &#123; resize(data.length / 2); &#125; return e; &#125; @Override public E getFront() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; return data[front]; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(\"Queue: size \" + size); str.append(\" capacity \" + data.length); str.append(\"\\nfront [\"); for (int i = 0; i &lt; size; i++) &#123; if (i == size - 1) &#123; str.append(data[(front + i) % data.length].toString()); &#125; else &#123; str.append(data[(front + i) % data.length].toString() + \", \"); &#125; &#125; str.append(\"] tail\"); return str.toString(); &#125;&#125; 这次我们得到的 dequeue 操作就是 O(1) 的了(严格的讲均摊复杂度为 O(1)，因为里面 resize() 复杂度是 O(n) 的)。 链表链表是一种非常重要的线性数据结构，我们在实现栈和队列时使用的是动态数组实现的，这个动态数组是针对用户而言是动态的，实际上底层是静态的，是通过 resize() 操作去解决容量问题的。而链表则是一种真正的动态数据结构，它是这么一种数据结构，我们把数据存储在一个节点(Node)中，一个节点一般包含两部分的内容，一个是存储的数据，一个是它要指向的下一个节点 class Node &#123; private E e; private Node next;&#125; 一个节点指向一个节点，所以最后看起来就像是一个链，我们把这种数据结构称为链表 最后一个节点的下一个节点为 NULL，表示后面没有节点了。它是一个真正的动态的数据结构，不需要处理容量的问题。但是它也有缺点，它没有数组那样快的查询能力，它要查询某个节点的数据，只能通过头结点一直寻找下来(后面我们将看到)，所以它的查询速度比数组慢。 链表实现现在我们将实现这么一个结构，首先设计好节点类 public class LinkedList&lt;E&gt; &#123; //我们将Node设置为LinkedList的私有内部类 private class Node&lt;E&gt; &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125;&#125; 我们要想向链表中添加(或其他操作)元素，不可避免的要遍历链表(因为链表不能通过索引访问，只能通过前面的节点找到后面的节点)，而要遍历链表，我们就要将链表的头存储起来，这样才能遍历链表，我们将链表的头称为 head 同时我们使用变量 size 来记录链表中元素的个数 public class LinkedList&lt;E&gt; &#123; //为了节省篇幅，Node类不再展示，下同 //头结点 private Node head; //链表中元素的个数 private int size; public LinkedList() &#123; head = null; size = 0; &#125;&#125; 现在我们实现两个简单的方法 getSize() 和 isEmpty() public int getSize() &#123; return size;&#125;public boolean isEmpty() &#123; return size == 0;&#125; 添加元素向链表头添加元素 首先将要插入的新节点指向 head，然后将 head 设置为新节点，实现如下 public void addFirst(E e) &#123; //体会一下这条语句的意思 head = new Node(e,head); size++;&#125; 在链表的中间添加一个元素 比如现在往节点 1 后面插入一个元素，首先将新节点指向节点 2，然后节点 1 指向新节点，实现如下 public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //如果是头结点需要单独处理 if (index == 0) &#123; addFirst(e); &#125; //prev代表要插入位置的前一个节点 Node prev = head; for (int i = 0; i &lt; index - 1; i++) &#123; prev = prev.next; &#125; prev.next = new Node(e, prev.next); size++;&#125; 向链表的尾部添加一个元素直接复用上面的代码 public void addLast(E e) &#123; add(size, e);&#125; 虚拟头结点我们在向链表中添加元素时，因为 head 前面没有节点，所以我们在添加元素时会对 head 进行单独的处理，为了不使 head 具有特殊性，我们在链表的最头部添加一个虚拟头结点，里面不存储元素，它的存在是为了使得操作链表方便 现在我们修改上面的 head 为 dummyHead public class LinkedList&lt;E&gt; &#123; //虚拟结点 private Node dummyHead; private int size; public LinkedList() &#123; //这里修改了 dummyHead = new Node(null, null); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; //直接调用add方法 public void addFirst(E e) &#123; add(0,e); &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //不需要对head进行单独的处理了 //index - 1修改为了index Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; prev.next = new Node(e, prev.next); size++; &#125; public void addLast(E e) &#123; add(size, e); &#125;&#125; 获得某个索引的值实现的思路同 add 很像，不过这里我们找的不是前一个节点，而是当前的节点 public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //cur代表当前节点 Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return (E) cur.e;&#125; 基于这个方法，我们可以很快的实现 getFirst() 和 getLast() public E getFirst() &#123; return get(0);&#125;public E getLast() &#123; return get(size - 1);&#125; 更新某个索引的值实现的思路完全是同 get() 方法，直接上代码 public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.e = e;&#125; 查找链表是否存在元素epublic boolean contains(E e) &#123; //从当前节点开始，一直遍历到最后一个节点 for (Node cur = dummyHead.next; cur != null; cur = cur.next) &#123; if (cur.e.equals(e)) &#123; return true; &#125; &#125; return false;&#125; 删除链表中的元素 上图已详细说明了操作的步骤，这里直接贴上代码实现 public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //获得要删除节点的前一个节点 Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; //图示的操作 Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size--; return (E) delNode.e;&#125; 根据上面的方法，可以很快的实现 removeFirst() 和 removeLast() 方法 public E removeFirst() &#123; return remove(0);&#125;public E removeLast() &#123; return remove(size - 1);&#125; toString()@Overridepublic String toString() &#123; StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; //你可以使用上面的for循环 while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"NULL\"); return res.toString();&#125; 全部代码public class LinkedList&lt;E&gt; &#123; private class Node&lt;E&gt; &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedList() &#123; dummyHead = new Node(null, null); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void addFirst(E e) &#123; add(0,e); &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; prev.next = new Node(e, prev.next); size++; &#125; public void addLast(E e) &#123; add(size, e); &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return (E) cur.e; &#125; public E getFirst() &#123; return get(0); &#125; public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.e = e; &#125; public boolean contains(E e) &#123; for (Node cur = dummyHead.next; cur != null; cur = cur.next) &#123; if (cur.e.equals(e)) &#123; return true; &#125; &#125; return false; &#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size--; return (E) delNode.e; &#125; public E removeFirst() &#123; return remove(0); &#125; public E removeLast() &#123; return remove(size - 1); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"NULL\"); return res.toString(); &#125;&#125; 使用链表实现栈由于链表的 addFirst() 和 removeFirst() 的操作都是 O(1)，所以我们使用链表头作为栈顶，具体的实现逻辑如下 public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListStack() &#123; linkedList = new LinkedList&lt;&gt;(); &#125; @Override public void push(E e) &#123; linkedList.addFirst(e); &#125; @Override public E pop() &#123; return linkedList.removeFirst(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public E peek() &#123; return linkedList.getFirst(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Stack: top \"); res.append(linkedList); return res.toString(); &#125;&#125; 使用链表实现队列我们之前使用数组实现队列，由于它的 dequeue 操作是 O(n) 级别的，所以我们使用 front 来标记队首，使用循环队列设计，同样的在链表中从链表尾部删除或增加元素都是 O(n) 级别的，为了解决这一个问题，我们决定在链表的尾部增加一个 tail 变量来标记，从而使得在尾部增加元素是 O(1) 级别的 另外考虑在尾部删除一个元素是 O(1) 的吗? 答案是不是。因为我们删除一个节点需要知道该节点的前一个节点，而知道 tail 节点是无法知道 tail 的前一个节点的，我们还是要遍历。所以我们在 head 端删除元素，在 tail 端添加元素，并且由于只涉及到头部和尾部的操作，所以我们也不需要添加虚拟头结点了 下面就是实现的代码 public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&lt;E&gt; &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node head; private Node tail; private int size; public LinkedListQueue() &#123; head = null; tail = null; size = 0; &#125; @Override public void enqueue(E e) &#123; //队列为空时，tail和head都为null 添加元素后二者都指向第一个元素 if (size == 0) &#123; tail = new Node(e); head = tail; &#125; else &#123; tail.next = new Node(e); tail = tail.next; &#125; size++; &#125; @Override public E dequeue() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; Node delNode = head; head = head.next; delNode.next = null; size--; //如果队列为空了，此时tail指向的是delNode，此时应该让tail为null if (size == 0) &#123; tail = null; &#125; return (E) delNode.e; &#125; @Override public E getFront() &#123; if (head == null) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; return (E) head.e; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Queue: front \"); Node cur = head; while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"NULL tail\"); return res.toString(); &#125;&#125; 二分搜索树什么是树结构 当你把上面的图倒过来看，就像是一棵树，所以我们把这种结构称为是树结构。那为什么要使用树结构，因为树结构在生活中很常见，如文件夹的组织方式，又或者如公司职能的组织方式，这些都是树结构的例子。为什么会使用树结构呢? 原因就是因为高效。 概念同链表一样，它也是一种动态的数据结构，链表中的节点是指向一个节点，而二叉树是指向两个节点，我们把这两个节点称为左子树和右子树，又或者称为左孩子和右孩子。如下图表示的就是二叉树 class Node &#123; E e; Node left; Node right;&#125; 根节点 最顶部的那个节点，如上图中 28 就是根节点 二叉树具有唯一的一个根节点 叶子节点 没有孩子的节点，如上图的最后一行都是叶子节点 二叉树的每个节点最多有两个孩子，最多有一个父亲 那是什么是二分搜索树，首先二分搜索树是二叉树，它满足这样的特点，对于每个节点 大于左子树所有节点的值 小于右子树所有节点的值 可以验算，上面的这棵树满足二分搜索树的性质，所以这棵树是二分搜索树。下面我们来实现二分搜索树中节点有关代码 public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left; public Node right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; //根节点 private Node root; //树中元素的个数 private int size; public BST() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; 实现添加元素 上图想必已经将添加元素的规则说的很详细了，所以这里直接上代码 public void add(E e) &#123; if (root == null) &#123; root = new Node(e); size++; &#125; else &#123; add(root, e); &#125;&#125;private void add(Node node, E e) &#123; //递归终止条件 if (e.equals(node.e)) &#123; return; &#125; else if (e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null) &#123; node.left = new Node(e); size++; return; &#125; else if (e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null) &#123; node.right = new Node(e); size++; return; &#125; if (e.compareTo(node.e) &lt; 0) &#123; add(node.left, e); &#125; if (e.compareTo(node.e) &gt; 0) &#123; add(node.right, e); &#125;&#125; 其实上面的代码还可以改进，因为我们在 add(E e) 中对 root 为根节点进行了单独的考虑，其实可以不再这里考虑，因为通过上面的规则知道，当一个节点为 null 时，不管它是根节点还是左右孩子，新加入的节点都将取代这个 null 节点 所以我们优化上面的代码如下 public void add(E e) &#123; root = add(root, e);&#125;private Node add(Node node, E e) &#123; //这里返回的Node所指的语义是node所代表的根节点 if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; //如果比根节点小，对左子树进行更新 node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; //如果比根节点大，对右子树进行更新 node.right = add(node.right,e); &#125; //等于的话什么都不做 return node;&#125; 查询操作public boolean contains(E e) &#123; return contains(root, e);&#125;private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125;&#125; 二叉树的遍历对于某个数据结构的遍历就是将该数据结构中所有的元素都访问一遍，分为三类 前序遍历 父节点在访问左子树之前访问 中序遍历 父节点在访问左子树之后，在访问右子树之前访问 后序遍历 父节点在访问右子树之后访问 前序遍历public void preOrder() &#123; preOrder(root);&#125;private void preOrder(Node node) &#123; if (node == null) &#123; return; &#125; //先访问父节点 System.out.println(node); preOrder(node.left); preOrder(node.right);&#125; 中序遍历public void inOrder() &#123; inOrder(root);&#125;private void inOrder(Node node) &#123; if (node == null) &#123; return; &#125; inOrder(node.left); System.out.println(node); inOrder(node.right);&#125; 中序遍历的结果是元素从小到大排序。 后序遍历public void postOrder() &#123; postOrder(root);&#125;private void postOrder(Node node) &#123; if (node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node);&#125; 后序遍历的一个应用是内存释放，我们必须先把左右孩子的内存释放完才能释放该节点的内存。 前序遍历的非递归实现 代码实现 public void preOrderNR() &#123; //非递归写法 if (root == null) &#123; return; &#125; //这里的Stack是上面自己写的Stack Stack&lt;Node&gt; stack = new ArrayStack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node top = stack.pop(); System.out.println(top); if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125;&#125; 层序遍历 代码实现 public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LoopQueue&lt;&gt;(); queue.enqueue(root); while (!queue.isEmpty()) &#123; Node front = queue.dequeue(); System.out.println(front); if (front.left != null) &#123; queue.enqueue(front.left); &#125; if (front.right != null) &#123; queue.enqueue(front.right); &#125; &#125;&#125; 删除元素在二分搜索树中删除一个节点是比较复杂的，我们首先从最简单的情况开始，删除二分搜索树中的最小值和最大值，首先是如何找到最大值和最小值 public E minimum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return minimum(root).e;&#125;private Node minimum(Node node) &#123; if (node.left == null) &#123; return node; &#125; return minimum(node.left);&#125;public E maximum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return maximum(root).e;&#125;private Node maximum(Node node) &#123; if (node.right == null) &#123; return node; &#125; return maximum(node.right);&#125; 找到了之后如何删除呢 public E removeMin() &#123; E ret = minimum(); root = removeMin(root); return ret;&#125;private Node removeMin(Node node) &#123; if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125; public E removeMax() &#123; E ret = maximum(); root = removeMax(root); return ret;&#125;private Node removeMax(Node node) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 现在讲解如何删除二分搜搜数中的任意一个节点 public void remove(E e) &#123; root = remove(root, e);&#125;private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; else &#123; Node successor = minimum(node.right); successor.right = removeMin(node.right);//为什么这条语句必须在前面??? successor.left = node.left; node.left = node.right = null; //size--; 在removeMin中已经维护size了 return successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); &#125; else &#123; node.right = remove(node.right, e); &#125; return node;&#125; 上面说的是取右子树中的最小值，你也可以考虑取左子树中的最大值，道理都是一样的。 完整代码public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left; public Node right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; //根节点 private Node root; //树中元素的个数 private int size; public BST() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(E e) &#123; root = add(root, e); &#125; private Node add(Node node, E e) &#123; //这里返回语义指的的是node所代表的根节点 if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; //如果比根节点小，对左子树进行更新 node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; //如果比根节点大，对右子树进行更新 node.right = add(node.right,e); &#125; //等于的话什么都不做 return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125; //前序遍历 public void preOrder() &#123; preOrder(root); &#125; private void preOrder(Node node) &#123; if (node == null) &#123; return; &#125; System.out.println(node); preOrder(node.left); preOrder(node.right); &#125; public void preOrderNR() &#123; //非递归写法 if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new ArrayStack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node top = stack.pop(); System.out.println(top); if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125; //中序遍历 public void inOrder() &#123; inOrder(root); &#125; private void inOrder(Node node) &#123; if (node == null) &#123; return; &#125; inOrder(node.left); System.out.println(node); inOrder(node.right); &#125; //后序遍历 public void postOrder() &#123; postOrder(root); &#125; private void postOrder(Node node) &#123; if (node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node); &#125; public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LoopQueue&lt;&gt;(); queue.enqueue(root); while (!queue.isEmpty()) &#123; Node front = queue.dequeue(); System.out.println(front); if (front.left != null) &#123; queue.enqueue(front.left); &#125; if (front.right != null) &#123; queue.enqueue(front.right); &#125; &#125; &#125; public E minimum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return minimum(root).e; &#125; private Node minimum(Node node) &#123; if (node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; public E maximum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return maximum(root).e; &#125; private Node maximum(Node node) &#123; if (node.right == null) &#123; return node; &#125; return maximum(node.right); &#125; public E removeMin() &#123; E ret = minimum(); root = removeMin(root); return ret; &#125; private Node removeMin(Node node) &#123; if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; public E removeMax() &#123; E ret = maximum(); root = removeMax(root); return ret; &#125; private Node removeMax(Node node) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; node.right = removeMax(node.right); return node; &#125; public void remove(E e) &#123; root = remove(root, e); &#125; private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; else &#123; Node successor = minimum(node.right); successor.right = removeMin(node.right);//为什么这条语句必须在前面??? successor.left = node.left; node.left = node.right = null; //size--; 在removeMin中已经维护size了 return successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); &#125; else &#123; node.right = remove(node.right, e); &#125; return node; &#125;&#125; 优先队列和堆普通队列：先进先出，就像是我们在银行办业务或者是在超市买东西，但是考虑在医院，有病人有突发情况，这个时候容不得他去排队挂号了，这时他的优先级是比较高的，所以他需要得到优先的处理，像这种队列中的元素具有优先级的队列，我们把它称之为优先队列。在游戏中我们也会设置优先攻击血量最低的怪或者距离最近的怪，这时候血量和距离就成为了判断优先级的标准；在操作系统的任务调度，我们为程序分配 CPU，内存等等资源，并不是先到先得的，也是根据程序的优先级来进行分配的。 堆的结构这里的堆指的是二叉堆，它满足以下的性质 二叉堆是一棵完全二叉树 把元素顺序排列成树的形状 堆中某个节点的值总是不大于其父亲节点的值(最大堆，相应也可以定义最小堆) 如果我们使用数组去实现堆 上面的序号表示的是在数组中的下标，我们发现如果父节点的下标为 i，那么左孩子的下标就为 2i + 1，右孩子的下标为 2i + 2，所以可以很快的根据父节点的下标得到左右孩子的下标，如果知道左右孩子的下标 i，那么 (i - 1)/2 就可以得到父节点的下标(整数除法，小数部分会被舍去)。这个结论可以使用数学归纳法进行证明，但不是这里的重点，所以不多做阐述。 public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap() &#123; data = new Array&lt;&gt;(); &#125; public int size() &#123; return data.getSize(); &#125; public boolean isEmpty() &#123; return data.isEmpty(); &#125; //根据左右孩子的下标获得父亲节点的下标 private int parent(int index) &#123; return (index - 1) / 2; &#125; //根据父节点的下标获得左孩子的下标 private int leftChild(int index) &#123; return 2 * index + 1; &#125; //根据父节点的下标获得右孩子的下标 private int rightChild(int index) &#123; return 2 * index + 2; &#125;&#125; 堆的实现向堆中添加元素 public void swap(int i, int j) &#123; if (i &lt; 0 || i &gt;= size() || j &lt; 0 || j &gt;= size()) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E temp = data.get(i); data.set(i, data.get(j)); data.set(j, temp);&#125;public void add(E e) &#123; data.addLast(e); siftUp(data.getSize() - 1);&#125;private void siftUp(int index) &#123; //index不是根节点(根节点不要上浮了) 并且孩子比父亲大 while (index != 0 &amp;&amp; data.get(index).compareTo(data.get(parent(index))) &gt; 0) &#123; swap(index, parent(index)); index = parent(index); &#125;&#125; 向堆中取出最大元素 public E findMax() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(\"堆为空\"); &#125; return data.get(0);&#125;public E extractMax() &#123; E ret = findMax(); swap(0,data.getSize() - 1); data.removeLast(); siftDown(0); return ret;&#125;private void siftDown(int index) &#123; //没有孩子时，下沉结束 while (leftChild(index) &lt; size()) &#123; int max = leftChild(index); int rightIndex = rightChild(index); if (rightIndex &lt; size()) &#123; max = data.get(max).compareTo(data.get(rightIndex)) &gt; 0 ? max : rightIndex; &#125; //最大孩子比父节点小时，下沉结束 if (data.get(max).compareTo(data.get(index)) &lt;= 0) &#123; break; &#125; swap(max,index); index = max; &#125;&#125; replacereplace 操作指的是从堆中取出元素，并向堆中添加一个元素，实现的方法为 //取出堆中的最大元素，并添加一个新元素epublic E replace(E e) &#123; E ret = findMax(); data.set(0,e); siftDown(0); return ret;&#125; heapifyheapify 是指将任意一个数组整理成堆的形状， 我们把这个方法做成一个构造函数 public MaxHeap(E[] arr) &#123; data = new Array&lt;&gt;(arr.length); for (int i = 0; i &lt; arr.length; i++) &#123; data.addLast(arr[i]); &#125; for (int i = parent(data.getSize() -1); i &gt;=0; i--) &#123; siftDown(i); &#125;&#125; 完整代码public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap() &#123; data = new Array&lt;&gt;(); &#125; public MaxHeap(E[] arr) &#123; data = new Array&lt;&gt;(arr.length); for (int i = 0; i &lt; arr.length; i++) &#123; data.addLast(arr[i]); &#125; for (int i = parent(data.getSize() -1); i &gt;=0; i--) &#123; siftDown(i); &#125; &#125; public int size() &#123; return data.getSize(); &#125; public boolean isEmpty() &#123; return data.isEmpty(); &#125; //根据左右孩子的下标获得父亲节点的下标 private int parent(int index) &#123; return (index - 1) / 2; &#125; //根据父节点的下标获得左孩子的下标 private int leftChild(int index) &#123; return 2 * index + 1; &#125; //根据父节点的下标获得右孩子的下标 private int rightChild(int index) &#123; return 2 * index + 2; &#125; public void swap(int i, int j) &#123; if (i &lt; 0 || i &gt;= size() || j &lt; 0 || j &gt;= size()) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E temp = data.get(i); data.set(i, data.get(j)); data.set(j, temp); &#125; public void add(E e) &#123; data.addLast(e); siftUp(data.getSize() - 1); &#125; private void siftUp(int index) &#123; //index不是根节点(根节点不要上浮了) 并且孩子比父亲大 while (index != 0 &amp;&amp; data.get(index).compareTo(data.get(parent(index))) &gt; 0) &#123; swap(index, parent(index)); index = parent(index); &#125; &#125; public E findMax() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(\"堆为空\"); &#125; return data.get(0); &#125; public E extractMax() &#123; E ret = findMax(); swap(0,data.getSize() - 1); data.removeLast(); siftDown(0); return ret; &#125; private void siftDown(int index) &#123; //没有孩子时，下沉结束 while (leftChild(index) &lt; size()) &#123; int max = leftChild(index); int rightIndex = rightChild(index); if (rightIndex &lt; size()) &#123; max = data.get(max).compareTo(data.get(rightIndex)) &gt; 0 ? max : rightIndex; &#125; //最大孩子比父节点小时，下沉结束 if (data.get(max).compareTo(data.get(index)) &lt;= 0) &#123; break; &#125; swap(max,index); index = max; &#125; &#125; //取出堆中的最大元素，并添加一个新元素e public E replace(E e) &#123; E ret = findMax(); data.set(0,e); siftDown(0); return ret; &#125;&#125; 基于堆的优先队列public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue() &#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public void enqueue(E e) &#123; maxHeap.add(e); &#125; @Override public E dequeue() &#123; return maxHeap.extractMax(); &#125; @Override public E getFront() &#123; return maxHeap.findMax(); &#125; @Override public int getSize() &#123; return maxHeap.size(); &#125; @Override public boolean isEmpty() &#123; return maxHeap.isEmpty(); &#125;&#125; 线段树对于有一类的问题，我们主要关心的是线段(区间)，比如说查询一个区间 [i, j] 内的最大值，最小值等等。假设你有一个网站，你想查询某年(或某年以后)的用户访问量，消费最多的用户等等，这些都是在某个区间内进行查询，一般线段树的区间是固定的，不包含删除和添加的操作，只有查询和更新的操作 线段树的表示 现在如果假设有n个元素，用数组存储的话，需要多少空间呢 public class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; public SegmentTree(E[] arr) &#123; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * data.length]; &#125; public int getSize() &#123; return data.length; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index]; &#125; private int leftChild(int index) &#123; return 2 * index + 1; &#125; private int rightChild(int index) &#123; return 2 * index + 2; &#125;&#125; 实现创建线段树下面就要根据数组来创建一棵线段树，我们的方法先创建下面的子线段树，然后由这些子线段树合并成大的线段树，以此类推 在合并左右子树的过程中，我们不能写死合并的过程，具体怎么合并应该由业务决定，由用户去决定如何合并，所以合并的过程我们写一个接口，具体的实现由用户去实现 public interface Merger&lt;E&gt; &#123; public E merge(E a, E b);&#125; 然后我们在构造方法中添加创建线段树的过程(为了创建线段树，增加了一个辅助方法) private Merger&lt;E&gt; merger;//merger由用户传入 用户决定如何合并public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * data.length]; //构造线段树 创建根节点为0，范围为[0,data.length - 1]的线段树 buildSegmentTree(0, 0, data.length - 1);&#125;//在treeIndex创建一棵[l,r]的线段树private void buildSegmentTree(int treeIndex, int l, int r) &#123; if (l == r) &#123; tree[treeIndex] = data[l]; return; &#125; //l != r 那么就要创建子树的线段树 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; //(l +r) / 2中l + r可能会大于int表示的范围从而溢出 buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); //融合的方法由用户传入 tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);&#125; 为了方便我们打印出线段树，我们实现一个 toString() 方法 @Overridepublic String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"[\"); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append(\"null\"); &#125; if (i != tree.length - 1) &#123; res.append(\", \"); &#125; &#125; res.append(\"]\"); return res.toString();&#125; 查询 实现代码 public E query(int queryL, int queryR) &#123; if (queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return query(0, 0, data.length - 1, queryL, queryR);&#125;private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if (l == queryL &amp;&amp; r == queryR) &#123; return tree[treeIndex]; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (queryL &gt;= mid + 1) &#123; return query(rightChildIndex, mid+1, r, queryL, queryR); &#125; else if (queryR &lt;= mid) &#123; return query(leftChildIndex, l, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex, l, mid, queryL, mid); E rightResult = query(rightChildIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult);&#125; 更新public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; set(0, 0, data.length - 1, index, e);&#125;private void set(int treeIndex, int l, int r, int index, E e) &#123; if (l == r) &#123; tree[treeIndex] = e; return; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (index &gt;= mid + 1) &#123; set(rightChildIndex, mid+1, r, index, e); &#125; else &#123; set(leftChildIndex, l, mid, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftChildIndex], tree[rightChildIndex]);&#125; 完整代码public class SegmentTree&lt;E&gt;&#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * data.length]; buildSegmentTree(0, 0, data.length - 1); &#125; //在treeIndex创建一棵[l,r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r) &#123; if (l == r) &#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; //(l +r) / 2中l + r可能会大于int表示的范围从而溢出 buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]); &#125; public E query(int queryL, int queryR) &#123; if (queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return query(0, 0, data.length - 1, queryL, queryR); &#125; private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if (l == queryL &amp;&amp; r == queryR) &#123; return tree[treeIndex]; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (queryL &gt;= mid + 1) &#123; return query(rightChildIndex, mid+1, r, queryL, queryR); &#125; else if (queryR &lt;= mid) &#123; return query(leftChildIndex, l, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex, l, mid, queryL, mid); E rightResult = query(rightChildIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; set(0, 0, data.length - 1, index, e); &#125; private void set(int treeIndex, int l, int r, int index, E e) &#123; if (l == r) &#123; tree[treeIndex] = e; return; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (index &gt;= mid + 1) &#123; set(rightChildIndex, mid+1, r, index, e); &#125; else &#123; set(leftChildIndex, l, mid, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftChildIndex], tree[rightChildIndex]); &#125; public int getSize() &#123; return data.length; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index]; &#125; private int leftChild(int index) &#123; return 2 * index + 1; &#125; private int rightChild(int index) &#123; return 2 * index + 2; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"[\"); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append(\"null\"); &#125; if (i != tree.length - 1) &#123; res.append(\", \"); &#125; &#125; res.append(\"]\"); return res.toString(); &#125;&#125; TrieTrie 树又称为字典树、前缀树。如果我们使用一般树结构去查询一个数据集里的单词，它的复杂度是 O(log n)，但是如果我们使用 Trie 去查询单词的话，查询的复杂度只与单词的长度有关，与数据的规模无关。比如对于一个 $2^{20}$ 规模的数据集，我们去查一个单词 &quot;word&quot;，一般树的复杂度为 O(20)，而 Trie 树的复杂度为 O(4)，其中 4 是单词的长度，所以 Trie 树是一种很高效的查询字符串的树结构。 class Node &#123; char c; Node next[26];&#125; 但是这样考虑忽略了大小写，并且没有考虑一些特殊的字符，如 @ 等符号或标点符号。所以我们每个节点不再是静态的指向 26 个节点，而是动态的指向若干个节点 class Node &#123; char c; Map&lt;Character,Node&gt; next;&#125; 另外我们通过某个字符来到一个节点，可以通过 Map已经知道了，所以我们不必存储这个字符 class Node &#123; Map&lt;Character,Node&gt; next;&#125; 另外通过叶子节点是无法区别单词的结尾的，因为有的单词可能为某个单词的前缀，如 &quot;pan&quot; 为 &quot;panda&quot; 的前缀，所以我们要增加一个变量 isWord 来表示是否是单词的结尾 import java.util.TreeMap;public class Trie &#123; private class Node &#123; public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125; public int getSize() &#123; return size; &#125;&#125; 实现添加单词 public void add(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); //判断是否有指向这个字符的节点 if (cur.next.get(c) == null) &#123; //没有则新建一个节点 cur.next.put(c, new Node()); &#125; //移动到这个节点 cur = cur.next.get(c); &#125; //遍历完毕，判断这个节点是否被标记为单词的结尾 如果没有则标记并且维护size++ if (!cur.isWord) &#123; cur.isWord = true; size++; &#125;&#125; 查询单词查询单词的逻辑与添加单词的逻辑高度重复，如果在查询过程中遇到没有指向该字符的节点，则直接返回 false，如果遍历完毕都没有发生上面的情况，则判断该节点是否被标记为单词的结尾，如果没有则返回 false，否则返回 true。 public boolean contains(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return cur.isWord;&#125; 前缀搜索查询是否包含某个前缀，与 contains() 方法几乎一样，不过最后不用判断是否是单词结尾，直接返回 true public boolean isPrefix(String prefix) &#123; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return true;&#125; 简单字符匹配对于字符串中的字符 . 规定它可以匹配任意的字符，那么这样的一个匹配算法如何写，如果我们遇到的字符不是 . 的话，逻辑和上面一样，如果遇到的是.的话，我们就要去搜索该节点中所有的分叉(子树) public boolean match(String word) &#123; return match(root, word, 0);&#125;private boolean match(Node node, String word, int index) &#123; //递归终止条件 if (index == word.length()) &#123; return node.isWord; &#125; char c = word.charAt(index); //如果不是. if (c != '.') &#123; //没有指向该字符的节点 返回false if (node.next.get(c) == null) &#123; return false; &#125; else &#123; //否则继续匹配 return match(node.next.get(c), word, index + 1); &#125; &#125; else &#123; //如果是. 去该节点的所有分叉中搜索 for (char nextChar : node.next.keySet()) &#123; //如果有任一个分叉匹配到了，则返回true if (match(node.next.get(nextChar), word, index + 1)) &#123; return true; &#125; &#125; //说明上面的没有一个匹配成功了，返回fasle return false; &#125;&#125; 全部代码import java.util.TreeMap;public class Trie &#123; private class Node &#123; public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125; public int getSize() &#123; return size; &#125; public void add(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (cur.next.get(c) == null) &#123; cur.next.put(c, new Node()); &#125; cur = cur.next.get(c); &#125; if (!cur.isWord) &#123; cur.isWord = true; size++; &#125; &#125; public boolean contains(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return cur.isWord; &#125; public boolean isPrefix(String prefix) &#123; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return true; &#125; public boolean match(String word) &#123; return match(root, word, 0); &#125; private boolean match(Node node, String word, int index) &#123; //递归终止条件 if (index == word.length()) &#123; return node.isWord; &#125; char c = word.charAt(index); if (c != '.') &#123; if (node.next.get(c) == null) &#123; return false; &#125; else &#123; return match(node.next.get(c), word, index + 1); &#125; &#125; else &#123; for (char nextChar : node.next.keySet()) &#123; if (match(node.next.get(nextChar), word, index + 1)) &#123; return true; &#125; &#125; //说明上面的没有一个匹配成功了 return false; &#125; &#125;&#125; 并查集我们之前遇到的树结构都是由父亲指向孩子，但是并查集不一样，它是由孩子指向父亲的一种结构，并查集结构可以非常高效的回答连接问题(Connectivity Problem)，它可以很快的判断网络中节点的连接状态。并查集主要支持两个动作 union(p, q) 将元素 p, q 连接起来 isConnected(p, q) 判断元素 p, q 是否是连接的，即是否所属一个集合 这里先给出并查集的接口，后面我们将实现多个版本的并查集 public interface UF &#123; public int getSize(); public boolean isConnected(int p, int q); public void unionElements(int p, int q);&#125; Quick Find //第一版的并查集public class UnionFind1 implements UF&#123; private int[] id; public UnionFind1(int size) &#123; id = new int[size]; //这时id全部为0，相当于在一个集合中 一开始应该全部不在一个集合中 for (int i = 0; i &lt; id.length; i++) &#123; id[i] = i; &#125; &#125; @Override public int getSize() &#123; return id.length; &#125; //找到元素p所属的集合 private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return id[p]; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; if (find(p) == find(q)) &#123; return; &#125; for (int i = 0; i &lt; id.length; i++) &#123; if (id[i] == find(p)) &#123; id[i] = find(q); &#125; &#125; &#125;&#125; Quick Union //第二版的并查集public class UnionFind2 implements UF&#123; private int[] parent; public UnionFind2(int size) &#123; parent = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; index = parent[index]; &#125; return index; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; else &#123; parent[pRoot] = parent[qRoot]; &#125; &#125;&#125; 基于rank的优化 //第三版的并查集public class UnionFind3 implements UF&#123; private int[] parent; //记录根节点的高度 private int[] rank; public UnionFind3(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; index = parent[index]; &#125; return index; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; //只要在两个数的高度相等的时候 树的高度才会增加 if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; 路径压缩 //第四版的并查集public class UnionFind4 implements UF&#123; private int[] parent; private int[] rank; public UnionFind4(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; //只添加了这一行代码 parent[index] = parent[parent[index]]; index = parent[index]; &#125; return index; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; //这时rank不代表高度 因为在路径压缩时没有维护rank //但是整体上rank还是能够表示大小关系的 if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; //第五版的并查集public class UnionFind5 implements UF&#123; private int[] parent; private int[] rank; public UnionFind5(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //修改了这里 if (index != parent[index]) &#123; parent[index] = find(parent[index]); &#125; return parent[index]; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; 第五版的效率不一定比第四版的好，因为第四版最后也可能做到”扁平化”，并且第五版的递归操作比较耗时。 AVL树概念及实现我们在研究二分搜索树时发现，如果我们将数据顺序添加进树中时，它有会退化成一棵链表，即所有的元素都添加到一个孩子上，这样树结构的优势就体现不出来，为了不使左右孩子的高度相差太大，我们需要对树进行调整，使树达到平衡，成为一棵平衡二叉树，AVL 就是一种经典的平衡二叉树 在 AVL 中，我们定义的平衡二叉树为，对于任意一个节点，左子树和右子树的高度相差不能超过 1。 我们为每一个节点标注好高度值，计算方法为取左右子树高度较高的高度，然后 +1 然后我们还有记录节点左右子树的高度差，我们称之为平衡因子(规定用左子树的高度-右子树的高度) 由于我们只是在添加元素和删除元素时对树进行调整，其余的代码同二分搜索树是相同的，所以就不贴出所有的代码，只给出不同的代码，首先我们需要在 Node 类中添加一个 height 变量来记录高度 private class Node &#123; public E e; public Node left; public Node right; //高度 public int height; public Node(E e) &#123; this.e = e; left = null; right = null; //高度初始为1 height = 1; &#125; @Override public String toString() &#123; return e.toString(); &#125;&#125; 新增加一个获得某节点高度的函数和平衡因子的函数 private int getHeight(Node node) &#123; if (node == null) &#123; return 0; &#125; return node.height;&#125;private int getBalanceFactor(Node node) &#123; if (node == null) &#123; return 0; &#125; return getHeight(node.left) - getHeight(node.right);&#125; 有了这些因素，我们一般需要在添加元素时进行维护，重新计算高度和平衡因子，从而进行调整 private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; //更新高度 node.height = Math.max(getHeight(node.left),getHeight(node.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(node); if (Math.abs(balanceFactor) &gt; 1) &#123; //进行调整 &#125; return node;&#125; 我们后面的内容主要是如何调整，后面所以只给出如何调整的代码，在学如何调整之前，我们来写两个辅助函数来判断这棵树是不是二分搜索树和 AVL 树，因为如果我们的代码有问题的话，有可能破坏二分搜索树的性质，这样有利于我们检查，那怎么检查一棵树是不是二分搜索树，我们根据二分搜索树的性质，它的中序遍历的结果是从小到大的特性，我们重写中序遍历为 public boolean isBST() &#123; ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;(); inOrder(root, arrayList); for (int i = 1; i &lt; arrayList.size(); i++) &#123; if (arrayList.get(i-1).compareTo(arrayList.get(i)) &gt; 0) return false; &#125; &#125; return true;&#125;private void inOrder(Node node, ArrayList&lt;E&gt; arrayList) &#123; if (node == null) &#123; return; &#125; inOrder(node.left, arrayList); arrayList.add(node.e); inOrder(node.right, arrayList);&#125; 现在我们判断这棵树是不是平衡二叉树 public boolean isBalanced() &#123; return isBalanced(root);&#125;//判断某个节点是不是平衡private boolean isBalanced(Node node) &#123; if (node == null) &#123; return true; &#125; int balanceFactor = getBalanceFactor(node); if (Math.abs(balanceFactor) &gt; 1) &#123; return false; &#125; return isBalanced(node.left) &amp;&amp; isBalanced(node.right);&#125; 下面对不平衡的四种情形进行讨论，并给出调整方法 // 对节点y进行向右旋转操作，返回旋转后新的根节点x// y x// / \\ / \\// x T4 向右旋转 (y) z y// / \\ - - - - - - - -&gt; / \\ / \\// z T3 T1 T2 T3 T4// / \\// T1 T2private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; x.right = y; y.left = T3; //更新x和y的高度值 先更新y的，因为y是x的右孩子，x的更新取决于y y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x;&#125;// 对节点y进行向左旋转操作，返回旋转后新的根节点x// y x// / \\ / \\// T4 x 向左旋转 (y) y z// / \\ - - - - - - - -&gt; / \\ / \\// T3 z T4 T3 T1 T2// / \\// T1 T2private Node leftRotate(Node y) &#123; Node x = y.right; Node T3 = x.left; x.left = y; y.right = T3; y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x;&#125;public void add(E e) &#123; root = add(root, e);&#125;private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; //更新高度 node.height = Math.max(getHeight(node.left),getHeight(node.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(node); //调整 if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) &#123; return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) &#123; return leftRotate(node); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node;&#125;public void remove(E e) &#123; root = remove(root, e);&#125;private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; Node retNode; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; retNode = leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; retNode = rightNode; &#125; else &#123; Node successor = minimum(node.right); ////由于removeMin没有维持balance，所以我们复用remove successor.right = remove(node.right,successor.e); successor.left = node.left; node.left = node.right = null; retNode = successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); retNode = node; &#125; else &#123; node.right = remove(node.right, e); retNode = node; &#125; //否则retNode.height会有空指针异常 if (retNode == null) &#123; return null; &#125; //更新高度 retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(retNode); if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) &#123; return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) &#123; return leftRotate(retNode); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode;&#125; 完整代码import java.util.ArrayList;public class AVLTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left; public Node right; public int height; public Node(E e) &#123; this.e = e; left = null; right = null; height = 1; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; //根节点 private Node root; //树中元素的个数 private int size; public AVLTree() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private int getHeight(Node node) &#123; if (node == null) &#123; return 0; &#125; return node.height; &#125; private int getBalanceFactor(Node node) &#123; if (node == null) &#123; return 0; &#125; return getHeight(node.left) - getHeight(node.right); &#125; public boolean isBST() &#123; ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;(); inOrder(root, arrayList); for (int i = 1; i &lt; arrayList.size(); i++) &#123; if (arrayList.get(i-1).compareTo(arrayList.get(i)) &gt; 0) &#123; return false; &#125; &#125; return true; &#125; private void inOrder(Node node, ArrayList&lt;E&gt; arrayList) &#123; if (node == null) &#123; return; &#125; inOrder(node.left, arrayList); arrayList.add(node.e); inOrder(node.right, arrayList); &#125; public boolean isBalanced() &#123; return isBalanced(root); &#125; //判断某个节点是不是平衡 private boolean isBalanced(Node node) &#123; if (node == null) &#123; return true; &#125; int balanceFactor = getBalanceFactor(node); if (Math.abs(balanceFactor) &gt; 1) &#123; return false; &#125; return isBalanced(node.left) &amp;&amp; isBalanced(node.right); &#125; private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; x.right = y; y.left = T3; //更新x和y的高度值 先更新y的，因为y是x的右孩子，x的更新取决于y y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; private Node leftRotate(Node y) &#123; Node x = y.right; Node T3 = x.left; x.left = y; y.right = T3; y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; public void add(E e) &#123; root = add(root, e); &#125; private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; //更新高度 node.height = Math.max(getHeight(node.left),getHeight(node.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(node); if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) &#123; return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) &#123; return leftRotate(node); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125; public E minimum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return minimum(root).e; &#125; private Node minimum(Node node) &#123; if (node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; public void remove(E e) &#123; root = remove(root, e); &#125; private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; Node retNode; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; retNode = leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; retNode = rightNode; &#125; else &#123; Node successor = minimum(node.right); successor.right = remove(node.right,successor.e);//由于removeMin没有维持balance，所以我们用remove successor.left = node.left; node.left = node.right = null; //size--; 在removeMin中已经维护size了 retNode = successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); retNode = node; &#125; else &#123; node.right = remove(node.right, e); retNode = node; &#125; //否则retNode.height会有空指针异常 if (retNode == null) &#123; return null; &#125; //更新高度 retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(retNode); if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) &#123; return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) &#123; return leftRotate(retNode); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode; &#125;&#125; 红黑树2-3树2-3树的节点它可以有一个元素，也可以有两个元素，它也满足二分搜索树的性质 我们把含有两个孩子的节点称为 2 节点，含有 3 个孩子的节点称为 3 节点 2-3 树是一种绝对平衡的树，所谓绝对平衡的树指的是从根节点到任意一个叶子节点，所经过的节点是都是相同的。那么 2-3 树是怎么做到的呢? 红黑树与2-3树的等价性由于我们一般每个节点都是表示一个数据的，2-3 树有点难以实现，所以有人发明一种树叫做红黑树，它可以说是 2-3 树的等价，那么它树如何等价的呢? 上图想必很清楚的描述了等价的过程 现在我们来实现一下上面描述的红黑树，大部分的代码都是和二分搜索树是重合的，只是在添加时有调整，另外这里我们不牵涉到从红黑树中删除元素，因为太复杂了(其实是我不会) public class RedBlackTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; //规定红色为true 黑色为false private static final boolean RED = true; private static final boolean BLACK = false; private class Node &#123; public E e; public Node left; public Node right; public boolean color; public Node(E e) &#123; this.e = e; left = null; right = null; //我们在2-3树中添加节点时 永远是和别的节点融合 所以默认为红色 color = RED; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node root; private int size; public RedBlackTree() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(E e) &#123; root = add(root, e); &#125; // 判断节点node的颜色 private boolean isRed(Node node)&#123; if(node == null) return BLACK; return node.color; &#125; private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125;&#125; 红黑树的性质在了解了红黑树与 2-3 等价以后，我们来看红黑树满足哪些性质 每个节点或者是红色的，或者的是黑色的 根节点是黑色的 每一个叶子节点(最后的空节点是黑色的) 因为红色节点只存在于 3 节点中，而所有的叶子节点都是 2 节点 如果一个节点是红色的，那么它的所有孩子节点都是黑色的 从任意一个节点到黑色节点，经过的黑色节点是一样的 因为 2-3 树到所有叶子节点的距离都是一样的，而经过的节点，不管是 2 节点还是 3 节点，都包括一个黑色节点，所以经过的黑色节点是一样的 向红黑树中添加元素因为根节点是黑色的，所以我们在添加完元素后需要将根节点变为黑色 public void add(E e) &#123; root = add(root, e); root.color = BLACK;&#125; 在添加元素到红黑树中时，可能会破坏红黑树的规则，这时就需要红黑树进行自我调整，我们就来看一下添加过程会碰到的所有情形，以及处理方法 // node x// / \\ 左旋转 / \\// T1 x ---------&gt; node T3// / \\ / \\// T2 T3 T1 T2private Node leftRotate(Node node)&#123; Node x = node.right; // 左旋转 node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x;&#125; // 颜色翻转private void flipColors(Node node)&#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK;&#125; // node x// / \\ 右旋转 / \\// x T2 -------&gt; y node// / \\ / \\// y T1 T1 T2private Node rightRotate(Node node)&#123; Node x = node.left; // 右旋转 node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x;&#125; 对上面的情况进行总结 private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; if (isRed(node.right) &amp;&amp; !isRed(node.left)) node = leftRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rightRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node); return node;&#125; 完整代码public class RedBlackTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; //规定红色为true 黑色为false private static final boolean RED = true; private static final boolean BLACK = false; private class Node &#123; public E e; public Node left; public Node right; public boolean color; public Node(E e) &#123; this.e = e; left = null; right = null; //我们在2-3树中添加节点时 永远是和别的节点融合 所以默认为红色 color = RED; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node root; private int size; public RedBlackTree() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private boolean isRed(Node node) &#123; if (node == null) &#123; return BLACK; &#125; return node.color; &#125; // node x // / \\ 左旋转 / \\ // T1 x ---------&gt; node T3 // / \\ / \\ // T2 T3 T1 T2 private Node leftRotate(Node node) &#123; Node x = node.right; node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x; &#125; // node x // / \\ 右旋转 / \\ // x T2 -------&gt; y node // / \\ / \\ // y T1 T1 T2 private Node rightRotate(Node node) &#123; Node x = node.left; node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x; &#125; private void flipColors(Node node) &#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK; &#125; public void add(E e) &#123; root = add(root, e); root.color = BLACK; &#125; private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; if (isRed(node.right) &amp;&amp; !isRed(node.left)) node = leftRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rightRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node); return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125;&#125; 哈希表我们通过将我们要查找的某种数据类型转化为一个索引 index，然后通过索引去数组中查找，这时它的复杂度就是 O(1) 级别的。而将某个数据类型转化为索引的函数我们就称为是哈希函数，比如说将 26 个小写字母转化为索引，我们可以这么写 index = ch - 'a'; 这样就建立起了一一对应的关系，但是并不是所有的对应关系都是一一对应的，因为数组的容量是有限的，而输入的范围可能是无穷的，所以很有可能不同的键对应着同一个索引，比如说键是字符串，因为字符串的组合方式是非常的多，可以看做是无穷的，我们不可能去开辟一个无穷的空间去与这些字符串一一对应，所以不同的字符串生成的索引很有可能会有冲突，我们称这种情况为哈希冲突。由于上面讲到的哈希冲突，所以我们要设计好哈希函数(hashCode())使得发生哈希冲突的可能性小，即使哈希函数产生的哈希值均匀的分布在数组中。 哈希函数的设计哈希函数应该满足上面提到的：哈希函数产生的哈希值均匀的分布在数组中。数据的类型五花八门，对于特殊的领域有特殊领域的哈希函数的设计方式，甚至还有专门的论文，说这么多就是想说哈希函数的设计十分的复杂，在这里我们只提最简单的一种，哈希函数的设计应该满足 一致性 如果 a == b，那么 hashCode(a) == hashCode(b) 高效性 计算迅速 均匀性 输出尽可能均匀 由于 Java 中基本数据类型和字符串类型有默认的 hashCode() 计算，所以我们就用 Java 自带的 hashCode 计算基本数据类型和字符串的哈希值，而对于引用类型 Java 是根据地址计算的哈希值，所以可能会出现问题，需要我们自己自定义规则，比如对于一个 Student 类，我们规定学号以及姓名相同(不区分大小写)就是同一个学生，所以根据一致性原则，它们应该产生相同的哈希值，但是由于 Java 默认是根据地址产生哈希值，由于二者的地址是不同的，所以产生的哈希值有极大的概率是不同的，所以我们需要自己创建哈希函数。 链地址法现在我们来演示往哈希表中添加元素的步骤 import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable(int M) &#123; this.M = M; size = 0; hashTable = new TreeMap[M]; for (int i = 0; i &lt; hashTable.length; i++) &#123; hashTable[i] = new TreeMap&lt;&gt;(); &#125; &#125; public HashTable() &#123; this(97); &#125; public int getSize() &#123; return size; &#125; //得到在数组中的索引 private int hash(K key) &#123; //与0x7fffffff是为了消除负数 return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public void add(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //先查看已经是否有这个键了 if (map.containsKey(key)) &#123; //有则更新 map.put(key, value); &#125; else &#123; //没有则进行添加，并维护size map.put(key, value); size++; &#125; &#125; public V remove(K key, V value) &#123; V ret = null; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //如果包含键则删除，没有返回null if (map.containsKey(key)) &#123; ret = map.remove(key); size--; &#125; return ret; &#125; public void set(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //没有该键抛出异常 if (!map.containsKey(key)) &#123; throw new IllegalArgumentException(\"键不存在\"); &#125; map.put(key,value); &#125; //直接得到相应的TreeMap，然后去查，TreeMap有检查步骤 public V get(K key) &#123; return hashTable[hash(key)].get(key); &#125;&#125; import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private static final int upperTol = 10; private static final int lowerTol = 2; private static final int initCapacity = 7; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable(int M) &#123; //只显示改变的内容 //... hashTable = new TreeMap[initCapacity]; &#125; public void add(K key, V value) &#123; //... if (size &gt;= upperTol * M) &#123; resize(2 * M); &#125; &#125; public V remove(K key, V value) &#123; //... if (size &lt; M * lowerTol &amp;&amp; M / 2 &gt;= initCapacity) &#123; resize(M / 2); &#125; return ret; &#125; private void resize(int newM) &#123; TreeMap&lt;K,V&gt;[] newHashTable = new TreeMap[newM]; //后面要更新M，但是还需要旧M遍历数组 int oldM = M; //由于后面要重新计算下标，所以这里要更新M M = newM; for (int i = 0; i &lt; oldM; i++) &#123; TreeMap&lt;K, V&gt; map = hashTable[i]; for (K key: map.keySet()) &#123; //重新计算下标并赋值 newHashTable[hash(key)].put(key, map.get(key)); &#125; &#125; hashTable = newHashTable; &#125;&#125; 但是我们发现每次我们都扩容为 2 \\* M，这时 M 就不是一个素数了，为了解决这一个问题，我们准备一个素数表，让 M 取素数表中的值，每次扩容 M 在素数表中的索引 +1，缩容 -1 import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; //素数表 private static final int[] capacity = &#123;&#125;; private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable() &#123; this.M = capacity[capacityIndex]; size = 0; hashTable = new TreeMap[M]; for (int i = 0; i &lt; hashTable.length; i++) &#123; hashTable[i] = new TreeMap&lt;&gt;(); &#125; &#125; public void add(K key, V value) &#123; //... if (size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; size) &#123; capacityIndex++; resize(capacity[capacityIndex]); &#125; &#125; public V remove(K key, V value) &#123; //... if (size &lt; M * lowerTol &amp;&amp; capacityIndex - 1 &gt;= 0) &#123; capacityIndex--; resize(capacity[capacityIndex]); &#125; return ret; &#125;&#125; 完整代码import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private static final int[] capacity = &#123;&#125;; private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable() &#123; this.M = capacity[capacityIndex]; size = 0; hashTable = new TreeMap[M]; for (int i = 0; i &lt; hashTable.length; i++) &#123; hashTable[i] = new TreeMap&lt;&gt;(); &#125; &#125; public int getSize() &#123; return size; &#125; //得到在数组中的索引 private int hash(K key) &#123; //与0x7fffffff是为了消除负数 return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public void add(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //先查看已经是否有这个键了 if (map.containsKey(key)) &#123; //有则更新 map.put(key, value); &#125; else &#123; //没有则进行添加，并维护size map.put(key, value); size++; &#125; if (size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; capacity.length) &#123; capacityIndex++; resize(capacity[capacityIndex]); &#125; &#125; public V remove(K key, V value) &#123; V ret = null; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //如果包含键则删除，没有返回null if (map.containsKey(key)) &#123; ret = map.remove(key); size--; &#125; if (size &lt; M * lowerTol &amp;&amp; capacityIndex - 1 &gt;= 0) &#123; capacityIndex--; resize(capacity[capacityIndex]); &#125; return ret; &#125; public void set(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //没有该键抛出异常 if (!map.containsKey(key)) &#123; throw new IllegalArgumentException(\"键不存在\"); &#125; map.put(key,value); &#125; //直接得到相应的TreeMap，然后去查，TreeMap有检查步骤 public V get(K key) &#123; return hashTable[hash(key)].get(key); &#125; private void resize(int newM) &#123; TreeMap&lt;K,V&gt;[] newHashTable = new TreeMap[newM]; //后面要更新M，但是还需要旧M遍历数组 int oldM = M; //由于后面要重新计算下标，所以这里要更新M M = newM; for (int i = 0; i &lt; oldM; i++) &#123; TreeMap&lt;K, V&gt; map = hashTable[i]; for (K key: map.keySet()) &#123; //重新计算下标并赋值 newHashTable[hash(key)].put(key, map.get(key)); &#125; &#125; hashTable = newHashTable; &#125;&#125; 参考链接 玩转数据结构","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"MySQL学习笔记","date":"2019-09-13T16:00:00.000Z","path":"/MySQL学习笔记/","text":"这篇文章是记录我学习 MySQL 时的一些笔记，不成体系，仅为以后快速学习准备，由于记录的是从零学习 MySQL 的笔记，所以笔记的内容是十分的基础的，基本上是以用为主，不牵涉到具体的原理性问题。 MySQL基本概念我们使用Java编写程序，一般数据都是存储在内存中的，一旦程序终止或断电，那么数据就会丢失，所以我们需要将数据存储到本地文件中，我们一般存储到数据库中，而 MySQL 正是这么一款数据库。 安装 MySQL 很简单，直接使用搜索引擎搜索 MySQL，进入官网进行安装，MySQL 是开源的软件。目前企业使用的是5.5-5.7的版本，选择进行下载即可。若要卸载 MySQL，在手动卸载 MySQL 后，还要删除 C:\\ProgramData\\MySQL 这个文件夹，否则重新安装时不能成功。 连接MySQL在命令行中输入 mysql -uroot -p 然后会提示你输入密码 输入的密码以密文的形式显示，以保证安全。当然你也可以直接在 -p 后面输入密码，不过这样并不安全。 SQL语句分类SQL 语句按功能分为 DDL：操作数据库，表 DML：增、删、改数据 DQL：查询数据 DLL：与授权有关 在 MySQL 中不区分大小写，不过关键字一般会大写，而数据库名和表名一般小写，SQL语句需要以;结尾，否则会一直等待输入。 注释MySQL 的注释为 -- 后面需要接一个空格，否则会报错，另一种注释为 #，这是 MySQL 独有的，后面不需要加空格 show databases; -- 显示所有的数据库show databases; #显示所有的数据库 DDL这里来介绍操作数据库和表的 SQL 语句，这些操作一般就是 C(Create), R(Retrieve), U(Update), D(Delete)。 操作数据库查询首先介绍查询数据库的语句，连接上 MySQL 后，在命令行中输入(这里关键字没有大写) show databases; 这个语句的作用是显示出所有的数据库 +--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || sys || world |+--------------------+6 rows in set (0.31 sec) 下面这条语句的作用是显示出某数据库所用的字符集 show create database 数据库名; 比如 show create database world; 输出为 +----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| world | CREATE DATABASE `world` /*!40100 DEFAULT CHARACTER SET latin1 */ |+----------+------------------------------------------------------------------+1 row in set (0.05 sec) 可见 world 数据库所用的字符集为 latin1。 创建创建数据库的语句为 create database 数据库名; 如 create database db1; -- 创建一个名为db1的数据库 如果数据库已经存在，那么会发生错误，例如再次执行上面的命令 create database db1; 会发生如下错误 ERROR 1007 (HY000): Can't create database 'db1'; database exists 这个时候我们可以使用 create database if not exists db1; -- 如果db1不存在，那么创建db1，否则什么也不做 我们还可以在创建数据库时指定字符集，如 create database db2 character set gbk; 使用 show create database db2; 查看字符集 +----------+-------------------------------------------------------------+| Database | Create Database |+----------+-------------------------------------------------------------+| db2 | CREATE DATABASE `db2` /*!40100 DEFAULT CHARACTER SET gbk */ |+----------+-------------------------------------------------------------+1 row in set (0.03 sec) 修改我们可以通过下面的命令修改数据库的字符集 alter database 数据库名 character set 字符集; 例如修改 db2 数据库为 utf8 编码 alter database db2 character set utf8; 删除我们可以使用 drop 命令删除数据库，例如 drop database db2; 使用 show databases; 查看数据库，发现 db2 已经被删除了 +--------------------+| Database |+--------------------+| information_schema || db1 || mysql || performance_schema || sakila || sys || world |+--------------------+ 如果数据库不存在，那么会报错，比如在删除一次 db2 ERROR 1008 (HY000): Can't drop database 'db2'; database doesn't exist 这个时候我们可以使用下面的语句 drop database if exists db2; -- 如果db2存在则删除db2，否则什么也不做 使用数据库通过 select database(); 命令可以查看我们正在使用哪一个数据库 +------------+| database() |+------------+| NULL |+------------+1 row in set (0.00 sec) 因为我们没有使用数据库，所以这里显示的是 NULL，可以通过 use 数据库名;来使用数据库，比如使用 db1 数据库 use db1; 再次执行 select database(); 输出为 +------------+| database() |+------------+| db1 |+------------+1 row in set (0.00 sec) 操作表查询可以使用 show tables 查询某数据库中所有的表，例如现在我们使用 world 数据库，然后查询其中所有的表 use world;show tables; 结果为 +-----------------+| Tables_in_world |+-----------------+| city || country || countrylanguage |+-----------------+3 rows in set (0.09 sec) 我们还可以使用 desc 表名; 来查询某表的结构，我们来查询 city 表的结构 desc city; +-------------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------------+----------+------+-----+---------+----------------+| ID | int(11) | NO | PRI | NULL | auto_increment || Name | char(35) | NO | | | || CountryCode | char(3) | NO | MUL | | || District | char(20) | NO | | | || Population | int(11) | NO | | 0 | |+-------------+----------+------+-----+---------+----------------+5 rows in set (0.65 sec) 使用 show create table 表名; 查看表的字符集。 创建创建表的语法为 create table 表名(列名1 数据类型1, ..., 列名n 数据类型n); MySQL 中常用的数据类型有 int 整数类型 double 浮点数类型，接收两个参数，如 double(5,2)，5 代表数字的总长度，2 代表小数点后的位数 date 日期类型，格式为 yy-MM-dd datetime 日期类型，格式为yy-MM-dd HH:mm:ss timestamp 时间戳，格式为yy-MM-dd HH:mm:ss，当不赋值或赋值为NULL时，自动使用当前的时间作为值 varchar 字符串类型，接收一个参数表示字符串的最大长度，如 varchar(20) 现在我们在 db1 中创建一个 student 表 use db1; -- 使用数据库db1create table student(name varchar(10), age int, score double(4,1), insert_time timestamp); -- 创建表student 里面包括name age score insert_time 等列desc student; -- 查看student表的结构 +-------------+-------------+------+-----+-------------------+-----------------------------+| Field | Type | Null | Key | Default | Extra |+-------------+-------------+------+-----+-------------------+-----------------------------+| name | varchar(10) | YES | | NULL | || age | int(11) | YES | | NULL | || score | double(4,1) | YES | | NULL | || insert_time | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |+-------------+-------------+------+-----+-------------------+-----------------------------+4 rows in set (0.07 sec) 删除同删除数据库一样，有两种用法 drop table 表名;drop table if exists 表名; 这里不多做解释。 修改 重命名表名 alter table 表名 rename to 新表名; 修改表的字符集 alter table 表名 character set 字符集; 添加一列 alter table 表名 add 列名 数据类型; 修改列名及其类型 alter table 表名 change 列名 新列名 新数据类型; 修改列的数据类型 alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; DMLDML 是与修改数据有关的 sql 语句。修改数据主要包括的是增删改数据。为了查看修改数据的效果，这里介绍一个查询数据的命令 select * from 表名; 现在创建一个 student 的表 CREATE TABLE student ( name varchar(10), -- 名字长度最大10个字符 age int, -- 年龄 math_score double(3,1), -- 数学成绩 english_score double(3,1), -- 英语成绩 insert_time timestamp -- 数据加入的时间); DESC student; -- 查看表的结构 添加数据向表中添加数据的写法为 insert into 表名(列名1, 列名2, ..., 列名n) values(值1, 值2, ..., 值n); -- 列名和值要一一对应 例如向表中添加数据 INSERT INTO student (name, age, math_score, english_score) VALUES ('dilireba', 27, 60, 70);INSERT INTO student (name, age, math_score, english_score) VALUES ('gulinazha', 28, 62, 68); 使用 SELECT * FROM student; 得到数据为 注意： 列名和值名要一一对应 如果表名后不定义列名，则默认为给所有列添加，如 INSERT INTO student VALUES (&#39;dilireba&#39;, 27, 60, 70); 除了数字类型，其他类型要用引号(&#39;)括起来 删除数据删除数据的格式为 delete from 表名 [where 条件]; -- 删除满足条件的行 其中 [] 代表的是里面的内容可省略，如果不加条件的话，默认为删除表中的所有数据，现在我们删除上例中 age &gt; 27 的行，如下 DELETE FROM student WHERE age &gt; 27; 得到的结果为 如果要删除表中的所有数据的话，不推荐使用 delete from 表名; 因为它会将表中的数据一行一行的删除，效率较慢，推荐使用 truncate table 表名; 它会直接删除这个表，然后创建一个空表，这个表的名字和结构与删除的表相同，从效果上就相当于是删除了表中所有的数据，但是它的效率比 delete from 表名; 快。 更新数据更新数据的语法为 update 表名 set 列名1 = 值1, ..., 列名n = 值n [where 条件]; -- 当符合条件时，更新值 如何省略条件，那么会修改所有的行，如现在我要更新，如何符合条件 age = 27，那么将 age 修改为 28，如下 UPDATE student set age = 28 WHERE age = 27; DQL查询数据的基本语法为 SELECT 字段列表FROM 表名列表WHERE 条件列表GROUP BY 分组字段HAVING 分组后的条件限定ORDER BY 排序LIMIT 分页限定 下面会详细的讲解其中各个关键字的意思。创建一个 student 表如下 CREATE TABLE student ( id int, -- 编号 name varchar(20), -- 姓名 age int, -- 年龄 sex varchar(5), -- 性别 address varchar(100), -- 地址 math int, -- 数学 english int -- 英语); 向其中插入以下数据 INSERT INTO student(id,name,age,sex,address,math,english) VALUES (1,'马云',55,'男', '杭州 ',66,78), (2,'马化腾 ',45,'女 ','深圳 ',98,87), (3,'马景涛 ',55,'男 ','香港 ',56,77), (4,'柳岩',20,'女 ','湖南 ',76,65), (5,'柳青 ',20,'男 ','湖南 ',86,NULL), (6,'刘德华 ',57,'男 ','香港',99, 99), (7,'马德',22,'女','香港',99,99), (8,'德玛西亚',18,'男','南京',56,65); 如果提示 Incorrect string value: '\\xE9\\xA9\\xAC\\xE4\\xBA\\x91' for column 'name' at row 1 那么就是因为字符编码的问题，这时可以修改 name,address,sex 的字符集为 utf8 alter table student change name name char(20) character set utf8;alter table student change address address char(100) character set utf8;alter table student change sex sex char(5) character set utf8; 基础查询查询多个字段SELECT name, age FROM student; -- 查询name和age字段 去重查询 address 字段时，发现有相同的，如”香港” SELECT address FROM student; 如果希望重复出现的只出现一次，那么可以使用 DISTINCT SELECT DISTINCT address FROM student; 计算列现在要计算它们的数学成绩和英语成绩的和 SELECT name, math, english, math+english FROM student; -- 为了看出是谁的总分，这里加上一个name字段 我们发现第 5 行的结果为 null，这是因为 null+ 其它数得到的结果都是 null，但是这里我们应该把 null 当做 0 处理 ，这样加出来的就是总分，而不是 null SELECT name, math, english, math+ifnull(english,0) FROM student; 这里使用了 ifnull(english,0)，如果 english 的值是 null，那么就替换为 0，所以我们得到的结果为 起别名我们注意到上面的最后一列的列名为 math+ifnull(english,0)，这个列名没有什么意义，我们应该为它起个别名，如 score SELECT name, math, english, math+ifnull(english,0) AS score FROM student; 其中 AS 作为一个起别名的作用，AS 其实可以省略，使用空格替代即可，如 SELECT name, math, english, math+ifnull(english,0) score FROM student; 该句得到的结果与上面的相同 条件查询我们使用 WHERE 来指明条件查询，比如我要查询年龄在 20 岁以上的 SELECT name,age FROM student WHERE age &gt; 20; 可见 WHERE 后面跟的是一个逻辑值，既然是逻辑值就可以使用与或非运算 AND OR NOT SELECT name,age FROM student WHERE age &gt; 20 AND age &lt; 50; -- 年龄在20-50之间的 我们可以使用 BETWEEN ... AND ... 来简化上面的操作 SELECT name,age FROM student WHERE age BETWEEN 20 AND 50; -- 在20-50之间，包括20和50 SELECT name,age FROM student WHERE age = 18 OR age = 20 OR age = 25; -- 查询年龄为18或20或25的 我们可以使用 IN 达到相同的效果 SELECT name,age FROM student WHERE age IN (18,20,25); -- 查询年龄为18或20或25的 排序查询使用 ORDER BY 来对查询结果进行排序，后面跟要排序的字段，默认对字段进行升序排序。 ASC：升序 DESC：降序 SELECT name,math FROM student ORDER BY math; -- 默认为升序 SELECT name,math FROM student ORDER BY math DESC; -- 降序 ORDER BY 可以对多个字段进行排序，先对前面的字段进行排序，如果前面的字段相同，在根据后面的字段排序，比如按照数学和英语成绩排名，优先按数学成绩来，如果数学成绩相同则按英语成绩来 SELECT name,math,english FROM student ORDER BY math DESC, english DESC; 模糊查询使用 LIKE 进行模糊查询，比如记不住全称，这时可以使用模糊查询，比如想查询姓马的，在查询之前要介绍占位符 _：表示单个任意字符 %：表示多个任意字符 SELECT name FROM student WHERE name LIKE '马%'; 如果我想查询名字中带有”德”字的 SELECT name FROM student WHERE name LIKE '%德%'; 聚合函数聚合函数将一列作为整体，进行纵向计算。聚合函数有 count：统计个数，不包括 NULL。 max：计算最大值 min：计算最小值 sum：计算总和 avg：计算平均值 SELECT count(math) FROM student;SELECT max(math) FROM student;SELECT min(math) FROM student;SELECT sum(math) FROM student;SELECT avg(math) FROM student; 分组查询使用 GROUP BY 进行分组查询，比如我想男生和女生的数学平均分，那么可以使用 SELECT sex,avg(math) avg -- avg是别名FROM student GROUP BY sex; 如果我想对分数在 70 以上的人计算平均分，并且统计人数，可以这么写 SELECT sex,avg(math) avg, count(id) count -- avg和count是别名FROM student WHERE math &gt; 70 GROUP BY sex; 如果分组后的还要进行筛选，那么可以使用 HAVING，比如这里我要筛选分组后人数大于 2 的才进行统计 SELECT sex,avg(math) avg, count(id) countFROM studentWHERE math &gt; 70GROUP BY sexHAVING count(id) &gt; 2; 分页查询当我们查询数据时，如果我们一页只能显示几行数据，我们就要进行分页查询，使用 LIMIT，后面跟两个数，第一个数代表查询的起始位置，从 0 开始，第二个代表一页显示的行数，如 SELECT *FROM studentLIMIT 0,3; -- 查询中0开始的3行数据 如果我们要查询第二页，可以怎么写 SELECT *FROM studentLIMIT 3,3; 约束所谓约束就是对数据产生限制，比如说某列不能为空(NULL)，有或者说某列的数据不能重复。约束一般包括下面四种约束 非空约束(not null) 唯一约束(unique) 主键约束(primary key) 外键约束(foreign key) 非空约束所谓的非空约束指的就是该列不能有 NULL 值，下面介绍如何创建非空约束，分为两种情况，一种是在创建表示添加非空约束，一种是在创建表之后添加非空约束 创建表示添加非空约束 CREATE TABLE emp( id int, name varchar(10) not null); -- 为name添加非空约束 name不能为NULL 如果此时为 name 赋值为 NULL，那么这条语句将会报错 INSERT INTO emp(id,name) VALUES (0,NULL); -- 为name赋值为NULL 将会报错 Column 'name' cannot be null 在创建表后添加非空约束 如现在给 id 也添加非空约束，应当这么写 ALTER TABLE emp MODIFY id int not null; -- 为id添加非空约束 删除非空约束 删除的办法与添加的语法差不多，如现在我又要删除 id 的非空约束，应当这么写 ALTER TABLE emp MODIFY id int; -- 删除id的非空约束 唯一约束唯一约束指的是该列的值不能相同，关键字为 unique。 创建表时如何添加唯一约束 CREATE TABLE emp( id int UNIQUE, name varchar(10)); -- 为name添加非空约束 name不能为NULL 创建表后添加唯一约束 ALTER TABLE emp MODIFY id int UNIQUE; 删除唯一约束 删除唯一约束的语法与删除非空约束的语法不同，如下 ALTER TABLE emp DROP INDEX id; 主键约束主键约束(primary key)是上面两个的总和，即该列既不能为 NULL，也不能相同。一张表只能有一个字段为主键。 创建表时添加主键 CREATE TABLE emp( id int PRIMARY KEY, name varchar(10)); 创建表后添加主键 ALTER TABLE emp MODIFY id int PRIMARY KEY; 删除主键 ALTER TABLE emp DROP PRIMARY KEY ; -- 因为主键只有一个，不必指明是哪个字段 下面介绍一个小知识点，主键自动增长，当我们添加数据时，如果我们设置了主键增长并且没有为主键赋值，那么主键的值会相较于上一条数据主键的值增长，设置主键自动增长的语法为(假设设置(了) id 为主键) CREATE TABLE emp( id int PRIMARY KEY AUTO_INCREMENT, -- 创建表时添加 name varchar(10) ); ALTER TABLE emp MODIFY id int AUTO_INCREMENT; -- 创建表后添加 id已经设置为主键了 删除主键增长的方法为 ALTER TABLE emp MODIFY id int; -- 这样是不会删除主键的，只会删除主键自动增长 外键约束假设有这么一张表 观察研发部门和部门地点，发现数据冗余很严重，并且在后续添加数据中添加的也是这么一对一对的，很麻烦并且有在添加数据可能会出错，所以我们可以把这张表拆成两张表，如下 现在问题是怎么将这两张表联系起来，答案就是外键约束。那么什么是外键，从表(被别人约束的表)中与主表(用来约束别人的表)主键对应的那一列，如：员工表中的 dep_id。 新建表时增加外键 [CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名) 创建表后添加外键 ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名); 比如我在创建 employee 表时添加外键 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20), age INT, dep_id INT, -- 外键对应主表的主键 CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id)); employee 表已经存在的情况下添加外键 ALTER TABLE employee ADD CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id); 删除外键 -- 删除 employee 表的 emp_depid_fk 外键ALTER TABLE employee DROP FOREIGN KEY emp_depid_fk; 这个时候又会出现新的问题，比如我改变主表中 id=1 为 id=5，但是这时是不会成功的，因为如果改了，从表中的 dep_id 便没有对应的值，这个时候就需要级联操作(在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作)。 ON UPDATE CASCADE 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新 ON DELETE CASCADE 级联删除 create table employee( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 -- 创建外键约束 constraint emp_depid_fk foreign key (dep_id) references department(id) on update cascade on delete cascade); 三大范式设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式 ： 第一范式(1NF) 、第二范式(2NF) 、第三范式(3NF) 、巴斯-科德范式(BCNF) 、第四范式(4NF)和第五范式(5NF，又称完美范式) 。满足最低要求的范式是第一范式(1NF) 。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF) ，其余范式以次类推。一般说来，数据库只需满足第三范式(3NF)就行了。 为了理解三大范式，我们首先来看这么一张表 我们首先来看第一范式的概念：数据库表的每一列都是不可分割的原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。上面的那个表不满足第一范式，因为系的那一列被拆成了两列，我们将它拆分成不同的列 它现在满足第一范式的要求了，接下来看第二范式的概念：在1NF的基础上，非码属性必须完全依赖于码。为了理解这句话的意思，先看下面几个概念： 函数依赖：A=&gt;B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值。则称 B 依赖于 A 例如：学号=&gt;姓名。(学号，课程名称) --&gt; 分数 完全函数依赖：A=&gt;B， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。 例如：(学号，课程名称) =&gt; 分数 部分函数依赖：A=&gt;B， 如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可。 例如：(学号，课程名称) --&gt; 姓名，只依靠学号 传递函数依赖：A=&gt;B, B=&gt;C . 如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A 例如：学号 =&gt; 系名，系名 =&gt; 系主任 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：(学号，课程名称) 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 其实 2NF 就是在 1NF 基础上消除非主属性对主码的部分函数依赖，上表中的码为(学号，课程名称)，只有分数完全依赖该码组，所以我们拆分表如下， 第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖)，在学生表中存在学号 =&gt; 系名 =&gt; 系主任的传递依赖，所以再次拆分表 三大范式小结 1NF: 原子性，表中每列不可再拆分。 2NF: 不产生局部依赖，一张表只描述一件事情 3NF: 不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其它列间接依赖于主键。 多表查询多表查询顾名思义就是同时查询多张表，假设有下面这么两张表(第一张是职员(emp)表，第二张是部门(dept)表) 现在我们同时查询这两张表 SELECT *FROM emp, dept; 我们将得到下面这么一张表 这张表的结果是两张表一一组合得到的，得到的结果也叫做笛卡尔积，我们可以看到很有的信息都是错误的，我们的目的就是去除这些无用的信息。 内连接用左边表的记录去匹配右边表的记录，如果符合条件的则显示。内连接分为 隐式内连接 使用 WHERE 条件指定 显示内连接 使用 INNER JOIN ... ON 语句 比如现在我要在上面的笛卡尔积中筛选出 emp 表外键 dept_id 等于主表主键 id 的，那么分别使用隐式内连接和显式外连接的写法为 #隐式写法SELECT *FROM emp, deptWHERE emp.dept_id = dept.id; #显式写法SELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id; 外连接为了演示外连接，在上面的部门表中新加入一个销售部 外连接分为 左外连接 右外连接 两者只要掌握一种即可，因为用另一种时，将二表的顺序交换即可。那什么是左外连接，就是在内连接的基础上，以左表为基准，显示左表的所有内容，如果右表没有对应的内容，那么显示为 NULL，现在我们进行一次内连接查询 SELECT * FROM dept INNER JOIN emp e ON e.dept_id = dept.id; # e是emp的别名 现在我们进行一次左外连接查询 SELECT * FROM dept LEFT JOIN emp e ON dept.id = e.dept_id; 因为左外连接查询是以左表(dept)为基准，左表的内容会全部显示出来，即销售部会被查询出来，而对应的员工表没有对应的元素，所以会显示空 而右外连接与左外连接相反，是以右表为基准，现在如果我们将二表的位置交换，并且使用右外连接查询，得到的结果与上面的会是相同的 SELECT * FROM emp e RIGHT JOIN dept d ON e.dept_id = d.id; 子查询所谓的子查询是指将查询得到的结果作为另一个查询语句的条件，比如我想查出薪资最高员工的信息，那么思路如下 查出最高的薪资是多少 匹配谁的薪资为最高薪资 那么第一步查出的最高薪资就作为了第二步进行匹配的条件 SELECT * FROM emp t1 WHERE t1.salary = (SELECT max(salary) FROM emp); 子查询得到的结果有多种，例如 单行单列 单列多行 多行多列的值(表) 当结果是单个列的值的时候，肯定在 WHERE 后面作为条件，父查询使用比较运算符，如：&gt; 、&lt;、&lt;&gt;、 = 等。现在我要查询小于平均薪资的人有哪些，那么可以这么写 SELECT * FROM emp t1 WHERE t1.salary &lt; (SELECT avg(salary) FROM emp); 子查询结果是单列多行，结果集类似于一个数组，父查询使用 IN 运算符。查询工资大于5000的员工，来自于哪些部门 SELECT t1.nameFROM dept t1WHERE t1.id IN (SELECT emp.dept_id FROM emp WHERE emp.salary &gt; 5000); 子查询结果只要是多列，肯定在FROM后面作为表 SELECT 查询字段 FROM （子查询）表别名 WHERE 条件; 子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段。查询出2011年以后入职的员工信息，包括部门名称 SELECT *FROM (SELECT * FROM db1.emp t1 WHERE t1.join_date &gt; \"2011-1-1\") t3, dept dWHERE d.id = t3.dept_id; 事务所谓事务是指一系列的操作，这些操作要么同时成功，要么同时失败。比如转账，不能我这里转账成功，你那么收不到钱，那么钱就这么消失了? 如果事务执行成功了，那么就提交，如果有一条失败了，那么就需要进行回滚(即回到之前的状态)。与事务有关的三条语句为 start transaction 开启事务 commit 提交事务 可手动提交，也可设置为自动提交 roll back 回滚事务 当事务执行失败时自动自动，也可手动执行 假设有这么一张表，里面存储的是用户名和余额信息 现在张三要向李四转账 500 块，如下 -- 张三账号-500 update account set balance = balance - 500 where name='张三'; -- 李四账号+500 update account set balance = balance + 500 where name='李四'; 如果我们不开启事务的话，那么当张三转了 500 块时，这时服务器崩溃了，李四没有收到钱，但是钱还是少了，这种情况是不能发生的，我们应当开启一个事务，这两个操作要么同时成功，要么同时失败。 START TRANSACTION; -- 开启一个事务-- 张三账号-500update account set balance = balance - 500 where name='张三';-- 李四账号+500update account set balance = balance + 500 where name='李四';COMMIT; -- 提交事务 开启事务后，所有的操作都在临时日志文件中，commit 操作是将临时日志中的内容写到数据库的存储引擎中，所以在提交事务之前，是不会对数据库中的内容进行修改的。而 rollback 则是清空临时日志文件，之前没有进行提交的内容全部清除。 事务的步骤可以简述为下面几步 客户端连接数据库服务器，创建连接时创建此用户临时日志文件 开启事务以后，所有的操作都会先写入到临时日志文件中 所有的查询操作从表中查询，但会经过日志文件加工后才返回 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件 事务的提交分为自动提交和手动提交，在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 事务的特性事务的四大特性 ACID 原子性(Atomicity) 每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都失败。 一致性(Consistency) 事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前 2 个人的 总金额是 2000，转账后 2 个人总金额也是 2000 隔离性(Isolation) 事务与事务之间不应该相互影响，执行时保持隔离的状态。 持久性(Durability) 一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 这篇文章MySQL事务：ACID特性的实现原理总结分析详细讲解了 MySQL 的事务，所以在这里我不多做介绍，因为讲的没人家好。 事务的隔离级别事务在操作时的理想状态是所有的事务之间保持隔离，互不影响。但是因为并发操作，多个用户同时访问同一个数据时，可能引发并发访问的问题，如 脏读 一个事务读取到了另一个事务中尚未提交的数据 比如李四向张三转了 500 块，但是没有提交，这时张三读取数据，发现已经到账 500 块，跟李四说到账了，这时李四进行 roll back 不可重复读 一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这是事务 update 时引发的问题 两次查询输出的结果不同，到底哪次是对的? 不知道以哪次为准。 有的时候这不是一个问题，当然是后面的为准。但是我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和发短信给客 户，结果在一个事务中针对不同的输出目的地进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作 人员就不知道以哪个为准了。 脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据 幻读 一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致的，这是 insert 或 delete 时引发的问题 幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从 “1” 修改为 “2” 的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 “1” 并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体(比如数据的个数)。 MySQL数据库有四种隔离级别 read uncommitted 上面三种问题都有可能发生 read committed 不可能发生脏读，因为只有读到已提交的数据 repeatable read 可能发生幻读 这时 MySQL 的默认隔离级别 serializable 所有的问题都不会发生 上面的级别最低，下面的级别最高，隔离级别越高，性能越差，安全性越高。在 MySQL 数据库中设置事务的隔离级别 set [glogal | session] transaction isolation level 隔离级别名称;set tx_isolation='隔离级别名称'; 权限管理我们现在默认使用的都是 root 用户：超级管理员，拥有全部的权限。但是一个公司里面的数据库服务器上面可能同时运行着很多个项目的数据库。所以我们应该可以根据不同的项目建立不同的用户，分配不同的权限来管理和维护数据库。 创建用户CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; ‘用户名’ 将创建的用户名 ‘主机名’ 指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以 从任意远程主机登陆，可以使用通配符% 该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 #创建 user1 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123 create user 'user1'@'localhost' identified by '123'; #创建 user2 用户可以在任何电脑上登录 mysql 服务器，密码为 123 create user 'user2'@'%' identified by '123'; 创建的用户名都在 mysql 数据库中的 user 表中可以查看到，密码经过了加密。 授予权限GRANT 权限 1, 权限 2... ON 数据库名.表名 TO '用户名'@'主机名'; GRANT…ON…TO 授权关键字 权限 授予用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等。如果要授 予所有的权限则使用 ALL 数据库名.表名 该用户可以操作哪个数据库的哪些表。如果要授予该用户对所有数据库和表的相应操作 权限则可用 * 表示，如 *.* ‘用户名‘@’主机名’ 给哪个用户授权 #给 user1 用户分配对 test 这个数据库操作的权限：创建表，修改表，插入记录，更新记录，查询 grant create,alter,insert,update,select on test.* to 'user1'@'localhost'; #给 user2 用户分配所有权限，对所有数据库的所有表 grant all on *.* to 'user2'@'%'; 撤销权限REVOKE 权限 1, 权限 2... ON 数据库.表名 from '用户名'@'主机名'; REVOKE…ON…FROM 撤销授权的关键字 权限 用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等，所有的权限则使用 ALL 数据库名.表名 对哪些数据库的哪些表，如果要取消该用户对所有数据库和表的操作权限则可用*表 示，如*.* ‘用户名‘@’主机名’ 给哪个用户撤销 #撤销 user1 用户对 test 数据库所有表的操作的权限 revoke all on test.* from 'user1'@'localhost'; 查看权限SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'root'@'localhost'; 删除用户DROP USER '用户名'@'主机名'; 修改管理员密码如果忘了原来的管理员密码 cmd --&gt; net stop mysql 停止 mysql 服务 需要管理员运行该 cmd 使用无验证方式启动 mysql 服务：mysqld --skip-grant-tables 打开新的 cmd 窗口,直接输入 mysql 命令，敲回车。就可以登录成功 use mysql; update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;; 关闭两个窗口 打开任务管理器，手动结束 mysqld.exe 的进程 启动 mysql 服务 使用新密码登录。 如果记得原来的密码 mysqladmin -uroot -p password 新密码 #需要在未登陆 MySQL 的情况下操作，新密码不需要加上引号。 修改普通用户密码set password for '用户名'@'主机名' = password('新密码'); 参考链接 数据库隔离级别，每个级别会引发什么问题 MySQL事务：ACID特性的实现原理总结分析 MySQL数据查询之多表查询 MySQL插入中文错误","tags":[{"name":"数据库","slug":"数据库","permalink":"https://lastknightcoder.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lastknightcoder.gitee.io/tags/MySQL/"}]},{"title":"Java Web笔记","date":"2019-08-19T16:00:00.000Z","path":"/JavaWeb/","text":"TomcatWeb服务器软件 服务器：安装了服务器软件的计算机 服务器软件：接收用户请求，处理请求，做出响应 Web服务器软件：用户通过浏览器进行访问我们部署的项目 webLogic：oracle公司，大型JavaEE服务器，收费，支持所有的JavaEE规范 webSphere：IBM公司，大型JavaEE服务器，收费，支持所有的JavaEE规范 JBOSS：JBOSS公司，大型JavaEE服务器，收费，支持所有的JavaEE规范 Tomcat：Apache基金组织，中小型JavaEE服务器，仅仅支持少量的JavaEE规范，开源的，免费的 下载、安装、卸载下载：tomcat.apache.org(Tomcat 8) 安装：解压压缩包即可(路径不要含中文) 卸载：删除文件夹 bin 可执行文件conf 配置文件lib 依赖jar包logs 日志文件temp 临时文件webapps 存放web项目的work 运行时数据LICENSENOTICERELEASE-NOTESRUNNING.txt 启动 双击bin/startup.bat 访问：127.0.0.1:8080，有页面说明访问成功(127.0.0.1可写为localhost) 启动遇到的问题 黑窗口一闪而过 原因：没有配置JAVA_HOME 在环境变量中新建JAVA_HOME，值为jdk的路径，不包括bin目录 然后将PATH中的…/bin(jdk的路径)改为%JAVA_HOME%/bin 启动报错 原因：端口被占用，两种方法 找到占用8080端口的进程杀死 修改自身的端口号 conf/server.xml文件 修改port 一般会将tomcat的默认端口号修改为80(浏览器默认端口号) 关闭 正常关闭 shutdown.bat Ctrl + C 强制关闭 部署项目 直接将项目(这里假设为hello)放到webapps文件夹中即可 */hello：项目的访问路径，虚拟路径 简化部署：打包为war包，将war包复制到webapps下，war包会自动解压缩 缺点：必须拷贝到webapps中 config/server.xml &lt;Host ...&gt; ... &lt;Context docBase=\"项目路径\" path=\"虚拟路径\" /&gt;&lt;/Host&gt; 缺点：不安全，弄坏配置文件 /conf/Catalina/localhost 创建一个文件xxx.xml(任意名称) 编写&lt;Context docBase=”项目路径” /&gt; 虚拟目录就是xml文件的名称 Java动态项目的目录结构 根目录 WEB-INF web.xml：web项目的核心配置文件 classes：放置字节码文件的目录 lib：放置依赖的jar包 Tomcat集成到IDEA中Run –&gt; Edit Configurations -&gt; Defaults -&gt; Tomcat Server -&gt; Local -&gt; Configure -&gt; Tomcat安装目录 Servlet(server applet)概念Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat)识别的规则。 快速入门 创建JavaEE项目 定义一个类实现Servlet接口 实现接口中的抽象方法 配置Servlet package web;import javax.servlet.*;import java.io.IOException;public class ServletDemo01 implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //只写了这一行 System.out.println(\"Hello Servlet\"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 配置Servlet(web.xml) &lt;!--Servlet配置--&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;servlet-class&gt;web.ServletDemo01&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet执行原理 解析URL请求路径，获取Servlet的资源路径 查找web.xml中是否有对应的&lt;url-pattern&gt;标签内容 查找&lt;servlet-class&gt;全类名 tomcat将字节码文件加载进内存，并且创建其名称 调用其方法 Servlet生命周期方法init 在Servlet创建时执行，只会执行一次 默认情况第一次被访问时创建Servlet 配置&lt;servlet&gt;下的&lt;load-on-startup&gt;可修改Servlet创建时机 负数，第一次被访问时创建 0或正数，服务器启动时创建 Servlet是单例的 多个用户同时访问时，可能存在线程安全问题 解决：尽量不要在Servlet中定义成员变量，定义了成员变量，也不要进行赋值 service 提供服务的方法，每一次Servlet访问时执行 destroy Servlet被杀死时被执行(服务器被正常关闭时) 在Servlet被销毁之前执行 getServletConfig(了解) 获取Servlet的配置对象 getServletInfo(了解) 获取Servlet的信息(版本、作者…) Servlet3.0注解配置Servlet3.0 支持注解配置 创建JavaEE项目，勾选servlet3.0以上版本，可以不勾选web.xml 定义类实现Servlet接口，实现方法 在类上使用@WebServlet注解 @WebServlet(“资源路径”) Servlet体系结构Servlet –&gt; GenericServlet –&gt; HttpServlet GenericServlet：将Servlet接口除service()外进行了空实现，只对service()进行了抽象 HttpServlet：对http协议封装，简化操作 doGet() doPost() Servlet url_pattern配置可以定义多个访问路径：@WebServlet({“/d4”,”/dd4”,”/ddd4”}) /xxx /xxx/xxx(目录结构) /xxx/*(*是通配符，优先级较低) *.do(*表示任意，.do代表后缀名，如/demo4.do) HTTP规定请求消息和响应消息的格式。 特点： 基于TCP/IP的高级协议 默认端口号：80 基于请求响应模型，一次请求对应一次响应 无状态的：每次请求相互独立 历史版本： 1.0：每一次请求响应会建立新的连接 1.1：复用连接 请求消息数据格式 请求行 请求头 请求空行 请求体 请求方式(七种，只介绍常见两种)： GET： 参数在请求行中，在url后 请求的url长度有限制 不太安全 POST 参数在请求体中 请求的url长度没有限制 相对安全 请求头： Host：主机 User-Agent：使用的浏览器版本信息 Accept：可以接受什么格式 Accept-Language：可接受的语言 Referer：告诉服务器我从哪里来，作用 防盗链 统计信息 Connection：keep-alive(连接不会断开，可复用) 请求正文： 封装POST请求消息的请求参数的 RequestRequest和Response原理： tomcat根据url创建对应的Servlet对象 tomcat服务器会创建request和response对象，request对象中封装的是请求消息数据 tomcat将request和response传递给service方法，并调用service方法 程序员通过request对象获取请求消息数据，通过response对象设置响应数据 服务器在做出响应之前，会用response对象中拿程序员设置的响应消息数据 Request继承结构： ServletRequest(接口) –&gt; HttpServletRequest(接口) –&gt; RequestFacade(类，Tomcat编写) 获取请求消息数据 获取请求行 格式：GET 虚拟路径/Servlet路径?参数 HTTP/1.1 获取请求方式：getMethod 获取虚拟目录：getContextPath 获取Servlet路径：getServletPath 获取请求参数：getQueryString 获取URI：getURI 获取URL：getURL 获得协议及版本：getProtocol 获取客户机的IP地址：getRemoteAddr URL &lt; URI 获取请求头 通过请求头的名称获取请求头的值：getHeader(String name) 获取所有的请求头名称：Enumeration&lt;String&gt; getHeaderNames() 获取请求体 获取流数据 字符流：BufferedReader getReader() 字节流：ServletInputStream getInputStream() 再从流对象中 其他功能 获取请求方法通用方式(get和post都可以) String getParameter(String name)：根据参数名称获取参数值 String[] getParameterValues(String name)：根据参数名称获取参数值的数组(多用于复选框) Enumeration getParameterNames()：获取所有请求的参数名称 Map&lt;String, String[]&gt; getParameterMap：获取所有参数的Map集合 中文乱码问题： get：tomcat 8已经解决 post：设置流的编码 resquest.setCharacterEncoding(“utf-8”) 请求转发：一种在服务器内部的资源跳转的方式 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径没有发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享对象 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法 setAttribute(String name, Obkect obj)：存储数据 Object getAttribute(String name)：通过键获取值 void removeAttribute(String name)：删除键值对 获取ServletContext ServletContext getServletContext() 开发步骤： 创建项目，导入html，配置文件，jar包 创建数据库环境，User表 创建实体类User 创建UserDao，操作数据库中User表的类 BeanUtils简化数据封装 Map&lt;String String[]) map = req.getParameterMap();User user = new User();BeanUtils.populate(loginUser, map); 响应消息数据格式 响应行 响应头 响应空行 响应体 响应行： 协议以及版本：HTTP/1.1 响应状态码：200 1xx：服务器接客户端消息但是没有接收完成，一段时间后服务器向客户端询问是否还有数据发送 2xx：成功。 200 3xx：重定向。 302(重定向) 304(访问缓存) 4xx：客户端错误。 404(请求路径没有对应的资源) 405(请求方式没有对应的doXxx方法) 5xx：服务器端错误。 500(服务器内部出现异常) 状态码的描述：OK 响应头： 格式 名称：值 常见响应头 Content-Type：服务器告诉客户端响应体数据格式以及编码格式 Content-disposotion：服务器告诉客户端以什么格式打开我的响应体 in-line：默认值，在当前页面打开 attachment：以附件形式打开(文件下载) 响应体： 真实传输的数据 Response功能：设置响应消息的 设置响应行 设置状态码：setStatus(int sc) 设置响应头： setHeader(String name, String value) 设置响应体 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 重定向： 设置状态码302 设置响应头location 简单重定向方法： sendRedirect(String url) 重定向的特点： 地址栏发生变化 可以访问其他站点(服务器)的资源 两次请求(不可用Request域对象共享数据) 路径写法： 相对路径：当前资源与访问资源的路径关系(./index.html = index.html) 绝对路径：(/responseDemo2) 给客户端浏览器使用(a标签，表单，重定向等)：需要加虚拟目录(项目访问路径) req.getContextPath：动态获取虚拟目录 给服务器端使用：不需要加虚拟目录(如转发) 输出字符/字节： 乱码问题：浏览器默认以GBK解码(与操作系统有关，Windows在中文环境下是GBK) response.setHeader(\"content-type\", \"text/html;charset=utf-8\");//简便写法response.setContentType(\"text/html;charset=utf-8\"); 验证码： int width = 100;int height = 50;//设置图片的宽高和类型BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);//美化图片//获取画图对象Graphics g = image.getGraphics();//设置背景色g.setColor(Color.PINK);g.fileRect(0, 0, width, height);//设置边框色以及绘制g.setColor(Color.BLUE);g.drawRect(0,0 width - 1, height - 1);//获取随机字符并绘制String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";Random ran = new Random();for (int i = 1; i &lt;= 4; i++) &#123; index = ran.nextInt(str.length()); char ch = str.charAt(index); g.drawString(ch+\"\", 20*i, 25);&#125;//设置干扰线g.setColor(Color.GREEN);for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextIne(height); g.drawLine(x1, y1, x2, y2);&#125;//绘制到浏览器中ImageIO.writer(image, \"jpg\", response.getOutputStream()); ServletContext概念：代表整个Web应用，可以和程序的容器来通信。 获取： request对象获取：request.getServletContext() HttpServlet的方法：this.getServletContext() 功能： 获取MIME类型 MIME：互联网通信过程中定义的一种文件数据类型 格式：大类型/小类型(text/html image/jpeg) String getMimeType(String file) String fileName = \"a.jpg\"; String mimeType = servletContext.getMimeType(fileName); &lt;!--￼8--&gt; Cookie 会话： 概念：一次会话(浏览器第一次发生请求，直到一方断开)包含多次请求和响应 功能：一次会话的多次请求间共享数据 方式： 客户端：Cookie 服务器：Session 将数据保存到客户端，使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie,得到数据 Cookie[] request.getCookies() package web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo\")public class CookieDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie c = new Cookie(\"msg\", \"hello\"); response.addCookie(c); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; package web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo2\")public class CookieDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); String value = cookie.getValue(); System.out.println(name + \": \" + value); &#125; &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 实现原理： response发送响应头：set-cookie:msg=hello request发送请求头：Cookie:mas=hello 细节： 一次可不可以发送多个Cookie 可以 Cookie能在浏览器中保存多长的时间 默认：浏览器关闭时Cookie数据被销毁 持久化存储： cookie.setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中，数值表示存活时间 负数：默认值 0：删除Cookie信息 Cookie能不能存中文 Tomcat 8之前不能直接存储中文信息，Tomcat 8之后可以 Cookie共享问题 一个Tomcat服务器部署了多个web项目，在这些项目中cookie能不能共享 默认不能共享 setPath(String path)：设置Cookie的获取范围，默认情况设置当前的虚拟目录 不同的Tomcat服务器间Cookie共享问题 setDomain(String path)：如果一级域名相同，那么多个服务器之间Cookie可以共享 特点： Cookie存储数据在浏览器 浏览器对于单个Cookie的大小有限制(4KB)，数目也有限制(20个) 作用： 一般用于存在少量不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次登录时间 package web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLDecoder;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.Date;@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); Cookie[] cookies = request.getCookies(); boolean flag = false; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie cookie: cookies) &#123; String name = cookie.getName(); if (\"lastTime\".equals(name)) &#123; flag = true; String time = cookie.getValue(); time = URLDecoder.decode(time, \"utf-8\"); Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy:MM:dd HH:mm:ss\"); String str_date = sdf.format(date); str_date = URLEncoder.encode(str_date, \"utf-8\"); cookie.setValue(str_date); cookie.setMaxAge(60 * 60 * 24 * 30); response.addCookie(cookie); response.getWriter().write(\"lastTime: \" + time); break; &#125; &#125; &#125; if (flag == false) &#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy:MM:dd HH:mm:ss\"); String str_date = sdf.format(date); str_date = URLEncoder.encode(str_date, \"utf-8\"); Cookie cookie = new Cookie(\"lastTime\", str_date); cookie.setMaxAge(60 * 60 * 24 * 30); response.addCookie(cookie); response.getWriter().write(\"欢迎首次访问\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; Session概念：服务器端会话技术，用以保存一次请求的数据，相关类为HttpSession HttpSession session = request.getSession(); 方法(Session是域对象)： setAttribute getAttribute removeAttribute 原理：Session的实现是依赖于Cookie的 细节： 客户端关闭，服务器不关闭获取的Session是同一个吗 不是 //如果希望是同一个，可以这么写 Cookie c = new Cookie(\"JSESSIONID\", session.getId()); c.setMaxAge(60 * 60); response.addCookie(c); &lt;!--￼12--&gt; JSTL概念：JavaServer Pages Tag Library 作用：简化和替换JSP页面上的Java代码 使用步骤： 导入jar包 引入标签库：taglib指令(&lt;%@ taglib %&gt;) 使用标签 常用标签： if &lt;c:if test=\"\"&gt; &lt;/c:if&gt; choose &lt;c:choose&gt; &lt;c:when test=\"\"&gt;&lt;/c:when&gt; ... ... &lt;c:otherwise&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; forEach &lt;c:forEach begin=\"\" end=\"\" var=\"\" step=\"\"&gt; &lt;/c:forEach&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"str\" varStatus=\"s\"&gt; $&#123;s.index&#125; $&#123;s.count&#125;&lt;/c:forEach&gt; Filter作用： 一般用于完成通用的操作，如登录验证、统一编码处理，敏感字符过滤 入门： 定义类实现接口Filter 实现方法 配置拦截路径 package web;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(\"/*\")public class FilterDemo implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"... ...\"); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo&lt;/filter-name&gt; &lt;filter-class&gt;web.FilterDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 生命周期： init doFilter destroy 过滤器配置： 拦截路径配置 具体路径：/index.jsp 目录拦截：/user/* 后缀名拦截：*.jsp 拦截所有资源：/* 拦截方式配置：资源被访问的方式 注解配置：设置dispatcherTypes属性 REQUEST：默认值，浏览器直接请求资源 FORWORD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 &lt;filter-mapping&gt; &lt;filter-name&gt;demo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;...&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 过滤器链的配置 如果有两个过滤器 Filter1 –&gt; Filter2 –&gt; 资源执行 –&gt; Filter2 –&gt; Filter1 执行顺序问题 注解配置：按照类名的字符串比较规则进行比较，最小的先则执行 AFilter &lt; BFilter(AFilter先执行) web.xml配置：谁定义在上面，谁先执行 代理： 概念 真实对象 代理对象 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 实现方式 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 代理对象和真实对象实现相同的接口 代理对象：Proxy.newProxyInstance() 第一个参数：类加载器 第二个参数：接口数组 第三个参数：处理器 invoke proxy method：代理对象调用的方法，被封装为对象 args：代理对象调用方法时，传递的实际对象 使用代理对象调用方法 Listener事件监听机制 事件源 监听器 注册监听 ServletContextLinstener：监听ServletContext对象的创建和监听 contextDestroyed(ServletXontextEvent sec) contextImitialized(ServletContextEvent sec) 步骤： 定义一个类，实现ServletContextLinstener接口 实现方法 配置 package web;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class ListenerDemo implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; System.out.println(\"服务器启动自动被调用\"); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; System.out.println(\"服务器正常关闭后被调用\"); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://lastknightcoder.gitee.io/tags/Web/"}]},{"title":"JDBC","date":"2019-08-14T16:00:00.000Z","path":"/JDBC/","text":"初识JDBC如果我们要使用Java来操作数据库，由于数据库的种类繁多，并且sql语句并不完全相同，总而言之不同的数据库千差万别，这是不是意味着我们要对不同的数据库写不同的程序，这样的话对程序员的要求有点高，并且学习的成本也很大，所以我们要定义一套规范，要求对所有的数据库程序员只要写相同的程序就可以了。就相当于插座，我们定义好插座的标准，那么所有的商家必须按我的标准来，否则就不能使用插座。同理，在Java中定义好数据库的接口，定义接口中的方法有什么作用，而具体的实现细节则有数据库的厂商进行编写，程序员只要调用接口里面的方法就可以了。这里给出一个摘至维基百科的定义 Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is a Java-based data access technology used for Java database connectivity. 所以使用JDBC的好处便显而易见 程序员如果要开发访问数据库的程序，只需要会调用JDBC接口中的方法即可，不用关注类是如何实现的 使用同一套Java代码，进行少量的修改就可以访问其他JDBC支持的数据库 我们使用Java操作数据库，会使用到数据库的驱动，由各大数据库厂商提供，需要额外去下载，里面是对JDBC接口实现的类，导入驱动jar包的具体的步骤如下 在项目中新建一个libs文件夹 将jar包复制到这个文件夹中 选中这个jar包，右击找到&quot;Add as Library&quot; 上面是导入jar包的通用步骤，后面会经常导入jar包，所以需要熟记。 第一个JDBC程序使用Java操作数据库一般包括下面几步 注册驱动 获得连接数据库的对象 获得执行sql语句的对象 执行sql语句 释放资源(断开连接) 程序如下(具体类后面解释) import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class Demo01 &#123; public static void main(String[] args) throws Exception&#123; //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db1\", \"root\", \"root\"); //创建sql语句 String sql = \"update account set balance = 2000 where id = 1\"; //创建执行sql语句的对象 Statement statement = conn.createStatement(); //执行sql语句 statement.executeUpdate(sql); //释放资源 statement.close(); conn.close(); &#125;&#125; 核心类下面就详细介绍JDBC的核心类(接口)以及它们的功能 DriverManager：驱动管理对象，功能如下 注册驱动：告诉程序该使用哪一个数据库驱动jar包 mysql5之后可以省略注册驱动的步骤，即不需要写Class.forName() 获取数据库连接 static Connection getConnection(String url, String user, String password) url：连接的路径 格式：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数=参数值 例子：jdbc:mysql://localhost:3306/db1 如果ip地址为本机地址且端口号为3306，则上面可省略ip地址和端口号，简写为：jdbc:mysql:///db1 如果出现乱码问题，可以指定参数?characterEncoding=utf8 user：用户名 password：密码 Connection：数据库连接对象，相当于是在Java程序与数据库之间建立了一条通道，功能如下 获取执行sql的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit)，传入false即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象，含有如下方法 boolean execute(String sql)：可以执行任意的sql语句，不常用，了解即可 int executeUpdate(String sql) 执行DML(insert、update、delete)语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql)：执行DQL(select)语句 ResultSet：结果集对象，封装查询结果，数据库通过通道返回的结果 boolean next() 判断游标所指向的行是否为空 getXxx() getXxx(int columnIndex) 根据列数来获得数据 getXxx(int columnLabel) 根据列名称获得数据 这里给出一个使用ResultSet的例子，比如我们要去查询account表 import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class Demo02 &#123; public static void main(String[] args) throws Exception &#123; Class.forName(\"com.mysql.jdbc.Driver\"); Connection conn = DriverManager.getConnection(\"jdbc:mysql:///db1\", \"user\", \"root\"); Statement statement = conn.createStatement(); String sql = \"select * from account\"; ResultSet resultSet = statement.executeQuery(sql); //将查询到的数据打印出来 while (resultSet.next()) &#123; //根据列名查询数据 int id = resultSet.getInt(\"id\"); String name = resultSet.getString(\"name\"); double balance = resultSet.getDouble(\"balance\"); System.out.println(id + \"---\" + name + \"---\" + balance); &#125; resultSet.close(); statement.close(); conn.close(); &#125;&#125; JDBC工具类其实上面的代码并不是十分的规范，因为资源的释放可能不能释放成功，因为前面发生异常就可以导致后面的程序执行不到，这样资源无法释放，就会导致内存越用越少(内存泄漏)，所以我们应当将资源释放的代码写到finally代码块中，如下 import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Demo01 &#123; public static void main(String[] args) &#123; //定义在try代码块外是为了在finally中能够访问 Connection conn = null; Statement statement = null; try &#123; conn = DriverManager.getConnection(\"jdbc:mysql:///db1\", \"root\", \"root\"); statement = conn.createStatement(); String sql = \"update account set balance = 2000 where id = 1\"; statement.executeUpdate(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 这时我们发现代码十分的冗长(特别是资源释放的部分)，并且每次写代码都会重复这些，再者程序所连接的数据库是写死的，如果需要改变的话还需要改动程序，我们可以将这些信息写在一个jdbc.properties的配置文件中，如果有改动直接改动配置文件即可 url=jdbc:mysql:///db1user=rootpassword=rootdriver=com.mysql.jdbc.Driver 将上面的这些操作抽离出来，写一个JDBC的工具类，在工具类中读取配置文件，以及抽离出一些方法，这样不用每次都写这么长的代码 import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; //读取jdbc.properties中的内容 获得url user password driver等信息 //因为只需要读取一次，所以写在static代码块中 static &#123; try &#123; Properties properties = new Properties(); ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); properties.load(new FileReader(path)); url = properties.getProperty(\"url\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); driver = properties.getProperty(\"driver\"); Class.forName(driver); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //返回连接对象 public static Connection getConnection() throws SQLException&#123; return DriverManager.getConnection(url, user, password); &#125; //释放资源 public static void close(Connection conn, Statement stam) &#123; if (stam != null) &#123; try &#123; stam.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //释放资源 public static void close(Connection conn, Statement stam, ResultSet resultSet) &#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //复用上面的代码 close(conn, stam); &#125;&#125; 用户登录练习我们来写一个方法来判断用户输入的用户名和密码是否正确，思路就是根据用户输入的用户名和密码去数据库中查询，如果返回的ResultSet有内容，那么就确定输入正确，否则失败。假设有下面这么一个表(user) +------+----------+----------+| id | user | password |+------+----------+----------+| 1 | zhangsan | 123 || 2 | lisi | 345 |+------+----------+----------+ 下面是检查用户名和密码的方法 public static boolean login(String user, String password) &#123; Connection conn = null; Statement statement = null; ResultSet resultSet = null; try &#123; conn = JDBCUtils.getConnection(); statement = conn.createStatement(); //拼接user和password未一个sql语句 String sql = \"select * from user where user = '\" + user + \"' and password = '\" + password + \"'\"; resultSet = statement.executeQuery(sql); //如果返回有数据则返回true 否则返回false return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn, statement, resultSet); &#125; return false;&#125; 下面在main方法中写测试代码 public static void main(String[] args) &#123; //用户输入用户名和密码 Scanner scanner = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String user = scanner.nextLine(); System.out.println(\"请输入密码：\"); String password = scanner.nextLine(); boolean flag = login(user, password); if (flag) &#123; System.out.println(\"登录成功\"); &#125; else &#123; System.out.println(\"用户名或密码错误\"); &#125;&#125; 我们来试验一下 请输入用户名：lisi请输入密码：234用户名或密码错误 请输入用户名：zhangsan请输入密码：123登录成功 PreparedStatementPreparedStatement的作用同Statement，也是用来执行sql命令的，但是已经有了Statement，为什么还需要PreparedStatement呢? 那就要知道Statement存在什么问题，我们来看上面的用户登录程序，如果我们登录时这么写 请输入用户名：daad请输入密码：a' or 'a' = 'a登录成功 得到的结果居然登录成功了，因为sql语句被拼接成了 select * from user where user &#x3D; &#39;daad&#39; and password &#x3D; &#39;a&#39; or &#39;a&#39; &#x3D; &#39;a&#39;; 最后的or ‘a’ = ‘a’得到的永远是true，所以总是可以得到返回结果，所以自然会显示登录成功，这种情况叫做SQL注入。PreparedStatement正是为了解决这一个问题的，上面出现问题是因为我们的sql语句是拼接而成的，所以才会出现问题，PreparedStatement采取的办法是首先使用?占据位置(占位符)，然后对?所占据的位置进行赋值，赋值的方法为 setXxx()：接收两个参数 第一个参数表示为第几个占位符赋值，从1开始 第二个参数是值 所以我们将上面的登录代码修改如下 public static boolean login(String user, String password) &#123; Connection conn = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; conn = JDBCUtils.getConnection(); //使用?作为占位符 String sql = \"select * from user where user = ? and password = ?\"; //创建PreparedStatement对象 preparedStatement = conn.prepareStatement(sql); //为占位符赋值 preparedStatement.setString(1, user); preparedStatement.setString(2, password); //不需要传入sql resultSet = preparedStatement.executeQuery(); //如果返回有数据则返回true 否则返回false return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn, preparedStatement, resultSet); &#125; return false;&#125; 这时还是使用与上面相同的操作 请输入用户名：dadd请输入密码：a or 'a' = 'a'用户名或密码错误 在实际中我们一般使用PreparedStatement，因为它不仅可以防止SQL注入，并且效率更高。 JDBC事务事务就是一组sql操作，这一组sql操作要么同时成功，要么同时失败。比如转账，一方钱的支出与另一方钱的到账必须同时成功或者同时失败，没有这里钱转出去了，另一方却没有到账的情况。有关事务一般包含下面三个操作 开启事务 setAutoCommit(false) 开启事务后，直至提交，执行的sql语句不会在数据库中生效，而是会写在日志中，只有提交后才会将根据日志修改数据库中的数据 默认是自动提交的，即每次执行一次sql命令都会更改数据库中的内容，我们将自动提交关闭就相当于是开启了事务 提交事务 commit() 回滚事务 rollback() 事务执行失败，这时我们就要回到执行事务前的状态，这时会把日志中的内容清空 一般在catch代码块中进行回滚操作 假设有下面这么一个表 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 2000 || 2 | 李四 | 1000 |+----+------+---------+ 现在张三要给李四转500块钱 import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Demo04 &#123; public static void main(String[] args) &#123; //转账的金额 double money = 500; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = JDBCUtils.getConnection(); String sql1 = \"update account set balance = balance - ? where id = ?\"; String sql2 = \"update account set balance = balance + ? where id = ?\"; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setDouble(1, money); preparedStatement1.setInt(2, 1); preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setDouble(1, money); preparedStatement2.setInt(2, 2); preparedStatement1.executeUpdate(); preparedStatement2.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(connection, preparedStatement1); //因为connection已经关闭了，所以传入null JDBCUtils.close(null, preparedStatement2); &#125; &#125;&#125; 执行上面的程序然后再次查表得 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1500 || 2 | 李四 | 1500 |+----+------+---------+ 但是如果我们在执行张三支出500块后手动添加一个异常，这时李四则不会收到500块 preparedStatement1.executeUpdate();int i = 3 / 0;preparedStatement2.executeUpdate(); +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1000 || 2 | 李四 | 1500 |+----+------+---------+ 张三的钱减少了500块，但是李四却没有收到。这就是问题，所以我们要开启事务，并且在catch代码块中进行回滚 import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Demo04 &#123; public static void main(String[] args) &#123; double money = 500; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = JDBCUtils.getConnection(); //开启事务 connection.setAutoCommit(false); String sql1 = \"update account set balance = balance - ? where id = ?\"; String sql2 = \"update account set balance = balance + ? where id = ?\"; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setDouble(1, money); preparedStatement1.setInt(2, 1); preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setDouble(1, money); preparedStatement2.setInt(2, 2); preparedStatement1.executeUpdate(); int i = 3 / 0; preparedStatement2.executeUpdate(); //提交事务 connection.commit(); &#125; catch (Exception e) &#123; try &#123; if (connection != null) &#123; //回滚事务 connection.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(connection, preparedStatement1); JDBCUtils.close(null, preparedStatement2); &#125; &#125;&#125; 这次再次执行 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1000 || 2 | 李四 | 1500 |+----+------+---------+ 虽然还是发生了异常，但是张三和李四并没有发生上面一方转出一方没有到账的情况，而是转账失败。 数据库连接池每次我们使用完连接对象后都会将该对象销毁，然后下次需要连接对象时又需要重新创建。如果考虑到有频繁的操作数据库的操作，每次创建销毁的开销是很大的，所以就有了数据库连接池，里面有很多的连接对象，当我们需要时就从里面拿，用完之后不是销毁，而是将对象归还给连接池，这样做能够有效的提升程序的性能。Java定义了一个DataSource接口，我们可以通过该接口的getConnection()方法获取一个连接，并且可以通过close()方法归还这个连接(前提是这个连接是从连接池中获得的)。DataSource接口的实现我们不需要关心，我们只要知道如何使用即可，我们学习如何使用两种数据库连接池技术 C3P0 Druid：阿里巴巴提供，目前最好的数据库连接池之一 C3P0C3P0的使用步骤 导入jar包 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 定义配置文件 只能为c3p0-config.xml或c3p0.properties，配置文件需放在src目录下 使用实现类ComboPooledDataSource获得连接池对象 下面给出配置文件c3p0-config.xml的内容 &lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql:///db1&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!--初始连接对象数--&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;!--最大连接对象数--&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;!--最大等待时间 3s--&gt; &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 下面给出一个使用的示例 import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class Demo05 &#123; public static void main(String[] args) throws SQLException &#123; //获得连接池对象 DataSource ds = new ComboPooledDataSource(); //获取连接 Connection conn = ds.getConnection(); &#125;&#125; DruidDruid的使用步骤 导入jar包 druid-1.0.9.jar 定义配置文件 .properties文件 可以放置在任何的地方 使用工厂方法DruidDataSourceFactory.createDataSource()获得连接池 需要传入一个Properties对象(配置文件) 下面给出druid.properties的内容 driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 想必上面的各参数的含义不必解释，那么就给出一个使用Druid的例子 import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;public class Demo06 &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); //得到配置文件的输入流对象 InputStream is = Demo06.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); &#125;&#125; 工具类我们发现每次使用连接池时会有很多重复的操作，同上面我们应该写一个工具类JDBCUtils将一些操作抽离出来，JDBCUtils类如下 import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static DataSource ds; //读取配置文件 初始化连接池对象 static &#123; Properties pro = new Properties(); try &#123; pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //返回连接对象 public static Connection getConnection() throws SQLException&#123; return ds.getConnection(); &#125; //关闭资源 public static void close(Connection conn, Statement stam) &#123; if (stam != null) &#123; try &#123; stam.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection conn, Statement stam, ResultSet resultSet) &#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //复用上面的代码 close(conn, stam); &#125; //返回连接池对象 public static DataSource getDataSource() &#123; return ds; &#125;&#125; Spring JDBCSpring对JDBC进行了简单的封装，提供了一个JdbcTemplate对象来简化JDBC的开发，使用步骤为 导入jar包 spring-beans-5.0.0.RELEASE.jar spring-core-5.0.0.RELEASE.jar spring-jdbc-5.0.0.RELEASE.jar spring-tx-5.0.0.RELEASE.jar commons-logging-1.2.jar 创建JdbcTemplate对象 new JdbcTemplate(ds)：ds为数据库连接池对象 使用JdbcTemplate对象的方法对数据库进行操作 update()：执行DML语句 第一个参数为sql语句 第二个参数为可变参数，是占位符?所对应的值 queryForMap()：将结果封装为Map对象 只能查询一行数据，将结果封装为Map对象 将列名最为Key，将字段值作为Value queryForList()：将结果封装为List对象 查询多行数据，每一行数据封装为一个Map对象，这些Map对象会被添加到一个List集合中返回 queryForObject()：将结果封装为对象 用以查询一些聚合函数 query()：将结果封装为JavaBean对象 下面就来做一个简单的演示，假设db1数据库中有一张表account其中内容如下 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1000 || 2 | 李四 | 1000 |+----+------+---------+ update现在我们使用update命令修改张三的balance为2000 import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;public class Demo07 &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); //Junit单元测试 方法可以单独执行 不需要写在main方法中 @Test public void testUpdate() &#123; String sql = \"update account set balance = 2000 where id = ?\"; template.update(sql, 1); &#125;&#125; 我们再次查询account表 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 2000 || 2 | 李四 | 1000 |+----+------+---------+ queryForMap查询张三所在行(id = 1)，得到一个Map对象，我们将其打印出来 @Testpublic void testQueryForMap() &#123; String sql = \"select * from account where id = ?\"; Map map = template.queryForMap(sql, 1); System.out.println(map);&#125; 结果为 &#123;id=1, NAME=张三, balance=2000.0&#125; queryForList如果我们需要查询多条数据怎么办，这个时候就使用queryForList，它会将每条数据封装为Map集合，然后将这些Map集合添加到List集合中 @Testpublic void testQueryForList() &#123; String sql = \"select * from account\"; List&lt;Map&lt;String, Object&gt;&gt; mapList = template.queryForList(sql); for (Map&lt;String, Object&gt; map: mapList) &#123; System.out.println(map); &#125;&#125; 得到的结果为 &#123;id=1, NAME=张三, balance=2000.0&#125;&#123;id=2, NAME=李四, balance=1000.0&#125; query更多的时候我们希望将得到的结果封装为一个对象，现在我们新建一个类Account如下 public class Account &#123; private Integer id; private String name; private Double balance; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", balance=\" + balance + '&#125;'; &#125;&#125; 现在我们希望将获得结果封装为一个个Account对象，这时我们就需要使用query()方法了，query方法的第一个参数是sql语句，第二个参数是RowMapper&lt;&gt;的实现类，这个类我们可以自己实现，也可以使用Spring提供好的实现类，我们就使用Spring提供好的实现类BeanPropertyRowMapper&lt;&gt;，我们只要将Account的class属性传递进去即可 @Testpublic void testQuery() &#123; String sql = \"select * from account\"; List&lt;Account&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); for (Account account : list) &#123; System.out.println(account); &#125;&#125; 结果为 Account&#123;id=1, name='张三', balance=2000.0&#125;Account&#123;id=2, name='李四', balance=1000.0&#125; queryForObject现在我们来查询account表中右多少条数据，我们使用聚合函数count()，得到的结果是一个long类型的数字，我们使用queryForObject()查询，接收两个参数，第一个参数是sql命令，第二个参数是返回类型的class属性 @Testpublic void testQueryForObject() &#123; String sql = \"select count(id) from account\"; Long num = template.queryForObject(sql, Long.class); System.out.println(num);&#125; 结果为 2","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://lastknightcoder.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://lastknightcoder.gitee.io/tags/JDBC/"}]},{"title":"Java注解","date":"2019-08-09T16:00:00.000Z","path":"/Java注解/","text":"我们在之前就有接触过注解，比如@Override，它可以帮我们检查是否重写了方法，如果没有，它在编译阶段就会报错。注解一般有下面三个功能 编译检查 比如@Override 代码分析 读取注解的属性，然后使用反射技术进行分析 编写文档 比如javadoc 系统自定的注解下面介绍三个系统自定义的注解 @Override 检查方法是否是重写父类的方法 @Deprecated 将该注解标记的内容显示为已过时 @SuppressWarnings(“all”) 压制所有的警告 如果有一个方法被@Deprecated修饰了，如 @Deprecatedpublic static void show() &#123; System.out.println(\"show ...\");&#125; 那么在调用时会这样 代表这个方法已经过时了，但是你想调用还是可以调用的。 在我们写代码时，经常会弹出一些警告，如 我们可以使用@SuppressWarnings(“all”)表示压制所有的警告 这时类里面所有的警告都压制了。 自定义注解格式要定义一个注解，首先我们看它的格式是什么 元注解public @interface 注解名称 &#123;&#125; 其实注解本质是一个接口，所以我们可以在里面定义抽象方法，这些抽象方法我们又把它叫做属性，这些抽象方法的返回值只能是下面这些类型 基本数据类型 String 枚举 注解 以上类型的数组 下面定义了一个MyAnno的注解，里面有两个属性，name和age import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//元注解暂时不必关注@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; String name(); int age();&#125; 下面我们使用MyAnno @MyAnno(name=\"小明\",age=18)public static void show() &#123; System.out.println(\"show ...\");&#125; 使用注解时，要为属性赋值，否则会报错，并且格式为属性名=值的形式，我们可以在MyAnno中设定默认值，这样在使用注解时就可以不赋值，如 String name() default \"小明\";int age() default 18; 现在我们在使用时可以不赋值 @MyAnno()public static void show() &#123; System.out.println(\"show ...\");&#125; 如果注解里面只有一个属性，并且属性名为value，那么在使用注解时可以省略value直接赋值，如 import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; int value();&#125; 那么使用时直接赋值 @MyAnno(12)public static void show() &#123; System.out.println(\"show ...\");&#125; 数组的赋值为属性名 = {}的形式，如果里面只有一个值，那么花括号可以省略。 元注解元注解就是描述注解的注解，这里只介绍两个 @Target() 表示注解能作用的位置，比如作用在类上 它有一个value属性，类型是ElementType枚举类型 我们一般使用TYPE, FIELD, METHOD分别表示能够作用在类、成员变量、方法上 @RETENTION() 表示注解被保留的阶段 它也有一个value属性，类型是RetentionPolicy枚举类型 我们一般使用RetentionPolicy.RUNTIME表示保留到运行时 解析注解在反射那里根据配置文件来创建一个类的对象，并且调用方法，现在我们将根据注解的属性来创建一个类的对象和调用相应的方法，现在有以下注解 import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; String className(); String methodName();&#125; 新建类使用该注解 import java.lang.annotation.Annotation;import java.lang.annotation.Target;import java.lang.reflect.Method;@MyAnno(className = \"Animal\", methodName = \"eat\")public class TestAnno &#123; public static void main(String[] args) throws Exception &#123; //获取该类的Class对象 Class&lt;TestAnno&gt; cla = TestAnno.class; //获取注解 会在内存中生成一个该注解的子类实现对象 MyAnno an = cla.getAnnotation(MyAnno.class); //调用方法会将属性值返回 String className = an.className(); String methodName = an.methodName(); //根据类名获取Class对象 Class cls = Class.forName(className); //获取方法 Method method = cls.getMethod(methodName); //使用无参构造方法创建对象 Object o = cls.newInstance(); //调用方法 method.invoke(o); &#125;&#125; 运行结果为 eat ... 这时我们只要改变注解的属性值，就可以创建任意类的对象，并且调用相应的方法。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"注解","slug":"注解","permalink":"https://lastknightcoder.gitee.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Java异常","date":"2019-08-04T16:00:00.000Z","path":"/Java异常/","text":"所谓的异常就是不正常，我们在之前很多地方有碰到异常，比如对象向下转型时有碰到ClassCastException。所有的异常都继承自Exception类。Exception下面有一个重要的的子类叫做RuntimeException。 异常分为编译期异常和运行时异常，如Exception就是编译期异常，而RuntimeException是运行时异常，如果在方法中抛出了一个编译期异常，那么必须处理该异常，继续向上抛出或者就地处理，而对于运行异常可以选择不处理，那么就会默认交给JVM处理。 处理异常的过程首先JVM检测到了异常，这时JVM会创建一个异常对象，该对象包含发生错误的内容、原因和位置。如果在发生异常处的方法内没有异常处理逻辑，那么JVM会把该异常抛给这个方法的调用者，如果该调用者也没有异常处理逻辑，那么就会一直向上抛出，直到遇到main方法，如果main方法也没有异常处理逻辑，那么这时异常就会抛给JVM，JVM会打印红色字体至控制台，并且终止Java程序的运行。 与异常有关的关键字有五个，分别为throw, throws, try, catch, finally。下面介绍这五个关键字的作用。 throwthrow关键字用于在方法中抛出一个异常，如下 public static double divide(double a, double b) &#123; if (b == 0) &#123; throw new ArithmeticException(\"除0\"); &#125; return a/b;&#125; 这个方法的作用是a/b，在检测到b=0时，我们抛出了一个异常，并给出提示信息”除0”。现在我们在main方法中调用该方法 System.out.println(divide(5,0)); 由于我们没有对异常进行处理，所以程序会进行终结并在控制台打印出信息： 注意： throw必须写在方法的内部 new的必须是Exception或其子类 throwsthrows的作用是声明异常，或者说叫把异常抛给调用者，我们知道，编译期异常是必须要进行处理，那么处理的办法有两种，一种就是把继续向上抛出，另一种就是使用try-catch进行处理。而throws就是将异常继续抛出，现在我们将上面的ArithmeticException改为Exception，由于Exception为编译期异常，必须进行处理，否则编译不通过 由图片可以知道，由于我们没有对该异常处理，所以编译没有通过，我们这里的处理办法就是继续抛出 我们通过throws关键字抛出异常了，但是我们发现在main方法处又出现了问题，这是因为main方法没有处理divide()方法可能抛出的异常，因为divide()抛出的异常为编译期异常，必须进行处理，这里我们继续向上抛出，如下 这时代码就不会报错了。 注意： 使用throws时可以抛出多个异常，异常与异常之间使用逗号隔开 如果抛出的多个异常具有父子类关系，那么抛出父类异常就可以了 try-catch虽然我们通过throws可以向上抛出异常，但是如果不进行处理的话，最终还是会抛出给JVM，而JVM的处理方法就是打印异常信息然后终止程序。我们应该在异常发生时进行捕获，这个时候就不会将异常最终抛给JVM，程序就不会终止，而是会继续的执行下去。进行捕获的代码就是try-catch。具体格式为 try &#123; //可能发生异常的代码&#125; catch &#123;接收异常的变量&#125; &#123; //对异常进行处理&#125; 所以我们重写上面的那个方法为 public class TestException &#123; public static void main(String[] args) &#123; try &#123; //可能发生异常的代码 System.out.println(divide(5,0)); &#125; catch (ArithmeticException e) &#123; //这里对异常的处理只是将异常打印出来 //处理异常后并不会终止程序，所以后面的代码还是可以执行 System.out.println(e); &#125; System.out.println(\"后续代码\"); &#125; public static double divide(double a, double b) &#123; if (b == 0) &#123; throw new ArithmeticException(\"除0\"); &#125; return a/b; &#125;&#125; 运行结果为 java.lang.ArithmeticException: 除0后续代码 可见后面的代码执行了。 Throwable(它是Exception的父类)中有三个处理异常的方法 getMessage 打印简短信息 toString 就是上面的直接打印对象 printStackTrace JVM向控制台输出的信息就是调用这个方法，该方法打印的信息很全 finally其实在try-catch后面还可以跟一个finally块，我们知道如果没有发生异常的话，catch里面的代码块是不会执行的，而finally里的代码块，无论是是否抛出异常，都一定会执行的，所以finally里面的代码多用来释放资源的。我们来看一个例子 try &#123; System.out.println(divide(5,0));&#125; catch (ArithmeticException e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(\"finally代码块\");&#125; 这时是会抛出异常的，输出的结果为 可见finally里面的代码执行了，现在修改上面的代码为 try &#123; System.out.println(divide(5,1));&#125; catch (ArithmeticException e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(\"finally代码块\");&#125; 这时是不会抛出异常的，所以catch代码块里面的程序不会被执行，但是finally里面的代码始终会被执行，执行的结果为 注意： 由于finally里面的代码一定是会执行的，所以要避免在finally里面写return语句，否则返回的一直是finally里面的结果。 多异常捕获多次捕获，多次处理即使用多个try-catch语句块 try &#123; //可能发生异常的代码&#125; catch(异常1 e) &#123; //处理异常1&#125;try &#123; //可能发生异常的代码&#125; catch(异常2 e) &#123; //处理异常2&#125;... 一次捕获，多次处理即一个try匹配多个catch try &#123; //可能发生异常的代码&#125; catch (异常1 e) &#123; //处理异常1&#125; catch (异常2 e) &#123; //处理异常2&#125; ... 如果在try中发生了异常，那么首先会判断这个异常能不能被异常1接收，如果能那么就在第一个catch中进行处理，如果不能，那么就判断能不能被异常2接收，以此类推。 这里需要注意的点是，父类异常必须子类异常后面。假设父类异常写在前面，如果发生了子类异常，根据多态，父类能够接收这个异常，所以写在后面的子类异常永远接受=收不到这个异常，就相当于是死代码了。 一次捕获，一次处理就是在catch中使用Exception变量接收异常，因为所有的异常都是Exception的子类，所以可以接收所有的异常 try &#123; //可能发生异常的代码&#125; catch (Exception e) &#123; //处理异常&#125; 子类注意事项如果父类方法抛出多个异常，子类重写了该方法，那么子类方法有三种方案 抛出相同异常 抛出父类异常的子类 不抛出异常 如果父类的方法没有抛出异常，那么子类重写的方法也不能抛出异常。该子类产生的异常只能try-catch捕获处理，不能使用throws抛出。 自定义异常自定义的异常必须继承一个异常类。如果继承的是Exception，那么该异常就是编译期异常，如果继承的是RuntimeException，那么就是运行时异常。下面简单的演示 public class MyException extends RuntimeException&#123; //一个空参构造方法 public MyException()&#123;&#125; //一个带异常信息的构造方法 public MyException(String message) &#123; super(message); &#125;&#125; 现在进行测试 public class TestMyException &#123; public static void main(String[] args) &#123; divide(5,0); &#125; public static double divide(double a, double b) &#123; if (b == 0) &#123; //继承至RuntimeException，是运行时异常，可以不进行处理 throw new MyException(\"除0\"); &#125; return a / b; &#125;&#125; 结果为","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"异常","slug":"异常","permalink":"https://lastknightcoder.gitee.io/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"Java文件操作","date":"2019-08-02T16:00:00.000Z","path":"/Java文件操作/","text":"FileFile类代表的是文件或者文件夹(目录)，将目录和文件抽象为一个类。File提供了很多方法用来操作文件夹或者文件。下面具体介绍该类。 静态成员变量File类有四个成员变量 pathSeparator pathSeparatorChar 这两个保存的路径分隔符 Windows下为;，Linux下为: separator separatorChar 这两个保存的是文件名称分隔符 Windows下为\\反斜杠，Linux下为/正斜杠 下面看这个例子 import java.io.File;public class TestFile &#123; public static void main(String[] args) &#123; System.out.println(File.pathSeparator); System.out.println(File.pathSeparatorChar); System.out.println(File.separator); System.out.println(File.separatorChar); &#125;&#125; 输出为 ;;\\\\ 构造方法File(String pathname) 传入一个字符串类型，这个字符串为第一个路径名 传入的路径可以是绝对路径，也可以是相对路径 传入的路径可以存在，也可以不存在 可以是文件结尾，也可以是文件夹结尾\\ 下面来看看该方法的使用 File file1 = new File(\"G:\\\\JavaProject\\\\FirstProject\"); //绝对路径写法System.out.println(file1);File file2 = new File(\"SecondProject\"); //相对路径写法System.out.println(file2); 输出为 G:\\JavaProject\\FirstProjectSecondProject 注意： 由于\\代表的是转义，所以要写两个\\\\ 可见File类重写了toString()方法 File(String parent,String child) 该构造方法需要传入两个参数，一个为父级目录的路径，一个为子级目录的路径 该种构造方法相比上面的要灵活一点 下面示例使用 String parent = \"C:\\\\JavaProject\\\\\";File file3 = new File(parent,\"FirstProject\");System.out.println(file3);File file4 = new File(parent,\"SecondProject\");System.out.println(file4); 输出为 C:\\JavaProject\\FirstProjectC:\\JavaProject\\SecondProject File(File parent, String child) 同上个构造方法，传入也是父级和子级的路径，不过传入的父级路径是一个File对象 这样可以调用File类的方法，更加灵活 下面示例使用 File parent = new File(\"C:\\\\JavaProject\");File file5 = new File(parent,\"FirstProject\");System.out.println(file5); 输出为 C:\\JavaProject\\FirstProject 常用方法按照功能不同分为了三类 获取功能 判断功能 创建删除 获取功能与获取功能有关的方法有四个 getAbsolutePath() 获得文件或文件夹的绝对路径 不论在构造方法中传入的是绝对路径还是相对路径，获得都是绝对路径 getPath() 在构造方法中传入的是什么，返回的就是什么 toString()调用的就是这个方法 getName() 获得文件或文件夹的名称，即路径的结尾部分 length() 获得文件的长度，以字节为单位 如果该文件不存在，那么返回0 下面示例这四个方法的使用 import java.io.File;public class TestFile &#123; public static void main(String[] args) &#123; File file = new File(\"src\\\\Dog.java\"); //传入的相对路径，获得是src目录下的Dog.java文件 //打印绝对路径 System.out.println(file.getAbsolutePath()); //G:\\JavaProject\\SecondProject\\src\\Dog.java //打印路径，传入什么打印什么 System.out.println(file.getPath()); //src\\Dog.java //获得文件的名称 System.out.println(file.getName()); //Dog.java //获得文件的大小 System.out.println(file.length()); //353 &#125;&#125; 判断功能与判断功能有关的方法有三个 exists() 判断传入构造方法的路径是否存在 isDirectory() 判断是不是目录(文件夹) 如果路径不存在，无论是否为目录(文件夹)，返回false isFile() 判断是否为文件 如果路径不存在，无论是否为文件，返回false 下面进行示例 File file = new File(\"src\\\\Dog.java\"); //传入的相对路径，获得是src目录下的Dog.java文件//判断该路径是否存在System.out.println(file.exists()); //true//是否为文件夹System.out.println(file.isDirectory()); //false//是否为文件System.out.println(file.isFile()); //true 创建删除与创建和删除有关的方法有四个 createNewFile() 如果该文件不存在，则创建该文件，如果存在则不创建 返回布尔值，创建返回true 不能创建目录，所以该文件所在目录必须存在，否则会抛出异常 delete() 删除该类代表的文件或文件夹，直接从硬盘删除，不走文件夹，要小心 删除成功返回true makdir() 创建由此File类代表的目录，只能创建单级目录 makdirs() 创建由此File类代表的目录，包括必需但不存在的父级目录 下面演示使用 import java.io.File;import java.io.IOException;public class TestFileMethod &#123; public static void main(String[] args) throws IOException &#123; //D:\\\\目录下没有1.txt File file1 = new File(\"D:\\\\1.txt\"); //createNewFile使用了throws抛出异常，需要处理，我们在main中直接抛出即可 System.out.println(file1.createNewFile()); //true //D:\\\\下没有新建文件夹 File file2 = new File(\"D:\\\\新建文件夹\"); //创建这个文件夹 System.out.println(file2.mkdir()); //true File file3 = new File(\"D:\\\\abc\\\\def\"); //创建多级目录 System.out.println(file3.mkdir()); //不能创建 mkdir只能创建单级目录 false System.out.println(file3.mkdirs()); //true //将上面创建的文件及文件夹全部删除 System.out.println(file1.delete()); //true System.out.println(file2.delete()); //true System.out.println(file3.delete()); //true abc这个文件夹还在 &#125;&#125; 目录遍历为了遍历目录，有两个方法 list() 返回一个字符串数组，这些字符串是文件名或文件夹名 listFiles() 返回时的File类对象数组 注意： 上面两个方法，如果目录不存在或者不是目录，那么会抛出空指针异常 隐藏文件和文件夹也能获取到 File file = new File(\"G:\\\\JavaProject\\\\SecondProject\\\\src\");String[] filename = file.list();for (int i = 0; i &lt; filename.length; i++) &#123; System.out.println(filename[i]);&#125;File[] files = file.listFiles();for (File file4 : files) &#123; System.out.println(file4.getName());&#125; 输出为 comDog.javaDoudizhu.javaGenericsDemo.javaJustForFun.javaMyException.javaMyThread.java... 递归递归就是在函数里面调用自己。 递归必须要用终止条件，否则会不断的调用自己，造成栈内存溢出 递归的次数也不能太多，否则也会造成栈内存溢出 构造方法 下面做几个小的练习来熟悉递归。 递归练习第一个练习是根据函数接收的参数$n$，来计算$1 + 2 … + n$，因为我们是从递归的角度看，所以应当这么看$$sum(n) = \\begin{cases}1, &amp;if ,, n =1 \\\\n + sum(n - 1), &amp;if ,,n &gt; 1 \\end{cases}$$ 所以程序我们应该这么写 //这里没有考虑输入为负数时的处理public static int sum(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n + sum(n - 1); &#125;&#125; 在main方法中调用该方法测试 int res = sum(100);System.out.println(res); 输出为 5050 可见程序是正确的。 第二个练习是计算阶乘，思路同上面完全是一样的$$fac(n) = \\begin{cases}1, &amp;if ,, n =0 \\\\n * fac(n - 1), &amp;if ,,n &gt; 1 \\end{cases}$$ 代码如下 public static int fac(int n) &#123; if (n == 0) &#123; return 1; &#125; else &#123; return n * fac(n - 1); &#125;&#125; 在main方法中调用测试 int res = fac(5);System.out.println(res); 输出为 120 文件夹遍历下面使用递归来实现文件夹的遍历，我们getFile()文件来进行文件夹的遍历，它接收一个File对象作为参数 public static void getFile(File file) &#123; File[] files = file.listFiles(); for (File file1 : files) &#123; System.out.println(file1.getName()); //如果是文件夹的，就遍历该文件夹 if (file1.isDirectory()) &#123; getFile(file1); &#125; &#125;&#125; 我在D盘下新建了一个Test文件夹，它的目录结构如下 Test a a.txt b.txt b c.txt d.txt 我们在main方法中遍历该文件夹 getFile(new File(\"D:\\\\Test\")); 输出为 aa.txtb.txtbc.txtd.txt 过滤器listFiles其实还可以接收一个叫做过滤器的参数。这个过滤器是一个接口，分为有FileFilter和FilenameFilter两个接口，这两个接口里面都只有一个方法accept()，listFiles会调用这个方法，将它获得的路径传入该方法中，如果得到的结果为true，那么就保留这个路径在最终返回的数组中，如果返回的是false，那么就不要这个路径。可见这样就起到了文件过滤的作用，而过滤什么样的文件，需要什么样的文件，完全由accept()方法决定，所以这也是它们为什么叫做过滤器的原因。 FileFilter下面来介绍FileFilter，FileFilter里面的accept(File pathname)接收一个参数，这个参数就是路径名，listFiles()会将它获得的路径传入accept()，accept()进行过滤，以决定要什么样的路径。下面我们做一个示范，打印出一个图片文件夹里面以.png结尾的图片 //传入的是图片文件夹的路径public static void printPNG(File file) &#123; //因为接口里面只要一个方法，所以这里使用Lambda表达式 File[] files = file.listFiles(pathname -&gt; &#123; //判断是不是以.png结尾 boolean b = pathname.getName().endsWith(\".png\"); if (b) &#123; //如果是以.png结尾，则加入到files数组中 return true; &#125; else &#123; return false; &#125; &#125;); //打印files数组，查看结果是否正确 for (File fi : files) &#123; System.out.println(fi.getName()); &#125;&#125; 我们在main方法调用测试 printPNG(new File(\"D:\\\\images\")); 打印输出为 可见只有.png结尾的图片才被放入了files数组中。 FilenameFilter它的accept(File dir, String name)接收两个参数，其余的与FileFilter相同，下面就同样的功能演示其代码 public static void printPNGAgain(File file) &#123; File[] files = file.listFiles(((dir, name) -&gt; &#123; //根据dir和name创建一个File对象 //后面的代码完全同上面一样 File newFile = new File(dir,name); boolean b = newFile.getName().endsWith(\".png\"); if (b) &#123; return true; &#125; else &#123; return false; &#125; &#125;)); for (File fi : files) &#123; System.out.println(fi.getName()); &#125;&#125; 在main方法中调用该方法 printPNGAgain(new File(\"D:\\\\images\")); 输出同上面一模一样 字节流下面介绍两个类用来从文件中读取数据和写入数据到文件的类。不管是读取数据还是写入数据，都是以字节为单位的。 OutputStream该类可以将内存中的数据写入到文件中。OutputStream类是一个抽象类，我们可以使用它的子类FileOutputStram，它的构造方法中传入的参数可以是一个File对象，也可以是一个代表路径的字符串。它里面主要有以下方法 write(byte b) 写入一个字节到文件中 write(byte[] bytes) 将一个字节数组写入到文件中 如果传入的byte是一个负数，那么该数与其后面的那个字节组成一个中文 write(byte[] bytes, int off, int len) 写入字节数组索引从off开始，长度为len字节的数据 close() 关闭流 下面示例其使用 //如果没有a.txt，会创建一个a.txt新文件OutputStream fos = new FileOutputStream(new File(\"a.txt\")); //可以传入\"a.txt\"字符串fos.write(97); //写入a//\\r\\n代表 回车换行fos.write(\"\\r\\n\".getBytes()); //String类的getBytes()方法可以得到一个byte数组fos.write(\"abc\".getBytes());fos.close(); 上面的程序是会把原来文件里面的内容情空，然后将数据写入了，如果想向文件中追加数据的话，那么就要在构造方法的第二个参数传入true，代表是追加。如 OutputStream fos = new FileOutputStream(new File(\"a.txt\"), true); InputStream与OutputStream相对的，该类的作用是读取文件中的内容，一般我们使用的是其子类FileInputStream，构造方法同OutputStream，包含的方法有 read() 读取一个字节并返回，如果读到了文件的末尾，那么返回-1，我们可以通过返回的是否是-1来判断是否已经读到了文件的末尾 read(byte[] bytes) 读取bytes大小的字节，返回的是读取的有效位数 假如文件有5个字节，我用长度为6的字节数组去读取，那么返回的就是5 如果已经读到了文件的末尾，不是返回0，而是返回-1。 close() 关闭流 InputStream fis = new FileInputStream(new File(\"a.txt\")); //可以传入\"a.txt\"字符串int len = fis.read(); //读取一个字符，读取的虽然是byte，但是返回时会被提升为int，所以用用int接收System.out.println((char)len);fis.close(); 文件复制综合读取数据和写入数据，我们通过这两个流复制一个文件 OutputStream fos = new FileOutputStream(new File(\"copy.jpg\"));InputStream fis = new FileInputStream(new File(\"a.jpg\"));byte[] bytes = new byte[1024]; //用来读取数据的数组，也是写数据的数组int len = 0;// 判断是否读取完毕while ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes,0, len);&#125;//先关闭写的流，因为写完了，说明肯定读完了fos.close();fis.close(); 字符流字节流是一个字节一个字节读取的，但是对于中文，如果使用GBK编码的话由2个字节组成，如果使用UTF-8编码的话由3个字节组成。所以如果一个字节进行读取的话就得不到想要的字符。那么这里就需要引入一个新的流来读取字符，以字符为单位进行读取。 ReaderReader就相当于是InputStream，它的作用就是从文件中读取数据到内存，不过不同的是，Reader读取的最小单位为字符，它的构造方法与InputStream一样，包含的方法也一样，不过参数有所不同，不在是字节，而是字符。Reader也是一个抽象类，我们在这里常使用它的子类FileReader。我们在本目录下新建一个文件b.txt，在里面写入你好，使用UTF-8编码(不要使用GBK) Reader reader = new FileReader(\"b.txt\"); //也可以传入一个File对象int c = 0;while ((c = reader.read()) != -1) &#123; System.out.println((char)c);&#125; 输出为 你好 FileReader其实也有新建一个字节流去读取数据，不过中间有一个将字节转为字符的过程，转换默认是按照UTF-8的方式解码的，所以如果你在Windows下直接新建文件，默认是GBK的，这样读取就会是乱码，可以直接在IDEA中新建文件，默认为UTF-8编码。 如果我们读取得到了一个字符数组，我们可以使用String类的构造方法 String(char[] value) String(char [] value, int off, int len) 将字符数组转化为字符串，方便处理。 WriterWriter就是向文件中写入一个字符，同OutputStream不同，Writer有一个特有的方法 flush() 该方法的作用是将缓存区里的内容写入到文件中 这是怎么回事，其实Writer的底层是创建一个了字节流写数据的，我们直接写入字符不是直接写在文件中，而是写在缓冲区中，然后缓冲区中的内容转化为字节写入文件中。在调用close()，在关闭流之前，会把缓冲区中的内容写到文件中，如果既没有调用flush()也没有调用close()，那么写入的数据不会写入文件中。 还有一个方法是 write(String str [, int off, int len]) 可以直接写入字符串，不用写字符数组那么麻烦了 //如果没有c.txt，那么会新建一个Writer writer = new FileWriter(\"c.txt\"); //也可以传入一个File对象//写入的默认是utf-8编码writer.write(\"你好啊\");//如果不调用close()，那么c.txt里面什么都没有writer.close(); 同OutputStream一样，这里的write也是覆盖重写，如果想要只是追加数据的话，在构造方法的第二个参数传入true Writer writer = new FileWriter(\"c.txt\",true); Properties属性集Properties是继承至HashTable的一个集合。它是与IO流关联起来的，通过load()和store()方法可以读取特定格式的文件数据，和将Properties集合中的数据写入到文件中。 store下面介绍将Properties中的数据写入到文件中。首先介绍如何向Properties集合中添加数据 setProperty(String key, String value) Properties集合中的键和值都是String类型的。store()分为两种，一种是字节流，传入的是OutputStream对象，一种是字符流，传入的是Writer对象 store(OutputStream in, String comment) store(Writer writer, String comment) 第二个参数String comment是注释，写入文件会写在第一行，并且以#开头，一般我们传入一个空字符串 Properties properties = new Properties();properties.setProperty(\"古力娜扎\",\"18\");properties.setProperty(\"迪丽热巴\",\"17\");properties.store(new FileWriter(\"properties.txt\"), \" \"); properties.txt文件里面的内容为 # #Fri Aug 09 11:28:20 CST 2019古力娜扎=18迪丽热巴=17 load在介绍load()之前，说明一下如何获取Properties中的元素 getProperty(String key) 通过键获取值，相当于Map中的get() stringPropertiesName() 相当于Map中的 keySet()，返回一个Set集合，泛型为String 下面介绍load()方法，load()就是读取指定格式的文件，比如，指定格式如下两种 古力娜扎=18 或者 古力娜扎 18 中间的分隔符可以使用=或者空格，如果碰到以#开头的，则不会读取，我们来读取刚刚写的properties.txt文件 Properties properties = new Properties();//读取文件properties.load(new FileReader(\"properties.txt\"));Set&lt;String&gt; propertiesName = properties.stringPropertyNames();//遍历集合for (String name : propertiesName) &#123; System.out.println(name+\"=\"+properties.getProperty(name));&#125; 输出为 古力娜扎=18迪丽热巴=17 缓冲流之前我们使用过字节流InputStream和OutputStream进行过文件复制的练习，但是其实我们可以发现，使用这两个流的速度很慢，所以这里就引入了缓冲流BufferedInputStream和BufferedOutPutStream，还有BufferedReader和BufferedWriter。为了感受字节流和缓冲流的差异，我们这次来复制一个1MB的文件。 字节流复制首先使用字节流，一个字节一个字节的读取 long start = System.currentTimeMillis();InputStream fis = new FileInputStream(\"file.pdf\");OutputStream fos = new FileOutputStream(\"copy.pdf\");int len = 0;while ((len = fis.read()) != -1) &#123; fos.write(len);&#125;fos.close();fis.close();long end = System.currentTimeMillis();System.out.println(\"共耗时\" + (end - start) + \"毫秒\"); 输出为 共耗时11738毫秒 现在还是使用字节流，不过一次读取1KB long start = System.currentTimeMillis();InputStream fis = new FileInputStream(\"G:\\\\JavaProject\\\\ThirdProject\\\\src\\\\file.pdf\");OutputStream fos = new FileOutputStream(\"copy.pdf\");int len = 0; //存储读取的有效位数byte[] bytes = new byte[1024]; //读取1KBwhile ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes,0,len);&#125;fos.close();fis.close();long end = System.currentTimeMillis(); 输出为 共耗时203毫秒 缓冲流复制这次使用缓冲流，先一个字节一个字节的读取 long start = System.currentTimeMillis();BufferedInputStream buffis = new BufferedInputStream(new FileInputStream(\"file.pdf\"));BufferedOutputStream buffos = new BufferedOutputStream(new FileOutputStream(\"copy.pdf\"));int len = 0;while ((len = buffis.read()) != -1) &#123; buffos.write(len);&#125;buffos.close();buffis.close();long end = System.currentTimeMillis();System.out.println(\"共耗时\" + (end - start) + \"毫秒\"); 输出为 共耗时94毫秒 这次一次读取一1KB long start = System.currentTimeMillis();BufferedInputStream buffis = new BufferedInputStream(new FileInputStream(\"file.pdf\"));BufferedOutputStream buffos = new BufferedOutputStream(new FileOutputStream(\"copy.pdf\"));int len = 0;byte[] bytes = new byte[1024];while ((len = buffis.read(bytes)) != -1) &#123; buffos.write(bytes,0,len);&#125;buffos.close();buffis.close();long end = System.currentTimeMillis();System.out.println(\"共耗时\" + (end - start) + \"毫秒\"); 输出为 共耗时16毫秒 下面我来做一个表格总结一下速度 缓冲流(ms) 字节流(ms) 1MB 94 11738 1KB 16 203 从这些数据看，就知道缓冲流的速度比字节流的快很多。 缓冲流的一些特有方法缓冲流提供了几个特有的方法，如BufferedOutputStream和BufferedReader中有一个方法为 readline() 一次读取一行数据，读到的数据不包括换行符 如果读到了末尾，那么返回null BufferedInputStream和BufferedWriter也提供了一个方法叫做 newline() 作用是换行，可以根据不同的操作系统进行换行 之前我们写的\\r\\n只适用于Windows系统 转换流我们在使用字符流时，只能读取UTF-8格式的文件，写出的数据的格式也是UTF-8的，现在假设我要读取一个GBK的文件，里面有中文”你好”，看看会发生什么。 FileReader reader = new FileReader(\"text.txt\");int len = 0;while ((len = reader.read()) != -1) &#123; System.out.print((char)len);&#125;reader.close(); 发现读取的只是乱码 这是因为FileReader是按照UTF-8的格式读取的，但是文件的格式却是GBK，编码不一样，那么解码当然会出问题。所以就有了转换流的出现，有两个类是做这件事情的，分别是InputStreamReader和OutputStreamWriter，它们的构造方法是 InputStreamReader(InputStream in, String charset) OutputStreamWriter(OutputStream out, String charset) 第二个参数就是用来指定字符集的，如果不指定字符集的话，就默认为UTF-8。 String path = \"text.txt\";InputStreamReader reader = new InputStreamReader(new FileInputStream(path), \"gbk\");int len = 0;while ((len = reader.read()) != -1) &#123; System.out.print((char) len);&#125;reader.close(); 输出为 你好 下面做一个小的练习，将一个GBK格式的文件转换为一个UTF-8格式的文件 String path = \"text.txt\";//也可写成GBKInputStreamReader reader = new InputStreamReader(new FileInputStream(path), \"gbk\"); //不指定字符集的话，默认为UTF-8(utf-8)OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"test.txt\"));int len = 0;while ((len = reader.read()) != -1) &#123; writer.write(len);&#125;writer.close();reader.close(); 序列流如果我们想将对象保存在硬盘中怎么办? 因为一旦断电，内存中的对象就会全部的消失。这个时候就需要序列流将对象保存在文件中，对应也有相应的序列流读取文件得到一个对象。 ObjectOutputStream 将文件写到文件中的类 writeObject(Object o) 该方法将对象写到文件中 ObjectInputStream 从文件中读取对象的类 readObject() 将文件中的对象读取出来，返回一个Object对象 下面介绍使用及注意事项。首先创建一个Person类 package IOProjectpublic class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.age = age; this.name = name; &#125; public Person() &#123; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 然后在测试类中创建一个对象，并使用ObjectOutputStream类的对象将这个对象写到文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person\"));Person p = new Person(\"迪丽热巴\",18);oos.writeObject(p);oos.close(); 这时抛出了一个异常 这时因为Person没有实现Serializable接口，这里谈第一个注意事项 只有实现了Serializable接口才能将其对象序列化和反序列化 Serilaizable是一个标志性接口，所谓的标志性指的是只起一个标志的作用，Serializable接口里面什么都没有，我们不需要实现任何的方法 现在将Person实现Serializable接口然后执行上面的程序就不会有问题了。 下面使用ObjectInputStream读取刚刚序列化的对象，这个过程叫做反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person\"));Object o = ois.readObject();System.out.println(o);ois.close(); 输出为 Person&#123;age=18, name='迪丽热巴'&#125; 说明我们读取成功了。 下面添加几个注意事项 static修饰的静态变量不能进行序列化 被transient修饰的成员变量也不能进行序列化 如果对象序列化后，修改了类文件，那么不能被序列化 现在我们修改Person类中的age使用transient修饰，进行序列化和反序列化操作，得到的结果为 Person&#123;age=0, name='迪丽热巴'&#125; age = 0并不等于18，说明age没有被序列化到文件中。 现在我们将Person类的对象序列化，然后修改Person类，接着在反序列化 Exception in thread \"main\" java.io.InvalidClassException: IOProject.Person; local class incompatible: stream classdesc serialVersionUID = -774581383406272369, local class serialVersionUID = -4004215360553243182 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at IOProject.TestSerial.main(TestSerial.java:13) 抛出了一个异常InvalidClassException，这是因为它们的serialVersionUID对不上。serialVersionUID是根据类文件自动计算的，当我们修改类文件时，serialVersionUID发生了改变，当我们反序列化时会比较serialVersionUID，由于这时它们的serialVersionUID不同，所以抛出了这个异常。我们可以在类里面为这个变量赋一个固定的值，这样serialVersionUID就不会发送改变，但是赋值也是有要求的 必须使用final static long修饰 我们在Person类中加入 private final static long serialVersionUID = 1L; 然后执行上面的操作，发现没有问题。输出为 Person&#123;age=18, name='迪丽热巴'&#125; //这里age没有使用transient修饰 打印流PrintStream是一个有关于打印流的类，我们一直使用的System.out其中的out就是一个PrintStream对象，下面是其在System类中的定义 public final static PrintStream out = null; 打印流有以下的特点 它只负责数据的输出 永不抛出IOExecption 它继承了OutputStream类 它有自己的特有方法，如print(), println()，这两个方法可以打印出任意的数据类型 当它调用OutputStream类的方法write()时，打印数据时会查编码表，如write(97)会打印出a，但是print(),println()方法输入什么，打印出什么，如print(97)打印出97。 下面简单介绍使用，首先看PrintStream的构造方法 PrintStream(File file) PrintStream(OutputStream out) PrintStream(String filename) PrintStream printStream = new PrintStream(\"a.txt\");printStream.write(97);printStream.println(97);printStream.println(22.2);printStream.println(true);printStream.println('a');printStream.println(\"abc\");printStream.close(); 打开a.txt文件，里面的内容为 a9722.2trueaabc System类有一个方法setOut(PrintStream out)，可以用来改变System.out的指向，这样打印出的内容不会在控制台显示，而是会在文件中 PrintStream printStream = new PrintStream(\"a.txt\");System.setOut(printStream);System.out.println(\"怎么了，你累了，说好的幸福呢？\"); 运行程序发现控制台没有任何的输出 而在a.txt中出现了打印的语句。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"文件","slug":"文件","permalink":"https://lastknightcoder.gitee.io/tags/%E6%96%87%E4%BB%B6/"},{"name":"File","slug":"File","permalink":"https://lastknightcoder.gitee.io/tags/File/"}]},{"title":"Java网络编程","date":"2019-07-25T16:00:00.000Z","path":"/Java网络编程/","text":"网络编程主要是客户端与服务器之间的交互，与客户端有关的类是Socket，与服务器有关的类是ServerSocket。客户端与服务器之间的通信主要是通过字节流实现的，客户端Socket含有方法 getInputStream() getOutputStream() 来获得流，而服务器通过accept()监听请求的客户端，该方法返回一个Socket类对象，这个对象就是访问的客户端，服务器通过这个Socket获得流，通过该流与客户端通信。 构造方法客户端Socket类的构造方法为 Socket(String host, int port) 第一个参数为域名地址或者IP地址 第二个参数为端口号 服务器端ServerSocket的构造方法为 ServerSocket(int port) 这个参数为端口号 客户端与服务器之间的简单通信下面写一个简单的示例来进行客户端与服务器的通信。 客户端代码 import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class Client &#123; public static void main(String[] args) throws IOException &#123; //创建客户端对象socket 服务器IP地址为127.0.0.1，代表本机 端口号为8888 Socket socket = new Socket(\"127.0.0.1\",8888); //获得输出流以便向服务器发送信息 OutputStream os = socket.getOutputStream(); //向服务器发送信息 os.write(\"这里是客户端\".getBytes()); //获得输入流，以接收服务器返回的信息 InputStream is = socket.getInputStream(); //读取服务器返回的信息并打印 byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0, len)); //释放资源 socket.close(); &#125;&#125; 服务器端代码 import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static void main(String[] args) throws IOException &#123; //创建一个服务器对象 ServerSocket serverSocket = new ServerSocket(8888); //通过accept()方法获得客户端对象 Socket socket = serverSocket.accept(); //通过客户端对象获得输入流，已读取客户端发送的消息 InputStream is = socket.getInputStream(); //读取客户端发送的消息并打印 byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes, 0, len)); //通过客户端对象获得输出流，以便发送消息给客户端 OutputStream os = socket.getOutputStream(); os.write(\"收到了，谢谢\".getBytes()); //释放资源 socket.close(); serverSocket.close(); &#125;&#125; 先运行服务器端的程序，然后运行客户端的程序，服务器的输出为 这里是客户端 客户端的输出为 收到了，谢谢 文件上传将本地的文件传输到服务器，其实原理就是文件的复制，之前我们写过，不过现在是使用网络流来实现，下面是代码，说明都在代码的注释中。 客户端代码 import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class ClientUpload &#123; public static void main(String[]args) throws IOException &#123; //创建输入流读取要上传的文件 InputStream fis = new FileInputStream(\"upload.pdf\"); //创建客户端对象 Socket client = new Socket(\"127.0.0.1\", 8888); //读取文件，并将文件通过socket的输出流传给服务器 byte[] bytes = new byte[1024]; int len = 0; OutputStream os = client.getOutputStream(); while ((len = fis.read(bytes)) != -1) &#123; os.write(bytes, 0, len); &#125; //由于read不会将最后读取到-1发送，那么服务器就得不到-1，就不会终止 //就会进入死循环，所以下面的代码是写入终止符，你可以把下面这行代码去掉，看看会发生什么 client.shutdownOutput(); //获得输入流以便获得服务器的返回信息 InputStream is = client.getInputStream(); while ((len = is.read(bytes)) != -1) &#123; System.out.println(new String(bytes,0,len)); &#125; //释放资源 fis.close(); client.close(); &#125;&#125; 服务器端代码 import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerUpload &#123; public static void main(String[] args) throws IOException &#123; //获得输出流，将上传的文件写到服务器的硬盘中 OutputStream fos = new FileOutputStream(\"uploadServer.pdf\"); //创建服务器对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); //获得输入流读取客户端发送的数据 InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = 0; //读到-1才会终止，所以客户端最后要发一个终止符-1，否则会不断循环 while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes); &#125; //向客户端返回数据\"已经上传完成\" OutputStream os = socket.getOutputStream(); os.write(\"已经上传完成\".getBytes()); socket.close(); fos.close(); server.close(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"网络编程","slug":"网络编程","permalink":"https://lastknightcoder.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Java反射","date":"2019-07-19T16:00:00.000Z","path":"/Java反射/","text":"反射是框架设计的灵魂，通过反射我们可以在程序运行时读取配置文件动态的创建一个类，也可以通过读取注解来达到我们想到的功能。与反射有关的类是Class类。 Class类对象的获取方法Class类对象的获取方法有三种 Class.forName(String name) 参数是类的全类名(包名+类名)，可以获得该类的Class对象 类名.class 通过类的静态属性class可以获取Class对象 对象.getClass() 通过对象的getClass()方法可以获取Class对象 假设一个Animal类 public class Animal &#123; public Animal(String name, int age) &#123; this.name = name; this.age = age; &#125; public Animal() &#123; &#125; public String name; private int age; public void eat() &#123; System.out.println(\"eat ...\"); &#125; public void eat(String string) &#123; System.out.println(\"eat \" + string); &#125; private void sleep() &#123; System.out.println(\"sleep ...\"); &#125; @Override public String toString() &#123; return \"Animal&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 现在要通过上面的三种方法获取该类的Class对象 //通过全类名获取Class对象Class cls1 = Class.forName(\"Animal\");//通过类的静态属性class获取Class对象Class cls2 = Animal.class;//通过对象的getClass()获取静态对象Animal animal = new Animal();Class cls3 = animal.getClass(); 另外需要注意的是，通过上面三种方法获取的Class对象是同一个对象 System.out.println(cls1 == cls2); //trueSystem.out.println(cls1 == cls3); //true Class类的常见成员方法与成员变量有关的方法 getFields() 获取public修饰的所有成员变量，返回一个Field[] getField(String name) 获取指定名称被public修饰的成员变量 getDeclaredFields() 同getFields()，不过任意修饰符修饰的都可以获取 getDeclaredField(String name) 同getField(String name)，不过任意修饰符修饰的都可以获取 Field[] fields1 = cls1.getFields();//public java.lang.String Animal.namefor (Field field : fields1) &#123; System.out.println(field);&#125;Field[] fields2 = cls1.getDeclaredFields();//public java.lang.String Animal.name//private int Animal.agefor (Field field : fields2) &#123; System.out.println(field);&#125;Field field1 = cls1.getDeclaredField(\"age\");//private int Animal.ageSystem.out.println(field1); 可以通过set(Object obj, Object value)方法对指定的对象设定值，也可以通过get(Object obj)方法来获取值 Field field2 = cls1.getDeclaredField(\"name\");field2.set(animal,\"Dog\");System.out.println(animal.name); //DogSystem.out.println(field2.get(animal)); //Dog 如果我们要对age进行赋值，因为age变量是private修饰的，是不能在类外面直接访问的，我们可以调用setAccessible(true)方法，来忽略访问修饰符的安全检查(暴力反射) Field field1 = cls1.getDeclaredField(\"age\");field1.setAccessible(true);field1.set(animal,10);System.out.println(field1.get(animal)); //10//System.out.println(animal.age); //会报错，不能这么访问 与构造方法有关的方法 getConstructors() 得到由public修饰的所有构造方法 getConstructor() 获取指定参数的构造函数，如 getConstructor()：获取无参构造函数 getConstructor(String.class, int.class)：获得第一个参数类型为String类型和第二个参数类型为int类型的构造方法 cls1.getDeclaredConstructors() 参照Field cls1.getDeclaredConstructor() 参照Field //获得无参的构造方法Constructor cons1 = cls1.getConstructor();Stream.of(cons1).forEach(System.out::println); //public Animal()//获得参数类型分别为String类型和int类型的构造方法Constructor cons2 = cls1.getConstructor(String.class, int.class);Stream.of(cons1).forEach(System.out::println); //public Animal() 现在获得了构造方法，那么构造方法的作用就是创造对象，我们可以通过Contructor对象的的newInstance()方法创建一个对象，如 //newInstance方法返回的是一个Object对象Animal animal1 = (Animal) cons1.newInstance();Animal animal2 = (Animal) cons2.newInstance(\"Cat\", 2);System.out.println(animal1);System.out.println(animal2); 输出为 Animal&#123;name='null', age=0&#125;Animal&#123;name='Cat', age=2&#125; 如果想创建一个无参的对象，可以直接通过Class对象的newInsatance()方法创建，如 Animal animal3 = (Animal) cls1.newInstance(); 与成员方法有关的方法 getMethods 获取所有public修饰的方法 getMethod() 通过方法名和参数类型(区别重载的方法)获取public修饰的指定方法 getDeclaredMethods 忽略修饰符 getDeclaredMethod 忽略修饰符 //获取不带参数的eat方法Method eat1 = cls1.getMethod(\"eat\");//获取带一个参数类型为String的eat方法Method eat2 = cls1.getMethod(\"eat\",String.class);//获取private修饰的sleep方法Method sleep = cls1.getDeclaredMethod(\"sleep\"); 获取到了方法，那么接下来就是怎么使用的问题，我们可以使用invoke()方法来执行方法，需要传入相应的对象和需要的参数，如果方法不需要参数，那么可以不传，如 eat1.invoke(animal);//需要传入参数eat2.invoke(animal,\"饭\");//因为sleep是private修饰的，要执行就要执行下面这一步sleep.setAccessible(true);sleep.invoke(animal); 输出为 eat ...eat 饭sleep ... 我们还可以通过getName()方法获得方法名，如 System.out.println(eat1.getName()); //eat 我们可以通过Class对象的getName()方法获得该类的全类名(包名+类名) System.out.println(cls1.getName()); //Animal 使用反射读取配置文件动态创建任意的对象我们现在有这么一个需求，那就是希望创建任意一个类的对象，并且调用相应的方法，要求不能更改代码，而只需要更改配置文件即可。现在我们创建一个config.properties的配置文件，内容如下 className=AnimalmethodName=eat 我们要做的就是读取配置文件，然后根据配置文件创建相应类的对象并且调用其方法 import java.io.FileNotFoundException;import java.io.FileReader;import java.lang.reflect.Method;import java.util.Properties;public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; //创建Properties读取配置文件 Properties pro = new Properties(); pro.load(new FileReader(\"G:\\\\JavaProject\\\\Fourth\\\\src\\\\config.properties\")); //获得类名和方法名 String className = pro.getProperty(\"className\"); String methodName = pro.getProperty(\"methodName\"); //根据类名获取Class对象 Class cls = Class.forName(className); //获取方法 Method method = cls.getMethod(methodName); //使用无参构造方法创建对象 Object o = cls.newInstance(); //调用方法 method.invoke(o); &#125;&#125; 现在我们运行一下 eat ... 现在我们要创建什么类的对象并且要调用什么方法，只需要修改配置文件就可以了，不用修改代码了。虽然还有很多的问题，比如只能使用无参构造方法创建对象，只能调用无参的方法，不过即使是这样也让我们感受到了反射的强大。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://lastknightcoder.gitee.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java8新特性","date":"2019-07-13T16:00:00.000Z","path":"/Java8新特性/","text":"本篇文章会介绍Java 8中的一些新特性(不包括Lambda表达式，因为在Java多线程这篇文章中介绍过了)。主要内容是Java 8中新增的函数式接口以及Stream流，还有方法引用。 常用函数式接口函数式接口指的就是接口里面只含有一个抽象方法。这样我们就可以使用Lambda表达式编程，这是一种函数式编程的思想，强调的是怎么做。Java 8提供了很多的函数式接口，这里我们介绍常见的函数式接口。 Supplier\\&lt;T&gt; Consumer\\&lt;T&gt; Predicate\\&lt;T&gt; Functional\\&lt;T,R&gt; Supplier&lt;T&gt;该接口里面有一个T get()方法，按照字面意思，是提供者的意思，表示生产出一个与泛型类型T相同的数据。下面我们来讲一个例子说明此接口的使用。假设有一个方法，需要返回一个字符串，该字符串由Supplier接口的get()方法产生，而产生什么样的字符串，则由程序员在调用该方法是传入Lambda决定。如下方法传入一个Supplier接口得到一个字符串 public static String getString(Supplier&lt;String&gt; supplier) &#123; return supplier.get();&#125; 我们在main方法中调用该方法 String str = getString(() -&gt; &#123; return \"Hello World!\";&#125;); 输出为 Hello World! Consumer&lt;T&gt;与Supplier接口不同的是，Consumer接口是消费或者说处理一个与泛型类型相同数据类型的数据，它有一个accept(T t)方法，该方法用来消费数据，假设有下面这一个方法 public static void handleString(String str, Consumer&lt;String&gt; consumer) &#123; consumer.accept(str);&#125; 我们使用Consumer来消费(处理)传入的这个字符串，而怎么消费，就取决与程序员在调用该方法时传入的Lambda，这时对程序员来说，就是怎么做的问题，相当于传入一个方法去处理数据，这就是函数式编程，这里我们就简单的将传入的数据进行打印 handleString(\"Hello Again!\", (String str) -&gt; &#123; System.out.println(str);&#125;); 输出为 Hello Again! Consumer接口中有一个默认方法andThen(Consumer consumer)，看下面的程序说明它的用处 con1.andThen(con2).accept(str); //con1和con2都是Consumer接口的实现类对象//相当于下面的代码con1.accept(str);con2.accept(str); 假设有一个方法有需要传入两个Consumer接口对数据进行消费 public static void handleInterger(Integer i, Consumer&lt;Integer&gt; con1, Consumer&lt;Integer&gt; con2) &#123; con1.andThen(con2).accept(i);&#125; 在mian方法中使用，con1对数字进行+10然后打印，con2对数字进行*10然后打印 handleInteger(10, (i) -&gt; &#123; i = i + 10; System.out.println(i);&#125;, (i) -&gt; &#123; i = i * 10; System.out.println(i);&#125;); 输出为 20100 Predicate&lt;T&gt;Predicate接口中有一个test(T t)，它的作用是对某种数据类型进行判断，它返回一个boolean值。假设有一个集合，我们对其中的元素进行判断，符合条件放入一个新的集合，看下面的方法。 public static HashMap&lt;String, Integer&gt; getMap(HashMap&lt;String,Integer&gt; map, Predicate&lt;Integer&gt; predicate) &#123; //创建一个集合用以放符合条件的元素 HashMap&lt;String,Integer&gt; resmap = new HashMap&lt;&gt;(); //遍历集合 Set&lt;String&gt; key = map.keySet(); for (String str : key) &#123; int val = map.get(str); //对值进行判断 boolean res = predicate.test(val); //如果值符合条件，就加入新的集合 if (res) &#123; resmap.put(str,val); &#125; &#125; return resmap;&#125; 现在我们在main方法中进行调用 HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();map.put(\"迪丽热巴\",18);map.put(\"古力娜扎\",19);map.put(\"佟丽娅\",20);map.put(\"奥特曼\",100);//筛选出年龄小于等于20岁的HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123; if (i &lt;= 20) &#123; return true; &#125; return false;&#125;);System.out.println(resmap); 运行结果为 &#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125; Predicate还有三个默认方法 and(Predicate\\&lt;T&gt; pre) 与 or(Predicate\\&lt;T&gt; pre) 或 negate() 非 假设对于上面的那个方法，我提出一个新的需求，要求不仅年龄要小超过20岁，而且年龄要大于18 public static HashMap&lt;String, Integer&gt; getMap(HashMap&lt;String,Integer&gt; map, Predicate&lt;Integer&gt; predicate1, Predicate&lt;Integer&gt; predicate2) &#123; HashMap&lt;String,Integer&gt; resmap = new HashMap&lt;&gt;(); Set&lt;String&gt; key = map.keySet(); for (String str : key) &#123; int val = map.get(str); boolean res = predicate1.and(predicate2).test(val); if (res) &#123; resmap.put(str,val); &#125; &#125; return resmap;&#125; 在main方法中调用该方法 HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123; if (i &lt;= 20) &#123; return true; &#125; return false;&#125;, (Integer i) -&gt; &#123; if (i &gt; 18) &#123; return true; &#125; return false;&#125;);System.out.println(resmap); 输出结果为 &#123;佟丽娅=20, 古力娜扎=19&#125; 至于or()和negate()的使用方法同上。 Function&lt;T,R&gt;该接口的作用是将T这种数据类型转化为R这种数据类型，它里面有一个R apply(T t)方法。下面这个方法将一个字符串转化为一个整数 public static Integer StrToInt(String str, Function&lt;String, Integer&gt; fun) &#123; return fun.apply(str);&#125; 在main()方法中调用该方法 Integer integer = StrToInt(\"123\", (String str) -&gt; &#123; //将字符串转化为数字 return Integer.parseInt(str);&#125;);//打印该数字System.out.println(integer); 输出为 123 Function接口中还有一个默认方法andThen(Function&lt;T,R&gt; fun)，这个方法与在上面介绍的Consumer接口的andThen()很像，但是有点不同，Consumer接口的andThen是两个对象消费同一个数据，而Function接口的addThen()是将第一个fun处理后的结果拿给第二个fun去处理，相当于apply(apply())。比如现在我有一个需求，将一个字符串转化为数字，然后将这个数字，+10然后再转化为字符串，这个方法可以这么写 public static String StrPlus(String str, Function&lt;String,Integer&gt; fun1, Function&lt;Integer,String&gt; fun2) &#123; return fun1.andThen(fun2).apply(str);&#125; 我们在main方法中调用该方法 String s = StrPlus(\"123\", (String str) -&gt; &#123; //将字符串转化为数字并加10 Integer i = Integer.parseInt(str); i = i + 10; return i;&#125;, (Integer i) -&gt; &#123; //将数字转化为字符串 return i + \"\";&#125;);System.out.println(s); 输出为 133 Stream流Stream流是Java 8引入的新特性，首先它跟I/O流没有任何的关系，它主要是用来处理集合、数组问题的。要看Stream流有什么用处，还是要看集合处理有什么缺点。 问题引出有下面这么一个数组 String[] strings = &#123;\"张无忌\", \"张三丰\", \"赵敏\", \"张翠山\", \"小昭\", \"张良\"&#125;; 现在我们有如下要求 筛选出以”张”字开头的字符串，放入一个Arraylist集合中 在ArrayList集合中筛选出字符串长度为3的字符串，放入一个新的集合 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();for (String string : strings) &#123; if (string.startsWith(\"张\")) &#123; list1.add(string); &#125;&#125;System.out.println(list1);ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();for (String string : list1) &#123; if (string.length() == 3) &#123; list2.add(string); &#125;&#125;System.out.println(list2); 输出为 [张无忌, 张三丰, 张翠山, 张良][张无忌, 张三丰, 张翠山] 现在我们使Stream流的方式实现 Stream&lt;String&gt; stream = Stream.of(strings);stream.filter(str -&gt; str.startsWith(\"张\")) .filter(str -&gt; str.length() == 3) .forEach(str -&gt; System.out.print(str + \" \")); 输出为 张无忌 张三丰 张翠山 我们发现使用Stream流的代码比遍历集合简单很多，因为使用集合直接遍历真正核心的代码就那么一两句，比如 for (String string : strings) &#123; if (string.startsWith(\"张\")) &#123; list1.add(string); &#125;&#125; 这些代码中核心的就是string.startsWith(&quot;张&quot;)，而其他的代码是为了达到这个目的不得不写的代码。这就是集合相较于Stream流的局限性所在，观察Stream流的写法，根本没有什么遍历集合的代码，直接就是你想要干的事情。 获取Stream流的方法获取Stream流有两种方法 Collection中新加的stream()方法，该方法可以得到一个Stream流，对于Map集合，可以通过keySet(),values(),entrySet()等方法得到Set集合，然后通过Set对象调用stream()方法得到Stream流 Stream流的静态方法of()，该方法接收一个可变参数，所以可以传入一个数组 下面做一个演示 import java.util.*;import java.util.stream.Stream;public class getStream &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"哪吒\"); list.add(\"杨戬\"); Stream stream1 = list.stream(); stream1.forEach(s -&gt; System.out.println(s)); HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"迪丽热巴\",\"女\"); map.put(\"古力娜扎\",\"女\"); map.put(\"哪吒\",\"男\"); map.put(\"杨戬\",\"男\"); Set&lt;String&gt; key = map.keySet(); Stream stream2 = key.stream(); stream2.forEach(s -&gt; System.out.println(s)); Collection&lt;String&gt; vals = map.values(); Stream stream3 = vals.stream(); stream3.forEach(s -&gt; System.out.println(s)); Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet(); Stream stream4 = entries.stream(); stream4.forEach(s -&gt; System.out.println(s)); String[] strings = &#123;\"迪丽热巴\", \"古力娜扎\", \"哪吒\", \"杨戬\"&#125;; Stream stream5 = Stream.of(strings); stream5.forEach(s -&gt; System.out.println(s)); Stream&lt;Integer&gt; stream6 = Stream.of(1,2,3,4,5); stream6.forEach(s -&gt; System.out.println(s)); &#125;&#125; Stream中的常见方法Stream流中的方法分为两类，一类叫做延迟方法，该方法返回的还是一个Stream流对象，所以可以进行链式编程，如filter()；另一类叫做终结方法，该方法不返回Stream流对象，如forEach()， count()(终结方法只有这两个，其他的都是延迟方法)。 filter()该方法需要传入的是一个Predicate\\&lt;T&gt;接口，这个接口我们在常用函数式接口讲过，它是对某中数据进行测试，而filter的作用就是如果test(T t)返回的是true，那么就将这个数据加入到新的流中，遍历完流中所有的元素后返回。 //当字符串以迪开头时返回true，加入到新的流中，这个流会被返回Stream&lt;String&gt; stream1 = stream.filter(s -&gt; s.startsWith(\"迪\"));//forEach是后面要介绍的方法，这里只需要理解为遍历流并打印stream1.forEach(s -&gt; System.out.println(s)); 输出为 迪丽热巴 map()该方法传入的是一个Function&lt;T,R&gt;接口，所以它的作用是将一个类型的转转化为另一个类型的流。如下 //得到一个流，这个流是字符串的长度Stream&lt;Integer&gt; stream1 = stream.map(s -&gt; s.length());stream1.forEach(s -&gt; System.out.println(s)); 这时结果报错了 这是因为这个stream在调用上面的filter()的时候已经使用过了，而流使用了一次就会关闭，不能在使用，这就是为什么会报错的原因，所以我们把代码改为 //得到一个流，这个流是字符串的长度Stream&lt;Integer&gt; stream2 = Stream.of(strings).map(s -&gt; s.length());stream2.forEach(s -&gt; System.out.println(s)); 这时输出为 4422 forEach该方法传入的是一个Consumer\\&lt;T&gt;接口，是一个终结方法，该方法会遍历流中的元素，然后使用Consumer接口中的accept()方法对元素进行处理，比如 stream.forEach(s -&gt; System.out.println(s)); 会逐个打印出流中的元素。 limitlimit方法需要传入一个long类型的数值maxSize，该方法会截取流中的前maxSize个元素放到新流中并返回，如 //这是链式编程Stream.of(strings).limit(2).forEach(s -&gt; System.out.println(s)); 输出为 迪丽热巴古力娜扎 skip该方法接收一个long类型的数据n，它会跳过流中的前n个元素，将剩下的元素放入到一个新流中并返回，如 Stream.of(strings).skip(2).forEach(s -&gt; System.out.println(s)); 输出为 哪吒杨戬 count该方法不需要传入参数，返回一个long类型的整数，该整数是流中元素的个数，这个方法是一个终结方法，不返回Stream流 long num = Stream.of(strings).count();System.out.println(num); 输出为 4 方法引用我们之前在Stream流使用forEach()去打印流中的元素，如 stream.forEach(s -&gt; System.out.println(s)); 但是打印这个方法(System.out.println())是已经存在了的，我们可不可以直接传入这个方法，在这里或者说是引用这个方法，答案是可以的，如下 stream.forEach(System.out::println); 在这里我们引用了System.out对象的println方法，这行语句的作用是上面的语句作用是完全相同的，这就是方法的引用，::就是方法引用的运算符，这是新增的运算符。 那方法引用也要遵循一定的原则，比如你引用的对象必须是存在的，你引用的方法需要传入的参数的个数和类型必须是对的上的，否则就会抛出异常，由于方法的性质不同，所以有很多类型的引用，比如 对象引用成员方法 类引用静态方法 super引用父类方法 this引用成员方法 引用构造方法 引用数组构造方法 下面会详细的展开讲解。 对象引用成员方法其实 stream.forEach(System.out::println); 就是对象引用成员方法，我们引用了System.out对象的成员方法println。 类引用静态方法假设有一个接口Calculate，里面只有一个抽象方法cal(int i) public interface Calculate &#123; int cal(int i);&#125; 所以这是一个函数式接口，现在在有一个方法需要调用这个接口去得到一个数字的绝对值，如 public static int getAbs(int i, Calculate calculate) &#123; return calculate.cal(i);&#125; 我们知道Math类的静态方法abs()可以做到这件事情，所以我们可以直接引用这个方法，如 int num = getAbs(-10,Math::abs);System.out.println(num); 输出结果为 10 super引用父类成员方法假设有一个Greet接口，里面只有一个抽象方法greet()，所以这是一个函数接口 public interface Greet &#123; void greet();&#125; 现在有一个父类Person，里面有一个greet()方法，这个方法在后面是要被子类引用的 public class Person &#123; String name; public Person(String name) &#123; this.name = name; &#125; public Person() &#123; &#125; public void greet() &#123; System.out.println(\"I'm \" + name); &#125;&#125; 现在有一个子类Student继承了Person类 public class Student extends Person &#123; public Student(String name) &#123; super(name); &#125; public static void sayHello(Greet gre) &#123; gre.greet(); &#125; public void greet() &#123; sayHello(super::greet); &#125;&#125; Student中的sayHello()方法需要一个Greet接口，然后我们又在greet()方法中调用了这个方法，并且传入一个super::greet的方法引用(当然这样的代码没有什么意义，只是为了演示)，我们在main中创建一个对象，并调用此方法 Student student = new Student(\"小明\");student.greet(); 输出为 I'm 小明 this引用成员方法还是以上面的Student类为例，假设Student类中有一个成员方法为 public void tempt() &#123; System.out.println(\"我今晚有空哦\");&#125; 然后在greet()方法中再增加一个sayHello()，这时方法的引用指向的是tempt方法，如下 public void greet() &#123; sayHello(super::greet); sayHello(this::tempt);&#125; 现在在main方法中运行一下，输出为 I'm 小明我今晚有空哦 引用构造方法现在假设有这么一个接口 public interface Personable &#123; Person getPerson(String name);&#125; 里面只有一个抽象方法getPerson，所以这是一个函数式接口，该方法根据name返回一个Person对象，现在有一个方法需要传入这个接口得到一个Person对象 public static Person getPerson(String name, Personable personable) &#123; return personable.getPerson(name);&#125; 现在我们在main方法中调用该方法，传入的接口我们使用构造器引用Person::new Person person = getPerson(\"迪丽热巴\",Person::new);person.greet(); 运行输出为 I'm 迪丽热巴 引用数组构造方法引用数组构造方法的格式是int[]::new(这里只以int为例，当然也可以double[]::new)，具体的使用方法同上面的Person类的构造方法引用一致，这里就不多加介绍了。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"JDK 8","slug":"JDK-8","permalink":"https://lastknightcoder.gitee.io/tags/JDK-8/"}]},{"title":"Java多线程","date":"2019-07-12T16:00:00.000Z","path":"/Java多线程/","text":"多线程概述一个软件可以同时干多件事情，就是多线程，目前我们编写的程序都是单线程的，在main方法中从上到下的进行，执行完上面的程序才能执行后面的程序。下面就将讲解如何写多线程程序。 在Java中创建多线程有两种放法，一种是继承Thread类，然后重写它的run()方法。第二种是实现Runnable接口，并且实现run()方法。 继承Thread类继承Thread类实现多线程的步骤为 继承Thread类，重写run()方法 创建类对象，调用继承的start()方法 我们写一个MyThread类继承自Thread类，并重写run方法如下 public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"thread\" + i); &#125; &#125;&#125; 新建一个测试类，在其main方法中创建MyThread对象，并且调用对象继承自Thread的start()方法 MyThread thread = new MyThread();thread.start();for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\" + i);&#125; 程序输出为 观察到main方法中的程序和MyThread的run()方法中的程序在交替的进行。而不是在等待我执行完了，另一个在执行，而是两个在同时的执行，这就是多线程。 实现Runnable接口实现Runnable接口实现多线程的步骤为 实现Runnable接口并实现run()方法 在main中创建实现类对象 将实现类对象多为参数传入Thread()的构造方法，得到一个Thread对象 该Thread对象调用start()方法 下面进行演示，首先创建一个类实现Runnable接口 public class MyRun implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"Run\" + i); &#125; &#125;&#125; 下面在实现类中实现多线程，如下 Runnable run = new MyRun(); //创建实现类对象Thread thread = new Thread(run); //实现类对象作为参数传入Thread的构造方法thread.start(); //Thread对象调用start()方法启动线程for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\" + i);&#125; 输出为 可以观察到main中的程序和run()方法中的程序是在同时进行的。 Thread中的常见方法 getName() 获得线程的名称 currentThread() 获得正在执行的线程 setName(String str) 设置线程的名字 也可以通过new Thread(String str)设置线程的名字 sleep(long l) 线程休眠l毫秒 我们修改MyRun中的run()方法为 for (int i = 0; i &lt; 20; i++) &#123; //获得当前线程并且获得当前线程的名字 System.out.println(Thread.currentThread().getName() + i); &#125; 修改main方法为 Runnable run = new MyRun();Thread thread = new Thread(run);thread.setName(\"run\"); //增加了这一行，设置线程的名字thread.start();for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\" + i);&#125; 输出结果为 线程安全安全问题现在考虑这么一个问题，有三个售票机在售票，那么它们不能发生售出同样的票，也不能售出不存在的票。现在我要用一个类模拟售票机售票，并使用多线程模拟同时售票，新建一个SellTicket类 public class SellTicket implements Runnable&#123; private int ticket = 10; //总共10张票 @Override public void run() &#123; while (true) &#123; //表示一直售票 if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125; &#125; &#125;&#125; 在测试类的main方法中创建三个线程同时售票 Runnable sellTicket = new SellTicket();//创建三个线程 注意必须使用的同一个售票机对象 否则他们就是各自10张票而不是总共10张票new Thread(sellTicket).start();new Thread(sellTicket).start();new Thread(sellTicket).start(); 输出为 我们发现出现了不同的售票线程售出了相同的票，并且有的售票线程售出了不存在的票-1。 线程同步之所以会出现上面的问题，就是因为在有的售票机卖出了票，即进入了if语句后，但是还未进行ticket–操作，但是这个时候这个线程失去了CPU的执行权，并且别的线程拿到了CPU的执行权，由于未对ticket–，所以它们拿到的是同一张票，所以这就是为什么它们能卖出同一张票的原因。同理卖出不存在的票也是同种原因。 那么如何解决这个问题，我们必须要求在售票机在完成售票并且对ticket–之前，别的售票机不能对ticket进行操作，这样就不会出现票重复和卖出不存在的票的情况了，而实现这个的技术就叫做同步。有三种实现方式，分别是 synchronized代码块 同步方法 Lock锁 下面具体介绍用法。 sychronized代码块sychronized代码块的格式为 sychronized(锁对象) &#123; //需要同步的代码，也就是可能出现问题的代码&#125; 其中锁对象可以是任意的对象，当一个线程执行到同步代码块时，会将该锁对象交给这个线程，当这个线程执行完同步代码块时，会释放锁对象，所以如果这个线程在同步代码块内失去了CPU的执行权，因为别的线程没有锁对象，就不能进入同步代码块执行，就会进入堵塞状态，等待锁对象被释放。所以锁对象就相当于是钥匙了，要保证多个线程的锁对象要相同，这样就只有一把钥匙了。 我们重新修改SellTicket的类如下 public class SellTicket implements Runnable&#123; private int ticket = 10; //总共10张票 Object object = new Object(); //锁对象 @Override public void run() &#123; while (true) &#123; //表示一直售票 //同步代码块 一次只有一个线程执行 synchronized (object) &#123; if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125; &#125; &#125; &#125;&#125; 输出结果为 这次我们发现没有卖出重复的票，也没有卖出不可能的票。 同步方法同步方法其实就是使用synchronized修饰的方法，这个方法每次也只能有一个线程执行，它的锁对象是this，我们把上面买票的程序抽取出为一个方法sellTicket() public synchronized void sellTicket() &#123; if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125;&#125; 这时run()可简化为 @Overridepublic void run() &#123; while (true) &#123; //表示一直售票 sellTicket(); &#125;&#125; 输出为 也达到了同样的效果。 注意： 同步方法也可以为静态方法，不过这时的锁对象不在是this了，而是本类的class属性，也是一个对象。 Lock锁Lock是一个接口，它比较灵活。之前我们讲到，在线程执行到synchronized代码块时，会获得锁对象，在执行完代码块时，会释放锁对象，但是这些对我们都是不可见的，而Lock灵活在我们自己觉得在哪里加锁，哪里释放锁。它有两个方法 lock() 加锁 unlock() 释放锁 lock()一般写在同步代码前，unlock()写在同步代码后。ReentrantLock是Lock的实现类，下面我们将演示如何使用Lock锁同步，修改run方法为 Lock lock = new ReentrantLock(); //创建Lock锁实现类对象@Overridepublic void run() &#123; while (true) &#123; //表示一直售票 lock.lock(); //加锁 if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125; lock.unlock(); //释放锁 &#125;&#125; 输出为 可见达到了同步的效果。 等待唤醒当我们排队买奶茶时，我们对老板说我们要一杯奶茶，然后我们就等着，老板去制作奶茶，等老板制作好奶茶后去喊我们。这其实就是等待唤醒，当多个线程去操作同一个资源时，比如奶茶，就需要一方(顾客)等着，等待另一方(老板)唤醒，总不能奶茶没有好我去抢吧。 线程状态在讲解等待唤醒之前，我们先对线程的状态有一个大致的了解，看图 当我们创建一个线程对象还没有start()时，这时它处于New状态；当我们执行start()方法后，这时的线程状态由New转向Runnable运行状态；如果执行完run()方法，或者调用了stop()方法或者抛出了异常那么该线程进入死亡状态。如果在Runnable状态失去了CPU的执行权，那么就会进入Blocked阻塞状态；线程在这里等待CPU的执行权，拿到了CPU的执行权就会从该状态来到Runnable状态；如果线程在运行时执行了sleep(l)或wait(l)(l为等待的时间)方法，那么就会由Runnable状态进入Timed waiting状态，在这个状态中，线程放弃争夺CPU的执行权，当等待的时间到了之后，如果CPU空闲，那么就进入Runnable状态，如果忙碌，那么就进入Blocked状态，与其他线程一起争夺CPU的执行权。如果在Runnable执行了wait()(不带参数的)方法，就会进入Waiting永久等待状态，直到锁对象执行notify()方法唤醒，如果CPU空闲，就进入Runnable状态，否则进入Blocked状态争夺CPU执行权。 等待唤醒这里的等待唤醒指的就是上面提及的Runnable状态执行wait()方法到Waiting永久等待状态，以及执行notiify()方法有永久等待状态到Runnable状态。前者为等待，后者为唤醒。 注意： 只有锁对象才能调用wait()和notify()方法 wait()和notify()的调用者应该是同一锁对象，并且必须写在同步代码块中 执行wait()被唤醒后，会继续执行wait()后面的代码 notify()一次只能唤醒一个线程，唤醒的是睡眠最久的线程，notifyAll()能够唤醒所有的线程 下面以最先提及的买奶茶为例演示这一过程。首先创建Runnable顾客类和老板类和奶茶类 public class MilkTea &#123; String taste; //奶茶口味 boolean flag = false; //奶茶有没有做好&#125; public class CustomerThread implements Runnable &#123; private MilkTea milkTea; //作为锁对象 public CustomerThread(MilkTea milkTea) &#123; this.milkTea = milkTea; &#125; @Override public void run() &#123; while (true) &#123; synchronized (milkTea) &#123; if (milkTea.flag == false) &#123; //奶茶没有准备好 System.out.println(\"老板来杯珍珠奶茶\"); try &#123; milkTea.wait(); //等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(milkTea.taste + \"真好喝\"); //被唤醒后会执行这个 milkTea.flag = false; //奶茶喝完了 milkTea.notify(); &#125; &#125; &#125;&#125; public class Shopper implements Runnable &#123; private MilkTea milkTea; //作为锁对象 和Customer相同 public Shopper(MilkTea milkTea) &#123; this.milkTea = milkTea; &#125; @Override public void run() &#123; while (true) &#123; synchronized (milkTea) &#123; if (milkTea.flag == true) &#123; try &#123; milkTea.wait(); //等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; try &#123; System.out.println(\"做奶茶中 ...\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; milkTea.taste = \"珍珠奶茶\"; milkTea.flag = true; System.out.println(milkTea.taste + \"做好了\"); milkTea.notify(); &#125; &#125; &#125; &#125;&#125; 下面在测试类中创建两个线程 public class Test &#123; public static void main(String[] args) &#123; MilkTea milkTea = new MilkTea(); //作为锁对象 new Thread(new CustomerThread(milkTea)).start(); new Thread(new Shopper(milkTea)).start(); &#125;&#125; 输出为 这就是等待唤醒的过程。 线程池当我们需要一个新的线程执行任务，我们就会创建一个新的线程，但是如果这个线程执行的任务很少，并且我们需要频繁的创建线程，这个创建线程的过程会很耗费时间，所以我们就想有没有一个机制，我们不用创建线程，当我们需要线程时我们去取，当我们用完时，我们还给它。这样就不需要频繁创建线程，省去时间，提高效率。线程池可以帮我们实现这一个想法。 那接下来的问题我们怎么使用Java为我们准备的线程池，Executors提供了一个静态方法newFixedThreadPool(int nThreads)，这个方法接收的参数是线程池中线程的个数，返回一个ExecutorService对象，然后我们就可以使用该对象的submit(Runnable task)方法，传入一个Runnable实现类对象就可以了。下面我们来示例一番 import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPool &#123; public static void main(String[] args) &#123; //创建一个匿名内部类 Runnable run = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125; &#125;; //长度有三个线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); //三个线程执行任务 threadPool.submit(run); threadPool.submit(run); threadPool.submit(run); &#125;&#125; 输出为 pool-1-thread-1 0pool-1-thread-2 0pool-1-thread-1 1pool-1-thread-2 1pool-1-thread-1 2pool-1-thread-3 0pool-1-thread-2 2pool-1-thread-3 1pool-1-thread-1 3pool-1-thread-3 2pool-1-thread-2 3pool-1-thread-3 3pool-1-thread-1 4pool-1-thread-3 4pool-1-thread-2 4 Lambda表达式我们在创建一个线程时，我们一般需要做一下的步骤 创建一实现类实现Runnable接口 重写run方法 创建实现类对象 将该对象传入Thread的构造方法中 上面的写法可以简化，省去创建一个实现类，直接创建一个匿名内部类 创建一个Runnable匿名内部类 重写run方法 将该对象传入Thread的构造方法中 其实上面有很多的代码是多余，真正有用的代码就是run()方法里面的代码，但是为了创建一个线程我们不得不要创建一个对象，然后巴拉巴拉。其实有时候我们不关心谁来做，只需要告诉我怎么做，比如一个线程你只需要告诉我run()方法就可以了，告诉我怎么做就可以了，但是我们却要创建一个对象等等一系列的操作才能达到这个目的。 Lambda的使用Java在JDK 1.8中引入了Lambda表达式，可以极大简化我们的编程，可以做到我上面所说的只关心怎么做的问题，不需要创建对象。我们来看看下面这段代码用Lambda怎么写 new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;&#125;).start(); Lambda的写法为 new Thread(() -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;); 现在你可能没有看懂这个写法，下面让我为你解释一番。首先我们注意到 new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;&#125; 被简单的替换为了 () -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125; 两段代码很像，但是Lambda省略了很多的东西。首先我们知道Thread()里面传的是一个Runnable实现类的对象，该类重写类run方法，真正有用的就是run方法，所以我们把这些全部省略了，直接传入一个run()就可以了，并且由于run()方法的方法名是确定的，我们连run方法名都可以省去，返回值类型也是确定，所以我们也可以省去，最后只剩一个参数列表，在参数列表与方法体之间加入-&gt;就是Lambda表达式。使用Lambda不用创建对象，我们只需要传入一个方法，告诉它怎么做就可以了。这个也叫做函数式编程。 Lambda表达式的格式为 (参数列表) -&gt; &#123; //方法体&#125; 为了熟悉Lambda表达式的使用，我们来看一个例子，定义一个Calculator的接口，里面有一个方法叫calculate(int a, int b);，如下 public interface Calculator &#123; int calculate(int a, int b);&#125; 在测试类中定义一个方法，该方法需要Calculator接口作为参数 public static int cal(int a, int b, Calculator calculator) &#123; int result = calculator.calculate(a,b); return result;&#125; 这个方法表示的是，a,b经过Calculator计算之后得到一个数，而计算方法，根据我们传入的calculator而定，这明显是我们只需要告诉计算器怎么做就行，我们把做的方法告诉它，使用Lambda表达式 //加法计算器int result1 = cal(2,3, (int a, int b) -&gt; &#123; return a + b;&#125;);System.out.println(result1);//减法计算器int result2 = cal(2,3, (int a, int b) -&gt; &#123; return a - b;&#125;);System.out.println(result2); 输出为 5-1 根据我们传入的方法不同，这个计算器就不同，计算器关心的就是怎么做，你告诉怎么做就可以。 Lambda的省略格式其实上面的Lambda还可以进行化简，因为还有很多是可以推断出来的，比如参数列表里面的参数类型可以省略，因为这个参数类型时确定的，不可能会变的。如 int result1 = cal(2,3, (a, b) -&gt; &#123; return a + b;&#125;); 如果方法体里面只有一条语句时，那么花括号也可以省略，这时分号也可以省略，如果这条语句是return语句，那么return也可以省略，因为必须是要返回一个值的，这个可以推断出来，所以可以省略，所以上面又可以简写为 int result1 = cal(2,3, (a, b) -&gt; a + b); 如果参数列表里面只有一个参数的话，那么小括号也可以省略 param -&gt; &#123; //方法体&#125; Lambda表达式的使用前提虽然Lambda表达式这么好用，但是是有使用前提的 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 比如Runnable接口，里面只有一个run()方法是抽象方法 比如上面定义的Calculator接口，里面也只有一个抽象方法calculate() 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 不能是我要一个Calculator接口的calculate()方法，你给我传一个Runnable的run()方法，兄弟，暗号对不上啊。 备注：有且仅有一个抽象方法的接口，称为”函数式接口“。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://lastknightcoder.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java常用API","date":"2019-07-11T16:00:00.000Z","path":"/Java常用API/","text":"API全称叫做Application Programming Interface，翻译成应用程序编程接口，其实你把它看做是Java的使用说明书进行，它告诉你Java有哪些类，有哪些方法，你直接用就可以，相当于给你一个插座(接口)，你用的时候插上去就行。 Scanner我们之前做的都是从屏幕输出，现在将介绍如何获取从键盘输入。Scanner类是系统提供的一个类，它可以帮助我们从键盘获取输入。一般使用系统提供的类分为三部分 导包 创建对象 使用 导包语句放在package之后，放在public class之前，如果使用的类与当前类属于同一个包，那么不用导入，如果要使用的类在java.lang包下，也不需要导入。导包的格式为 import 包名.类名; //导入指定包下面的类import 包名.*; //导入指定包下的所有类 Scanner类位于java.util包下，所以我们需要导入，下面介绍如何使用Scanner类 import java.util.Scanner; //1. 导包public class TestScanner &#123; public static void main(String[] args) &#123; //2. 创建一个Scanner对象 //Scanner的构造方法需要传入参数，这里传入的是System.in，代表的是从键盘输入 Scanner sc = new Scanner(System.in); //3. 使用 int num = sc.nextInt(); //获得从键盘输入的一个整数 String str = sc.next(); //获得从键盘输入的一个字符串 //打印输入的结果 System.out.println(num); System.out.println(str); &#125;&#125; 程序运行效果为： 注意： 其实从键盘输入全部都是字符串，即使你输入的是65这里的整数，系统得到的只是对于的ASCII码值，而nextInt()方法之所以能获得整数，是因为nextInt()方法做了处理，将字符串转化为了整数。 next()方法只能获得一个字符串，如输入的是Hello World，它只能得到Hello。 RandomRandom类的作用主要是用于产生随机数的，它位于java.util包下面。下面介绍它的两个主要的方法 nextInt()：产生一个随机整数，范围时整个int的大小 nextInt(int n)：产生一个[0,n)的整数，左闭右开。 下面将介绍Random的使用。下面这个程序将产生10个随机整数，范围为整个int整数的范围 import java.util.Random;public class TestRandom &#123; public static void main(String[] args) &#123; Random r = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt()); &#125; &#125;&#125; 程序输出为 可见产生的整数是随机的，并且范围时整个int的范围，正值和负值都有。 下面这个程序将产生10范围为1-10的随机整数 import java.util.Random;public class TestRandomAgain &#123; public static void main(String[] args) &#123; Random r = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt(10) + 1); //nextInt(10)的范围为0-9，+1变为1-10 &#125; &#125;&#125; 程序输出为 输出的数字的范围在1-10之间，并且输出的数字是随机的。 StringString这个类是我们最常用的一个类了，因为我们会牵涉到很多的字符串的操作，所以这里要详细讲一下String类。 String类的定义String类位于java.lang包中，我们在之前讲过，java.lang是默认导入的，所以我们不需要导入这个包，这也是为什么在之前我们可以直接的使用String这个类。字符串效果上相当于是一个字节数组。 String作为引用类型，所以String对象的创建当然要借助于构造方法了，String的构造方法有很多，这里只讲常见的三种String构造方法。 public String() 创建一个空字符串 public String(char[] array) 根据一个字符数组来创建一个字符串 public String(byte[] array) 根据一个字节数组来创建一个字符串 下面我将演示通过这三种方法创建字符串对象。 public class TestString &#123; public static void main(String[] args) &#123; String str1 = new String(); //\"\" char[] chars = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars); //\"abc\" byte[] bytes = &#123;97, 98, 99&#125;; String str3 = new String(bytes); //\"abc\" System.out.println(str1); System.out.println(str2); System.out.println(str3); &#125;&#125; 输出为 abcabc 因为字符串是在是太常用，通过构造方法创建有点麻烦，所以系统设计出可以通过&quot;&quot;的字面量的形式来创建一个String对象，这也是我们经常使用的方式 String str = \"abc\"; 注意： Java程序中所有字符串的字面值（&quot;&quot;）都是String类的实例 字符串一旦创建不可改变 常量池我们知道可以通过字面量（&quot;&quot;）的形式来创建字符串对象，这样创建对象与使用构造方法创建的对象有什么不同呢? 下面我们来看一个字符串比较的例子 public class ConstantString &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; String str3 = new String(new char[]&#123;'a','b','c'&#125;); String str4 = new String(new byte[]&#123;97, 98, 99&#125;); System.out.println(str1); System.out.println(str2); System.out.println(str3); System.out.println(str4); &#125;&#125; 输出为 abcabcabcabc 在这里我们创建了四个字符串，他们的内容都是”abc”，现在我要对它们进行比较 System.out.println(str1 == str2);System.out.println(str1 == str3);System.out.println(str1 == str4);System.out.println(str3 == str4); 输出结果为 truefalsefalsefalse 这里得到的结果可能与你想象的不一样，所以我要详细讲一下。 首先==比较符比较的是什么？由于字符串都是引用类型，所以这里比较的是它们的地址，那按道理说，每创建一个对象，会在堆中开辟一个空间，每个空间的地址都不一样，那么它们比较的值应该都是false，那么为什么通过字面量创建的字符串对象比较出来的结果是true呢？ 要解释这一个现象，就需要知道一个东西，那就是常量池。程序中直接用双引号写上的（即通过字面量创建的字符串），都在常量池中，而new出来的对象不再常量池中。现在记住这一句话，我们去内存看看到底怎么回事，由于这次不牵涉到方法区，我们只画出栈内存和堆内存。 字符串的相关方法字符串比较之前我们说==比较是基于地址的比较，但是我们如果基于内容比较怎么办？比如说上面的字符串如果进行比较的话，就会返回true。有两个方法，第一个是equals()方法，该方法其实也是基于==比较的，不过String类重写了该方法，只要两个字符串的内容相同就会返回true。这里又提到了重写，不懂没关系，只要知道，字符串调用这个方法是基于内容的比较，而不是基于地址的比较，下面演示一番。 public class CompareString &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; String str3 = new String(new char[]&#123;'a','b','c'&#125;); String str4 = new String(new byte[]&#123;97, 98, 99&#125;); System.out.println(str1.equals(str2)); System.out.println(str1.equals(str3)); System.out.println(str1.equals(str4)); System.out.println(str3.equals(str4)); &#125;&#125; 输出为 truetruetruetrue 注意： equals()方法具有对称性 如果比较的双方一个是常量，一个是变量，推荐使用常量调用方法 针对第二条的原因是，如果变量str未被初始化，那么它的初始值是null，null根本没有equals方法，所以调用该方法会报错 String str; //str = nullstr.equals(\"abc\"); //会报错\"abc\".equals(str); //不会报错，会返回false 字符串比较的第二个方法是equalsIgnoreCase()，该方法与equals不同的是，该方法的比较忽略大小写，而equals()是大小写敏感的。 System.out.println(\"hello\".equalsIgnoreCase(\"Hello\")); 输出为 true 字符串截取与字符串截取有关的方法是substring()，该方法有两种常用的重载 substring(int index) 从index截取到末尾 substring(int begin, int end) 从begin截取到end，左闭右开[begin, end) 字符串转换介绍三个方法 toCharArray() 将字符串转换为char[] getBytes() 将字符串转换为byte[] replace(CharSequence oldString, CharSequence newString) 这里的CharSequence是接口，这里不懂也没关系，知道这个可以接收字符串类型就可以 这个方法的作用是新的字符串替换旧的字符串 字符串分割与字符串分割的方法只有一个 split(String regex) 按照regex的规则分割字符串，返回一个字符串数组 按照regex的规则分割字符串可能有点难以理解，其实这里的regex是正则表达式，不懂的话看懂下面的例子就可以 public class SplitString &#123; public static void main(String[] args) &#123; String str = \"a,b,c\"; String[] strings = str.split(\",\"); //按照逗号的分割字符串，得到的是[\"a\",\"b\",\"c\"] for (int i = 0; i &lt; strings.length; i++) &#123; System.out.println(strings[i]); &#125; &#125;&#125; 输出为 abc 注意： 如果要按”.”规则分割的话，不能写”.”，要写成”\\.”，因为.在正则表达式中有特殊的含义，所以需要转义。 ArraysArrays位于java.util包中。这个类提供了很多的静态方法，实现数组的常见操作。在这里我们介绍两个常用的方法 toString 接收一个数组参数 将参数数组变成字符串 [元素1，元素2， …] sort 按默认升序（从小到大）对数组进行排序 对于String，按字母在Unicode表中的大小排序 对于自定义的类型，需要Comparable或Comparator接口的支持 下面演示两个方法的使用 import java.util.Arrays;public class TestArrays &#123; public static void main(String[] args) &#123; //创建一个整型数组 int[] arrays = &#123;5, 8, 4, 12, 3, 7&#125;; //调用Arrays.toString() 我们不用遍历数组打印了 System.out.println(Arrays.toString(arrays)); //对数组进行排序 这里不是返回一个新的数组 而是对原有数组进行排序 Arrays.sort(arrays); //将排序后的数组打印出来 System.out.println(Arrays.toString(arrays)); &#125;&#125; 输出为 [5, 8, 4, 12, 3, 7][3, 4, 5, 7, 8, 12] MathMath类位于java.util包中，该类包含了很多与数学计算相关的静态方法。这里介绍几个与整数操作有关的方法 abs() 取绝对值 abs(-2) = 2 ceil() 向上取整 ceil(2.1) = 3，ceil(-2.1) = -2 floor() 向下取整 ·floor(2.1) = 2，floor(-2.1) = -3 round() 四舍五入 round(2.1) = 2，round(-2.1) = -2 当然Math类还包含很多的方法，具体的可以查阅资料。 ObjectObject类是所有类的父类，所有类都默认继承了（直接或间接）Object类。所以所有的类都默认有Object类中的成员方法。这里介绍两个比较重要的Object类的成员方法 toString() equals(Object object) toString我们在之前一直有用System.out.println()语句打印信息到控制台，当我们传入一个引用类型变量的时候，它会调用该对象的toString()方法，由于Object类的toString方法是默认打印堆内存的地址值，所以这也是为什么我们在打印数组时，打印出的是地址值。而我们打印String类型时，打印出的却是它的内容，这时因为String重写toString()方法。 为了验证我们的猜想，我们看下面这么一个类 public class Person &#123;&#125; 我们现在创建一个Person对象，并且打印出来，然后调用toString()方法，在打印一遍 public class TestToString &#123; public static void main(String[] args) &#123; Person per = new Person(); System.out.println(per); System.out.println(per.toString()); &#125;&#125; 输出为 Person@4554617cPerson@4554617c 我们发现结果是一样的，现在我们在Person类中重写toString()方法 public class Person &#123; @Override public String toString() &#123; return \"I'm a Person object\"; &#125;&#125; 在运行一遍，输出为 I'm a Person objectI'm a Person object equals在前面我们比较字符串时，我们说==是对象的地址值进行比较，而equals方法是基于内容的比较。事实上，Object类的equals方法也是进行对象地址值的比较，只不过是String类重写了equals方法。 我们可以通过重写equals方法来设置怎样两个对象才是相等的。比如还是以Person类进行举例，它有姓名和年龄两个成员变量，我们认为如果两个人的姓名和年龄都是一样的，那么我们就认为这两个人的对象是相同的 public class Person &#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object obj) &#123; //因为要使用Person对象的name和age属性，所以要向下转型 if (obj instanceof Person) &#123; Person person = (Person) obj; //如果姓名和年龄相同，就认为对象是相同的 if (this.name == person.name &amp;&amp; this.age == person.age) &#123; return true; &#125; &#125; return false; &#125;&#125; 现在我们在测试类类中测试一下 public class TestEquals &#123; public static void main(String[] args) &#123; Person person1 = new Person(\"迪丽热巴\",20); Person person2 = new Person(\"古力娜扎\",28); Person person3 = new Person(\"迪丽热巴\",20); System.out.println(person1.equals(person2)); //年龄和姓名不一样，返回false System.out.println(person1.equals(person3)); //名字和年龄一样，返回true System.out.println(person1 == person3); //地址值是不同的，所以是false &#125;&#125; 输出为 falsetruefalse DateDate是有关于日期的类，它位于java.util包中。现在主要介绍它的两种常用的构造方法，以及一个有关于格式化输出的类SimpleDateFormat。 构造方法Date date = new Date(); //默认得到的是当前时间的日期Date date = new Date(long l); //接收一个毫秒值，该毫秒值代表的是距离时间原点消耗的毫秒值 时间原点规定为1970年1月1日的00:00:00时刻。现在简单演示Date类的使用 import java.util.Date;public class TestDate &#123; public static void main(String[] args) throws ParseException &#123; Date date = new Date(); System.out.println(date); &#125;&#125; 输出为 Sat Jul 20 19:26:26 CST 2019 可见Date类重写了toString()方法。 Date类有一个getTime的方法，它可以获得该date对象对应的毫秒值，现在我们通过这个方法获得一个毫秒值，然后利用该毫秒值作为第二个构造函数的参数 import java.util.Date;public class TestDate &#123; public static void main(String[] args) throws ParseException &#123; Date date = new Date(); System.out.println(date); long ms = date.getTime(); Date date2 = new Date(ms); System.out.println(date2); &#125;&#125; 输出为 Sat Jul 20 19:29:24 CST 2019Sat Jul 20 19:29:24 CST 2019 SimpleDateFormat上面的时间输出其实不符合我们的使用习惯，所以我们可以让输出的日期符合我们的使用习惯。DateFormat这个类是为此而存在的，不过它是一个抽象类，SimpleDateFormat类继承了该类，我们可以使用该类格式化日期输出。 首先就是如何创建一个对象，如下 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(模式); 可能这里还不能理解模式是个什么鬼，那么就要看下面这个例子 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日\"); “yyyy年MM月dd日”就是模式，差不多就是模板吧，也就是你想要格式化输出的格式，其中yyyy代表年，MM代表月，dd代表日，HH代表小时，mm代表分，ss代表秒。 这里主要介绍它的两个方法 format 接收一个日期对象，返回一个字符串，这个字符串的格式与你上面定义的模式相同 parse 接收一个字符串，这个字符串的格式必须与你定义的模式相同，否则会报错 方法一个Date对象 parse方法会抛出一个异常，对于抛出异常的方法，要么继续抛出异常，要么使用try-catch处理 下面介绍这个类的使用 import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDate &#123; public static void main(String[] args) throws ParseException &#123; //parse方法有可能抛出这个异常，这里我们不处理，继续抛出 Date date = new Date(); //创建一个Date对象作为后面format方法的参数 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); //定义输出格式 String formatDate = simpleDateFormat.format(date); //获得由date转化得到的格式化输出字符串 System.out.println(formatDate); Date dateAgain = simpleDateFormat.parse(\"2017年5月13日 15:23:14\"); //根据指定的格式解析出一个Date对象 System.out.println(dateAgain); //打印该Date对象 &#125;&#125; 输出为 2019年07月20日 19:43:18Sat May 13 15:23:14 CST 2017 CalendarCalendar是一个有关于日期的类，它提供了一些操作日历的方法，它是一个抽象类，所以不能创建Calendar对象，我们可以通过它的静态方法getInstance()得到它的一个子类对象，如下 Calendar calendar = Calendar.getInstance(); 这里仅简单介绍它的四个方法 get(int field) 根据指定field值获取日历信息，field值一般为Calendar类的静态常量，如get(Calendar.YEAR)可以获得有关于年份的信息 set(int field, int value) 设置指定的field为指定的value add(int field, int amount) 为指定field加上amount 这里需要注意的是，如果加上数值之后超过范围之后，会有进位。比如现在为7月，我给MONTH加上了10，那么现在年份会加1年，并且此时的月份为7 + 10 -12 = 5。 getTime() 返回当前日历对应得Date对象 下面简单演示方法的使用 import java.util.Calendar;import java.util.Date;public class TestCalendar &#123; public static void main(String[] args) &#123; Calendar calendar = Calendar.getInstance(); System.out.println(calendar); //打印出的不是地址，可见Calendar也重写了toString()方法 System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); //西方的月份是从0开始的，所以这里我加1 System.out.println(calendar.get(Calendar.DATE)); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); //与上面DATE的效果是一样的 System.out.println(calendar.get(Calendar.HOUR)); System.out.println(calendar.get(Calendar.MINUTE)); System.out.println(calendar.get(Calendar.SECOND)); System.out.println(\"=============\"); calendar.set(Calendar.YEAR, 2020); //设置年份为2020年 System.out.println(calendar.get(Calendar.YEAR)); calendar.add(Calendar.MONTH,10); //给月份加10个月，现在为2021年5月了 System.out.println(calendar.get(Calendar.MONTH) + 1); Date dateAgain = calendar.getTime(); //得到一个日期对象 System.out.println(dateAgain); &#125;&#125; 输出为 java.util.GregorianCalendar[time=1563623852127,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2019,MONTH=6,WEEK_OF_YEAR=29,WEEK_OF_MONTH=3,DAY_OF_MONTH=20,DAY_OF_YEAR=201,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=3,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,MINUTE=57,SECOND=32,MILLISECOND=127,ZONE_OFFSET=28800000,DST_OFFSET=0]20197202075732=============20205Thu May 20 19:57:32 CST 2021 SystemSystem是有关于系统的类，这里不会介绍那么高深的内容，主要介绍两个静态方法 currentTimeMillis() 获得当前系统距时间原点的毫秒值 这个方法可以用来计算程序损耗的实践 在程序开始执行前获取一个时间，在程序执行完成获取一个时间，两个时间相减就可以知道程序执行的时间，就可以知道程序的哪一部分最耗时，从而做出优化 arraycopy() 该方法的作用是将源数组从指定位置开始复制，有一个参数规定了复制的长度，复制到另一个数组，这个数组也规定了起始的位置 该方法接收五个参数 第一个参数是一个源数组src，第二个参数是源数组的起始位置，第三个参数是目的数组，第四个参数是目的数组的起始位置，第五个参数是复制的长度 如果你在这里没有理解，请看下面的例子 下面简单演示这两个方法的使用 import java.util.Arrays;public class TestSystem &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //循环执行前获取一次时间 int sum = 0; for (int i = 0; i &lt; 10000000; i++) &#123; //1000万次 sum = sum + i; &#125; long end = System.currentTimeMillis(); //循环结束后获取一次时间 double time = (end - start) / 1000.0; //将单位转化为s System.out.println(\"共花费\" + time + \"s\"); //我们将源数组的前三个元素替换目的数组的前三个元素 int[] array1 = &#123;1, 2, 3, 4, 5&#125;; //源数组 int[] array2 = &#123;6, 7, 8, 9, 10&#125;; //目的数组 System.out.println(\"转换前\"); System.out.println(Arrays.toString(array1)); System.out.println(Arrays.toString(array2)); System.arraycopy(array1, 0, array2, 0, 3); //前三个元素，所以都是从索引0开始 System.out.println(\"转换后\"); System.out.println(Arrays.toString(array1)); System.out.println(Arrays.toString(array2)); &#125;&#125; 输出为 共花费0.011s转换前[1, 2, 3, 4, 5][6, 7, 8, 9, 10]转换后[1, 2, 3, 4, 5][1, 2, 3, 9, 10] 可见程序是执行的相当的快。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://lastknightcoder.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java集合与泛型","date":"2019-07-07T16:00:00.000Z","path":"/Java集合与泛型/","text":"CollectionCollection是集合的意思，你可以把它看做一种装东西的容器，就像数组一样。它是一个接口，有很多的类实现了它，比如Arralist，LinkedList，HashMap，等等很多。不同的类使用不同的方法去实现，所以他们之间的某些性能是不同的。 Collection中的方法我们这次学习的是Collection接口中的方法，虽然实现它的类很多，但是它们实现的方法的功能都是一样。这里介绍七个方法 add(E e) 添加元素 clear() 清空集合中的所有元素 remove(E e) 删除元素 contains(E e) 查看是否包含某个元素 isEmpty() 查看数组是否为空 size() 返回集合的长度，即元素的个数 toArray 返回一个Onject类型的数组 下面我们以ArrayList为例来学习上面的方法 import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;public class TestCollection &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); //多态写法 //测试add collection.add(\"张无忌\"); collection.add(\"令狐冲\"); collection.add(\"郭靖\"); collection.add(\"杨过\"); System.out.println(collection); //测试contains System.out.println(collection.contains(\"杨过\")); //测试size System.out.println(collection.size()); //测试remove collection.remove(\"杨过\"); System.out.println(collection); //测试toArray Object[] objects = collection.toArray(); System.out.println(Arrays.toString(objects)); //测试clear collection.clear(); System.out.println(collection); System.out.println(collection.size()); &#125;&#125; 我们注意到我们创建Collection对象时，与一般类相比创建多了&lt;&gt;，这个叫做泛型。是什么意思呢? 我们定义数组的话有不同的数据类型，来定义保存什么类型的数据，同样的Collection也有不同的数据类型，来决定里面保存的是什么类型的数据。而数据类型就是写在里面，目前我们就这么理解泛型，有关泛型更加详细的用法，下面会进行介绍。在=号的右边也有&lt;&gt;号，从JDK 1.7开始，右边的&lt;&gt;里面可以什么都不写，之前里面也要写数据类型，但是和右边的一样，所以没必要在写一遍。另一个需要注意的是，泛型（也就是&lt;&gt;里面的数据类型）必须是引用类型，不能是基本类型。 输出为 [张无忌, 令狐冲, 郭靖, 杨过]true4[张无忌, 令狐冲, 郭靖][张无忌, 令狐冲, 郭靖][]0 Iterator我们对集合一个重要的操作就是对集合进行遍历，不同于数组，集合不是所有的都是有序的，所以无法通过索引对集合进行遍历，那我们就只能通过迭代器Iterator来遍历集合，Iterator也是一个接口，集合有一个iterator()方法，可以获取迭代器实现类的对象。迭代器主要有两个方法 hasNext() 判断集合中是否还有下一个元素，有则返回true next() 取出集合中的下一个元素，如何集合中没有元素，使用该方法会抛出异常，所以应该先进行判断是否还有下一个元素 下面我们来示例使用方法 import java.util.Collection;import java.util.HashSet;public class TestIterator &#123; public static void main(String[] args) &#123; //HashSet是一个无序的集合 Collection&lt;String&gt; collection = new HashSet&lt;&gt;(); collection.add(\"亚瑟\"); collection.add(\"妲己\"); collection.add(\"安其拉\"); collection.add(\"狄仁杰\"); collection.add(\"李白\"); System.out.println(collection); &#125;&#125; 输出为 [李白, 妲己, 狄仁杰, 亚瑟, 安其拉] 可见HashSet是一个无序的集合，所以不能通过索引去获取集合中的元素，我们使用迭代器去遍历集合中的元素 Iterator&lt;String&gt; iterator = collection.iterator(); //由集合的iterator()方法创建迭代器while (iterator.hasNext()) &#123; //判断集合中是否还有下一个元素 String string = iterator.next(); //取出下一个元素，每取出一个元素，指针向后移动 System.out.println(string);&#125; 输出为 李白妲己狄仁杰亚瑟安其拉 foreach循环我们知道不能通过一般的for循环去遍历集合，所以Java中有一个增强的for循环，利用它可以遍历集合和数组，它的实现原理就是迭代器的原理，不过使用的是for循环的形式，我们把它叫做foreach循环，格式如下 for (元素类型 变量名 : 集合) 它会自动的取出集合中的元素，并且赋值给变量，然后你就可以在foreach循环中对取出的元素进行操作了，还是以上面的集合为例，演示如何使用foreach循环 for (String string : collection) &#123; System.out.println(string);&#125; 输出为 李白妲己狄仁杰亚瑟安其拉 泛型概述泛型我们之前在使用Collection集合时就已经接触过，那么为什么会使用泛型，比如你正在写一个集合给别人使用，但是你不知道别人会保存什么数据类型，你不能写死了说只能保存String类型，这个时候我就会使用泛型，保存什么类型的数据由别人自己觉得，就像数组一样。 如果省略泛型的话，那么默认为Object类型，比如下面我创建一个ArrayList集合，没有写泛型 import java.util.ArrayList;public class GenericsDemo &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(\"AA\"); list.add(2); list.add('c'); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 输出为 AA2c 这个时候ArrayList集合的对象能够添加任何的数据类型，因为所有的类都继承了Object类，而基本数据类型会进行自动装箱操作转化为对应的包装类。其实上面就是多态的写法，而多态的写法我们也知道它的弊端，他不能调用子类特有的方法，如果我们需要调用子类的方法的话就需要向下转型，这很容易发生异常，并且在编译时不会报错。并且一般我们在集合保存相同的数据类型，所以这个时候我们可以使用泛型。使用泛型的话至少有这两个优点 避免了类型转换的麻烦 编译时就可以看到错误 如果一个String的ArrayList添加Integer数据，那么编译时就会报错 泛型的定义类泛型定义在类中的格式应该如下 public class ClassName&lt;E&gt; &#123; &#125; 其中E就代表泛型，它会在创建对象的时候确定E是什么类型，比如ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();，那么这个时候E就是String。这么定义以后，我们就可以在类中的方法中使用E，如 public void method(E e) &#123; &#125; public E method() &#123; &#125; 可以让它作为方法的参数和返回值，如果在创建对象的时候传入的E是String，那么这些方法的参数或者返回全部都是String类型的。我们可以看做E是一个接收类类型的变量。 方法方法中定义泛型，格式如下 修饰符 &lt;泛型&gt; 返回值 方法名(参数列表) &#123; &#125; 比如下面这么定义 public &lt;M&gt; void method (M m) &#123; &#125; 泛型会在调用方法时确定，比如传入的是一个String类型的参数，那么M就是String。 接口在接口中定义的格式如下 public interface InterfaceName&lt;E&gt; &#123; &#125; 实现类实现接口可以指定泛型是什么或者不指定，就是这个意思 指定 实现类 implements InterfaceName&lt;String&gt; &#123; &#125; 不指定 实现类&lt;E&gt; implements InterfaceName&lt;E&gt; 通配符假设我要写一个方法，输入一个ArrayList对象，要求打印输入列表的所有元素，但是ArrayList是什么类型的不知道，所以方法参数类型不能写死，不能这么写 public void method(ArrayList&lt;String&gt; list) &#123; &#125; 但是我们在上面学了方法的泛型，所以我们可以这么写 public &lt;E&gt; void method(ArrayList&lt;E&gt; list) &#123; &#125; Java停供了一种更加方面的写法，即使用通配符 public void show(ArrayList&lt;?&gt; list) &#123; &#125; 其中?代表的就是通配符，指的就是能够匹配任何的数据类型。 不仅如此我们还能够对通配符进行限定，如 ? extends E 说明参数的类型必须是E的子类或者E本身 ? super E 说明参数的类型必须是E的父类或者E本身 比如下面 import java.util.ArrayList;public class TestTongpeifu &#123; //接收的类型必须为Number类的子类或者Number类本身 public static void show(ArrayList&lt;? extends Number&gt; list) &#123; System.out.println(list); &#125; //接收的类型必须为Number类的父类或者Number类本身 public static void show2(ArrayList&lt;? super Number&gt; list) &#123; System.out.println(list); &#125; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;Object&gt; list3 = new ArrayList&lt;&gt;(); ArrayList&lt;Number&gt; list4 = new ArrayList&lt;&gt;(); show(list1); //Interger是Number的子类，可以 show(list2); //String类与Number类没有关系，报错 show(list3); //Object不是Number的子类，报错 show(list4); //Number本身，可以 show2(list1); //Interger是子类，报错 show2(list2); //String没关系，报错 show2(list3); //Object是父类，可以 show2(list4); //Number本身，可以 &#125;&#125; 与我们分析的一致。 ListList接口是Collection的子接口，实现它的类有ArrayList和LinkedList，ArrayList的底层实现原理是数组，所以它的查询速度快，但是它的增删操作很慢，LinkedList的底层实现原理是链表，所以它的查询操作很慢，它的增删操作很快。 List集合的特点List接口的特点有 有序，所以可以通过索引访问元素 集合中的元素允许重复 因为List接口可以有索引，所以除了Collection中的方法，List还有其特有的方法如下 add(int index, E e) 在指定索引中的位置添加元素，后面的元素向后推移 remove(int index) 删除指定索引的元素，并且返回删除的元素 get(int index) 获得指定索引处的元素 set(int index, E e) 将索引处为元素替换为e 下面示例上面的四个方法 import java.util.ArrayList;import java.util.List;public class TestList &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(5); list.add(7); System.out.println(list); //[1, 5, 7] //add(int index, E e) list.add(2,8); //在索引为2的地方插入8 System.out.println(list); //[1, 5, 8, 7] //get(int index) int num1 = list.get(1); //获得索引为1的元素 System.out.println(num1); //5 //set(int index, E e) list.set(0, 4); //设置索引为0的元素为4 System.out.println(list); //[4, 5, 8, 7] int num2 = list.remove(2); //删除索引为2的元素 System.out.println(list); //[4, 5, 7] &#125;&#125; List的遍历因为List集合是有序的，所以有三种方法可以进行遍历 普通for循环 迭代器 增强for循环 下面进行示例 //普通for写法for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i));&#125;//迭代器写法Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; Integer i = iterator.next(); System.out.println(i);&#125;//增强for写法for (Integer i : list) &#123; System.out.println(i);&#125; ArrayListArrayList在之前我们讲解Collection时就有接触到，所以这里就简单的介绍它。ArrayList集合的使用非常的简单，在上面已经演示过了，并且它的方法都是实现List里面的方法，而这些方法的使用在上面已经了解了，下面看看ArrayList简单例子即可。 import java.util.ArrayList;public class TestArrayList &#123; public static void main(String[] args) &#123; //创建一个ArrayList对象 里面保存的都是String类型 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //向列表中添加三个元素 list.add(\"张三\"); list.add(\"李四\"); list.add(\"王五\"); //打印列表 System.out.println(list); //ArrayList对toString()方法重写了，所以打印输出不是地址值 //获取列表里面的元素 System.out.println(\"列表的第一个元素为：\" + list.get(0)); System.out.println(\"列表的第二个元素为：\" + list.get(1)); System.out.println(\"列表的第三个元素为：\" + list.get(2)); System.out.println(\"列表的长度为：\" + list.size()); //获取列表的长度 System.out.println(\"===============\"); //删除 System.out.println(\"删除的元素为：\" + list.remove(1)); //删除第二个元素，即删除李四 System.out.println(\"列表的长度为：\" + list.size()); //列表的长度 System.out.println(list); &#125;&#125; 输出为： [张三, 李四, 王五]列表的第一个元素为：张三列表的第二个元素为：李四列表的第三个元素为：王五列表的长度为：3===============删除的元素为：李四列表的长度为：2[张三, 王五] 上面代码的注释已经详细说明上面代码的功能，这里说一下一个特别的地方。当我们打印数组名时，会得到数组的地址，但是当我们打印ArrayList对象，输出的不是地址，而是里面的元素，这是因为ArrayList重写了toString()方法，当System.out.println()里面传入的是引用类型时，会调用该引用类型的toString方法，由于ArrayList重写了toString()方法，所以打印输出的不是地址，没有重写该方法的类，打印输出默认是地址。如果在这里你搞不懂什么重写，toString()方法都是什么，那么没关系，你只要知道直接打印ArrayList对象名，输出的不是地址，而是里面包含的所有元素，具体重写是什么，toString()是什么，在后面的继承部分将会有阐述。 需要注意的是，泛型只能是引用类型，不能是基本数据类型，那么如果我们想要保存基本数据类型怎么办。当然是有办法的，Java中为每一个基本数据类型提供了一个包装类，它虽然是一个类，但是你在使用时完全把它当做基本数据类型就可以，因为泛型里面不能是基本数据类型，才会有这么一个包装类。下表是基本数据类型与包装类对应的名称 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 上面除了int和char对应的包装类不只是首字母大写，其他都是只要首字母大写即可。下面我将演示如何存储基本数据类型，以int类型为例 import java.util.ArrayList;public class BasicDataToArrayList &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //把Integer当做int看待即可，我们不需要new 一个Integer对象 编译器会帮我们做处理，我们不需要担心 list.add(100); list.add(25); list.add(15); //打印列表 System.out.println(list); &#125;&#125; 输出为 [100, 25, 15] 在基本数据类型与包装类之间有自动装换，基本数据类型转换为包装类的过程叫做装箱，包装类转化为基本数据类型的过程叫做拆箱，从JDK 1.5开始就支持自动装箱和自动拆箱。即我们可以这么写 Interger a = 12; //自动装箱 int -- Intergerint b = a; //自动拆箱 Interger -- int 所以我们在使用时把Interger看做int就可以了。 LinkedListLinkedList是List的实现类，它的底层原理是基于链表实现的，所以除了List接口中的方法，它还提供了很多与头尾有关的方法，如 addFirst addLast removeFirst removeLast getFirst getLast push 同addFirst一样 pop 同removeFirst 下面进行示范 import java.util.LinkedList;public class TestLinkedList &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); linkedList.add(\"AAA\"); linkedList.add(\"BBB\"); //addFirst 在\"AAA\"前面添加元素\"CCC\" linkedList.addFirst(\"CCC\"); System.out.println(linkedList); //[CCC, AAA, BBB] //push 在\"CCC\"前面添加\"DDD\" linkedList.push(\"DDD\"); System.out.println(linkedList); //[DDD, CCC, AAA, BBB] //pop 删除\"DDD\" System.out.println(linkedList.pop()); //DDD //获得第一个元素 getFirst System.out.println(linkedList.getFirst()); //CCC //removeFirst 删除第一个元素 System.out.println(linkedList.removeFirst()); //CCC System.out.println(linkedList); //[AAA, BBB] //removeLast 删除最后一个元素 System.out.println(linkedList.removeLast()); //BBB System.out.println(linkedList); //[AAA] &#125;&#125; 基本类型与包装类在前面我们就讲过这个概念，不过当时讲的不够详细，现在深入讲解。首先我们知道包装类是什么，因为基本数据类型它不是引用类型，而由于泛型必须是引用类型，所以才有包装类。包装类就是将基本数据类型包装为一个类，这个类我们完全可以当做基本数据类型使用，并且包装类除此之外，还提供了一些方法用法操作基本数据类型，这是基本数据类型所没有的。 装箱与拆箱首先我们将如何进行装箱操作，即将基本数据类型转换为对象的包装类，下面全部以Integer为例，其余的同理，Integer对象的创建有两种方法，一种是通过构造方法，一种是通过Integer的一个静态方法 构造方法 Interger(int value) 接收一个int类型的数值 Interger(String str) 接收一个字符串，该字符串要符合规定的格式，如”100” 静态方法 valueOf() 接收的参数同构造方法，也可以接收字符串类型的参数 下面演示如何创建Interger对象 Integer in1 = new Integer(2);Integer in2 = new Integer(\"20\");Integer in3 = Integer.valueOf(200);Integer in4 = Integer.valueOf(\"2000\");System.out.println(in1 + \" \" + in2 + \" \" + in3 + \" \" + in4); 输出为 2 20 200 2000 那如何通过包装类得到一个基本数据类型呢？通过intValue方法，如下 int i = in1.intValue();System.out.println(i); 输出为 2 自动装箱和自动拆箱自从JDK 1.5以后就实现了自动装箱和拆箱，可以直接把基本数据类型赋值给包装类，也可以把包装类直接赋值给基本数据类型，如下 Integer num = 10; //自动装箱 相当于 Integer num = new Interger(10) 不过现在是自动进行的了int i = num; //自动拆箱 相当于 int i = num.intValue() 基本数据类型与字符串类型相互转换基本数据类型转换为字符串类型 基本数据类型 + “”,如100 + “”得到”100” 包装类的toString(参数)，这个不是Onject的toString()方法，因为它有参数，不是重写 如Integer.toString(100)得到”100” String类的valueOf(参数)方法，如String.valueOf(100)得到”100” 字符串转基本数据类型 包装类的parseXxx，如Integer.parseInt(“100”)得到基本数据类型100 SetSet接口也是Collection的子接口，它的实现类有HaseSet，LinkedHashSet，HashSet是无序的，LinkedHashSet是有序的。 Set集合的特点 集合中的元素不能重复 没有索引 下面看一个例子 import java.util.HashSet;import java.util.Set;public class TestSet &#123; public static void main(String[] args) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(1); set.add(3); set.add(2); set.add(1); System.out.println(set); //无序且不能重复 [1, 2, 3] &#125;&#125; 可见集合的顺序与添加的顺序无关，并且添加重复的元素是不行的。 Set集合不能添加重复元素的原理：Set集合的底层原理是Hash表，首先会根据要添加的元素计算出它的哈希值，根据哈希值添加到数组中，数组中存储的是链表或者红黑树，元素会添加到数组里面的链表或者红黑树中。一般不同的元素会添加到数组的不同索引中，即不同的链表或红黑树中，但是也有可能虽然元素不同，但是它们的哈希值相同，这个就叫做哈希冲突。如果发生了哈希冲突，那么会使用equals()方法判断该链表或红黑树中是否存在与这个元素相同的元素，如果有，那么就不添加，如果没有，那么就添加。 所以如果你要添加自定义的类型，那么就要重写Object类的hashCode()方法和equals()方法。 Set集合的遍历Set由于它是无序的，所以它不能使用普通for循环遍历，所以只能使用 迭代器 增强for 由于与List差不多，这里就不在演示了。 LinkedHashSetLinkedHashSet是HashSet的子类，但是它是有序的。如 import java.util.LinkedHashSet;import java.util.Set;public class TestLinkedHashSet &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); set.add(\"aaa\"); set.add(\"ccc\"); set.add(\"bbb\"); System.out.println(set); //[aaa, ccc, bbb] 与添加的顺序相同 &#125;&#125; 可变参数可变参数指的方法能够接受的参数可以为多个，定义格式如下 数据类型... 变量名 它的底层原理是数组，会把这多个元素放到一个数组中。假设下面方法接受多个整数类型的参数，但是不知道能接受多少个，然后打印出这些数的和，那么就可以这么写 public class TestKebiancanshu &#123; public static void sum(int... ints) &#123; //ints就是一个数组 int sum = 0; for (int i = 0; i &lt; ints.length; i++) &#123; sum += ints[i]; &#125; System.out.println(sum); &#125; public static void main(String[] args) &#123; sum(1,2,3); //可以传入多个参数，也可以不传 sum(1,5,7,8); &#125;&#125; 输出为 621 注意： 一个方法只能有一个可变参数 一个方法如果有多个参数，可变参数要写在末尾 CollectionsCollections是一个工具类，它提供了很多的静态方法用来对Collection集合进行操作。我们下面就简单介绍Collections类的三个方法 addAll(Collection&lt;? super T&gt; c, T… elements) 接收两个参数，第一个为Collection集合，第二个参数为可变参数 为集合添加多个元素，如addAll(list, 1, 2, 3) shuffle(List&lt;?&gt; list) 接收一个List集合，将集合里面的元素随机打乱 sort(List&lt;T&gt; list) 接收一个list集合，将按照默认升序的规则排序 如果集合里面装的是自定义的类的对象，那么该类要实现Comaprable接口，并且要重写compareTo()方法 sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 接收一个List集合和一个实现Comparator接口的类的对象，可以传入匿名类 下面演示方法的使用 addAll List&lt;Integer&gt; list1 = new ArratList&lt;&gt;();Collections.addAll(list1, 1, 2, 3);System.out.println(list1); //[1, 2, 3] shuffle List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();Collections.addAll(list2, 1, 2, 3, 4, 5, 6);Collections.shuffle(list2);System.out.println(list2); //[6, 4, 3, 5, 2, 1] sort(List&lt;T&gt; list) //先演示对Integer类的排序List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();Collections.addAll(list3, 1, 7, 10, 5, 6, 4);Collections.sort(list3);System.out.println(list3); //[1, 4, 5, 6, 7, 10] 下面演示自定义类的排序，首先我们定义一个Person类，它有name和age属性，我们根据age的大小进行升序排序，如下 public class Person implements Comparable&lt;Person&gt; &#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Person o) &#123; //升序 return this.age - o.age; //降序o.age - this.age &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试该类 Person p1 = new Person(\"古力娜扎\",20);Person p2 = new Person(\"迪丽热巴\", 18);Person p3 = new Person(\"刘亦菲\", 21);List&lt;Person&gt; list4 = new ArrayList&lt;&gt;();Collections.addAll(list4, p1, p2, p3);Collections.sort(list4);System.out.println(list4); 输出为 [Person&#123;name='迪丽热巴', age=18&#125;, Person&#123;name='古力娜扎', age=20&#125;, Person&#123;name='刘亦菲', age=21&#125;] sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 这次我们不需要实现Comparable接口，只需要传入一个Comparator的实现类对象就可以，该类重写Comparator中的compare方法，在该方法中规定了排序的规则，我们可以传入一个匿名类 List&lt;Person&gt; list5 = new ArrayList&lt;&gt;();Collections.addAll(list5, p1, p2, p3);Collections.sort(list5, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //升序 return o1.age - o2.age; &#125;&#125;);System.out.println(list5); 输出为 [Person&#123;name='迪丽热巴', age=18&#125;, Person&#123;name='古力娜扎', age=20&#125;, Person&#123;name='刘亦菲', age=21&#125;] Map之前我们介绍的集合如List，Set都是单列集合，下面我们将介绍双列集合Map，它是通过键K去寻找值V的，所以说它是一个双列集合。它是一个接口，它的常用子类有HashMap和LinkedHashMap。其中HashMap是无序的，即在集合中存储的顺序与你添加的顺序是不一致的。LinkedHashMap是有序，即添加顺序与保存的顺序相同。LinkedHashMap是HashMap的子类。我们之前介绍的HashSet类是调用HashMap实现的，它只利用了HashMap的K。 Map集合的方法下面介绍Map集合的常用方法 put(key, value) 向Map中添加一对键值对，由于Map集合中的key是不能重复的，如果Map中已经存在该key，那么将集合中该key所对应的value值替换为添加的value，即相当于更新，并且返回被替换的value值，如果该集合中不存在该key，那么将该键值对添加，并且返回null get(key) 通过键值来获得对应的value值，如果集合不存在该key，那么返回null remove(key) 根据键来删除该键值对，如果该key不存在，那么返回null，如果存在，那么返回对应的value值 containsKey(key) 判断集合中是否存在键key，有则返回true，否则返回false 下面简单演示这四个方法 import java.util.HashMap;import java.util.Map;public class TestMap &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); //添加元素 map.put(\"迪丽热巴\",18); map.put(\"古力娜扎\",19); map.put(\"佟丽娅\",20); System.out.println(map); //&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125; //这里已经有\"迪丽热巴\"这个键了，所以对应的值会被更改为20，并将该值18返回 //这里最好使用Integer接收，因为可能返回null 而基本数据类型不能被赋值为null Integer val1 = map.put(\"迪丽热巴\",20); System.out.println(val1); //18 System.out.println(map); //&#123;佟丽娅=20, 迪丽热巴=20, 古力娜扎=19&#125; //通过键去获得值 Integer val2 = map.get(\"古力娜扎\"); System.out.println(val2); //19 //删除键\"佟丽娅\"对于的键值对 Integer val3 = map.remove(\"佟丽娅\"); System.out.println(val3); //20 System.out.println(map); //&#123;迪丽热巴=20, 古力娜扎=19&#125; //判断是否包含键\"佟丽娅\" System.out.println(map.containsKey(\"佟丽娅\")); //false &#125;&#125; 遍历Map集合主要有两个方法用来遍历Map集合 keySet 该方法会返回Set集合，里面是key的值，然后我们可以遍历该Set集合来遍历Map集合 entrySet 该方法也返回一个Set集合，不过这个集合里面的是Entry对象，Entry是Map的内部类，该类会在添加键值对时创建一个Entry对象保存相应的key和value的信息，我们可以通过Entry对象的getKey()和getValue()方法来获得键和值。同样我们可以遍历该Set集合来遍历Map集合 下面演示两个方法的使用 keySet import java.util.HashMap;import java.util.Map;import java.util.Set;public class TestMap &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); //添加元素 map.put(\"迪丽热巴\",18); map.put(\"古力娜扎\",19); map.put(\"佟丽娅\",20); System.out.println(map); //&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125; //获得key的Set集合 Set&lt;String&gt; set1 = map.keySet(); //遍历Set集合 for (String set: set1) &#123; System.out.println(set + \"=\" + map.get(set)); &#125; //获得Entry对象组成的Set集合 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set2 = map.entrySet(); //遍历该集合 for (Map.Entry&lt;String, Integer&gt; set : set2) &#123; System.out.println(set.getKey() + \"=\" + set.getValue()); &#125; &#125;&#125; 输出为 佟丽娅=20迪丽热巴=18古力娜扎=19佟丽娅=20迪丽热巴=18古力娜扎=19 斗地主案例练习该案例模拟斗地主的发牌和看牌过程，加强对集合的使用。 分析首先我们要使用Map&lt;Integer, String&gt;集合来保存一副扑克，Integer是索引，String是对应的扑克牌。我们通过索引去找牌，到时候把索引发给玩家就可以，这样因为玩家拿到的是索引，那么就可以进行排序。我们首先要创建一副扑克，可以使用两个String数组，一个保存花色，一个保存数字，然后通过循环组合两个数组来组合一副扑克牌。因为我们要进行排序，所以Integer的大小和牌的大小要一一对应，即0对应大王，1对应小王，2-5对应四个2，以此类推。洗牌我们可以使用Collections的shuffle()方法，由于该方法要求传入List集合，我们要创建一个List集合，该集合要保存Integer索引。发牌就把索引发给玩家，玩家通过索引去Map集合中看牌。 代码实现import java.util.*;public class Doudizhu &#123; public static void main(String[] args) &#123; //使用两个数组组合形成一幅扑克牌 String[] colors = &#123;\"♠\",\"♥\",\"♣\",\"♦\"&#125;; String[] numbers = &#123;\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"&#125;; //将扑克牌存储到Map集合中，键为整数索引，方便排序，值为牌，通过索引拿牌 Map&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //因为使用Collections.shuffle方法洗牌，所以要使用List集合存储索引 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //将大小王添加到Map中，并将索引添加到List中 int index = 0; poker.put(index,\"大王\"); list.add(index); index++; poker.put(index,\"小王\"); list.add(index); index++; //两个数组组合形成一副牌 for (String number : numbers) &#123; for (String color : colors) &#123; poker.put(index,color+number); list.add(index); index++; &#125; &#125; //洗牌 Collections.shuffle(list); ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; dipai = new ArrayList&lt;&gt;(); //发牌，将索引发给玩家 for (int i = 0; i &lt; list.size(); i++) &#123; if (i &gt;= 51) &#123; dipai.add(list.get(i)); &#125; else if (i % 3 == 0) &#123; player1.add(list.get(i)); &#125; else if (i % 3 == 1) &#123; player2.add(list.get(i)); &#125; else if (i % 3 == 2) &#123; player3.add(list.get(i)); &#125; &#125; //给牌排序 Collections.sort(player1); Collections.sort(player2); Collections.sort(player3); Collections.sort(dipai); //看牌 lookPoker(player1,poker,\"刘德华\"); lookPoker(player2,poker,\"周润发\"); lookPoker(player3,poker,\"周星驰\"); lookPoker(dipai,poker,\"底牌\"); &#125; //看牌方法 通过玩家的索引去Map集合中找到对应的牌 并打印出来 public static void lookPoker(ArrayList&lt;Integer&gt; list, Map&lt;Integer,String&gt; poker,String name) &#123; System.out.print(name + \"的牌是： \"); //通过玩家的索引，去poker中取牌 for (Integer number : list) &#123; System.out.print(poker.get(number) + \" \"); &#125; System.out.println(); &#125;&#125; 结果为","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"https://lastknightcoder.gitee.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"集合","slug":"集合","permalink":"https://lastknightcoder.gitee.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java面向对象","date":"2019-07-04T16:00:00.000Z","path":"/Java面向对象/","text":"在最初的开始，人们编写程序的基于过程的，那时候的编程方式是面向过程的。但是人们发现，随着代码规模的扩大，编写大规模的程序使用面向过程的方法十分的困难，这时候人们必须提出一种新的编程思想，使得编写大型程序变得简单。这种思想就是面向对象的思想。 就像我们学习数学一样，随着我们学习的深入，我们一直在进行抽象，比如从数抽象到代数，并且不断提出新的概念，提出很多的定理，方便我们的学习研究。面向对象也是一样，它把实际中的事物抽象出来，这个事物可以是我们见到的实物，比如椅子，桌子，手机，也可以是我们我们看不见的东西，比如某个系统。这个抽象出来的东西我们叫做类，我们利用类的概念，可以清楚的把握类与类之间的关系，使得程序的结构十分的清晰，便于管理，便于开发大型的程序。 我们把抽象出来的东西叫做类，那么一个类的实例就是对象。比如，我们把人抽象为了一个类，这是一个抽象的概念，那么小明这个具体的人就是该类的一个实例，也叫做对象。我们把椅子抽象为一个类，一个具体的椅子就是一个对象。类可以看做是对象的模板，对象可以看做是类的具体实现。 我们可以通过两个方面是描述一个事物，一个是属性，比如说对于人这个类，它的属性就有姓名，身高，年龄等等，这些都是它的属性，另一个就是行为，比如说人的行为有吃饭，睡觉等等。 类的定义类使用关键字class进行定义，我们在之前用过很多次，但是我们之前不知道这是什么，比如在HelloWorld案例中 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 其中HelloWorld表示的就是类名。类定义的格式是 public class 类名 &#123; //成员变量 //成员方法&#125; 在上面我们有提到，一个事物可以由属性和行为两部分描述，表现在程序书写中为成员变量和成员方法，其中变量用来描述类的属性，方法用来描述类的行为，前面加上成员二字以表示与局部变量的不同，例如下面定义了一个Person类，它有姓名，年龄属性，有吃和睡的行为 public class Person &#123; String name; int age; public void eat() &#123; System.out.println(\"吃吃吃\"); &#125; public void sleep() &#123; System.out.println(\"睡睡睡\"); &#125;&#125; 我们注意到成员变量时定义在类当中的，并且成员方法没有使用关键字static修饰。 我们定义了一个类，那我们怎么使用它呢? 从前面我们了解到，类是一个抽象的概念，是一个模板，我们要将它具体化才能够使用它，类是不能够直接使用的，而具体化的过程就是创建一个对象。创建对象的格式为 类名 对象名称 = new 类名(); 例如下面创建一个per的对象 public class Person &#123; String name; int age; public void eat() &#123; System.out.println(\"吃吃吃\"); &#125; public void sleep() &#123; System.out.println(\"睡睡睡\"); &#125; public static void main(String[] args) &#123; Person per = new Person(); //创建一个名为per的对象 &#125;&#125; 我们创建这个对象的模板是Person类，那么它就应该有name, age属性和eat, sleep行为，那么我们怎么去使用这些东西呢? 方法就是通过点语法 对象名.属性 //使用属性对象名.方法() //使用方法 例如下面我们打印出per对象的属性值，并且调用它的方法 public static void main(String[] args) &#123; Person per = new Person(); //创建一个名为per的对象 System.out.println(per.name); System.out.println(per.age); per.eat(); per.sleep();&#125; 输出为 null0吃吃吃睡睡睡 我们发现per.name的值是null，per.age的值是0，实际上我们并没有给per.name和per.age赋值，系统在创建对象时会有默认值，规则和数组的一样。 类的内存模型我们来看看执行下面的代码，在内存中发生了什么 public class Person &#123; String name; int age; public void eat() &#123; System.out.println(\"吃吃吃\"); &#125; public void sleep() &#123; System.out.println(\"睡睡睡\"); &#125; public static void main(String[] args) &#123; Person per = new Person(); //创建一个名为per的对象 System.out.println(per.name); System.out.println(per.age); per.eat(); per.sleep(); &#125;&#125; 编译器首先会在方法区中找main方法，然后将它推入栈中 Person per = new Person(); 这行语句会在main中创建一个per变量，接着会在堆中开辟出一块空间，存储的是per这个对象，这个对象是以方法区中的类为模板的，该对象具有成员变量和成员方法。但是注意的是，对象的成员方法是地址值，指向方法区中的方法的信息，当调用方法时，会根据该地址值去方法区中寻找该方法。由于每个对象的行为都是一样的，只是属性不同，所以不需要在堆中为每一个对象都开辟空间来保存方法的信息，只需要保存一个地址值即可。这样做可以节省内存空间。 System.out.println(per.name);System.out.println(per.age);per.eat();per.sleep(); 上面的语句是访问对象的成员变量和成员方法，首先会根据per对象保存的地址值，去堆中寻找对应的保存地址，然后根据成员变量名去访问数据。调用成员方法，分为了四步，第一步是根据per对象的地址值找到堆中的方法；第二步，堆中的方法保存的地址值，根据堆中的地址值去方法区中查找方法的信息；第三步，将方法压入栈中，栈会为该方法开辟一块空间；第四步，方法执行完毕，方法被栈移除。 对象与方法对象作为一种数据类型，它也可以作为方法的参数和返回值。与数组一样，传递的是地址值，返回的也是地址值。 对象作为参数public static void printObject(Person per) &#123; System.out.println(per.name); System.out.println(per.age);&#125; 对象作为返回值public static Person getPersonObject() &#123; Person per = new Person(); return per;&#125; 成员变量与局部变量成员变量与局部变量的区别 定义的位置不一样 局部变量：定义在方法中 成员变量：定义在方法之外，定义在类中 作用范围不一样 局部变量：只能在方法中使用 成员变量：在类中都可以使用 默认值 局部变量：没有默认值 成员变量：有默认值，规则同数组 在内存中的位置不一样 局部变量：在栈内存中 成员变量：在堆内存中 生命周期 局部变量：随着方法的进栈而产生，随着方法的出栈而消失 成员变量：随着对象的创建而产生，随着对象的被垃圾回收而消失 封装面向对象有三大特性，分别为 封装 继承 多态 下面详细讲述其中的封装。 我们知道，当我们创建了一个对象之后，可以通过点(.)语法去访问成员变量，也可以为它赋值，如下 public class Person &#123; String name; int age; public static void main(String[] args) &#123; Person per = new Person(); per.name = \"李四\"; per.age = 20; System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; 输出为： 我叫做：李四，我：20岁。 但是一旦我们将成员变量使用修饰符private修饰的话，那么我们就不能通过.语法访问成员变量了，如下面的例子 public class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person per = new Person(); per.name = \"李四\"; //编译成功 per.age = 20; //编译成功 System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; 我们发现怎么使用private修饰的变量怎么还可以访问，不是说不可以访问了吗? 这是因为main方法是Person类的方法，在一个类里面是可以随便访问的，现在有一个Test类，然后我们去访问数据 public class Test &#123; public static void main(String[] args) &#123; Person per = new Person(); per.name = \"李四\"; //编译失败 per.age = 20; //编译失败 System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; private就是私有的意思，意味的这个变量的私密的，外部不可以访问，如果要访问的话，只能通过getter和setter方法 public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String who)&#123; name = who; &#125; public int getAge() &#123; return age; &#125; public void setAge(int num)&#123; age = num; &#125; &#125; 现在我们在Test类中创建Person对象访问 public class Test &#123; public static void main(String[] args) &#123; Person per = new Person(); per.setName(\"李四\"); //通过setter方法去设置成员变量的值 per.setAge(20); //通过setter方法去设置成员变量的值 System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; 输出为 我叫做：李四，我：20岁。 明显可见，下面的代码量比上面大了很多，感觉这么做是多此一举，那么为什么要这么做呢？考虑下面这么一种情况，如果没有进行封装，那么我们可以使用.语法为age变量赋值，我们可以赋值为-20，这明显是不合理的，但是可以进行赋值，如果我们进行封装，那么我们可以在setter方法中进行判断，使得一些不合理的，有害的操作不能够正常赋值。 public void setAge(int num) &#123; if (num &gt; 0) &#123; age = num; &#125;&#125; getter方法和setter方法的格式一般为”get变量名”或”set变量名”，根据驼峰命名法，变量名首字母需要大写，如上面的setAge, getAge。但是如果getter方法的返回值是boolean类型的话，我们一般写成isXxx的形式。 this关键字考虑上例我们的setter方法 public void setName(String who)&#123; name = who;&#125; 其实我一直想写成这样 public void setName(String name)&#123; name = name;&#125; 我的想法是第一个name是成员变量name，第二个name是传入的参数，但是这样不行，因为这时的两个name都被看做是传入的参数，那有什么办法可以解决成员变量与局部变量重名的问题吗？方法就是使用this关键字，修改上面代码如下 public void setName(String name)&#123; this.name = name;&#125; 这时this.name就代表的是成员变量name。那么this到底是个什么东西？哪个对象调用这个方法，那么this就是调用这个方法的对象. per.setName(\"李四\"); per这个对象调用setName方法，那么这时的this就是per。 构造方法构造方法其实就是创建对象的方法，用new在创建对象，就是在调用这个方法。还记得我们是怎么创建对象的吗 Person per = new Person(); 其中Person()就是构造方法。 构造方法的定义构造方法定义的格式为 public 类名() &#123; &#125; 注意： 构造方法名要与类名的完全一样，包括大小写 不要写返回值类型，void也不要写 不能return一个具体的返回值 构造方法同成员方法一样，是定义在类中的，但是我们好像到现在从来没有定义过构造方法，但是我们却可以使用，这时为什么？ 如果我们没有编写构造方法，那么编译器会为我们自动生成一个构造方法，该构造方法没有参数，方法体为空，比如像这样 public Person() &#123; &#125; 但是一旦当我们定义了一个构造方法，那么编译器不会自动生成一个构造方法 public Person(String name, int age) &#123; this,name = name; this,age = age;&#125; 我们定义个一个构造方法，此时总共就这一个构造方法，编译器不会自动生成。但是我们一般还会写一个无参的构造方法，继承那里会讲到为什么。 构造方法也可以进行重载，在上面我们已经演示了 利用构造方法进行初始化我们一般可以利用构造方法进行初始化，注意我们之前初始化都是这样 Person per = new Person();per.setName(\"李四\");per.setAge(20); 现在我们定义一个有两个参数的构造方法 public Person(String name, int age) &#123; this.name = name; this.age = age;&#125; 然后就可以这么调用 Person per = new Person(\"李四\", 20); 这一行的代码与上面三行代码的效果是一样的。 一个标准的类一个标准的类应该满足一下特点 所有的成员变量都使用private修饰 为每一个成员变量编写一个setter,getter方法 编写一个无参构造函数 编写一个有参构造函数 一个标准的类也叫做Java Bean。 匿名对象所谓的匿名对象，指的就是没有名字的对象。即在创建对象时，并没有为它赋予变量名。由于它没有名字，没有变量保存它的地址，所以它只能够使用一次，如下 new Person().age; 如果某个对象只使用一次的话，我们可以考虑使用匿名对象。 匿名对象作为方法的参数匿名对象也是对象，当然可以作为方法的参数。匿名对象传入方法的是地址值，下面举一个例子 import java.util.Scanner;public class Anonymous &#123; //getNum方法接收一个Scanner对象，返回一个int类型的数值 public static int getNum(Scanner sc) &#123; int num = sc.nextInt(); return num; &#125; public static void main(String[] args) &#123; //传入了一个匿名对象 int num = getNum(new Scanner(System.in)); System.out.println(num); &#125;&#125; 程序运行效果为 匿名对象作为方法的返回值匿名对象也可以作为方法的返回值，返回的也是地址值 import java.util.Scanner;public class Anonymous &#123; //返回一个Scanner对象 public static Scanner getScannerObject() &#123; return new Scanner(System.in); &#125; public static void main(String[] args) &#123; //GetScannerObject方法返回一个Scanner对象 Scanner sc = getScannerObject(); String str = sc.next(); &#125;&#125; 程序运行效果为 static关键字static关键字我们在之前见到过很多次了，比如 public static void main(String[] args)&#123; &#125; 或者在定义方法时 public static void add() &#123; &#125; 都用到static，而在成员方法中却没有用到static，所以这里我们就来看看static到底是什么，它有什么用。 static修饰符的作用一旦被static修饰，不管是变量还是方法，那么这么变量或方法不再是属于某个对象的，而是属于类，相当于说被static修饰之后，就不是某个人的私有财产，而是大家的公共财产。被static修饰的变量和方法分别叫做静态变量和静态方法。 访问static修饰的变量或方法，可以通过.语法，可以通过类名.，也可以通过对象名.。以前我们调用成员变量和成员方法就是通过对象名.出来的。但是这里推荐使用类名.，这样大家一眼就可以看出这是共有财产而不是私有财产。而且即使你使用了对象名.，在编译器编译时也会自动转换为类名.。 为了理解static修饰符，我们来看这么一个例子。假设有一个Student类，里面有一个id成员变量，我们希望每当创建一个对象时，会自动赋予id变量一个值，比如说，如果one第一个创建的学生，那么它的id就是1，以此类推。我们可以使用一个static变量idCounter来计数，每创建一个对象它就加一 public class Student &#123; String name; int id; static int idCounter; public Student() &#123; //每创建一个对象，id计数器加一，并且赋给id this.id = ++idCounter; &#125; public Student(String name) &#123; this.name = name; //每创建一个对象，id计数器加一，并且赋给id this.id = ++idCounter; &#125; public static void main(String[] args) &#123; Student one = new Student(\"one\"); System.out.println(\"我的名字是：\" + one.name + \"我的id是：\" + one.id); Student two = new Student(\"two\"); System.out.println(\"我的名字是：\" + two.name + \"我的id是：\" + two.id); &#125;&#125; 输出为 我的名字是：one我的id是：1我的名字是：two我的id是：2 这里我要解释一下，为什么有的方法使用static修饰了，我们知道，如果使用static修饰，该方法就可以通过类.出来，如果这个方法是本类的，那么类名可以省略不写。比如这样 public static void add() &#123; &#125;public static void main(String[] args) &#123; //在这里调用add方法，属于同一个类，可以省略类名 add();&#125; 如果我们需要直接在main方法中直接使用这个方法，我们就会使用static修饰。这里只是解释前面为什么有的方法要使用static修饰，因为我们希望直接调用。 这里有关static有几个需要注意的事项 静态只能访问静态，静态不能访问非静态。即在静态方法里面，不能访问成员变量，也不能调用成员方法。这时因为在内存中，先有静态内容，后有非静态内容。”先人不知后人，后人知道先人”。 静态方法中不能使用this。我们知道，谁调用这个方法，那么this就是这个对象。但是调用静态方法是类，而不是对象，即使使用对象调用静态方法，编译器在编译时也会转换为类调用。 static的内存图在方法区中有一块内存空间，专门用以保存静态变量的 从上面的图可以看出来，静态变量与对象没有任何关系。 静态代码块静态代码块的格式是 static &#123; &#125; 该代码块写在类中。它的特点是在第一次创建对象的时候执行唯一的一次。后面在创建对象不会再执行。它先于构造方法的执行。它的作用一般是为了初始化静态变量。 继承继承，主要解决的是共性抽取。子类继承了父类，就拥有父类所有的成员变量和成员方法。除此之外，子类还可以拥有自己的内容。子类与父类的关系，可以这么理解：子类就是一个父类。比如父类是人，子类是学生，子类就是父类说的就是学生是人。也叫is-a关系。 继承的格式子类通过extends关键字基础父类，而父类的定义与一般类的定义相同，现在假设有一个父类Person和一个子类Student。 public class Person &#123; String name; int age; public void showA() &#123; System.out.println(\"我是父类的方法\"); &#125;&#125; public class Student extends Person &#123; int id; //子类拥有父类的成员变量和成员方法&#125; 子类访问父类成员变量上面讲过，一旦子类继承了父类，那么子类就拥有子类的所有成员变量和成员方法。那么子类怎么访问父类的成员变量，这里分为重名和不重名两种 不重名 这种情况最简单，这时是直接用子类对象.父类的成员变量就可以访问 Student stu = new Student();stu.name;stu.age; 重名 直接 如果使用子类对象.的话，访问的就是子类的成员变量 间接 间接指的就是通过成员方法访问，此时举个例子说明 假设父类有一个int num;，子类也有一个int num;。现在父类有一个showA方法如下 public void showA() &#123; System.out.println(num);&#125; 那么如果子类对象调用这个方法的话，那么使用的就是父类的num。现在如果子类有一个showB方法，如下 public void showB() &#123; System.out.println(num);&#125; 如果子类对象调用这个方法，那么使用就是子类的num。简而言之，方法属于谁，就用谁的。 区分三种变量这三种变量指的就是 父类的成员变量 子类的成员变量 局部变量 之前我们讲过区分局部变量和成员变量，我们使用this关键字加以区分。现在假设在子类的一个成员方法中，父类，子类有成员变量name，而该方法也有一个局部变量，这时我们这么区分，如下： super.name; //父类的namethis.name; //子类的namename //局部变量name 同理，如果子类有成员方法和父类的一个成员方法重名的话，如果我们想在子类的某个成员方法中使用父类的这个成员方法的话，我们可以使用super.父类方法()调用。super这个关键字指的就是父类对象。 重写之前我们有多次提到重写的概念，那么重写是什么? 重写指的就是子类的某个方法与父类的方法的方法名称一样，参数列表也一样，相当于把父类的这个方法覆盖了。当我们使用子类对象.这个方法时，优先使用子类的方法。 重写的方法需要满足一定的要求，如下： 必须父子类方法名相同，参数列表相同 子类方法的返回值范围要小于父类方法(Object &gt; String) 子类方法的权限必须大于等于父类的权限操作符 //权限修饰符的大小熟悉怒public &gt; protected &gt; (default) &gt; private 注意： 有一个注解，@Override，把它放在要重写的方法前面，可以检查是否重写正确，比如你重写的方法漏掉了一个字母，这相当于你自己有了一个新的成员方法，并不是重写，编译器不会报错，这可能会造成问题，因为你是想重写的。但是你如果在方法前面加上@Override，它会检查这个方法是不是重写，如果不是会报错。这个是可选的，但是推荐使用。 @Override //写在方法的前面public void show() &#123; &#125; 继承中的构造方法为了讲解清楚，假设有两个类，一个是Person类，是父类，另一个是Student类，是子类。两个方法的定义如下 public class Person &#123; public Person() &#123; System.out.println(\"父类的构造方法\") &#125;&#125; public class Student extends Person&#123; public Student() &#123; System.out.println(\"我是子类的构造方法\"); &#125;&#125; 我要讲的是，在子类构造方法的第一行，默认有super();，这个代表调用父类的构造方法，即在调用子类构造方法时，会先调用父类的无参构造方法，现在我们创建一个Student对象，看看打印输出 public class TestExtends &#123; public static void main(String[] args) &#123; Student student = new Student(); &#125;&#125; 打印输出为 我是父类的构造方法我是子类的构造方法 可见是默认会调用父类的无参构造方法。所以我们在之前建议为类写一个无参的构造方法，因为在创建子类对象时会先调用父类的无参构造方法，如果父类没有的话，会报错。 注意： super调用必须是第一个语句，比如下面会报错 public Student() &#123; System.out.println(\"我是子类的构造方法\"); super(); //会报错，因为不是第一个语句&#125; 这也意味着在方法中只能调用一次super()方法，因为第二个super不是第一个语句了 public Student() &#123; super(); super(\"name\",12); //假设父类有一个有参构造方法 由于不是第一个语句，报错 //这意味着只能调用一个super()方法 System.out.println(\"我是子类的构造方法\"); &#125; this()可以调用本类的构造方法，this()也必须是第一个语句，所以this()和super()不能同时出现。 如果父类有有参数的构造方法，我们可以在子类的构造方法中显式的调用该方法，如上面super(“name”,12)，这个时候就不会默认调用无参的构造方法。所以父类中没有无参的构造方法不一定会报错。建议最好还是写一个吧，即使什么都没有，有特殊需求的除外。 继承的三个特征 Java语言是单继承的，只能有一个直接父类 可以有多级继承，继承的源头是Object 一个子类的直接父类是唯一的，但是可以有多个子类 抽象类抽样方法：使用关键字abstract修饰的方法，抽象方法没有方法体，直接大括号结束。抽样方法所在的类必须是抽样类，抽样类的定义是在class前面加abstract。 如下定义了一个抽样类 public abstract class Animal &#123; public abstract void eat(); public abstract void sleep();&#125; eat(), sleep()方法是抽样方法，没有方法体，直接分号结束。 注意： 不能直接创建抽象类对象，应当用一个类继承该抽象类，该类必须重写所有的抽象方法，如果该类没有重写所有的抽象方法，那么该类也必须是抽象类。 抽象类可以有构造方法，给抽象类的成员变量初始化 抽样类不一定要有抽象方法，但是含抽象方法的类必须是抽象类 如下创建一个Dog类继承抽象类Animal public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"汪汪汪...\"); &#125; @Override public void sleep() &#123; System.out.println(\"呼呼呼...\"); &#125; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.eat(); dog.sleep(); &#125;&#125; 输出为 汪汪汪...呼呼呼... 接口接口就是公共的规范标准。 接口的定义我们类的定义是使用class关键字，而接口的定义是使用interface关键字。如下定义了一个接口 public interface MyInterface &#123; ...&#125; 接口里面可以有什么，这与版本有关。 Java 7 常量 抽象方法 Java 8(新增) 默认方法 静态方法 Java 9(新增) 私有方法 接口的使用 接口不能够直接使用，需要一个类去实现它。我们在之前使用extends去继承一个类，而实现一个接口使用implements关键字，如 public class MyClass implements MyInterface &#123; &#125; 实现必须实现接口中的所有抽样方法。如果没有全部实现，那么该类必须为抽样类 创建实现类对象使用 抽象方法接口中的抽样方法的修饰符必须是public abstract，所这两个关键字可以省去，如下的写法都是对的 public abstract void eat(); //不省略abstract void eat(); //只省略publicpublic void eat(); //只省略abstractvoid eat(); //两个都省略 默认方法默认方法的定义为 public default 返回值 方法名(参数列表) &#123; //修饰符必须是public，所以public可以省略 //方法体&#125; 默认方法就要解决的是升级问题。假设你要升级一个接口，如果你添加一个抽象方法的话，那么由于实现类没有实现该抽象方法，那么实现类就不能使用，这样是不合理的。但是添加默认方法的话，实现类不需要实现该方法，实现类可以正常的使用，并且可以通过实现类对象调用该默认方法。 静态方法静态方法的定义为 public static 返回值 方法名(参数列表)&#123; //同default方法，public可以省略 //方法体&#125; 实现类不能直接调用静态方法，只能通过接口.静态方法调用。因为一个实现类是可以同时实现多个接口的，如何多个接口有相同的静态方法，那么通过实现类调用静态方法，那么调用哪个呢？所以实现类是不能直接调用静态方法的。不同于继承，因为继承只有一个直接父类。 私有方法私有方法是为解决代码重复问题的。假设有两个默认方法，这两个默认方法的代码重复很多，那我们想着可以把重复的代码抽出来形成一个新的方法，然后在这两个默认方法中调用这个新方法就可以。但是这个新方法是一个中间方法，应当是只能在接口内才能够被调用，所以不能是默认方法。这个方法应该被定义为私有方法。 私有方法分为两类 普通私有方法 解决默认方法代码重复问题，只使用private修饰 静态私有方法 解决静态方法代码重复问题，使用private static修饰 常量接口中也能定义”成员变量”，只不过必须使用public static final修饰，final代表的就是不可变的意思，所以就相当于是一个常量。接口中的常量必须进行赋值，不能不赋值 public static final int NUM = 10； 对于常量，我们采用所有字母大写，并且单词之间使用下划线分割。接口使用常量的方法是接口.常量，原因同静态方法一样。 注意事项 接口没有静态代码块和构造方法 一个类可以同时实现多个接口 ... implements 接口1，接口2，... 如果实现的两个接口有相同的抽象方法，只需要实现一个即可 不能没有实现所有的抽象方法，那么就必须是抽象类 如果实现的两个接口有重复的默认方法，那么实现类必须重写该默认方法 一个类的直接父类与接口的默认方法重复的话，优先使用直接父类的方法 接口与接口之间多继承的 接口 extends 接口1，接口2，... 如果继承的多个接口默认方法重复，那么必须重写，且重写的方法必须为默认方法。如果抽象方法重复，只继承一个。 多态继承和实现接口是多态的基础。 多态的定义多态的定义就是父类引用指向子类对象。 父类 对象名 = new 子类();接口 对象名 = new 实现类(); 如假设有一个父类Person和一个子类Student如下 public class Person &#123; String name = \"父类\"; public Person() &#123; &#125; public void show() &#123; System.out.println(\"我是父类的show方法\"); &#125;&#125; public class Student extends Person&#123; String name = \"子类\"; @Override public void show() &#123; System.out.println(\"我是子类的show方法\"); &#125;&#125; 现在我使用多态的写法，创建一个Student对象指向Person引用，并且调用show方法 public class Muti &#123; public static void main(String[] args) &#123; Person per = new Student(); per.show(); System.out.println(per.name); &#125;&#125; 这时的输出为 我是子类的show方法父类 是不是有点难以理解上面的输出，下面讲解一下为什么会有上面的输出。 多态访问成员变量和成员方法的规则访问成员方法的规则 如果多态写法创建的对象，调用成员方法时，在编译时看左边，即看父类有没有这个方法，如果父类没有，那么会报错，如下面我在Student中新建了一个子类特有的方法，如果使用per对象调用的话，将会发生错误。 public class Student extends Person&#123; String name = \"子类\"; @Override public void show() &#123; System.out.println(\"我是子类的show方法\"); &#125; public void showAgain() &#123; System.out.println(\"我是子类特有的方法\"); &#125;&#125; 我们观察到程序报错了，因为父类并没有这个方法。 在运行时看右边，即如果这个方法子类重写了，那么调用子类的方法，我们在上面也看到了，输出的是子类的方法 口诀：”编译看左边，运行看右边” 访问成员变量的规则访问成员变量的规则与访问成员方法的规则不同。 访问成员变量时，编译时的规则也一样，如果父类没有该变量，则访问不了该变量。访问不了子类的变量。 即使子类中的成员变量与父类中的成员变量重名，那么访问的也是父类的成员变量，在上面我们已经看到了，我们在打印输出name是输出的是父类的成员变量。 口诀：”编译看左边，运行也看左边” 对象转型对象转型分为向上转型和向下转型。 对象向上转型多态就是向上转型，因为是子类对象指向父类的引用。创建的是子类的对象，但是使用却是当做父类对象使用。多态有一个明显的弊端就是无法使用子类特有的方法和子类的成员变量。 对象向下转型我们提到了多态的弊端，但是我就是要使用子类的特有方法怎么办，这个时候我们可以使用向下转型，比如 Person per = new Student();Student stu = (Student) per; //向下转型 这样我们就可以使用Student对象特有的方法了，比如 public class Muti &#123; public static void main(String[] args) &#123; Person per = new Student(); Student stu = (Student) per; stu.showAgain(); &#125;&#125; 输出为 我是子类特有的方法 但是，向下转型要注意，我原来是Student对象才能转为Student对象，我如果原来不是，那么运行时会抛出异常，如下面我创建一个Teacher继承了Person，现在我要把per强行转型为Teacher对象 我们观察到，在编译时并没有报错，现在我们来运行一下 抛出了ClassCastException异常，意思是类型转换异常。所以向下转型不安全。 那我们为什么不直接创建一个子类对象指向子类呢？何必多次一举使用多态写法然后又给转回来呢? 我们来看这么一个方法 public void someMethod(Person per) 这个类的方法参数只要求是Person就可以，它不管你是Student还是Teacher，所以如果我们把Student对象传进去，这是不是多态的写法，如果我们在里面要用到Student特有的方法，我们是不是要向下转型。 其实常常我们使用接口作为参数，表示的意思就是我才不管你是什么，你只有实现我的接口就可以了，那么我就可以使用你了。比如有一个接口叫做USB，那么传进来的参数，你只要实现了我们USB接口就可以，不管你是鼠标实现了还是键盘实现了，你只要实现了，我就可以用。这就是多态的用法啊。 instanceof上面我们说了，对象的向下转型是有风险的，因为如果我不是Student你给我转给Student那么会抛出异常的。现在instanceof关键字可以解决这个问题，他可以判断多态创建的父类引用为哪个子类。具体用法为 多态创建的父类引用 instanceof 子类 该表达式返回一个boolean值，如果多态创建的父类引用是这个子类，那么返回true，否则返回false。例如 Person per = new Student();per instanceof Student; //trueper instanceof Teacher; //false 现在考虑这么一个函数 public void someMethod(Person per) 我们现在就在方法中根据per instanceof Xxx的结果进行安全的向下转型 public void someMethod(Person per) &#123; if (per instanceof Student) &#123; Student student = (Student) per; //实现Student对象特有的操作 &#125; else if (per instanceof Teacher) &#123; Teacher teacher = (Teacher) per; //实现Teacher对象特有的操作 &#125;&#125; finalfinal关键字可以修饰 一个类 修饰一个类时，该类不能够被继承 所以final不能和abstract关键字一起使用，因为抽象类不能自己创建对象，只能被继承 方法 修饰一个方法时，子类不能重写该方法 局部变量 修饰一个局部变量时，这个变量不能进行更改 下面两种写法都可以 final int num = 10; final int num;num = 10; 成员变量 因为成员变量有默认值，所以要手动赋值 要么直接赋值，要么在构造方法中进行赋值，在构造方法中赋值时，所有的构造方法都要进行赋值，即使是无参构造方法，也要进行赋值 final int num = 10;//下面的写法是错误的final int num;num = 10; public Xxx() &#123; num = 0;&#125;public Xxx(int num) &#123; this.num = num;&#125; 权限修饰符权限修饰符总共有四种，权限从大到小的顺序为 public protected (default)，就是什么都不写 private 下表列出了不同修饰符下的访问规则 同一个类 同一个包 不同包的子类 不同包非子类 public 能 能 能 能 protected 能 能 能 不能 (default) 能 能 不能 不能 private 能 不能 不能 不能 内部类内部类是一个很重要的概念，主要分为两类 成员内部类 局部内部类 匿名内部类 下面我们来看一下内部类的使用 成员内部类成员内部类就像成员变量和成员方法一样定义在类里面，比如有一个叫做Body，内部还有一个类叫做Heart。我们可以这么定义 public class Body &#123; public class Heart &#123; &#125;&#125; 内部类可以随意的访问外部类的成员变量和成员方法，但是外部类要访问内部类要借助内部类对象。 如何使用成员内部类 在外部类的方法中使用内部类，然后在main方法中调用外部类的方法。 直接创建内部类的对象，创建格式为 外部类.内部类 对象名 = new 外部类().new 内部类(); 比如上面我想创建一个Heart对象就可以这么写 Body.Heart heart = new Body().new Heart(); 内部类变量与外部类变量重名问题，假设外部类有一个成员变量num，内部类也有一个成员变量num，在内部类的成员方法中也有一个局部变量num，现在在内部类的这个方法中怎么访问外部类的成员变量，怎么访问内部类的成员变量。如下 num //局部变量this.num //内部类的成员变量外部类名.this.name //外部类的成员变量 现在来看一个例子 public class Body &#123; int num = 10; //外部类的num public class Heart &#123; int num = 20; //内部类的num public void showNum(int num) &#123; System.out.println(num); //打印局部变量 System.out.println(this.num); //打印内部类的成员变量 System.out.println(Body.this.num); //打印外部类的成员变量 &#125; &#125; public static void main(String[] args) &#123; Body.Heart heart = new Body().new Heart(); heart.showNum(30); //局部变量num &#125;&#125; 输出结果为 302010 局部内部类局部内部类就是定义在方法内部的类，定义如下 class 局部内部类名 &#123; &#125; 注意，不要写任何的修饰符。这并不代表它的修饰符权限是(default)，因为修饰符没有意义，类定义在方法的内部，只有在方法内部在能够访问。 我们在这里适时的总结一下修饰符修饰类 外部类 只能是public, (default) 内部类 成员内部类 可以是四种修饰符的任意一种 局部内部类 什么都不能写 局部内部类如果想访问方法中的局部变量，那么这个变量必须是局部final的，什么叫做有效final呢？指的就是没有使用final修饰符修饰（当然你使用final修饰更加的保险），但是变量的值没有发生改变。比如下面 public void testlocalInnerClass() &#123; int num = 10; class LocalInnerClass &#123; public void printNum() &#123; System.out.println(num); &#125; &#125;&#125; 这里的num虽然没有使用final修饰符修饰，但是它只进行了一次赋值，所以是有效final的，所以在局部内部类中可以访问该变量。假设num又进行了赋值，那么将会编译失败。 匿名内部类匿名内部类是相当重要的概念了。如果接口实现类(或者是父类的子类)只使用一次，那么这种情况可省略掉该类的定义，而改为使用匿名内部类。 比如有一个接口，叫做USB好了，然后在一个Computer类中要使用该接口，如下 public interface USB &#123; public abstract void open(); public abstract void close();&#125; public class Computer &#123; public void useUsb(USB usb) &#123; usb.open(); usb.close(); &#125;&#125; 现在我们创建一个类去实现USB接口，然后创建对象，传入Computer的这个方法中 public class ImpUSB implements USB &#123; @Override public void open() &#123; System.out.println(\"打开USB设备\"); &#125; @Override public void close() &#123; System.out.println(\"关闭USB设备\"); &#125;&#125; public class Computer &#123; public void useUsb(USB usb) &#123; usb.open(); usb.close(); &#125; public static void main(String[] args) &#123; Computer computer = new Computer(); ImpUSB impUSB = new ImpUSB(); computer.useUsb(impUSB); &#125;&#125; 输出为 打开USB设备关闭USB设备 但是这样写未必太麻烦了，这个类只使用了一次，但是为了使用这个接口，我却要写一个类去实现该接口，然后创建对象使用，未必有点麻烦。Java提供了更加方便的方法，那就是匿名内部类。 匿名内部类的定义格式为 接口名称 对象名 = new 接口名称() &#123; //在这里覆盖重写接口所有的方法&#125; 现在我们匿名内部类来实现上面同样的效果 public static void main(String[] args) &#123; Computer computer = new Computer(); //创建匿名内部类 USB usb = new USB() &#123; @Override public void open() &#123; System.out.println(\"花式打开USB设备\"); &#125; @Override public void close() &#123; System.out.println(\"花式关闭USB设备\"); &#125; &#125;; computer.useUsb(usb);&#125; 输出为 花式打开USB设备花式关闭USB设备 在这里我们并没有创建一个实现类去实现USB接口，而是创建了一个匿名内部类，这个类没有名字（这也是为什么叫做匿名内部类），所以它不能通过它在创建新的对象。正如匿名对象一样，只能调用一次方法。 匿名内部类的注意事项 匿名内部类在创建对象时，只能使用唯一的一次 匿名对象在调用方法只能调用唯一的一次 匿名内部类是省略了类的名称，匿名对象是省略了对象的名称","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://lastknightcoder.gitee.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java基础知识","date":"2019-07-03T16:00:00.000Z","path":"/Java基础知识介绍/","text":"第一个程序: HelloWorld下面将书写Java的第一个程序，它的作用是在命令行输出Hello World!。新建一个文件，文件名为HelloWorld.java，使用记事本或其他代码编辑工具打开，敲入以下代码 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 然后在命令行中输入 javac HelloWorld.javajava HelloWorld 然后就可以在命令行中看到Hello World!输出了。 注意事项： class后面的HelloWorld要与文件名一样，包括大小写 在命令行使用javac或者java命令时，要保证所处的路径与文件HelloWorld.java在同一个路径，否则会报错，解决办法有两种 第一种，使用cd命令切换到HelloWorld.java文件的目录 第二种，javac或者java命令后跟上HelloWorld.java的完整路径名称 javac命令后面有后缀.java，java命令后面没有任何的后缀 现在稍微解释上面程序的意思，因为刚刚起步，很多东西现在都解释不了，所以在这里并不要求弄懂。第一行 public class HelloWorld 这里，我们只需要记住HelloWorld必须与文件名相同。第二行 public static void main(String[] args) 这个是固定的写法，几乎每个程序都是这么写的，这个是程序的入口，程序从这里开始执行。第三行 System.out.println(\"Hello World!\"); 这个语句是关键的程序，它的作用就是向屏幕输出字符，这里我们输入的是Hello World!，注意输出的语句需要被双引号括起来。 标识符与命名规范标识符的命名规范 由数字、字母、下划线和美元符组成 不能由数字开头 不能是关键字 上面是标识符命名的硬性规范，即如果不按照上面的来做，那么程序在编译时不能够通过，下面介绍软性规范，意思就是如果你不按照下面的来，编译器不会报错，但是软性规范是大家约定俗成的，大家都遵守的，所以我们要按照下面的来 类名：大驼峰命名法，即首字母全部大写，如HelloWorld 变量名与方法名：小驼峰命名法，即第一个首字母小写，后面的首字母全部大写，如helloWorld Java中的常量Java中的常量分为： 字符串常量：使用双引号括起来的，如”Hello World!” 整型常量：其实就是整数，如5 浮点数：小数，如2.5 字符常量：用单引号括起来的，单引号里面必须有一个字符，不可以没有，也不可以多于一个，如’ab’,’’都是错误的，另外这个字符可以是中文，如’中’ 布尔常量：只有两个值true和false 空常量：null，这个在这里不多做介绍 在前面我们学习了向屏幕输出Hello World!，类似的，在这里我们可以尝试着把常量输出出来，新建一个文件为Constant.java，注意前面提及的命名规范，Constant是类名，所以首字母需要大写，然后在该文件中敲入 public class Constant &#123; public static void main(String[] args) &#123; //下面我将输出一些常量 System.out.println(\"Hello\"); //输出字符串常量 System.out.println(5); //输出整型常量 System.out.println(2.5); //输出浮点型常量 System.out.println('a'); //输出字符型常量 System.out.println(true); //输出布尔型常量 &#125;&#125; 输出为： Hello52.5atrue 注意： 不能打印出null，如System.out.println(null)会报错 上面//后面的内容为注释，编译器会自动的忽略，注释是对程序的解释，是为了帮助人看懂程序的 基本数据类型Java中的数据类型分为基本数据类型和引用数据类型，引用数据类型暂且不提，这里的重点是掌握基本数据类型，基本数据类型分为四类： 整型 浮点型 字符型 布尔类型 整型可以细分为： byte short int long 上面整型数据类型都表示整数，只是表示的范围大小不一样，byte使用一个字节即8bit来表示一个整数的大小，表示的范围为-128~127，short使用两个字节来表示，范围比byte大一点，大约在几万左右，int使用四个字节来表示，是最常用的数据类型，因为它的范围已经大到足够我们日常使用了，long使用八个字节来表示，比int的范围还要大，但是由于使用int已经足够了，从节省空间的角度讲，没必要用long。 浮点型可以分为 float double float使用四个字节来表示小数，虽然使用的是四个字节，但是表示的范围比使用八个字节的long更大，double使用八个字节来表示小数，所以使用double表示小数更精确，我们在平常使用最多的就是double。 字符型没法细分，只有一个，那就是char类型，使用两个字节表示。 布尔型也没有办法细分，只有一个，那就是boolean，使用一个字节表示，它只有两个值true和false。 注意： 字符串不是基本数据类型，它是引用类型，这个后面详细阐述。 变量变量的命名需要服从前面所讲的标识符所需遵从的硬性或软性的规定。变量的声明方法为： 数据类型 变量名 比如： int a;float f;double d; 上面是对变量的声明，但是没有对变量进行赋值，没有被赋值的变量是不能被使用的，否则会报错，下面举一些例子： byte by = 20;short s = 10;int a = 2;long l = 122222222222222L;float f = 1.2F;double d = 2.5;char c = 'a';boolean b = true; 注意： 对float变量进行赋值时，后面需要加上F 对long类型的变量进行赋值时，后面需要加上L(大小写都可以，不过小写的l像1，所以建议使用大写)，当右边常量的值的大小小于int类型的范围时，L可以省略 long l = 2; Java中，整型常量的类型默认为int，浮点型常量的类型默认为double 在一个花括号内部，变量名不能相同 数据类型转换数据类型转换分为两种： 自动类型转换，也称为隐型转换 强制类型转换 自动类型转换当将某数据类型的值赋值给某个能够表示更大范围的数据类型的变量时，会发生自动类型转换，比如 byte b = 20;int a = b; 上面的b是byte类型，a是int类型，int类型的范围更加的大，所以将b赋值给a时会自动类型转换，将20转化为int类型赋值给a，但是b还是byte类型。但是不能将大范围的数据类型的值赋值给更小范围数据类型的变量，如 int a = 20;byte b = a; //不行，编译器会报错 范围从小到大的顺序为 箭头代表可以转换。 在前面我们提及到，当将一个整数赋值给long类型的变量时，如果表示的范围没有超过int，那么可以不写后面的L，这时因为发生了自动类型转换 long l = 12; //后面没有加L，Java默认整数类型为int，这里发生了自动类型转换 强制类型转换上面提及到大范围不能转向小范围，但是我们可以强行转换，比如我想将int类型的数值转化为byte类型的数值 int a = 20;byte b = (byte) a; 在要转换的数据前面加上(byte)就可以强行转化为byte类型。 虽然可以将大范围转化为小范围，但是我们在平常时不会这么干，因为往往将大范围的数转化为小范围的数时，会有精度损失，比如： double d = 3.5;int i = (int) d; //结果为3，小数点后面的数直接舍去，并不是四舍五入 我们知道Java的整数默认为int，那么下面的语句为什么没有报错 byte b = 20; //20是int类型，int不能转byte，为什么没有报错short s = 30; //同上 这是因为，在编译时，编译器会检查右边数值的范围，如果没有超过byte或者short能够表示的大小，那么编译器会自动帮我们强制类型转换为byte或short，相当于 byte b = (byte) 20;short s = (short) 30; 几点注意 char,short,byte类型在进行计算时，会自动提升为int类型参与计算 byte num1 = 10;byte num2 = 20;//下面这行语句会报错byte num3 = num1 + num2; //在计算时，num1和num2会自动的提升为int类型，而int类型不能转为byte，所以会报错 但是，下面的写法是正确的 byte b = 1 + 2; 当右边全是常量时，编译器在编译时会直接计算，相当于下面 byte b = 3; 由于3没有超出byte能够表示的范围，所以会被强制转换为byte。 char c = 'A';//下面这行语句会输出一个数字System.out.println(c + 0); //65 我们知道char是一个字符，那么为什么字符可以进行计算呢？这是因为计算机在底层是使用数字表示字符的，比如上面’A’就是使用数字65表示的，上面的字符与数字0进行计算，会自动提升为int类型，所以最后输出的就是数字。 我们需要知道几个特殊字符对应的数字 字符 ASCII码 ‘0’ 48 ‘A’ 65 ‘a’ 97 大写字母与小写字母之间差32。 boolean类型不能进行数据类型转换 例如，下面将对boolean类型进行转换，是错误的写法： int i = 1;boolean b1 = i; //错误boolean b2 = (boolean) i; //错误 boolean b = true;int i1 = b; //错误int i2 = (int) b; //错误 运算符Java中的运算符分为以下几种： 算术运算符 赋值运算符 比较运算符 逻辑运算符 三元运算符 算术运算符算术运算符包括以下几种： +，加法 -，减法 *，乘法 /，除法 %，取余 ++，自增 –，自减 不同类型的数据之间进行运算，得到的结果的数据类型为范围最大的那个数据类型，如： double d = 2 + 3.5; //int + double ==&gt; doubleint i = 2 + 3.5; //该写法错误 加法有两种作用： 两数字间进行加法运算 字符串的连接 int c = 3 + 5; //进行加法运算，结果为8String s = \"Hello\" + \"World\"; //拼接为HelloWorld 注意：任何数据类型与字符串连接时，会自动变成字符串 String s = 1 + \"Hello\"; //1Hello 除法需要注意的是，两个整数相除，得到的还是整数，即使除不尽，如 int a = 10/3; //a = 3 下面重点介绍++和–，由于二者十分的相似，这里只介绍++。++的作用是自动加1，如 int a = 3;a++; //相当于a = a + 1 a变为了4 其中++可以在变量的前面，也可以在变量的后面，如下 a++;++a; 二者的作用均是使变量a加1，当二者如上单独使用时，二者没有区别，但是当混合使用时，有区别，具体表现如下 ++a：先将a进行+1，然后使用a a++：先使用a，再将其进行+1 例如： int a = 3;b = a++; //先使用a，即先将a的值赋值给b，所以b=3，然后+1，所以最后a=4 int a = 3;b = ++a; //先将a+1，即a=4，然后将a赋值给b，所以b=4 –的作用是减1，其用法同++一模一样，这里不多加介绍。 注意： 常量不能进行++,–运算 30++; //该写法是错误的 赋值运算符赋值运算符分为基本赋值运算符和复合赋值运算符 基本赋值运算符 = 复合赋值运算符 += -= *= /= %= 基本赋值运算符的作用就是把右边的值赋给左边的变量 int a = 3; //把3赋给变量a 注意： 常量是不变的，不能被赋值，所以常量不能出现在赋值运算符的左边 50 = 30; //该写法是错误的 复合赋值运算符，这里介绍+=，其他与它类似 int a = 3;a += 3; //相当于a = a + 3a *= 3; //相当于a = a * 3// 其他的同理可以知道... ... 注意： 复合赋值运算符隐含了强制类型转换 short s = 2;s += 2; //这里暗含了强制类型转换，s + 2得到的是一个int类型，被强制转换为了short类型，所以相当于s = (short) (s + 2); 比较运算符比较运算符对操作数进行比较，得到一个boolean数据类型的值，比较运算符包含以下： ==：判断两个数是否相等 &gt; &lt; &gt;=：大于等于 &lt;= !=：判断两个数是否不相等 注意： 在判断某变量属于某区间，比如是否大于3小于5时，不能写成3 &lt; x &lt; 5，应当使用后面提及的逻辑运算符3 &lt; x &amp;&amp; x &lt; 5 逻辑运算符逻辑运算符的对象是boolean数据类型的值，包含下面三个操作 &amp;&amp;：与操作，当两个操作数同时为true时，结果才为true ||：或操作，两个操作数中有一个操作数为true时，结果就为true !：非操作，!true = false, !false = true 注意： 逻辑运算符的操作对象为boolean，所以如果操作对象不为boolean类型时，会报错 boolean b = 5 &amp;&amp; 2; //会报错boolean b = 5 &amp;&amp; true; //会报错 短路 表达式1 &amp;&amp; 表达式2：当表达式1为假时，已经可以判断出结果为假，所以不会对表达式2进行判断，不会执行表达式2 表达式1 || 表达式2：当表达式1为真时，已经可以判断出结果为真，同上。 int a = 3;System,out.println(false &amp;&amp; a++ &lt; 100); //此时进行了短路运算，a++ &lt; 100没有得到执行，所以a = 3 int a = 3;System.out.println(true || a++ &lt; 100); //同上 三元运算符这里的三元指的是有三个操作数，上面我们介绍的运算符的操作数要么是一个的，如++,–,!，要么是两个的，如+,-,…，三元运算符的格式是 变量 = 条件判断 ? 表达式1 : 表达式2; 首先会进行条件判断，如果条件判断得到的结果为true，那么会将表达式1的结果赋值给变量，此时表达式2不会得到执行；否则将表达式2的结果赋值为变量。 int a= 3;int b = 4;int c = 4 &gt; 3 ? a : b++; //c = 3，表达式2没有执行，b = 4System.out.println(b); //输出为4 注意： 变量的类型必须与表达式的结果的类型一致，否则会报错 int c = 4 &gt; 3 ? 2 : 2.5; //该语句是错的，2.5是double类型，不能转化为int 可能有的人会说返回的2，为什么会报错，因为在实际中，判断语句的结果不是确定的，否则直接将2赋值给c好了，根本不需要判断，因此两个表达式的结果都有可能赋值给变量，编译器会检查表达式得到的数据类型。 单独写三元表达式是错误的 int a = 4; b = 3;a &gt; b ? a : b; //这么单独写是错误的 但是可以这么写 System.out.println(a &gt; b ? a : b); //这么写是对的 流程控制流程指的就是程序执行的顺序，写过汇编的同学都知道，用汇编写程序的流程控制都是jump的，各种跳来跳去，这会导致程序的流程极其的不清楚，当出现bug时，极其的难以调试，我们称这种程序为“意大利面条”，意思就是像意大利面条一样交缠在一起，极其混乱。 后来人们发现，只需要三种结构就可以写出任何的程序，这三种结构就是顺序结构，选择结构，循环结构，使用这三种结构使得程序条理清晰，结构清晰。下面就详细的介绍这三种结构。 顺序结构顺序结构指的就是程序从上到下，按照顺序执行，例如 System.out.println(\"我是第一条语句\");System.out.println(\"我是第二条语句\"); 输出为 我是第一条语句我是第二条语句 选择结构有时候我们需要根据某种状态来判断哪段程序应该执行，比如用户输入用户名和密码，根据是否输入正确来决定程序的行为。 选择结构分为两大类，一个与关键字if,else有关，一个与关键字switch,case有关，下面详细进行介绍。 if-else语句单独一个if使用方法为 if (判断语句) &#123; //代码&#125; 对判断语句进行判断，如果结果为真，则执行if里面的代码，如果为假，则跳过整个语句。 if-else语句上面if语句是当结果为真时执行语句块，但是当结果为假却什么都不干，我们希望当结果为假时，也能有相应的操作，那么就要用到if-else语句 if (判断语句) &#123; //if语句块&#125; else &#123; //else语句块&#125; 当结果为真时，执行if语句块，结果为假时，执行else语句块。 if-else-if else语句级联有时候，我们不仅需要的是一次判断，而是多个判断，比如有一个分段函数，根据函数的不同取值，选择不同的函数，比如$$y =\\begin{cases}2x - 1, &amp;x &lt; 1 \\\\2x, &amp;1 \\leq x &lt; 2 \\\\2x + 1, &amp;x \\geq 2\\end{cases}$$ if (x &lt; 1) &#123; y = 2 * x - 1;&#125; else if (1 &lt;= x &amp;&amp; x &lt; 2) &#123; y = 2 * x;&#125; else &#123; //x &gt;= 2 y = 2 * x + 1&#125; switch-case语句switch-case语句的格式为 switch (表达式) &#123; case 常量1: 语句1; break; case 常量2: 语句2; break; ... case 常量n: 语句n; break; default: 语句n+1; break;&#125; 该段程序的执行过程为，首先计算switch表达式的结果，然后将表达式的结果与常量1,常量2,…比较，看是否相等，如果与其中某个常量相等，则会执行相应的语句块。如果与所有的case常量都不相等，那么就会执行default中的语句。 注意： 多个case的常量不能相同 switch表达式的结果只能是下面的几种类型 基本数据类型：byte,short,char,int 引用类型：String，枚举类型 case的顺序可以发生改变 另外，比较重要的是，其实break不是必须的，可以省略，如果省略的话，由于没有break，程序会继续执行下去，直到遇到break或者程序执行结束。 switch (1) &#123; case 1: System.out.println(1); //不会退出程序，继续执行 case 2: System.out.println(2); break; //在这里遇到break，退出 default: System.out.println(3); break;&#125; 程序的输出为 12 循环结构循环指的就是重复执行某段程序，一般循环由下面四部分组成 初始化 条件判断 循环体 循环控制语句 循环有三种，分别是 for循环 while循环 do-while循环 下面详细介绍。 for循环for循环的格式为 for (初始化语句; 条件判断; 循环控制) &#123; 循环体;&#125; 执行的顺序为，先执行初始化语句，然后进行条件判断，如果结果为真，那么进入循环体，如果结果为假，那么退出循环，执行完循环体后，接着执行循环控制语句，然后进行条件判断，循环往复。如下面的例子打印出1-100的和 int sum = 0;for (int i = 1; i &lt;= 100; i++) &#123; //注意，这个i只能在for循环里面用，在外面不能用 sum = sum + i;&#125; while循环while循环的格式为 while (判断语句) &#123; 循环体&#125; 首先会对判断语句进行判断，真就执行循环体，假就退出循环。执行完循环体，接着进行判断，循环往复。下面的例子计算1-100的和 int sum = 0;int i = 1; //初始化语句while (i &lt;= 100) &#123; //判断语句 sum = sum + i; //循环体 i++; //循环控制语句&#125; do-while循环do-while循环的格式为 do &#123; 循环体&#125; while (条件判断); 首先会执行一次循环体，然后进行条件判断，真就继续执行循环体，否则退出循环。 do-while循环与while循环的区别是，do-while一定会执行一次循环体，例如 int i = -1;do &#123; System.out.println(1);&#125; while (i &gt; 0); 输出为 1 循环控制break和continue当在循环体中执行到break时，会直接退出循环，如 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(i); if (i == 2) &#123; break; //当i = 2时退出循环 &#125;&#125; 程序输出为 12 当在循环体中执行到continue时，退出此次循环，直接进行下一次循环，如 for (int i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; continue; //退出此次循环，后面的代码不执行了，直接执行循环控制语句i++，进入下一次循环 &#125; System.out.println(i);&#125; 输出为 1245 死循环当循环一直进行下去，不能退出，那么就成为了死循环，例如下面就是一个死循环 while (true) &#123; System.out.println(\"Hello\");&#125;for (int i = 0; ; i++) &#123; //省略了条件判断语句，默认为真，是死循环 System.out.println(i);&#125;for (int i = 0; i &lt; 10; ) &#123; //省略了循环控制语句，i一直为0，条件判断一直为真，为死循环 System.out.println(i);&#125; 循环嵌套循环里面可以嵌套着一个循环，例如输出九九乘法表 for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.printf(\"%d*%d=%2d \",j,i,j*i); //类似于C语言，格式化输出，以便对齐 &#125; System.out.println();&#125; 输出为 1*1= 1 1*2= 2 2*2= 4 1*3= 3 2*3= 6 3*3= 9 1*4= 4 2*4= 8 3*4=12 4*4=16 1*5= 5 2*5=10 3*5=15 4*5=20 5*5=25 1*6= 6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7= 7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8= 8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9= 9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 方法入门方法定义方法定义的格式为 修饰符 返回类型 方法名(参数类型 参数) &#123; 代码 ...; return ...;&#125; 其中修饰符目前固定为public static，方法要符合之前在标识符里面的规定。 注意： 方法不能定义在方法里面 方法定义的前后顺序无所谓 方法应在class和main方法之间定义 return的作用有两个，第一个是终止程序退出方法，第二个是返回值 如果返回值的类型时void，可以只写return;，代表退出方法 public class Hello &#123; //定义了一个方法，该方法的作用是计算两个int整数的和，并返回一个int类型的值 //该方法接收两个int类型的参数，返回一个int类型的值 public static int add (int x, int y) &#123; return x + y; &#125; //main方法的顺序可以和上面add方法的顺序颠倒 public static void main(String[] args) &#123; //... ... //不能在里面定义方法 &#125;&#125; 方法调用方法调用的格式为 方法名(参数); 例如，在main方法中调用上面定义的add方法 public class Hello &#123; public static int add (int x, int y) &#123; return x + y; &#125; public static void main(String[] args) &#123; //调用add方法，其中2 和 3是参数，必须是int类型，否则会报错 int c = add(2, 3); //使用变量c来接受方法返回的结果，此时c = 5 &#125;&#125; 方法重载方法重载指的是两个方法的方法名相同，但是参数列表不同，参数列表不同包括三个方面 参数个数不同 参数类型不同 参数顺序不同 例如，下面的方法是重载 public static void add (int i, intj);static int add (double i, double j);public void add (double i, intj); 注意： 判断方法是否是重载，关键是看方法名是否相同，参数列表是否不同，与修饰符，返回值没有任何的关系 例如，下面的方法不是重载 public static void add (int i, int j);static void add (int i, int j); //与修饰符无关，参数列表相同，所以不是重载，编译会报错public static int (int i, int j); //与返回值无关，参数列表相同，所以也不是重载，编译会报错 下面举一个注意事项，假设有下面这么一个方法 public static void add (int i, double j); 在main方法中，我们可以这么调用 add(2, 2); //我们可以传入两个整数，因为会进行自动类型转换为double 然后我们对该方法重载了 public static void add (double i, int j); //参数列表的顺序不同，是重载 如果我们还在main方法中传入两个整数 add (2, 2); //这时会报错 因为在调用这个方法时，发现两个方法都可以，所以编译器就会感到模糊，不知道调用哪一个方法，就会报错。 数组假设你要保存一组学生的成绩，我们会考虑每个学生用不同的变量保存，如 int score1 = 100;int score2 = 80;... ... 这样写的话代码很长，并且不利于批量操作，比如如果我要给每个学生加上十分，那我们只能这么写 score1 = score1 + 10;... ... 这只是体力活。 Java中专门有一类数据类型用来保存这样的数据，它叫做数组，下面我们将详细介绍。 数组的初始化数组的初始化分为两组，分别为动态初始化（指定长度）和静态初始化（指定内容）。 动态初始化动态初始化的格式为 数据类型[] 数组名 = new 数据类型[数组长度]; 例如，下面声明了一个长度为3的int类型的数组 int[] array = new array[3]; 动态初始化其实可以分为两部分 int[] array;array = new array[3]; 静态初始化静态初始化的格式为 数据类型[] 数组名 = new 数据类型[] &#123;内容&#125;; 例如，下面创建了一个String类型的数组，里面有3个字符串，内容之间使用逗号隔开 String[] str = new String[]&#123; \"Hello\", \"World\", \"!!!\" &#125;; 编译器会自动计算内容的个数来确定数组的长度。静态初始化还有省略格式 数据类型[] 数组名 = &#123;内容&#125;; 例如上面的例子用省略格式重写为 String[] str = &#123; \"Hello\", \"World\", \"!!!\" &#125; 静态初始化也可以看做是由两部分组成 String[] str;str = new String[] &#123; \"Hello\", \"World\", \"!!!\" &#125;; 但是省略格式不能这样看，例如下面的写法是错误的 String[] str;str = &#123; \"Hello\", \"World\", \"!!!\" &#125;; 注意： 数组的长度在程序运行期间是固定的，不能够发生改变 可以通过数组名.length来得到数组的长度 静态初始化会根据内容来自动推算出数组的长度 访问数组我们通过数组名[索引]的方式来访问数组里面的内容，这里需要注意的是索引值是从0开始的，所以索引的范围为0~数组长度-1 int[] array = &#123; 1, 2, 3 &#125;;System.out.println(arrays[0]); //访问数组中的第一个元素，输出1System.out.println(arrays[1]); //访问数组中的第二个元素，输出2 注意： 索引的范围不能超过数组的长度，否则会报错 例如对于上面定义的数组，下面的代码会报错 array[3]; //会报错 动态初始化有默认值，不同类型的默认值不同，如下 数据类型 默认值 整型(byte,short,int,long) 0 浮点型(float和double) 0.0 字符(char) ‘\\u0000’ 布尔型(boolean) false 引用内容 null 静态初始化其实也有默认值，不过马上又被赋值被覆盖了 Java的内存模型Java的内容模型分为五部分，分别是 栈(Stack) 存放的都是局部变量，变量一旦超出作用域，立刻从栈内存中消失 当调用方法运行时，栈会为方法开辟一块空间 堆(Heap) 凡是new出来的，都在堆中 堆内存里面的东西都有一个地址值 堆内存里的数据都有默认值，同数组的默认值 方法区(Method Area) 存储class相关的信息，包括方法的信息 本地方法栈(Native Method Stack) 与操作系统相关 寄存器(PC Register) 与CPU相关，速度非常的快 目前我们需要关注的前三个。 数组的内存图下面我们来看一段代码，然后从内存的角度看看发生了什么 public static void main(String[] args) &#123; int[] array1 = new int[3]; System.out.println(array1); // 猜猜打印出什么 array1[0] = 10; System.out.println(array1[0]); int[] array2 = array1; System.out.println(array2); array2[1] = 200; System.out.println(array1[1]);&#125; 上面代码的输出为 [I@15db974210[I@15db9742200 下面将从内存的角度解释，首先第一行 public static void main(String[] args) 该方法的信息会保存在方法区中，如果方法区中没有该方法，那么程序会报错。然后找到main方法后，这时会把main推入栈中，栈内存会为main方法开辟一块空间 int[] array1 = new int[3]; 这一行是动态初始化数组，首先会在main方法中分配一块空间保存变量array1的值，在堆中会开辟一块空间，空间的大小为3个int的大小，里面的默认值为0，在堆中存放的东西都有一个地址，array1保存的就是这个地址。访问数组就是通过这个地址去访问在堆中保存的数据的。 System.out.println(array1); 这一行打印变量array1的值，我们知道array1保存的是数组在堆中的地址，所以输出的是[I@15db9742，其中[代表类型为数组，I代表是int类型，@符号后面的十六进制数字是地址的哈希值。 array1[0] = 10;System.out.println(array1[0]); 第一行是对数组中的第一个元素赋值为10，原来数组中的元素默认为0，现在改变为了10。在内存中的过程为，首先根据array1保存的地址去寻找在堆中的数组，然后根据索引值去寻找对应的位置，然后对数据进行修改 int[] array2 = array1;System.out.pritnln(array2); 这行语句声明了一个数组变量array2，它的值与array1的值相同，所以输出结果为[I@15db9742。这表示两个数组变量指向在堆中的同一个数组 array2[1] = 200;System.out.println(array1[1]); 上面的语句表示通过array2修改数组中的元素array2[1]为200，由于array1和array2指向的是同一个数组，所以array2对数组进行修改也会影响到array1。所以输出的结果是200而不是0。 数组练习学习了数组的内容之后，我们做几个练习巩固一下知识。 遍历数组遍历数组指的就是访问数组中的每一个元素。我们使用for循环，将数组中的每一个元素打印出来。 int[] array = &#123; 1, 4, 7, 9, 5&#125;;for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]);&#125; 输出为 14795 找到数组中的最大值思路为，想象为这是一个打擂台，数组中的元素就是挑战者，首先让数组中的第一个元素为擂主，后面的挑战者（数组元素）去挑战，比擂主强的话就成为新的擂主，比擂主弱那么擂主就继续在台上，那么最后所有人都挑战完了，那么此刻的擂主就是最强的男人。 int[] array = &#123; 1, 4, 7, 9, 5&#125;;int max = array[0]; //擂主为第一个元素for (int i = 1; i &lt; array.length; i++) &#123; //挑战者不断挑战 if (array[i] &gt; max) &#123; max = array[i]; //如果挑战者比擂主强，那么换擂主，否则擂主不变 &#125;&#125;System.out.println(max); //此刻的擂主就是最强的 输出为 9 数组反转所谓的数组反转就是相对应的位置调换顺序，比如索引为0与索引为array.length-1（最后一个元素）调换位置，一般的索引为i的元素与索引为array.length-1-i的元素交换位置，那么交换的条件就是i &lt; array.length -1 - i得到i &lt; (array.length -1) / 2 int[] array = &#123; 1, 4, 7, 9, 5&#125;;int len = array.length;for (int i = 0; i &lt; (len - 1) / 2; i++) &#123; int temp = array[i]; array[i] = array[len -1 -i]; array[len -1 -i] = temp;&#125;for (int i = 0; i &lt; len; i++) &#123; System.out.println(array[i]);&#125; 输出为 59741 数组与方法数组可以作为函数的参数，也可以作为函数的返回值返回。 方法作为函数参数下面定义一个方法，该方法的作用是打印出数组里面的所有的元素，该方法接收一个整型的数组参数。 public static void printArray (int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125;&#125; 下面在main方法中调用该方法 int[] array = &#123; 1, 2, 3 &#125;;printArray(array); 输出为 123 注意： 数组传递的是地址值，所以printArray方法中的array与main方法中的array指向的是同一个数组，所以如果在printArray方法中对数组元素进行修改的话，会影响到main方法中的array。 随着printArray方法的执行完成，在栈内存中会将为printArray开辟的空间出栈，此时printArray方法中的array变量会立即消失。 不仅是数组，引用类型作为方法的参数，传递的都是地址值 数组作为方法返回值下面有一个方法，该方法接收一个数组，返回该数组的所有数字之和及平均数，由于return语句只能返回0或1个值，要返回两个值的话，我们可以返回一个数组，数组的第一个值表示和，第二个值表示平均数。 public static double[] getSumAndAvg (int[] array) &#123; double sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; //求和 sum = sum + array[i]; &#125; double avg = sum / array.length; //得到平均数 double[] result = &#123; sum, avg &#125;; //创建一个数组，第一个值为sum 第二个值为avg return result;&#125; 在main方法中调用该方法 int[] array = &#123; 1, 4, 7, 9, 5&#125;;double[] resArr = getSumAndAvg(array); //得到数组System.out.println(\"Sum is \" + resArr[0]); //打印输出和System.out.println(\"Average is \" + resArr[1]); //打印输出平均数 输出为 Sum is 26.0Average is 5.2 注意： 方法返回时数组的地址值，内存分析过程同上类似 返回引用数据类型，返回的也是地址值","tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"}]},{"title":"Java开发环境搭建","date":"2019-06-30T16:00:00.000Z","path":"/Java环境搭建/","text":"Java环境搭建分为三步： 下载JDK 安装JDK 环境变量配置 下面将详细介绍安装的步骤。 下载JDK首先进入Oracle官网进行下载 点击Downloads 点击Java 选择Java(JDK) for Developers 这是JDK 12，是最新版的，目前主流的是JDK 8，我们往下翻 点击JDK DOWNLOAD 选择合适自己机器的版本下载，一般现在的机器都是64为，选择下载即可，但我们点击下载时，它要我们登录 这里提供一个账号 用户名：2696671285@qq.com 密码：Oracle123 登录成功后就开始下载了 安装JDK安装JDK就是一直点next即可，因为JDK是包含JRE的，所以JRE可以不必安装。这里需要注意的是，不要将安装目录安装在中文目录下，因为可能会碰到各种各样的问题，我们将它扼杀在摇篮里即可。这里需要记住安装的路径，比如我安装的路径是 G:\\java 安装好以后里面是这样的 环境变量配置现在要进行环境变量的配置，可能你不知道为什么需要进行配置。我们看这么一个情况，你在命令行输入一个命令，比如notepad(它会打开一个记事本)，但是当你输入一串乱七八糟的字符时，它会提示你 那命令行怎么知道notepad是一个命令，而你乱输入的字符不是命令呢? 因为当你输入字符后，命令行会去一个路径找是否有这个命令，如果有那么执行该命令，没有就会报出上面那样的错误。为了我们能够在命令行中使用有关于Java的命令，我们就要将有关Java的命令添加到路径中，这个路径就是我们要去配置的东西。那么与Java有关的命令放在哪里，首先打开你安装的那个目录 然后进入bin文件夹，这个文件夹里面就是有关Java的各种命令 比如我的路径为 G:\\java\\bin 现在来到桌面，右键我的电脑，点击属性 然后按照以下步骤 会进入下面这个界面 点击新建，将你刚刚复制的路径粘贴上去 现在大功告成了。为了检验是否配置成功，我们打开命令行，输入java和javac命令，如果出现下面的界面就说明成功了 如果提示命令找不到之类的，说明配置失败了，就要回头仔细看看是不是漏掉了什么。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.gitee.io/tags/Java/"},{"name":"学习","slug":"学习","permalink":"https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"软件安装及配置","slug":"软件安装及配置","permalink":"https://lastknightcoder.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"}]},{"title":"CSS基础","date":"2019-02-11T16:00:00.000Z","path":"/CSS基础/","text":"CSS入门之前我们学习过HTML的基本知识，对于网页来说，HTML搭建的只是框架，而对于网页的美容，则需要用到CSS，CSS就可以看做是网页的美容师。CSS的全称叫做Cascading Style Sheets,中文名字叫层叠样式表。我们可以用CSS设置字体的颜色，字体的大小以及图片外形，排版布局等等”美颜”的工作。 CSS的书写位置行内式CSS的书写位置有三个，第一个是行内，如下 &lt;标签 style=\"属性1:属性值1; 属性2:属性值2 ...\"&gt; 下面就是把这个一级标题设置为红色。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style = \"color:red\"&gt;CSS入门&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 内嵌式内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： &lt;head&gt; &lt;style&gt; 选择器&#123;属性1:属性值1; 属性2:属性值2; ...&#125; &lt;/style&gt;&lt;/head&gt; 比如下面 &lt;head&gt; &lt;style&gt; h1&#123;color:red;&#125; &lt;/style&gt;&lt;/head&gt; 就是把所有的h1标签的文字颜色设置为红色。 外链式外链式指的是HTML文件与CSS文件分开写，在实际工作中就是这么干的。但是为了方便，我在介绍CSS的使用的时候一般会用内嵌式。外链式的写法如下 &lt;link rel=\"stylesheet\" href=\"CSS文件的路径\" type=\"text/CSS\"/ &gt; link标签是单标签，它是放在head标签内的。在使用link标签时，必须指定link标签的三个属性,如下: href:定义所链接外部样式表文件的URL,可以是相对路径，也可以是绝对路径。 type:定义所链接文档的类型，在这里需要指定为”text/CSS”,表示链接的外部文件为CSS样式表。 rel:定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个样式表文件。 选择器标签选择器使用HTML的标签名作为选择器，为HTML的某一标签指定统一的CSS样式。比如上面的 h1&#123;color:red;&#125; 就是标签选择器，使用h1作为选择器，所有的h1标签包含的文字都被设置为红色。 类选择器类选择器是最常用的选择器，类选择器使用.（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： .类名&#123; 属性:属性值; ... ...&#125; 标签在调用CSS样式时，使class=”类名”即可，比如 &lt;head&gt; &lt;style&gt; .red&#123; color : red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=\"red\"&gt;CSS入门&lt;/h1&gt;&lt;/body&gt; 我们声明了一个类选择器，类名叫做red,在h1标签中，我们通过class=”red”调用了该类，所以h1标签所包含的文字设置成了红色。 多类名选择器如果我们在标签中需要调用多个类怎么办，比如有两个类分别为 .red&#123; color:red;&#125;.font14&#123; font-size=14px;&#125; 如果加入h1标签要调用这两个类的话，写法如 &lt;h1 class = \"red font14\"&gt;标题&lt;/h1&gt; 这个就叫做多类名选择器。 还有一个问题就是，如果调用的多个类有冲突怎么办?比如调用的两个类一个设置颜色为红色，一个设置颜色为蓝色，是如何处理这种冲突? .red&#123; color:red;&#125;.blue&#123; color:blue;&#125; 假设h1调用如下 &lt;h1 class=\"blue red\"&gt;标题&lt;/h1&gt; 你觉得会是蓝色还是红色的?答案是蓝色的，虽然调用时blue写在red前面，你想red会覆盖blue,所以会是红色，实际上最终的效果与调用的顺序无关，而与CSS书写的顺序有关，由于CSS书写时red在blue的上面，所以只有最后的blue生效。 id选择器与类选择器很相似，不管调用方式是通过id来调用的，并且书写方式上有差别，即将.改为了#。如下 #id名&#123; 属性:属性值; ... ...&#125; 调用方式同类调用方式，不过用的不是class=””而是id=””。与类选择器不同的是，由于id是唯一的，不同的标签的id不能相同，所以该种方法只能给唯一的一个id设置样式。并且id选择器能做到的，类选择器也能做到，所以实际上类选择器是用的最多的。 通配符选择器书写方式如下 *&#123; 属性:属性值; ... ... &#125; *就是通配符，代表所有标签的意思，意思是所有的标签都会被设置成这样的样式，该种方法在开发几乎不用。 字体样式字体大小font-size属性是用来设置字体大小的，字体大小的单位有很多，其中最常用的就是px,代表的是像素，1px代表的就是一个像素的大小。比如 font-size: 20px; 在网页中普遍使用14px+,并且尽量用偶数大小，因为奇数可能在低版本的浏览器中出现莫名的问题。 字体font-family属性是用来设置字体的，比如 font-family: \"楷体\"; 英文字体可以不加引号，但是如果英文字体含有空格，则需要加上引号，比如 font-family: \"Times New Roman\"; 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、UTF-8等)不匹配时会产生乱码的错误。xp系统不支持类似微软雅黑的中文。解决办法是可以使用CSS Unicode字体表示，比如 font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot; 就表示设置字体为微软雅黑。其中 \\5FAE\\8F6F\\96C5\\9ED1 就是Unicode字体。常见中文对应的Unicode字体如下: 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 字体粗细font-weight属性是用来设置字体粗细的，可选属性值有normal, bold, older, lighter,除了有着四种值可选外，其值还可以是数字，范围为100-900并且必须为100的倍数。normal相当于是400,bold相当于是700,一般建议用数字。 font-weight: 400; 字体风格font-style属性是用来设置字体风格的，有两种值可选，分别是normal对于正常的字体风格，另一个是italic对应的是斜体风格。 font-style: italic; 综合连写假如我们设置字体的时候，四个都要设置，假如我要设置字体大小为20px,字体为微软雅黑，字体粗细为500,字体风格为斜体，我们会这样写: .font &#123; font-size: 20px; font-family: \"\\5FAE\\8F6F\\96C5\\9ED1\"; font-weight: 500; font-style: italic;&#125; 因为对于字体样式写的比较频繁，这么写的话过于的繁琐，所以CSS规定可以对其综合连写，如下 .font &#123; font: italic 500 20px \"\\5FAE\\8F6F\\96C5\\9ED1\";&#125; 其中书写顺序必须为font-style, font-weight, font-size, font-family,其中font-size和font-family不可以省略。 文本样式颜色color属性用以设置文本的颜色，其取值有三种方法: red,green,blue…等内置的颜色 使用十六进制，比如#FF0000，其中十六进制的前两位代表三基色中的红色，中间两位代表绿色，后两位代表蓝色。所以#FF0000代表的就是红色。 使用RGB代码，比如红色为rgb(255,0,0)。 其中第二种方法使用的最多，如果十六进制的三对每两位是相同的，则可以缩写为一个，比如#FF0000可以缩写为#F00。#FFDD66可以缩写为#FD6。 行高line-height属性用以设置行高，比如对一个段落来说，其行与行之间的距离太小了，则可以通过设置行高来调整行间的距离。 p&#123; line-height: 40px;&#125; 文本对齐方式text-align用以设置文本的水平对齐方式，可选值有三个，分别为left, right, center。 text-align: center; 缩进text-indent用以设置段落首行的缩进距离，一般设置为2em即两个字的距离： text-indent: 2em; 文本修饰text-decoration属性用来修饰文本，有一下几个值可选: none：取消文本修饰或无修饰 underline：下划线 overline：上划线 line-through：删除线 复合选择器后代选择器假如有下面这么一个例子 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;后代选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;开心&lt;/p&gt; &lt;p&gt;快乐&lt;/p&gt; &lt;/div&gt; &lt;p&gt;乐观&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我们希望将开心和快乐变成红色，而不影响乐观，即将div标签下的p标签设置为红色，但不是所有的p标签设置为红色，所以不能这么写 p &#123; color: red;&#125; 也许你们可能会写一个类，然后让这两个p标签去调用，但是假设div下有很多这样的p标签的话，这样做就不现实，我这里使用的是后代选择器，如下 div p &#123; color: red;&#125; 即设置div标签下的p标签设置为红色。因为乐观所处的p标签不在div标签下，所以乐观不受影响。效果如下: 子代选择器假设有这么一个案例 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;子代选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;div&gt;&lt;a href=\"#\"&gt;二级菜单&lt;/a&gt;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 我们希望一级菜单变为红色，而二级菜单不受到影响，如果我们使用后代选择器 ul li a &#123; color: red;&#125; 那么li标签下的所有a标签都会受到影响，二级菜单也会受到影响，这个时候我们需要用子代选择器 ul&gt;li&gt;a &#123; color: red;&#125; 上面便是子代选择器的写法，与后代选择器不同，子代只包括”儿子”,而后代则是包括后代所有的。所以使用子代选择器，受到影响的只有li标签下的a标签，二级菜单没有受到影响。效果为: 交集选择器假设有下面这么一个案例 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;交集选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;啊啊&lt;/div&gt; &lt;div&gt;啊啊&lt;/div&gt; &lt;div&gt;啊啊&lt;/div&gt; &lt;p&gt;一一&lt;/p&gt; &lt;p&gt;一一&lt;/p&gt; &lt;p&gt;一一&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我们希望将第三个div标签中的文字设置为红色。很简单的一个方法就是这样 .red &#123; color: red;&#125; 然后让第三个div标签去调用，但是我们这里做出要求，当p标签去调用这个类时，它的颜色不会改变。这个时候我们就要用到交集选择器 div.red &#123; color: red;&#125; 上面的选择器表明，只有div标签调用这个类才会生效，其他标签调用这个类不会生效，这就是交集选择器。 并集选择器假设又有下面这个案例 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;并集选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;p&gt;123&lt;/p&gt; &lt;h1&gt;123&lt;/h1&gt; &lt;a href=\"#\"&gt;123&lt;/a&gt; &lt;strong&gt;123&lt;/strong&gt; &lt;/body&gt;&lt;/html&gt; 我们希望div,p.h1标签都设置为红色，其他的不变，我们可以这样写 div &#123; color: red;&#125;p &#123; color: red;&#125;h1 &#123; color: red;&#125; 使用并集选择器可以使上面的代码大大减少 div, p, h1 &#123; color: red;&#125; 使用逗号将标签或者类名隔开。 链接伪类选择器什么是伪类选择器，伪类选择器是向某些选择器添加特殊效果，比如为链接添加特殊效果,链接伪类选择器有四个，分别为 link：未访问过的链接状态 visited：已访问过的链接状态 hover：鼠标放上去时的链接状态 active：鼠标按下时的链接状态 类选择器使用点.,而伪类选择器使用冒号:。现在我们有这个需要，当未访问链接时，链接字体为25px,无下划线，当鼠标放上去时，颜色变为红色，当按下时颜色变为橙色，当访问后，颜色为绿色。CSS样式按如下写 a:link &#123; font-size: 25px; text-decoration: none; /*取消下划线*/&#125;a:visited &#123; color: green;&#125;a:hover &#123; color: red;&#125;a:active &#123; color: orange;&#125; 效果为 当未按下链接时，链接为蓝色，按把鼠标放上去时，链接变为红色，当按下链接时，链接变为橙色，当访问完链接后，链接变为了绿色。需要注意的一点是，伪类选择器的顺序必须按照lvha的顺序来，否则会达不到想要的效果。在实际的开发中，一般只用到hover,不会写的这么复杂，即我们只需要当鼠标放上去变颜色就行，如下 a &#123; font-size: 25px; text-decoration: none;&#125;a:hover &#123; color: red;&#125; 标签显示模式我们把标签分为三类，一类为块级(block)标签，一类为行内(inline)标签,最后一类为二者的综合，为行内块(inline-block)标签。每个块标签通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。常见的块级标签包括 &lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; 行内标签（内联标签）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。常见的行内标签包括 &lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; 假设我们对行内标签设置其宽高属性 a &#123; width: 20px; height: 30px;&#125; 这样做是没有效果的。链接a的宽高属性不会改变。 在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块标签。那么标签的这种显示模式可不可以转换呢? 答案是可以，我们可以使用display属性对其进行转换，如 display: inline; /*将块级标签转换为行内标签*/display: block; /*将行内标签转换为块级标签*/display: inline-block; /*将块级标签或者行内标签转换为行内块标签*/ 我们来看一个例子，假设有下面的程序 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标签显示模式&lt;/title&gt; &lt;style&gt; a &#123; text-decoration: none; /*取消下划线*/ background: pink; /*设置背景颜色，用以观察该标签显示模式的转换*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#\"&gt;链接&lt;/a&gt; &lt;a href=\"#\"&gt;链接&lt;/a&gt; &lt;a href=\"#\"&gt;链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 因为标签a是行内标签，所以这三个标签是显示在一行内的，如下: 并且无法对其设置宽高以及对齐属性。现在我们将标签a的显示模式改为块级模式 a &#123; text-decoration: none; background: pink; display: block;&#125; 效果为 可见链接已经变为了块级标签，一个标签占据一整行，并且我们可以对其设置宽高属性以及对其方式，如下 a &#123; text-decoration: none; background: pink; display: block; width: 400px; height: 100px; text-align: center;&#125; 效果为 可见链接a的宽高发生了变化，并且其内的文字水平居中对齐了。我们可以把所有的标签看做是一个盒子，有的盒子是占据一行的，并且可以设置其大小，有的盒子只能在行内，并且不能设置其大小，还有的盒子虽然在行内，但是可以设置其大小。我们就用CSS对盒子进行操作，或摆放，或修饰，或改变盒子的显示模式等等。 导航栏练习现在我们要做一个导航栏，其最终效果如下 我们要求导航栏的布局居中显示，并且其内的文字也要居中对齐。并且当鼠标放在网站导航上，其背景图片发生变换。 首先第一步便是显示着六个链接，如下 &lt;div class=\"nav\"&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt;&lt;/div&gt; 效果如下: 第二步，取消下划线，并且设置字体颜色为白色，并且添加背景图片，由于链接标签a是行内标签，其大小不可以改变，为了使添加的背景图片吻合，还需要改变其显示模式为display: inline-block,然后设置其宽高属性为图片宽高的大小。如下: .nav a &#123; text-decoration: none; /*取消下划线*/ color: #FFF; /*设置字体颜色为白色*/ display: inline-block; width: 120px; height: 50px; background-image: url(bg.png);&#125; 在这里，为了只影响导航栏的链接标签，这里我们用了后代选择器。效果如下: 这个时候我们发现导航栏没有居中对齐，并且里面的文字没有居中对齐 .nav &#123; text-align: center;&#125; 我们设置.nav类里的文字居中对齐，但是div里面的是链接，text-align属性还有用吗? 答案是可以，链接在块类标签里面可以当做是文字处理，这是一个知识点，记住了。效果如下： 我们发现导航栏居中对齐了现在我们需要将链接里面的文字水平居中对齐和垂直居中对齐，在.nav a加入如下 text-align: center;line-height: 50px; /*当行高等于标签设置的高度时，会使文字垂直居中对齐*/ 效果如下 现在最后一步就是将鼠标放上去，背景图片改变，我们使用伪类hover,如下 .nav a:hover &#123; background-image: url(\"bgc.png\");&#125; 这里为了只对导航栏的链接生效，这里也用了后代选择器，效果如下: 到这里我们已经完整的实现了导航栏的案例，下面贴出完整的代码。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;导航栏案例&lt;/title&gt; &lt;style&gt; .nav a &#123; text-decoration: none; /*取消下划线*/ color: #FFF; /*设置字体颜色为白色*/ display: inline-block; width: 120px; height: 50px; background-image: url(bg.png); text-align: center; line-height: 50px; &#125; .nav a:hover &#123; background-image: url(\"bgc.png\"); &#125; .nav &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 行高在之前我们有提到这个属性line-height，该属性用来设置行高，并且我们用它来设置过行间距。为了明白行高指的是什么之间的距离，我们需要明白下面这个图 一个文本内容被四条线划分，而行高指的就是基线与基线之间的距离，当不设置行高时，行高的大小为字体的大小，所以行与行之间是紧贴着的。 在导航栏练习中，为了使文字能够垂直居中对齐，我们让line-height的大小等于盒子的大小，为了解释这一现象，我们先看一下盒子的组成，盒子的高度由上距离，下距离和文本内容的高度组成，上距离的大小为(行高-内容高度)/2,下距离的高度=盒子高度-上距离的高度-内容高度。当文本垂直居中显示时，上距离的高度等于下距离的高度，这时上距离的高度=(盒子高度-内容高度)/2,对比于上距离高度的公式，得到此时行高等于盒子的高度。所以这就解释了为什么当行高等于盒子高度时，文字会垂直水平居中，当行高增大时，上距离的高度增大，文字会向下移动。","tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"CSS","slug":"CSS","permalink":"https://lastknightcoder.gitee.io/tags/CSS/"}]},{"title":"HTML基础","date":"2019-02-07T16:00:00.000Z","path":"/HTML入门/","text":"需要的开发工具由于目前的市场上Google的占有率最高，所以我们用Chorme作为开发用的浏览器，而写代码的工具有很多，我一般用WebStorm。 第一个HTML页面一般新入手一个语言，都是先敲一个代码，然后在解释这个代码，按照惯例都是显示Hello World,所以这里就在网页中显示Hello World。 &lt;html&gt; &lt;head&gt; &lt;title&gt;第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World &lt;/body&gt;&lt;/html&gt; 以上的程序可以写在任何文本编辑器中，然后将后缀名改为.html，用浏览器打开即可。 一般写html的格式应该如下 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 其中&lt;html&gt;,&lt;head&gt;等等称为标签，在html中，内容都是由标签来呈现的，而标签分为双标签和单标签，一般我们遇到的都是双标签，比如上面的&lt;html&gt;&lt;/html&gt;是双标签，&lt;html&gt;是开始标签，&lt;/html&gt;是结束标签。单标签比如&lt;br /&gt;是换行标签，它的作用是换行。 其中&lt;body&gt;&lt;/body&gt;标签里写的东西才是网页呈现的内容，比如上面的Hello World就是写在body标签里面的,而&lt;head&gt;&lt;/head&gt;标签里写的东西都不会呈现在网页中，一般写的都是网页的信息，比如所用的编码，网页的标题，网页的版权等等。 我们一般会在第一行加上&lt;!DOCTYPE html&gt;,这个是用来告诉浏览器我们使用的浏览器版本，这么写的话就代表我们使用的是html5的版本。 排版标签标题在html中共有6种标题，分别是 &lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;... ...&lt;h6&gt;&lt;/h6&gt; 其中h1为最大的标题，称为一级标题，h6称为六级标题，上面的标题标签都是双标签。 我们在网页中看看标题的效果: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;h4&gt;四级标题&lt;/h4&gt; &lt;h5&gt;五级标题&lt;/h5&gt; &lt;h6&gt;六级标题&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 段落段落标签是用&lt;p&gt;&lt;/p&gt;标签来呈现的，在&lt;p&gt;标签内部的内容视为一个段落，该标签会根据浏览器窗口的大小自动换行。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。 予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清， 亭亭净植，可远观而不可亵玩焉。(甚爱 一作：盛爱)&lt;/p&gt; &lt;p&gt;予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。 噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人?牡丹之爱，宜乎众矣!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 在html代码中进行换行操作时，在网页显示时不会进行换行操作，html中所有的功能都是由标签实现的，所以换行也需要换行标签实现。 我们可以见到，段落之间会自动换行，并且段落之间还隔有一个空行。 水平线水平线标签&lt;hr /&gt;是一个单标签，它的作用是显示一条水平线。 换行换行标签为&lt;br /&gt;,也是一个单标签，它的作用是换行，换行之后，不会像段落一样之间还有一个空行，而是两行会紧贴着。 两个无语义化的标签&lt;div&gt;&lt;/div&gt;和&lt;span&gt;&lt;/span&gt;,这两个标签没有实际的功能，在后面主要是配合CSS进行布局，所以这里就不要管它好了。 &lt;div&gt;标签会实现自动换行，所以一行只能有一个&lt;div&gt;标签，&lt;span&gt;不会自动换行，所以一行可以有多个&lt;span&gt;标签。 我们来看一个简单的例子: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;会自动换行&lt;/div&gt; &lt;span&gt;不会自动换行&lt;/span&gt;&lt;span&gt;可以有多个&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 文本格式化字体加粗加粗标签有两个，分别为&lt;b&gt;&lt;/b&gt;和&lt;strong&gt;&lt;/strong&gt;,二者都能进行加粗，不过&lt;strong&gt;标签比较有语义，所以用的比较多。 斜体斜体标签也有两个，分别为&lt;i&gt;&lt;/i&gt;和&lt;em&gt;&lt;/em&gt;,同样的，&lt;em&gt;用的比较多。 删除线同样也有两个，分别为&lt;s&gt;&lt;/s&gt;和&lt;del&gt;&lt;/del&gt;,后面的有语义，用的多。 下划线两个，分别为&lt;u&gt;&lt;/u&gt;和&lt;ins&gt;&lt;/ins&gt;,后面的有语义，为insert的缩写，用的较多。 简单的演示一下: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;strong&gt;粗体&lt;/strong&gt;&lt;/br &gt; &lt;em&gt;斜体&lt;/em&gt;&lt;/br &gt; &lt;del&gt;删除线&lt;/del&gt;&lt;/br &gt; &lt;ins&gt;下划线&lt;/ins&gt;&lt;/br &gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 图像标签向网页中添加图片的方法为 &lt;img src=\"图片的路径\"&gt; 这是一个单标签，src称为标签&lt;img&gt;的属性，它的值应该为图片的路径。 而路径又分为绝对路径和相对路径,下面将简单介绍一下二者，假设有如下的目录结构 磁盘C file1文件夹 html.md p1.png image文件夹 p2.png p3.png 现在我打开的是html.md文件,如果我要与绝对路径插入p1.png, p2.png, p3.png这三张图片，那么方法是这样的 &lt;img src=\"C:/file1/p1.png\"&gt;&lt;img src=\"C:/file1/image/p2.png\"&gt;&lt;img src=\"C:/p3.png\"&gt; 如果以相对路径插入图片，那么图片相对于该文件的位置就很重要，下面演示如何以相对路径插入图片 &lt;img src=\"p1.png\"&gt;&lt;img src=\"image/p2.png\"&gt;&lt;img src=\"../p3.png\"&gt; p1.png和文件html.md处于同一级目录，所以直接写src=”p1.png”即可，而p2.png位于image文件夹，该文件夹与html.md文件处于同一目录，所以写为src=”image/p2.png”,而p3.png位于上级目录，..表示上一级目录，所以写为src=”../p3.png”。 图像标签除了有src属性外，还有其他的属性，如下 属性 功能 alt 图像不能显示时的替换文本 title 鼠标悬停显示的内容 width, height 宽度和高度，设置其中一个就可以，会等比例的缩放 border 添加边框，其值为边框的粗细 下面给一个示例写法: &lt;img src=\"p1.png\" width=\"60%\" title=\"p1.png\" border=\"1\"&gt; 链接标签我们碰到，当我们点击一句话就可以跳转到一个网页，或者点击一张图片跳转。那么这个就是用链接标签实现的。链接标签为: &lt;a href=\"链接地址\"&gt;跳转的文字或图片&lt;/a&gt; 比如你点击这里就会跳转到百度。比较需要注意的是，跳转到外部的网页要写成https://www.baidu.com，而不要写成www.baidu.com。 另外，注意这个跳转是在本页面打开的，而不是新打开一个页面，如果需要在新页面打开，则可以改变其属性target的值，如下 &lt;a href=\"https://www.baidu.com\" target = \"_blank\"&gt;点击这里&lt;/a&gt; target有两种值可选，分别为_self和_blank,默认为_self，即在本页面打开。除了可以跳转到外链，也可以在页面内进行跳转，你可以给一个标签设定一个id值,比如 &lt;img src=\"1.png\" id = \"1\"&gt; 我给这张插入的图片设了id值为1,那么我可以通过下面的语句跳转到这张图片 &lt;a href=\"#1\"&gt;跳转到1.png&lt;/a&gt; 通过id跳转前面要加#号。 列表无序列表该种列表在实际中使用的较多,效果大概是这样 足球 篮球 无序列表的标签为 &lt;ul&gt; &lt;li&gt;足球&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt;&lt;/ul&gt; 注意:&lt;ul&gt;&lt;/ul&gt;标签里面只能放&lt;li&gt;&lt;/li&gt;标签，而&lt;li&gt;&lt;\\li&gt;能放任何内容。 有序列表有序列表也经常用，其标签与无序的很相似 &lt;ol&gt; &lt;li&gt;足球&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt;&lt;/ol&gt; 效果是这样 足球 篮球 注意事项同无序。 自定义列表使用以下格式定义自定义列表 &lt;dl&gt; &lt;dt&gt;球类&lt;/dt&gt; &lt;dd&gt;足球&lt;/dd&gt; &lt;dd&gt;篮球&lt;/dd&gt;&lt;/dl&gt; 效果如下 球类 足球 篮球 表格表格在网页中也很常见，其写法为 &lt;table&gt; &lt;tr&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;物理&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 其效果为 学科 分数 物理 99 &lt;table&gt;&lt;/table&gt;标签就表示表格，而&lt;tr&gt;&lt;/tr&gt;表示一行，&lt;td&gt;&lt;/td&gt;表示一个单元格。table标签有很多的属性，如下 属性 功能 align 该属性设定对齐方式，有left,center,right三个值可选 cellspacing 单元格与单元格之间的距离，默认为2 cellpadding 单元格内的字与单元格之间的距离，默认为1 一般我们设置table的以下三个属性为0，这三个属性分别为cellspacing, cellpadding, border，称之为”三参为0”。我们还可使用&lt;caption&gt;&lt;/caption&gt;标签设置表格的标题，如 &lt;table&gt; &lt;caption&gt;成绩单&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;物理&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 成绩单 学科 分数 物理 99 因为表头比较特殊，所以有的时候我们在表头中不用td，使用th,该标签会加粗居中，我们改动如下 &lt;th&gt;学科&lt;/th&gt;&lt;th&gt;分数&lt;/th&gt; 效果为 成绩单 学科 分数 物理 99 下面讲的这个在实际中也经常遇到的是单元格合并。假如有下面这个表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 123 123 123 123 123 123 123 123 123 我希望将最后一行的后两列合并成一个单元格,首先我们要知道单元格的合并分为行和并rowspan和列合并colspan,行合并是自左而右的，列合并是自上而下的。将最后一行的后两列合并为一个，所以是列和并，并且是两个合并成一个，所以colspan = “2”,所以上面的程序改为 &lt;table&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td colspan=\"2\"&gt;123&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果为 123 123 123 123 123 123 123 123 在第三个tr(代表第三行)的第二个td处设置colspan=”2”,因为要合并最后一列，所以要删去最后一个td。 表单现实中会经常提交表单，比如在注册邮箱时，你就需要提交表单，表单由三部分组成，表单控件，提示文本和表单域。 现在重点介绍表单控件，因为这个包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。与表单有关的标签是&lt;input/ &gt;,&lt;input/ &gt;是一个单标签，根据其属性type设置不同的值，可以指定不同的控件类型，如: type的值 控件 text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像形式的提交按钮 file 文件域 &lt;input/ &gt;还有其他的属性配合type属性使用，如下 属性 功能 name 控件的名称 value 控件的默认文本值 size 控件在页面中的显示宽度，只能为正整数 checked 定义选择控件默认被选中的项 maxlength 控件允许输入的最大字符数 这里我想说一下单选按钮，假设有两个单选按钮，比如男和女让你选，按道理只能选一个，如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"radio\"&gt;男&lt;input type=\"radio\"&gt;女 &lt;/body&gt;&lt;/html&gt; 你可以发现两个都可以选到，解决办法将二者的name属性设置为相同的，比如sex,相同的name代表他们是同一组的，对于单选按钮，同一组的只能选中一个。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男&lt;input type=\"radio\" name=\"sex\"&gt;女 &lt;/body&gt;&lt;/html&gt; 这个时候你只能选一个。 下面要介绍一个&lt;label&gt;&lt;/label&gt;标签，当label与一个表单控件绑定时，点击该label会获得该控件的输入焦点,那么如何与表单控件绑定呢?使用for属性,如下 &lt;label for=\"word\"&gt;Sex&lt;/label&gt;&lt;input type = \"text\" id = \"word\"&gt; 当你点击Sex,会自动获得输入焦点。效果如下: text只能输入一行的文本，事实上，我们在网页中经常见可以输入多行文本的输入框，比如在我们发表评论时的输入框，多行输入的标签是textarea,使用方法如下: &lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 默认显示文本&lt;/textarea&gt; 效果如下 最后一个要介绍的就是下拉菜单，下拉菜单的标签是 &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;青岛&lt;/option&gt;&lt;/select&gt; 如下所示 北京 上海 青岛 当option中设置selected属性为selected=”selected”,那么这个option是默认选中项。比如我要设置上海为默认选中项那么 &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=\"selected\"&gt;上海&lt;/option&gt; &lt;option&gt;青岛&lt;/option&gt;&lt;/select&gt; 北京 上海 青岛","tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTML","slug":"HTML","permalink":"https://lastknightcoder.gitee.io/tags/HTML/"}]}]