<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="熊滔"><meta name="description" content="人生天地间，忽如远行客"><link rel="alternative" href="/atom.xml" title="Coder" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Java8新特性 - Coder</title>
<link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/main.css">

<link rel="stylesheet" href="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="https://lastknightcoder.gitee.io/js/jquery-3.1.1.min.js"></script>

<script src="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="https://lastknightcoder.gitee.io/">Coder</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-07-13T16:00:00.000Z">2019-07-14 00:00:00</time><h1 class="post__title"><a href="https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a></h1><div class="post__main echo"><p>本篇文章会介绍<code>Java 8</code>中的一些新特性(不包括<code>Lambda</code>表达式，因为在<a href="https://lastknightcoder.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">Java多线程</a>这篇文章中介绍过了)。主要内容是<code>Java 8</code>中新增的函数式接口以及<code>Stream</code>流，还有方法引用。</p>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><p>函数式接口指的就是接口里面只含有一个抽象方法。这样我们就可以使用<code>Lambda</code>表达式编程，这是一种函数式编程的思想，强调的是怎么做。<code>Java 8</code>提供了很多的函数式接口，这里我们介绍常见的函数式接口。</p>
<ul>
<li><code>Supplier\&lt;T&gt;</code></li>
<li><code>Consumer\&lt;T&gt;</code></li>
<li><code>Predicate\&lt;T&gt;</code></li>
<li><code>Functional\&lt;T,R&gt;</code></li>
</ul>
<h3 id="Supplier-lt-T-gt"><a href="#Supplier-lt-T-gt" class="headerlink" title="Supplier&lt;T&gt;"></a>Supplier&lt;T&gt;</h3><p>该接口里面有一个<code>T get()</code>方法，按照字面意思，是提供者的意思，表示生产出一个与泛型类型<code>T</code>相同的数据。下面我们来讲一个例子说明此接口的使用。假设有一个方法，需要返回一个字符串，该字符串由<code>Supplier</code>接口的<code>get()</code>方法产生，而产生什么样的字符串，则由程序员在调用该方法是传入<code>Lambda</code>决定。如下方法传入一个<code>Supplier</code>接口得到一个字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = getString(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h3 id="Consumer-lt-T-gt"><a href="#Consumer-lt-T-gt" class="headerlink" title="Consumer&lt;T&gt;"></a>Consumer&lt;T&gt;</h3><p>与<code>Supplier</code>接口不同的是，<code>Consumer</code>接口是消费或者说处理一个与泛型类型相同数据类型的数据，它有一个<code>accept(T t)</code>方法，该方法用来消费数据，假设有下面这一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleString</span><span class="params">(String str, Consumer&lt;String&gt; consumer)</span> </span>&#123;</span><br><span class="line">    consumer.accept(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>Consumer</code>来消费(处理)传入的这个字符串，而怎么消费，就取决与程序员在调用该方法时传入的<code>Lambda</code>，这时对程序员来说，就是怎么做的问题，相当于传入一个方法去处理数据，这就是函数式编程，这里我们就简单的将传入的数据进行打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleString(<span class="string">"Hello Again!"</span>, (String str) -&gt; &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello Again!</span><br></pre></td></tr></table></figure>

<p><code>Consumer</code>接口中有一个默认方法<code>andThen(Consumer consumer)</code>，看下面的程序说明它的用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con1.andThen(con2).accept(str); <span class="comment">//con1和con2都是Consumer接口的实现类对象</span></span><br><span class="line"><span class="comment">//相当于下面的代码</span></span><br><span class="line">con1.accept(str);</span><br><span class="line">con2.accept(str);</span><br></pre></td></tr></table></figure>

<p>假设有一个方法有需要传入两个<code>Consumer</code>接口对数据进行消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleInterger</span><span class="params">(Integer i, Consumer&lt;Integer&gt; con1, Consumer&lt;Integer&gt; con2)</span> </span>&#123;</span><br><span class="line">    con1.andThen(con2).accept(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>mian</code>方法中使用，<code>con1</code>对数字进行<code>+10</code>然后打印，<code>con2</code>对数字进行<code>*10</code>然后打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleInteger(<span class="number">10</span>, (i) -&gt; &#123;</span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;, (i) -&gt; &#123;</span><br><span class="line">    i = i * <span class="number">10</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="Predicate-lt-T-gt"><a href="#Predicate-lt-T-gt" class="headerlink" title="Predicate&lt;T&gt;"></a>Predicate&lt;T&gt;</h3><p><code>Predicate</code>接口中有一个<code>test(T t)</code>，它的作用是对某种数据类型进行判断，它返回一个<code>boolean</code>值。假设有一个集合，我们对其中的元素进行判断，符合条件放入一个新的集合，看下面的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">(HashMap&lt;String,Integer&gt; map, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个集合用以放符合条件的元素</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; resmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历集合</span></span><br><span class="line">    Set&lt;String&gt; key = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String str : key) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(str);</span><br><span class="line">        <span class="comment">//对值进行判断</span></span><br><span class="line">        <span class="keyword">boolean</span> res = predicate.test(val);</span><br><span class="line">        <span class="comment">//如果值符合条件，就加入新的集合</span></span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            resmap.put(str,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在<code>main</code>方法中进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">map.put(<span class="string">"奥特曼"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//筛选出年龄小于等于20岁的</span></span><br><span class="line">HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resmap);</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;佟丽娅=<span class="number">20</span>, 迪丽热巴=<span class="number">18</span>, 古力娜扎=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>Predicate</code>还有三个默认方法</p>
<ul>
<li><code>and(Predicate\&lt;T&gt; pre)</code><ul>
<li>与</li>
</ul>
</li>
<li><code>or(Predicate\&lt;T&gt; pre)</code><ul>
<li>或</li>
</ul>
</li>
<li><code>negate()</code><ul>
<li>非</li>
</ul>
</li>
</ul>
<p>假设对于上面的那个方法，我提出一个新的需求，要求不仅年龄要小超过<code>20</code>岁，而且年龄要大于<code>18</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">(HashMap&lt;String,Integer&gt; map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; resmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; key = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String str : key) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(str);</span><br><span class="line">        <span class="keyword">boolean</span> res = predicate1.and(predicate2).test(val);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            resmap.put(str,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;, (Integer i) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resmap);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;佟丽娅=<span class="number">20</span>, 古力娜扎=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>至于<code>or()</code>和<code>negate()</code>的使用方法同上。</p>
<h3 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T,R&gt;"></a>Function&lt;T,R&gt;</h3><p>该接口的作用是将<code>T</code>这种数据类型转化为<code>R</code>这种数据类型，它里面有一个<code>R apply(T t)</code>方法。下面这个方法将一个字符串转化为一个整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">StrToInt</span><span class="params">(String str, Function&lt;String, Integer&gt; fun)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main()</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = StrToInt(<span class="string">"123"</span>, (String str) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将字符串转化为数字</span></span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//打印该数字</span></span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code>接口中还有一个默认方法<code>andThen(Function&lt;T,R&gt; fun)</code>，这个方法与在上面介绍的<code>Consumer</code>接口的<code>andThen()</code>很像，但是有点不同，<code>Consumer</code>接口的<code>andThen</code>是两个对象消费同一个数据，而<code>Function</code>接口的<code>addThen()</code>是将第一个<code>fun</code>处理后的结果拿给第二个<code>fun</code>去处理，相当于<code>apply(apply())</code>。比如现在我有一个需求，将一个字符串转化为数字，然后将这个数字，<code>+10</code>然后再转化为字符串，这个方法可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">StrPlus</span><span class="params">(String str, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;String,Integer&gt; fun1, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;Integer,String&gt; fun2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun1.andThen(fun2).apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s =  StrPlus(<span class="string">"123"</span>, (String str) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将字符串转化为数字并加10</span></span><br><span class="line">    Integer i = Integer.parseInt(str);</span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, (Integer i) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将数字转化为字符串</span></span><br><span class="line">   <span class="keyword">return</span> i + <span class="string">""</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">133</span></span><br></pre></td></tr></table></figure>

<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><code>Stream</code>流是<code>Java 8</code>引入的新特性，首先它跟<code>I/O</code>流没有任何的关系，它主要是用来处理集合、数组问题的。要看<code>Stream</code>流有什么用处，还是要看集合处理有什么缺点。</p>
<h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>有下面这么一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"赵敏"</span>, <span class="string">"张翠山"</span>, <span class="string">"小昭"</span>, <span class="string">"张良"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们有如下要求</p>
<ul>
<li>筛选出以”张”字开头的字符串，放入一个<code>Arraylist</code>集合中</li>
<li>在<code>ArrayList</code>集合中筛选出字符串长度为<code>3</code>的字符串，放入一个新的集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">        list1.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list1);</span><br><span class="line">ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String string : list1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        list2.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张无忌, 张三丰, 张翠山, 张良]</span><br><span class="line">[张无忌, 张三丰, 张翠山]</span><br></pre></td></tr></table></figure>

<p>现在我们使<code>Stream</code>流的方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line">stream.filter(str -&gt; str.startsWith(<span class="string">"张"</span>))</span><br><span class="line">        .filter(str -&gt; str.length() == <span class="number">3</span>)</span><br><span class="line">        .forEach(str -&gt; System.out.print(str + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张无忌 张三丰 张翠山</span><br></pre></td></tr></table></figure>

<p>我们发现使用<code>Stream</code>流的代码比遍历集合简单很多，因为使用集合直接遍历真正核心的代码就那么一两句，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">        list1.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码中核心的就是<code>string.startsWith(&quot;张&quot;)</code>，而其他的代码是为了达到这个目的不得不写的代码。这就是集合相较于<code>Stream</code>流的局限性所在，观察<code>Stream</code>流的写法，根本没有什么遍历集合的代码，直接就是你想要干的事情。</p>
<h3 id="获取Stream流的方法"><a href="#获取Stream流的方法" class="headerlink" title="获取Stream流的方法"></a>获取Stream流的方法</h3><p>获取<code>Stream</code>流有两种方法</p>
<ul>
<li><code>Collection</code>中新加的<code>stream()</code>方法，该方法可以得到一个<code>Stream</code>流，对于<code>Map</code>集合，可以通过<code>keySet(),values(),entrySet()</code>等方法得到<code>Set</code>集合，然后通过<code>Set</code>对象调用<code>stream()</code>方法得到<code>Stream</code>流</li>
<li><code>Stream</code>流的静态方法<code>of()</code>，该方法接收一个可变参数，所以可以传入一个数组</li>
</ul>
<p>下面做一个演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"哪吒"</span>);</span><br><span class="line">        list.add(<span class="string">"杨戬"</span>);</span><br><span class="line">        Stream stream1 = list.stream();</span><br><span class="line">        stream1.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="string">"女"</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="string">"女"</span>);</span><br><span class="line">        map.put(<span class="string">"哪吒"</span>,<span class="string">"男"</span>);</span><br><span class="line">        map.put(<span class="string">"杨戬"</span>,<span class="string">"男"</span>);</span><br><span class="line">        Set&lt;String&gt; key = map.keySet();</span><br><span class="line">        Stream stream2 = key.stream();</span><br><span class="line">        stream2.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; vals = map.values();</span><br><span class="line">        Stream stream3 = vals.stream();</span><br><span class="line">        stream3.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream stream4 = entries.stream();</span><br><span class="line">        stream4.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        String[] strings = &#123;<span class="string">"迪丽热巴"</span>, <span class="string">"古力娜扎"</span>, <span class="string">"哪吒"</span>, <span class="string">"杨戬"</span>&#125;;</span><br><span class="line">        Stream stream5 = Stream.of(strings);</span><br><span class="line">        stream5.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        stream6.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream中的常见方法"><a href="#Stream中的常见方法" class="headerlink" title="Stream中的常见方法"></a>Stream中的常见方法</h3><p><code>Stream</code>流中的方法分为两类，一类叫做延迟方法，该方法返回的还是一个<code>Stream</code>流对象，所以可以进行链式编程，如<code>filter()</code>；另一类叫做终结方法，该方法不返回<code>Stream</code>流对象，如<code>forEach()</code>， <code>count()</code>(终结方法只有这两个，其他的都是延迟方法)。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>该方法需要传入的是一个<code>Predicate\&lt;T&gt;</code>接口，这个接口我们在常用函数式接口讲过，它是对某中数据进行测试，而<code>filter</code>的作用就是如果<code>test(T t)</code>返回的是<code>true</code>，那么就将这个数据加入到新的流中，遍历完流中所有的元素后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当字符串以迪开头时返回true，加入到新的流中，这个流会被返回</span></span><br><span class="line">Stream&lt;String&gt; stream1 = stream.filter(s -&gt; s.startsWith(<span class="string">"迪"</span>));</span><br><span class="line"><span class="comment">//forEach是后面要介绍的方法，这里只需要理解为遍历流并打印</span></span><br><span class="line">stream1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迪丽热巴</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>该方法传入的是一个<code>Function&lt;T,R&gt;</code>接口，所以它的作用是将一个类型的转转化为另一个类型的流。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个流，这个流是字符串的长度</span></span><br><span class="line">Stream&lt;Integer&gt; stream1 = stream.map(s -&gt; s.length());</span><br><span class="line">stream1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>这时结果报错了</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java43.png"/>
</center>

<p>这是因为这个<code>stream</code>在调用上面的<code>filter()</code>的时候已经使用过了，而流使用了一次就会关闭，不能在使用，这就是为什么会报错的原因，所以我们把代码改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个流，这个流是字符串的长度</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(strings).map(s -&gt; s.length());</span><br><span class="line">stream2.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>这时输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>该方法传入的是一个<code>Consumer\&lt;T&gt;</code>接口，是一个终结方法，该方法会遍历流中的元素，然后使用<code>Consumer</code>接口中的<code>accept()</code>方法对元素进行处理，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>会逐个打印出流中的元素。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit</code>方法需要传入一个<code>long</code>类型的数值<code>maxSize</code>，该方法会截取流中的前<code>maxSize</code>个元素放到新流中并返回，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是链式编程</span></span><br><span class="line">Stream.of(strings).limit(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迪丽热巴</span><br><span class="line">古力娜扎</span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>该方法接收一个<code>long</code>类型的数据<code>n</code>，它会跳过流中的前<code>n</code>个元素，将剩下的元素放入到一个新流中并返回，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(strings).skip(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">哪吒</span><br><span class="line">杨戬</span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>该方法不需要传入参数，返回一个<code>long</code>类型的整数，该整数是流中元素的个数，这个方法是一个终结方法，不返回<code>Stream</code>流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> num = Stream.of(strings).count();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>我们之前在<code>Stream</code>流使用<code>forEach()</code>去打印流中的元素，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>但是打印这个方法<code>(System.out.println())</code>是已经存在了的，我们可不可以直接传入这个方法，在这里或者说是引用这个方法，答案是可以的，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在这里我们引用了<code>System.out</code>对象的<code>println</code>方法，这行语句的作用是上面的语句作用是完全相同的，这就是方法的引用，<code>::</code>就是方法引用的运算符，这是新增的运算符。</p>
<p>那方法引用也要遵循一定的原则，比如你引用的对象必须是存在的，你引用的方法需要传入的参数的个数和类型必须是对的上的，否则就会抛出异常，由于方法的性质不同，所以有很多类型的引用，比如</p>
<ul>
<li>对象引用成员方法</li>
<li>类引用静态方法</li>
<li><code>super</code>引用父类方法</li>
<li><code>this</code>引用成员方法</li>
<li>引用构造方法</li>
<li>引用数组构造方法</li>
</ul>
<p>下面会详细的展开讲解。</p>
<h3 id="对象引用成员方法"><a href="#对象引用成员方法" class="headerlink" title="对象引用成员方法"></a>对象引用成员方法</h3><p>其实</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>就是对象引用成员方法，我们引用了<code>System.out</code>对象的成员方法<code>println</code>。</p>
<h3 id="类引用静态方法"><a href="#类引用静态方法" class="headerlink" title="类引用静态方法"></a>类引用静态方法</h3><p>假设有一个接口<code>Calculate</code>，里面只有一个抽象方法<code>cal(int i)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这是一个函数式接口，现在在有一个方法需要调用这个接口去得到一个数字的绝对值，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAbs</span><span class="params">(<span class="keyword">int</span> i, Calculate calculate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate.cal(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>Math</code>类的静态方法<code>abs()</code>可以做到这件事情，所以我们可以直接引用这个方法，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = getAbs(-<span class="number">10</span>,Math::abs);</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="super引用父类成员方法"><a href="#super引用父类成员方法" class="headerlink" title="super引用父类成员方法"></a>super引用父类成员方法</h3><p>假设有一个<code>Greet</code>接口，里面只有一个抽象方法<code>greet()</code>，所以这是一个函数接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有一个父类<code>Person</code>，里面有一个<code>greet()</code>方法，这个方法在后面是要被子类引用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有一个子类<code>Student</code>继承了<code>Person</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Greet gre)</span> </span>&#123;</span><br><span class="line">        gre.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="keyword">super</span>::greet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code>中的<code>sayHello()</code>方法需要一个<code>Greet</code>接口，然后我们又在<code>greet()</code>方法中调用了这个方法，并且传入一个<code>super::greet</code>的方法引用(当然这样的代码没有什么意义，只是为了演示)，我们在main中创建一个对象，并调用此方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"小明"</span>);</span><br><span class="line">student.greet();</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 小明</span></span><br></pre></td></tr></table></figure>

<h3 id="this引用成员方法"><a href="#this引用成员方法" class="headerlink" title="this引用成员方法"></a>this引用成员方法</h3><p>还是以上面的<code>Student</code>类为例，假设<code>Student</code>类中有一个成员方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tempt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我今晚有空哦"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>greet()</code>方法中再增加一个<code>sayHello()</code>，这时方法的引用指向的是<code>tempt</code>方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sayHello(<span class="keyword">super</span>::greet);</span><br><span class="line">    sayHello(<span class="keyword">this</span>::tempt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在<code>main</code>方法中运行一下，输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 小明</span></span><br><span class="line"><span class="string">我今晚有空哦</span></span><br></pre></td></tr></table></figure>

<h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>现在假设有这么一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Personable</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">getPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面只有一个抽象方法<code>getPerson</code>，所以这是一个函数式接口，该方法根据<code>name</code>返回一个<code>Person</code>对象，现在有一个方法需要传入这个接口得到一个<code>Person</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">(String name, Personable personable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> personable.getPerson(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在<code>main</code>方法中调用该方法，传入的接口我们使用构造器引用<code>Person::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = getPerson(<span class="string">"迪丽热巴"</span>,Person::<span class="keyword">new</span>);</span><br><span class="line">person.greet();</span><br></pre></td></tr></table></figure>

<p>运行输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 迪丽热巴</span></span><br></pre></td></tr></table></figure>

<h3 id="引用数组构造方法"><a href="#引用数组构造方法" class="headerlink" title="引用数组构造方法"></a>引用数组构造方法</h3><p>引用数组构造方法的格式是<code>int[]::new</code>(这里只以<code>int</code>为例，当然也可以<code>double[]::new</code>)，具体的使用方法同上面的<code>Person</code>类的构造方法引用一致，这里就不多加介绍了。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/Java/">Java</a></li><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/JDK-8/">JDK 8</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="https://lastknightcoder.gitee.io/img/wechatpay.png" title="微信"><img src="https://lastknightcoder.gitee.io/img/alipay.png" title="支付宝"></div></section><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></main><footer class="foot"><div class="foot-copy">&copy; 2019 - 2020 熊滔</div></footer>
<script src="https://lastknightcoder.gitee.io/js/scroller.js"></script>

<script src="https://lastknightcoder.gitee.io/js/main.js"></script>
</body></html>