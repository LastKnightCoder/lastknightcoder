<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Java8新特性 | Coder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Java,JDK 8">
    <meta name="description" content="Java8中的新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8新特性">
<meta property="og:url" content="https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">
<meta property="og:site_name" content="Coder">
<meta property="og:description" content="Java8中的新特性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java43.png">
<meta property="article:published_time" content="2019-07-13T16:00:00.000Z">
<meta property="article:modified_time" content="2019-07-13T16:00:00.000Z">
<meta property="article:author" content="熊滔">
<meta property="article:tag" content="Java8 Stream流 函数式接口 方法引用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java43.png">
    
        <link rel="alternate" type="application/atom+xml" title="Coder" href="https://lastknightcoder.gitee.io/atom.xml">
    
    <link rel="shortcut icon" href="https://lastknightcoder.gitee.io/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://lastknightcoder.gitee.io/img/brand.jpg)">
      <div class="brand">
        <a href="https://lastknightcoder.gitee.io/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://lastknightcoder.gitee.io/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">熊滔</h5>
          <a href="mailto:2223106858@qq.com" title="2223106858@qq.com" class="mail">2223106858@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/LastKnightCoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java8新特性</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Java8新特性</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-13T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2019-07-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常用函数式接口"><span class="post-toc-number">1.</span> <span class="post-toc-text">常用函数式接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Supplier-lt-T-gt"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Supplier&lt;T&gt;</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Consumer-lt-T-gt"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Consumer&lt;T&gt;</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Predicate-lt-T-gt"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Predicate&lt;T&gt;</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Function-lt-T-R-gt"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">Function&lt;T,R&gt;</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stream流"><span class="post-toc-number">2.</span> <span class="post-toc-text">Stream流</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#问题引出"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">问题引出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#获取Stream流的方法"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">获取Stream流的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Stream中的常见方法"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Stream中的常见方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#filter"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">filter()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#map"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">map()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#forEach"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">forEach</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#limit"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">limit</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#skip"><span class="post-toc-number">2.3.5.</span> <span class="post-toc-text">skip</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#count"><span class="post-toc-number">2.3.6.</span> <span class="post-toc-text">count</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法引用"><span class="post-toc-number">3.</span> <span class="post-toc-text">方法引用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象引用成员方法"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">对象引用成员方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类引用静态方法"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">类引用静态方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#super引用父类成员方法"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">super引用父类成员方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#this引用成员方法"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">this引用成员方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#引用构造方法"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">引用构造方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#引用数组构造方法"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">引用数组构造方法</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Java8新特性"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Java8新特性</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-14 00:00:00" datetime="2019-07-13T16:00:00.000Z"  itemprop="datePublished">2019-07-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>本篇文章会介绍<code>Java 8</code>中的一些新特性(不包括<code>Lambda</code>表达式，因为在<a href="https://lastknightcoder.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">Java多线程</a>这篇文章中介绍过了)。主要内容是<code>Java 8</code>中新增的函数式接口以及<code>Stream</code>流，还有方法引用。</p>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><p>函数式接口指的就是接口里面只含有一个抽象方法。这样我们就可以使用<code>Lambda</code>表达式编程，这是一种函数式编程的思想，强调的是怎么做。<code>Java 8</code>提供了很多的函数式接口，这里我们介绍常见的函数式接口。</p>
<ul>
<li><code>Supplier\&lt;T&gt;</code></li>
<li><code>Consumer\&lt;T&gt;</code></li>
<li><code>Predicate\&lt;T&gt;</code></li>
<li><code>Functional\&lt;T,R&gt;</code></li>
</ul>
<h3 id="Supplier-lt-T-gt"><a href="#Supplier-lt-T-gt" class="headerlink" title="Supplier&lt;T&gt;"></a>Supplier&lt;T&gt;</h3><p>该接口里面有一个<code>T get()</code>方法，按照字面意思，是提供者的意思，表示生产出一个与泛型类型<code>T</code>相同的数据。下面我们来讲一个例子说明此接口的使用。假设有一个方法，需要返回一个字符串，该字符串由<code>Supplier</code>接口的<code>get()</code>方法产生，而产生什么样的字符串，则由程序员在调用该方法是传入<code>Lambda</code>决定。如下方法传入一个<code>Supplier</code>接口得到一个字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = getString(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h3 id="Consumer-lt-T-gt"><a href="#Consumer-lt-T-gt" class="headerlink" title="Consumer&lt;T&gt;"></a>Consumer&lt;T&gt;</h3><p>与<code>Supplier</code>接口不同的是，<code>Consumer</code>接口是消费或者说处理一个与泛型类型相同数据类型的数据，它有一个<code>accept(T t)</code>方法，该方法用来消费数据，假设有下面这一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleString</span><span class="params">(String str, Consumer&lt;String&gt; consumer)</span> </span>&#123;</span><br><span class="line">    consumer.accept(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>Consumer</code>来消费(处理)传入的这个字符串，而怎么消费，就取决与程序员在调用该方法时传入的<code>Lambda</code>，这时对程序员来说，就是怎么做的问题，相当于传入一个方法去处理数据，这就是函数式编程，这里我们就简单的将传入的数据进行打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleString(<span class="string">"Hello Again!"</span>, (String str) -&gt; &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello Again!</span><br></pre></td></tr></table></figure>

<p><code>Consumer</code>接口中有一个默认方法<code>andThen(Consumer consumer)</code>，看下面的程序说明它的用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con1.andThen(con2).accept(str); <span class="comment">//con1和con2都是Consumer接口的实现类对象</span></span><br><span class="line"><span class="comment">//相当于下面的代码</span></span><br><span class="line">con1.accept(str);</span><br><span class="line">con2.accept(str);</span><br></pre></td></tr></table></figure>

<p>假设有一个方法有需要传入两个<code>Consumer</code>接口对数据进行消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleInterger</span><span class="params">(Integer i, Consumer&lt;Integer&gt; con1, Consumer&lt;Integer&gt; con2)</span> </span>&#123;</span><br><span class="line">    con1.andThen(con2).accept(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>mian</code>方法中使用，<code>con1</code>对数字进行<code>+10</code>然后打印，<code>con2</code>对数字进行<code>*10</code>然后打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleInteger(<span class="number">10</span>, (i) -&gt; &#123;</span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;, (i) -&gt; &#123;</span><br><span class="line">    i = i * <span class="number">10</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="Predicate-lt-T-gt"><a href="#Predicate-lt-T-gt" class="headerlink" title="Predicate&lt;T&gt;"></a>Predicate&lt;T&gt;</h3><p><code>Predicate</code>接口中有一个<code>test(T t)</code>，它的作用是对某种数据类型进行判断，它返回一个<code>boolean</code>值。假设有一个集合，我们对其中的元素进行判断，符合条件放入一个新的集合，看下面的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">(HashMap&lt;String,Integer&gt; map, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个集合用以放符合条件的元素</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; resmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历集合</span></span><br><span class="line">    Set&lt;String&gt; key = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String str : key) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(str);</span><br><span class="line">        <span class="comment">//对值进行判断</span></span><br><span class="line">        <span class="keyword">boolean</span> res = predicate.test(val);</span><br><span class="line">        <span class="comment">//如果值符合条件，就加入新的集合</span></span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            resmap.put(str,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在<code>main</code>方法中进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">map.put(<span class="string">"奥特曼"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//筛选出年龄小于等于20岁的</span></span><br><span class="line">HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resmap);</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;佟丽娅=<span class="number">20</span>, 迪丽热巴=<span class="number">18</span>, 古力娜扎=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>Predicate</code>还有三个默认方法</p>
<ul>
<li><code>and(Predicate\&lt;T&gt; pre)</code><ul>
<li>与</li>
</ul>
</li>
<li><code>or(Predicate\&lt;T&gt; pre)</code><ul>
<li>或</li>
</ul>
</li>
<li><code>negate()</code><ul>
<li>非</li>
</ul>
</li>
</ul>
<p>假设对于上面的那个方法，我提出一个新的需求，要求不仅年龄要小超过<code>20</code>岁，而且年龄要大于<code>18</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">(HashMap&lt;String,Integer&gt; map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; resmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; key = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String str : key) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(str);</span><br><span class="line">        <span class="keyword">boolean</span> res = predicate1.and(predicate2).test(val);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            resmap.put(str,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;, (Integer i) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resmap);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;佟丽娅=<span class="number">20</span>, 古力娜扎=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>至于<code>or()</code>和<code>negate()</code>的使用方法同上。</p>
<h3 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T,R&gt;"></a>Function&lt;T,R&gt;</h3><p>该接口的作用是将<code>T</code>这种数据类型转化为<code>R</code>这种数据类型，它里面有一个<code>R apply(T t)</code>方法。下面这个方法将一个字符串转化为一个整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">StrToInt</span><span class="params">(String str, Function&lt;String, Integer&gt; fun)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main()</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = StrToInt(<span class="string">"123"</span>, (String str) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将字符串转化为数字</span></span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//打印该数字</span></span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code>接口中还有一个默认方法<code>andThen(Function&lt;T,R&gt; fun)</code>，这个方法与在上面介绍的<code>Consumer</code>接口的<code>andThen()</code>很像，但是有点不同，<code>Consumer</code>接口的<code>andThen</code>是两个对象消费同一个数据，而<code>Function</code>接口的<code>addThen()</code>是将第一个<code>fun</code>处理后的结果拿给第二个<code>fun</code>去处理，相当于<code>apply(apply())</code>。比如现在我有一个需求，将一个字符串转化为数字，然后将这个数字，<code>+10</code>然后再转化为字符串，这个方法可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">StrPlus</span><span class="params">(String str, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;String,Integer&gt; fun1, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;Integer,String&gt; fun2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun1.andThen(fun2).apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main</code>方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s =  StrPlus(<span class="string">"123"</span>, (String str) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将字符串转化为数字并加10</span></span><br><span class="line">    Integer i = Integer.parseInt(str);</span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, (Integer i) -&gt; &#123;</span><br><span class="line">    <span class="comment">//将数字转化为字符串</span></span><br><span class="line">   <span class="keyword">return</span> i + <span class="string">""</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">133</span></span><br></pre></td></tr></table></figure>

<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><code>Stream</code>流是<code>Java 8</code>引入的新特性，首先它跟<code>I/O</code>流没有任何的关系，它主要是用来处理集合、数组问题的。要看<code>Stream</code>流有什么用处，还是要看集合处理有什么缺点。</p>
<h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>有下面这么一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"赵敏"</span>, <span class="string">"张翠山"</span>, <span class="string">"小昭"</span>, <span class="string">"张良"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们有如下要求</p>
<ul>
<li>筛选出以”张”字开头的字符串，放入一个<code>Arraylist</code>集合中</li>
<li>在<code>ArrayList</code>集合中筛选出字符串长度为<code>3</code>的字符串，放入一个新的集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">        list1.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list1);</span><br><span class="line">ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String string : list1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        list2.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张无忌, 张三丰, 张翠山, 张良]</span><br><span class="line">[张无忌, 张三丰, 张翠山]</span><br></pre></td></tr></table></figure>

<p>现在我们使<code>Stream</code>流的方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line">stream.filter(str -&gt; str.startsWith(<span class="string">"张"</span>))</span><br><span class="line">        .filter(str -&gt; str.length() == <span class="number">3</span>)</span><br><span class="line">        .forEach(str -&gt; System.out.print(str + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张无忌 张三丰 张翠山</span><br></pre></td></tr></table></figure>

<p>我们发现使用<code>Stream</code>流的代码比遍历集合简单很多，因为使用集合直接遍历真正核心的代码就那么一两句，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">        list1.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码中核心的就是<code>string.startsWith(&quot;张&quot;)</code>，而其他的代码是为了达到这个目的不得不写的代码。这就是集合相较于<code>Stream</code>流的局限性所在，观察<code>Stream</code>流的写法，根本没有什么遍历集合的代码，直接就是你想要干的事情。</p>
<h3 id="获取Stream流的方法"><a href="#获取Stream流的方法" class="headerlink" title="获取Stream流的方法"></a>获取Stream流的方法</h3><p>获取<code>Stream</code>流有两种方法</p>
<ul>
<li><code>Collection</code>中新加的<code>stream()</code>方法，该方法可以得到一个<code>Stream</code>流，对于<code>Map</code>集合，可以通过<code>keySet(),values(),entrySet()</code>等方法得到<code>Set</code>集合，然后通过<code>Set</code>对象调用<code>stream()</code>方法得到<code>Stream</code>流</li>
<li><code>Stream</code>流的静态方法<code>of()</code>，该方法接收一个可变参数，所以可以传入一个数组</li>
</ul>
<p>下面做一个演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"哪吒"</span>);</span><br><span class="line">        list.add(<span class="string">"杨戬"</span>);</span><br><span class="line">        Stream stream1 = list.stream();</span><br><span class="line">        stream1.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="string">"女"</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="string">"女"</span>);</span><br><span class="line">        map.put(<span class="string">"哪吒"</span>,<span class="string">"男"</span>);</span><br><span class="line">        map.put(<span class="string">"杨戬"</span>,<span class="string">"男"</span>);</span><br><span class="line">        Set&lt;String&gt; key = map.keySet();</span><br><span class="line">        Stream stream2 = key.stream();</span><br><span class="line">        stream2.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; vals = map.values();</span><br><span class="line">        Stream stream3 = vals.stream();</span><br><span class="line">        stream3.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream stream4 = entries.stream();</span><br><span class="line">        stream4.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        String[] strings = &#123;<span class="string">"迪丽热巴"</span>, <span class="string">"古力娜扎"</span>, <span class="string">"哪吒"</span>, <span class="string">"杨戬"</span>&#125;;</span><br><span class="line">        Stream stream5 = Stream.of(strings);</span><br><span class="line">        stream5.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        stream6.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream中的常见方法"><a href="#Stream中的常见方法" class="headerlink" title="Stream中的常见方法"></a>Stream中的常见方法</h3><p><code>Stream</code>流中的方法分为两类，一类叫做延迟方法，该方法返回的还是一个<code>Stream</code>流对象，所以可以进行链式编程，如<code>filter()</code>；另一类叫做终结方法，该方法不返回<code>Stream</code>流对象，如<code>forEach()</code>， <code>count()</code>(终结方法只有这两个，其他的都是延迟方法)。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>该方法需要传入的是一个<code>Predicate\&lt;T&gt;</code>接口，这个接口我们在常用函数式接口讲过，它是对某中数据进行测试，而<code>filter</code>的作用就是如果<code>test(T t)</code>返回的是<code>true</code>，那么就将这个数据加入到新的流中，遍历完流中所有的元素后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当字符串以迪开头时返回true，加入到新的流中，这个流会被返回</span></span><br><span class="line">Stream&lt;String&gt; stream1 = stream.filter(s -&gt; s.startsWith(<span class="string">"迪"</span>));</span><br><span class="line"><span class="comment">//forEach是后面要介绍的方法，这里只需要理解为遍历流并打印</span></span><br><span class="line">stream1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迪丽热巴</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>该方法传入的是一个<code>Function&lt;T,R&gt;</code>接口，所以它的作用是将一个类型的转转化为另一个类型的流。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个流，这个流是字符串的长度</span></span><br><span class="line">Stream&lt;Integer&gt; stream1 = stream.map(s -&gt; s.length());</span><br><span class="line">stream1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>这时结果报错了</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java43.png"/>
</center>

<p>这是因为这个<code>stream</code>在调用上面的<code>filter()</code>的时候已经使用过了，而流使用了一次就会关闭，不能在使用，这就是为什么会报错的原因，所以我们把代码改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个流，这个流是字符串的长度</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(strings).map(s -&gt; s.length());</span><br><span class="line">stream2.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>这时输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>该方法传入的是一个<code>Consumer\&lt;T&gt;</code>接口，是一个终结方法，该方法会遍历流中的元素，然后使用<code>Consumer</code>接口中的<code>accept()</code>方法对元素进行处理，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>会逐个打印出流中的元素。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit</code>方法需要传入一个<code>long</code>类型的数值<code>maxSize</code>，该方法会截取流中的前<code>maxSize</code>个元素放到新流中并返回，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是链式编程</span></span><br><span class="line">Stream.of(strings).limit(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迪丽热巴</span><br><span class="line">古力娜扎</span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>该方法接收一个<code>long</code>类型的数据<code>n</code>，它会跳过流中的前<code>n</code>个元素，将剩下的元素放入到一个新流中并返回，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(strings).skip(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">哪吒</span><br><span class="line">杨戬</span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>该方法不需要传入参数，返回一个<code>long</code>类型的整数，该整数是流中元素的个数，这个方法是一个终结方法，不返回<code>Stream</code>流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> num = Stream.of(strings).count();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>我们之前在<code>Stream</code>流使用<code>forEach()</code>去打印流中的元素，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>但是打印这个方法<code>(System.out.println())</code>是已经存在了的，我们可不可以直接传入这个方法，在这里或者说是引用这个方法，答案是可以的，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在这里我们引用了<code>System.out</code>对象的<code>println</code>方法，这行语句的作用是上面的语句作用是完全相同的，这就是方法的引用，<code>::</code>就是方法引用的运算符，这是新增的运算符。</p>
<p>那方法引用也要遵循一定的原则，比如你引用的对象必须是存在的，你引用的方法需要传入的参数的个数和类型必须是对的上的，否则就会抛出异常，由于方法的性质不同，所以有很多类型的引用，比如</p>
<ul>
<li>对象引用成员方法</li>
<li>类引用静态方法</li>
<li><code>super</code>引用父类方法</li>
<li><code>this</code>引用成员方法</li>
<li>引用构造方法</li>
<li>引用数组构造方法</li>
</ul>
<p>下面会详细的展开讲解。</p>
<h3 id="对象引用成员方法"><a href="#对象引用成员方法" class="headerlink" title="对象引用成员方法"></a>对象引用成员方法</h3><p>其实</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>就是对象引用成员方法，我们引用了<code>System.out</code>对象的成员方法<code>println</code>。</p>
<h3 id="类引用静态方法"><a href="#类引用静态方法" class="headerlink" title="类引用静态方法"></a>类引用静态方法</h3><p>假设有一个接口<code>Calculate</code>，里面只有一个抽象方法<code>cal(int i)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这是一个函数式接口，现在在有一个方法需要调用这个接口去得到一个数字的绝对值，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAbs</span><span class="params">(<span class="keyword">int</span> i, Calculate calculate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate.cal(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>Math</code>类的静态方法<code>abs()</code>可以做到这件事情，所以我们可以直接引用这个方法，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = getAbs(-<span class="number">10</span>,Math::abs);</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="super引用父类成员方法"><a href="#super引用父类成员方法" class="headerlink" title="super引用父类成员方法"></a>super引用父类成员方法</h3><p>假设有一个<code>Greet</code>接口，里面只有一个抽象方法<code>greet()</code>，所以这是一个函数接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有一个父类<code>Person</code>，里面有一个<code>greet()</code>方法，这个方法在后面是要被子类引用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有一个子类<code>Student</code>继承了<code>Person</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Greet gre)</span> </span>&#123;</span><br><span class="line">        gre.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="keyword">super</span>::greet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code>中的<code>sayHello()</code>方法需要一个<code>Greet</code>接口，然后我们又在<code>greet()</code>方法中调用了这个方法，并且传入一个<code>super::greet</code>的方法引用(当然这样的代码没有什么意义，只是为了演示)，我们在main中创建一个对象，并调用此方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"小明"</span>);</span><br><span class="line">student.greet();</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 小明</span></span><br></pre></td></tr></table></figure>

<h3 id="this引用成员方法"><a href="#this引用成员方法" class="headerlink" title="this引用成员方法"></a>this引用成员方法</h3><p>还是以上面的<code>Student</code>类为例，假设<code>Student</code>类中有一个成员方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tempt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我今晚有空哦"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>greet()</code>方法中再增加一个<code>sayHello()</code>，这时方法的引用指向的是<code>tempt</code>方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sayHello(<span class="keyword">super</span>::greet);</span><br><span class="line">    sayHello(<span class="keyword">this</span>::tempt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在<code>main</code>方法中运行一下，输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 小明</span></span><br><span class="line"><span class="string">我今晚有空哦</span></span><br></pre></td></tr></table></figure>

<h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>现在假设有这么一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Personable</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">getPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面只有一个抽象方法<code>getPerson</code>，所以这是一个函数式接口，该方法根据<code>name</code>返回一个<code>Person</code>对象，现在有一个方法需要传入这个接口得到一个<code>Person</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">(String name, Personable personable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> personable.getPerson(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在<code>main</code>方法中调用该方法，传入的接口我们使用构造器引用<code>Person::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = getPerson(<span class="string">"迪丽热巴"</span>,Person::<span class="keyword">new</span>);</span><br><span class="line">person.greet();</span><br></pre></td></tr></table></figure>

<p>运行输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m 迪丽热巴</span></span><br></pre></td></tr></table></figure>

<h3 id="引用数组构造方法"><a href="#引用数组构造方法" class="headerlink" title="引用数组构造方法"></a>引用数组构造方法</h3><p>引用数组构造方法的格式是<code>int[]::new</code>(这里只以<code>int</code>为例，当然也可以<code>double[]::new</code>)，具体的使用方法同上面的<code>Person</code>类的构造方法引用一致，这里就不多加介绍了。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-07-13T16:00:00.000Z" itemprop="dateUpdated">2019-07-14 00:00:00</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://lastknightcoder.gitee.io">
            <img src="https://lastknightcoder.gitee.io/img/avatar.jpg" alt="熊滔">
            熊滔
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/JDK-8/" rel="tag">JDK 8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/&title=《Java8新特性》 — Coder&pic=https://lastknightcoder.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/&title=《Java8新特性》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java8新特性》 — Coder&url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/&via=https://lastknightcoder.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="https://lastknightcoder.gitee.io/Java%E5%8F%8D%E5%B0%84/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java反射</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="https://lastknightcoder.gitee.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java多线程</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://lastknightcoder.gitee.io/img/wechatpay.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://lastknightcoder.gitee.io/img/wechatpay.png" data-alipay="https://lastknightcoder.gitee.io/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="https://lastknightcoder.gitee.io/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>熊滔 &copy; 2019 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/&title=《Java8新特性》 — Coder&pic=https://lastknightcoder.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/&title=《Java8新特性》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java8新特性》 — Coder&url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/&via=https://lastknightcoder.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.gitee.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvUlEQVR42u3a0WrrMBAE0P7/T7dwnwrBvjO7VtPC8ZNJUlvHBWk9q4+P+Pj8d7yef//k9bi6QvJXr+evV3jswMPDwxsNPblZgmwfVjKee/D9Y8XDw8M7x0sWg3t2u3i0D+7+N5ef4+Hh4b2Vl1xuM6EnCwYeHh7e3+XlocOsaMbDw8P7/bw8VJ1Fq8ny8OasBQ8PD29StdYNsHed/1B/Dw8PD6/squcT9/2k3H57X6wXo8XDw8M7wNtEA7PYImdsAo4Hkg88PDy8Ea+duNtrtiX7MHTGw8PDO8Cblbl51NveflZkF+EyHh4e3oLXtrhmU3ZbCuf3/c/Cg4eHh/cmXttXWq1IwcaCvHDHw8PDO83LQ9g88N1sisrj4Mtv8fDw8A7w2mJ6NtBNwDE78PDw8M7x6g1McaiaN8na7QVFCIKHh4d3gFe82MfldT7cNiBeBcd4eHh4j/L2E3Eb6SYF9AZ/+caAh4eHd4CX3+DZweWf1M0wPDw8vEd5eXHcbn7Ki+nkavmiFcW4eHh4eAte/sd5SJFvBWiL8nZ7AR4eHt4J3myCbqfyfWzR/sfw8PDwzvHy6TufuNtQON+eNdxThoeHh3eANxtuPom35fKskXb5Gzw8PLwDvE17fvZQ2i1cm6gXDw8P7wRv9vLfDn0T++ZXw8PDwzvNy6fmdiiz8zwWKRpgeHh4eMd4m9I5jyfaQjnB1HkwHh4e3oI3m45ncW073ecPq2iV4eHh4a15n+WRBAp5XNtO/XljLHpjwMPDwxvxHtilFW+WyrcRtA8CDw8P7+d5mxvnzf62fG+batGeMjw8PLxHeasMY72loG2PPRzd4uHh4R3j5TdOAtx2QWpHiIeHh/d7eHnYmse+bXOreBx4eHh4x3htGDGLdJMFZhZSXF4BDw8P7wDv2QbYU22zpHxvHzoeHh7emvcFuYwNATDQmQIAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://lastknightcoder.gitee.io/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
