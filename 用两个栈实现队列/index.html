<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="熊滔"><meta name="description" content="人生天地间，忽如远行客"><link rel="alternative" href="/atom.xml" title="Coder" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>用两个栈实现队列 - Coder</title>
<link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/main.css">

<link rel="stylesheet" href="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="https://lastknightcoder.gitee.io/js/jquery-3.1.1.min.js"></script>

<script src="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="https://lastknightcoder.gitee.io/">Coder</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-06-23T16:00:00.000Z">2020-06-24 00:00:00</time><h1 class="post__title"><a href="https://lastknightcoder.gitee.io/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">用两个栈实现队列</a></h1><div class="post__main echo"><blockquote>
<p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>栈的特点是后进先出，队列的特点是先进先出，如何使用两个栈来实现队列的效果呢? 假设当添加数据时，我们把数据添加到第一个栈中，我们称之为 <code>stack1</code>，例如连续添加 <code>1, 2, 3, 4</code> 四个数据，如下</p>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200604102923.png" width="60%"/>

<p>我们添加数据时向 <code>stack1</code> 添加数据，而取出数据时从 <code>stack2</code> 取出数据，我们再次把 <code>stack1</code> 中的数据依次放入 <code>stack2</code> 中，经过两次入栈的操作，两个后进先出变成了先进先出</p>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200604103625.png" width="90%"/>

<p>现在我们入队和出队的规则应该如下，即入队时将数据压入 <code>stack1</code> 中，出队时从 <code>stack2</code> 中弹出，现在的问题是什么时候将 <code>stack1</code> 中的数据弹出压入到 <code>stack2</code> 中，其实很简单，出队时将 <code>stack2</code> 中的数据弹出，直到 <code>stack2</code> 为空，这时将 <code>stack1</code> 中的数据弹出压入到 <code>stack2</code> 中，然后从 <code>stack2</code> 弹出数据。下面演示一个完整的例子</p>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200604110658.png" width="80%"/>

<p>完整的代码示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加数据从 stack1 添加</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stack2 不为空时 从stack2 弹出数据</span></span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// stack2 为空时 且stack1 不为空时，将stack1的数据弹出压入到stack2中</span></span><br><span class="line">            <span class="keyword">if</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                    stack2.push(stack1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 然后从 stack2 弹出数据</span></span><br><span class="line">                <span class="keyword">return</span> stack2.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// stack1 和 stack2 都为空，说明队列为空 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is Empty"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：那如何使用两个队列实现一个栈呢?</p>
</blockquote>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/%E5%89%91%E6%8C%87offer/">剑指offer</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="https://lastknightcoder.gitee.io/img/wechatpay.png" title="微信"><img src="https://lastknightcoder.gitee.io/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2019 - 2020 熊滔</div></footer>
<script src="https://lastknightcoder.gitee.io/js/scroller.js"></script>

<script src="https://lastknightcoder.gitee.io/js/main.js"></script>
</body></html>