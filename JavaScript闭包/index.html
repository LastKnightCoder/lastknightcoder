<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="熊滔"><meta name="description" content="人生天地间，忽如远行客"><link rel="alternative" href="/atom.xml" title="Coder" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>JavaScript闭包 - Coder</title>
<link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/main.css">

<link rel="stylesheet" href="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="https://lastknightcoder.gitee.io/js/jquery-3.1.1.min.js"></script>

<script src="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="https://lastknightcoder.gitee.io/">Coder</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-04-17T16:00:00.000Z">2020-04-18 00:00:00</time><h1 class="post__title"><a href="https://lastknightcoder.gitee.io/JavaScript%E9%97%AD%E5%8C%85/">JavaScript闭包</a></h1><div class="post__main echo"><h2 id="JavaScript的作用域"><a href="#JavaScript的作用域" class="headerlink" title="JavaScript的作用域"></a>JavaScript的作用域</h2><p><code>JavaScript</code> 的作用域有两种</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
</ul>
<p>与其他语言不同的是，<code>JavaScript</code> 没有块级作用域，参考以下程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的变量 <code>x</code> 定义在 <code>if</code> 的语句块中，在其他的语言中，<code>x</code> 在语句块外是访问不到的，但是由于 <code>JavaScript</code> 没有块级作用域，所以变量 <code>x</code> 是全局变量，所以在语句块外也可以被访问到。</p>
<blockquote>
<p>注意：</p>
<p>上面的讨论是基于 <code>ES5</code> 的，在 <code>ES6</code> 中，通过关键字 <code>let</code> 或 <code>const</code> 声明的变量，可以实现块级作用域的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// not defined</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="JavaScript-作用域链"><a href="#JavaScript-作用域链" class="headerlink" title="JavaScript 作用域链"></a>JavaScript 作用域链</h2><p><code>JavaScript</code> 作用域链指的是查找变量的顺序，比如下面的程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们在 <code>bar()</code> 函数中访问了变量 <code>i</code>，这时 <code>bar()</code> 会先在 <code>bar()</code> 函数内部查找是否有变量 <code>i</code>，如果没有，则会去 <code>bar()</code> 函数的上一级作用域即 <code>foo()</code> 函数中寻找，如果还没有，则会去全局作用域寻找，如果没有找到，则会报错变量未定义，所以上述 <code>bar()</code> 函数的作用域链为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar --&gt; foo --&gt; 全局作用域</span><br></pre></td></tr></table></figure>

<p>编译器会根据作用域链去寻找变量，如果没有找到则会报错。</p>
<h2 id="闭包介绍"><a href="#闭包介绍" class="headerlink" title="闭包介绍"></a>闭包介绍</h2><p>什么是闭包，简单的说就是允许函数访问并操作函数外部的变量，只要该变量处于该函数的作用域链中，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = foo();</span><br><span class="line">func(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>函数 <code>foo()</code> 返回了一个函数，返回的这个函数中访问了变量 <code>x</code>，根据我们的讲解，会根据这个函数的作用域链去寻找这个变量 <code>x</code>，该匿名函数定义时的作用域链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回的匿名函数 --&gt; foo --&gt; 全局作用域</span><br></pre></td></tr></table></figure>

<p>所以当执行该匿名函数时，会根据上述的作用域链去寻找变量 <code>x</code>，会在 <code>foo</code> 中找到变量 <code>x</code>，所以输出的结果是 <code>1</code>。</p>
<p>你可能会有这样的疑惑，当执行完函数 <code>foo()</code> 后，变量 <code>x</code> 不是应该已经被销毁了吗，为什么还能够被访问。之所以会有这样的想法，可能是受其他编程语言的影响，如 <code>C</code>，<code>Java</code> 等，但是要明白 <code>JavaScript</code> 与这些编程语言不同，至少 <code>Java</code> 不能够返回函数，因为返回的函数还保存着对变量 <code>x</code> 的引用，所以变量 <code>x</code> 在执行完 <code>foo()</code> 之后是不会被清除的，这就是还能够访问 <code>x</code> 的原因。</p>
<p>那接下来看一个例子，看看你是否明白了闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序的效果是延时 <code>i * 100 ms</code> 打印输出 <code>i</code>，你可能希望得到下面这样的输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>但是真正的结果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>setTimeout</code> 是一个异步函数，当执行 <code>setTimeout</code> 时，并不会立即执行传入的回调函数，这些回调函数等到延迟时间到了以后，会将这些回调函数放入事件队列中，简单来说，当执行到 <code>setTimeout</code> 函数时，不会有任何的阻碍直接进入下一轮循环，等到循环执行完毕，编译器会取出事件队列中的函数执行(这些回调函数并不是执行到 <code>setTimeout</code> 方法时立即被添加到事件队列中的，而是等到设定的延迟时间后再添加到事件队列中的)，所以当执行这些回调函数时，循环已经执行完毕，变量 <code>i</code> 的值已经变为了 <code>10</code>，这些回调函数根据它的作用域链找到的变量 <code>i</code> 的值就全部是 <code>10</code> 了。</p>
<h2 id="闭包实现私有变量"><a href="#闭包实现私有变量" class="headerlink" title="闭包实现私有变量"></a>闭包实现私有变量</h2><p>在 <code>JavaScript</code> 中是没有关键字去声明私有变量的，但是我们可以通过闭包来实现这样的效果，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'ninja'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// 访问不到 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// ninja</span></span><br><span class="line">person.setName(<span class="string">'dummy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// dummy</span></span><br></pre></td></tr></table></figure>

<p>通过闭包，<code>setName</code> 和 <code>getName</code> 可以对 <code>name</code> 进行访问和操作，但是却不能够被实例变量 <code>person</code> 访问到，因为 <code>name</code> 并不是 <code>person</code> 的属性，这样我们就实现了私有变量。</p>
<h2 id="闭包处理回调函数"><a href="#闭包处理回调函数" class="headerlink" title="闭包处理回调函数"></a>闭包处理回调函数</h2><p>假设有这么一个动画函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tick = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animateIt</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tick &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            element.style.left = element.style.top = tick + <span class="string">"px"</span>;</span><br><span class="line">            tick++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数实现在 <code>1s</code> 内将元素向下和向右平移 <code>100px</code>，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    animateIt(<span class="string">"box1"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004172341.gif"/>
</center>

<p>但是当我们同时对两个元素使用动画时，由于二者共享变量 <code>tick</code>，则会导致二者的动画状态发生冲突，所以我们改动如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animateIt</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tick = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tick &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            element.style.left = element.style.top = tick + <span class="string">"px"</span>;</span><br><span class="line">            tick++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    animateIt(<span class="string">"box1"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box2"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    animateIt(<span class="string">"box2"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们将 <code>tick</code> 定义在函数内，由于闭包，<code>setInteval</code> 中的回调函数可以访问到tick，并且两个不同<code>id</code> 元素的<code>tick</code>是不同的，不会相互干扰</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/202004080010.gif"/>
</center>



</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/JavaScript-%E9%97%AD%E5%8C%85/">JavaScript 闭包</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="https://lastknightcoder.gitee.io/img/wechatpay.png" title="微信"><img src="https://lastknightcoder.gitee.io/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2019 - 2020 熊滔</div></footer>
<script src="https://lastknightcoder.gitee.io/js/scroller.js"></script>

<script src="https://lastknightcoder.gitee.io/js/main.js"></script>
</body></html>