<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Coder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="人生天地间，忽如远行客">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder">
<meta property="og:url" content="https://lastknightcoder.gitee.io/page/4/">
<meta property="og:site_name" content="Coder">
<meta property="og:description" content="人生天地间，忽如远行客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="熊滔">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="Coder" href="https://lastknightcoder.gitee.io/atom.xml">
    
    <link rel="shortcut icon" href="https://lastknightcoder.gitee.io/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://lastknightcoder.gitee.io/img/brand.jpg)">
      <div class="brand">
        <a href="https://lastknightcoder.gitee.io/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://lastknightcoder.gitee.io/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">熊滔</h5>
          <a href="mailto:2223106858@qq.com" title="2223106858@qq.com" class="mail">2223106858@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.gitee.io/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/LastKnightCoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Coder</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header index-header">

    <div class="container fade-scale">
        <h1 class="title">Coder</h1>
        <h5 class="subtitle">
            
                
            
        </h5>
    </div>

    


</header>

<div class="container body-wrap">

    <ul class="post-list">
    
        <li class="post-list-item fade">
            <article id="post-Java多线程"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-07-13 00:00:00" datetime="2019-07-12T16:00:00.000Z"  itemprop="datePublished">2019-07-13</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h2><p>一个软件可以同时干多件事情，就是多线程，目前我们编写的程序都是单线程的，在main方法中从上到下的进行，执行完上面的程序才能执行后面的程序。下面就将讲解如何写多线程程序。</p>
<p>在Java中创建多线程有两种放法，一种是继承Thread类，然后重写它的run()方法。第二种是实现Runnable接口，并且实现run()方法。</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>继承Thread类实现多线程的步骤为</p>
<ul>
<li>继承Thread类，重写run()方法</li>
<li>创建类对象，调用继承的start()方法</li>
</ul>
<p>我们写一个MyThread类继承自Thread类，并重写run方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个测试类，在其main方法中创建MyThread对象，并且调用对象继承自Thread的start()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java23.png"/>
</center>

<p>观察到main方法中的程序和MyThread的run()方法中的程序在交替的进行。而不是在等待我执行完了，另一个在执行，而是两个在同时的执行，这就是多线程。</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>实现Runnable接口实现多线程的步骤为</p>
<ul>
<li>实现Runnable接口并实现run()方法</li>
<li>在main中创建实现类对象</li>
<li>将实现类对象多为参数传入Thread()的构造方法，得到一个Thread对象</li>
<li>该Thread对象调用start()方法</li>
</ul>
<p>下面进行演示，首先创建一个类实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Run"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在实现类中实现多线程，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> MyRun(); <span class="comment">//创建实现类对象</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(run); <span class="comment">//实现类对象作为参数传入Thread的构造方法</span></span><br><span class="line">thread.start(); <span class="comment">//Thread对象调用start()方法启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java24.png"/>
</center>

<p>可以观察到main中的程序和run()方法中的程序是在同时进行的。</p>
<h3 id="Thread中的常见方法"><a href="#Thread中的常见方法" class="headerlink" title="Thread中的常见方法"></a>Thread中的常见方法</h3><ul>
<li>getName()<ul>
<li>获得线程的名称</li>
</ul>
</li>
<li>currentThread()<ul>
<li>获得正在执行的线程</li>
</ul>
</li>
<li>setName(String str)<ul>
<li>设置线程的名字</li>
<li>也可以通过new Thread(String str)设置线程的名字</li>
</ul>
</li>
<li>sleep(long l)<ul>
<li>线程休眠l毫秒</li>
</ul>
</li>
</ul>
<p>我们修改MyRun中的run()方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//获得当前线程并且获得当前线程的名字</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改main方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> MyRun();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(run);</span><br><span class="line">thread.setName(<span class="string">"run"</span>); <span class="comment">//增加了这一行，设置线程的名字</span></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java25.png"/>
</center>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>现在考虑这么一个问题，有三个售票机在售票，那么它们不能发生售出同样的票，也不能售出不存在的票。现在我要用一个类模拟售票机售票，并使用多线程模拟同时售票，新建一个SellTicket类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>; <span class="comment">//总共10张票</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类的main方法中创建三个线程同时售票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable sellTicket = <span class="keyword">new</span> SellTicket();</span><br><span class="line"><span class="comment">//创建三个线程 注意必须使用的同一个售票机对象 否则他们就是各自10张票而不是总共10张票</span></span><br><span class="line"><span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line"><span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line"><span class="keyword">new</span> Thread(sellTicket).start();</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java26.png"/>
</center>

<p>我们发现出现了不同的售票线程售出了相同的票，并且有的售票线程售出了不存在的票-1。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>之所以会出现上面的问题，就是因为在有的售票机卖出了票，即进入了if语句后，但是还未进行ticket–操作，但是这个时候这个线程失去了CPU的执行权，并且别的线程拿到了CPU的执行权，由于未对ticket–，所以它们拿到的是同一张票，所以这就是为什么它们能卖出同一张票的原因。同理卖出不存在的票也是同种原因。</p>
<p>那么如何解决这个问题，我们必须要求在售票机在完成售票并且对ticket–之前，别的售票机不能对ticket进行操作，这样就不会出现票重复和卖出不存在的票的情况了，而实现这个的技术就叫做同步。有三种实现方式，分别是</p>
<ul>
<li>synchronized代码块</li>
<li>同步方法</li>
<li>Lock锁</li>
</ul>
<p>下面具体介绍用法。</p>
<h4 id="sychronized代码块"><a href="#sychronized代码块" class="headerlink" title="sychronized代码块"></a>sychronized代码块</h4><p>sychronized代码块的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sychronized(锁对象) &#123;</span><br><span class="line">    <span class="comment">//需要同步的代码，也就是可能出现问题的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中锁对象可以是任意的对象，当一个线程执行到同步代码块时，会将该锁对象交给这个线程，当这个线程执行完同步代码块时，会释放锁对象，所以如果这个线程在同步代码块内失去了CPU的执行权，因为别的线程没有锁对象，就不能进入同步代码块执行，就会进入堵塞状态，等待锁对象被释放。所以锁对象就相当于是钥匙了，要保证多个线程的锁对象要相同，这样就只有一把钥匙了。</p>
<p>我们重新修改SellTicket的类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>; <span class="comment">//总共10张票</span></span><br><span class="line">    Object object = <span class="keyword">new</span> Object(); <span class="comment">//锁对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">            <span class="comment">//同步代码块 一次只有一个线程执行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java27.png"/>
</center>

<p>这次我们发现没有卖出重复的票，也没有卖出不可能的票。</p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>同步方法其实就是使用synchronized修饰的方法，这个方法每次也只能有一个线程执行，它的锁对象是this，我们把上面买票的程序抽取出为一个方法sellTicket()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">        ticket --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时run()可简化为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">        sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java28.png"/>
</center>

<p>也达到了同样的效果。</p>
<p>注意：</p>
<ul>
<li>同步方法也可以为静态方法，不过这时的锁对象不在是this了，而是本类的class属性，也是一个对象。</li>
</ul>
<h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p>Lock是一个接口，它比较灵活。之前我们讲到，在线程执行到synchronized代码块时，会获得锁对象，在执行完代码块时，会释放锁对象，但是这些对我们都是不可见的，而Lock灵活在我们自己觉得在哪里加锁，哪里释放锁。它有两个方法</p>
<ul>
<li>lock()<ul>
<li>加锁</li>
</ul>
</li>
<li>unlock()<ul>
<li>释放锁</li>
</ul>
</li>
</ul>
<p>lock()一般写在同步代码前，unlock()写在同步代码后。ReentrantLock是Lock的实现类，下面我们将演示如何使用Lock锁同步，修改run方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//创建Lock锁实现类对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//表示一直售票</span></span><br><span class="line">        lock.lock();  <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有票</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//为了增加出错的可能，使当前的线程休眠1ms</span></span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">            ticket --;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java29.png"/>
</center>

<p>可见达到了同步的效果。</p>
<h2 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h2><p>当我们排队买奶茶时，我们对老板说我们要一杯奶茶，然后我们就等着，老板去制作奶茶，等老板制作好奶茶后去喊我们。这其实就是等待唤醒，当多个线程去操作同一个资源时，比如奶茶，就需要一方(顾客)等着，等待另一方(老板)唤醒，总不能奶茶没有好我去抢吧。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>在讲解等待唤醒之前，我们先对线程的状态有一个大致的了解，看图</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java30.png"/>
</center>

<p>当我们创建一个线程对象还没有start()时，这时它处于New状态；当我们执行start()方法后，这时的线程状态由New转向Runnable运行状态；如果执行完run()方法，或者调用了stop()方法或者抛出了异常那么该线程进入死亡状态。如果在Runnable状态失去了CPU的执行权，那么就会进入Blocked阻塞状态；线程在这里等待CPU的执行权，拿到了CPU的执行权就会从该状态来到Runnable状态；如果线程在运行时执行了sleep(l)或wait(l)(l为等待的时间)方法，那么就会由Runnable状态进入Timed waiting状态，在这个状态中，线程放弃争夺CPU的执行权，当等待的时间到了之后，如果CPU空闲，那么就进入Runnable状态，如果忙碌，那么就进入Blocked状态，与其他线程一起争夺CPU的执行权。如果在Runnable执行了wait()(不带参数的)方法，就会进入Waiting永久等待状态，直到锁对象执行notify()方法唤醒，如果CPU空闲，就进入Runnable状态，否则进入Blocked状态争夺CPU执行权。</p>
<h3 id="等待唤醒-1"><a href="#等待唤醒-1" class="headerlink" title="等待唤醒"></a>等待唤醒</h3><p>这里的等待唤醒指的就是上面提及的Runnable状态执行wait()方法到Waiting永久等待状态，以及执行notiify()方法有永久等待状态到Runnable状态。前者为等待，后者为唤醒。</p>
<p>注意：</p>
<ul>
<li>只有锁对象才能调用wait()和notify()方法</li>
<li>wait()和notify()的调用者应该是同一锁对象，并且必须写在同步代码块中</li>
<li>执行wait()被唤醒后，会继续执行wait()后面的代码</li>
<li>notify()一次只能唤醒一个线程，唤醒的是睡眠最久的线程，notifyAll()能够唤醒所有的线程</li>
</ul>
<p>下面以最先提及的买奶茶为例演示这一过程。首先创建Runnable顾客类和老板类和奶茶类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">    String taste; <span class="comment">//奶茶口味</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//奶茶有没有做好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MilkTea milkTea; <span class="comment">//作为锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerThread</span><span class="params">(MilkTea milkTea)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.milkTea = milkTea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (milkTea) &#123; </span><br><span class="line">                <span class="keyword">if</span> (milkTea.flag == <span class="keyword">false</span>) &#123; <span class="comment">//奶茶没有准备好</span></span><br><span class="line">                    System.out.println(<span class="string">"老板来杯珍珠奶茶"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        milkTea.wait(); <span class="comment">//等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(milkTea.taste + <span class="string">"真好喝"</span>); <span class="comment">//被唤醒后会执行这个</span></span><br><span class="line">                milkTea.flag = <span class="keyword">false</span>; <span class="comment">//奶茶喝完了</span></span><br><span class="line">                milkTea.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopper</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MilkTea milkTea; <span class="comment">//作为锁对象 和Customer相同</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shopper</span><span class="params">(MilkTea milkTea)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.milkTea = milkTea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (milkTea) &#123;</span><br><span class="line">                <span class="keyword">if</span> (milkTea.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        milkTea.wait(); <span class="comment">//等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"做奶茶中 ..."</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    milkTea.taste = <span class="string">"珍珠奶茶"</span>;</span><br><span class="line">                    milkTea.flag = <span class="keyword">true</span>;</span><br><span class="line">                    System.out.println(milkTea.taste + <span class="string">"做好了"</span>);</span><br><span class="line">                    milkTea.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在测试类中创建两个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MilkTea milkTea = <span class="keyword">new</span> MilkTea(); <span class="comment">//作为锁对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CustomerThread(milkTea)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Shopper(milkTea)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java31.png"/>
</center>

<p>这就是等待唤醒的过程。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>当我们需要一个新的线程执行任务，我们就会创建一个新的线程，但是如果这个线程执行的任务很少，并且我们需要频繁的创建线程，这个创建线程的过程会很耗费时间，所以我们就想有没有一个机制，我们不用创建线程，当我们需要线程时我们去取，当我们用完时，我们还给它。这样就不需要频繁创建线程，省去时间，提高效率。线程池可以帮我们实现这一个想法。</p>
<p>那接下来的问题我们怎么使用Java为我们准备的线程池，Executors提供了一个静态方法newFixedThreadPool(int nThreads)，这个方法接收的参数是线程池中线程的个数，返回一个ExecutorService对象，然后我们就可以使用该对象的submit(Runnable task)方法，传入一个Runnable实现类对象就可以了。下面我们来示例一番</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个匿名内部类</span></span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//长度有三个线程的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>); </span><br><span class="line">        <span class="comment">//三个线程执行任务</span></span><br><span class="line">        threadPool.submit(run);</span><br><span class="line">        threadPool.submit(run);</span><br><span class="line">        threadPool.submit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>我们在创建一个线程时，我们一般需要做一下的步骤</p>
<ul>
<li>创建一实现类实现Runnable接口</li>
<li>重写run方法</li>
<li>创建实现类对象</li>
<li>将该对象传入Thread的构造方法中</li>
</ul>
<p>上面的写法可以简化，省去创建一个实现类，直接创建一个匿名内部类</p>
<ul>
<li>创建一个Runnable匿名内部类</li>
<li>重写run方法</li>
<li>将该对象传入Thread的构造方法中</li>
</ul>
<p>其实上面有很多的代码是多余，真正有用的代码就是run()方法里面的代码，但是为了创建一个线程我们不得不要创建一个对象，然后巴拉巴拉。其实有时候我们不关心谁来做，只需要告诉我怎么做，比如一个线程你只需要告诉我run()方法就可以了，告诉我怎么做就可以了，但是我们却要创建一个对象等等一系列的操作才能达到这个目的。</p>
<h3 id="Lambda的使用"><a href="#Lambda的使用" class="headerlink" title="Lambda的使用"></a>Lambda的使用</h3><p>Java在JDK 1.8中引入了Lambda表达式，可以极大简化我们的编程，可以做到我上面所说的只关心怎么做的问题，不需要创建对象。我们来看看下面这段代码用Lambda怎么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>Lambda的写法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在你可能没有看懂这个写法，下面让我为你解释一番。首先我们注意到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被简单的替换为了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两段代码很像，但是Lambda省略了很多的东西。首先我们知道Thread()里面传的是一个Runnable实现类的对象，该类重写类run方法，真正有用的就是run方法，所以我们把这些全部省略了，直接传入一个run()就可以了，并且由于run()方法的方法名是确定的，我们连run方法名都可以省去，返回值类型也是确定，所以我们也可以省去，最后只剩一个参数列表，在参数列表与方法体之间加入-&gt;就是Lambda表达式。使用Lambda不用创建对象，我们只需要传入一个方法，告诉它怎么做就可以了。这个也叫做函数式编程。</p>
<p>Lambda表达式的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了熟悉Lambda表达式的使用，我们来看一个例子，定义一个Calculator的接口，里面有一个方法叫<code>calculate(int a, int b);</code>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中定义一个方法，该方法需要<code>Calculator</code>接口作为参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = calculator.calculate(a,b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法表示的是，a,b经过Calculator计算之后得到一个数，而计算方法，根据我们传入的calculator而定，这明显是我们只需要告诉计算器怎么做就行，我们把做的方法告诉它，使用Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">int</span> result1 = cal(<span class="number">2</span>,<span class="number">3</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">int</span> result2 = cal(<span class="number">2</span>,<span class="number">3</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result2);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>根据我们传入的方法不同，这个计算器就不同，计算器关心的就是怎么做，你告诉怎么做就可以。</p>
<h3 id="Lambda的省略格式"><a href="#Lambda的省略格式" class="headerlink" title="Lambda的省略格式"></a>Lambda的省略格式</h3><p>其实上面的Lambda还可以进行化简，因为还有很多是可以推断出来的，比如参数列表里面的参数类型可以省略，因为这个参数类型时确定的，不可能会变的。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = cal(<span class="number">2</span>,<span class="number">3</span>, (a, b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果方法体里面只有一条语句时，那么花括号也可以省略，这时分号也可以省略，如果这条语句是return语句，那么return也可以省略，因为必须是要返回一个值的，这个可以推断出来，所以可以省略，所以上面又可以简写为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = cal(<span class="number">2</span>,<span class="number">3</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>

<p>如果参数列表里面只有一个参数的话，那么小括号也可以省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">param -&gt; &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的使用前提"><a href="#Lambda表达式的使用前提" class="headerlink" title="Lambda表达式的使用前提"></a>Lambda表达式的使用前提</h3><p>虽然Lambda表达式这么好用，但是是有使用前提的</p>
<ul>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<ul>
<li>比如Runnable接口，里面只有一个run()方法是抽象方法</li>
<li>比如上面定义的Calculator接口，里面也只有一个抽象方法calculate()</li>
</ul>
</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<ul>
<li>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
<li>不能是我要一个Calculator接口的calculate()方法，你给我传一个Runnable的run()方法，兄弟，暗号对不上啊。</li>
</ul>
</li>
</ul>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为”<strong>函数式接口</strong>“。</p>
</blockquote>

    

        <a href="https://lastknightcoder.gitee.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-Java常用API"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-07-12 00:00:00" datetime="2019-07-11T16:00:00.000Z"  itemprop="datePublished">2019-07-12</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/Java%E5%B8%B8%E7%94%A8API/">Java常用API</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <p>API全称叫做Application Programming Interface，翻译成应用程序编程接口，其实你把它看做是Java的使用说明书进行，它告诉你Java有哪些类，有哪些方法，你直接用就可以，相当于给你一个插座(接口)，你用的时候插上去就行。</p>
<h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><p>我们之前做的都是从屏幕输出，现在将介绍如何获取从键盘输入。Scanner类是系统提供的一个类，它可以帮助我们从键盘获取输入。一般使用系统提供的类分为三部分</p>
<ul>
<li>导包</li>
<li>创建对象</li>
<li>使用</li>
</ul>
<p>导包语句放在package之后，放在public class之前，如果使用的类与当前类属于同一个包，那么不用导入，如果要使用的类在java.lang包下，也不需要导入。导包的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名; <span class="comment">//导入指定包下面的类</span></span><br><span class="line"><span class="keyword">import</span> 包名.*;  <span class="comment">//导入指定包下的所有类</span></span><br></pre></td></tr></table></figure>

<p>Scanner类位于java.util包下，所以我们需要导入，下面介绍如何使用Scanner类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">//1. 导包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建一个Scanner对象</span></span><br><span class="line">        <span class="comment">//Scanner的构造方法需要传入参数，这里传入的是System.in，代表的是从键盘输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 使用</span></span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();   <span class="comment">//获得从键盘输入的一个整数</span></span><br><span class="line">        String str = sc.next();   <span class="comment">//获得从键盘输入的一个字符串</span></span><br><span class="line">        <span class="comment">//打印输入的结果</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行效果为：</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java16.gif"/>
</center>

<p><strong>注意：</strong></p>
<ul>
<li>其实从键盘输入全部都是字符串，即使你输入的是65这里的整数，系统得到的只是对于的ASCII码值，而nextInt()方法之所以能获得整数，是因为nextInt()方法做了处理，将字符串转化为了整数。</li>
<li>next()方法只能获得一个字符串，如输入的是Hello World，它只能得到Hello。</li>
</ul>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java17.gif"/>
</center>

<h1 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h1><p>Random类的作用主要是用于产生随机数的，它位于java.util包下面。下面介绍它的两个主要的方法</p>
<ul>
<li>nextInt()：产生一个随机整数，范围时整个int的大小</li>
<li>nextInt(int n)：产生一个[0,n)的整数，左闭右开。</li>
</ul>
<p>下面将介绍Random的使用。下面这个程序将产生10个随机整数，范围为整个int整数的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java18.gif"/>
</center>

<p>可见产生的整数是随机的，并且范围时整个int的范围，正值和负值都有。</p>
<p>下面这个程序将产生10范围为1-10的随机整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandomAgain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">10</span>) + <span class="number">1</span>); <span class="comment">//nextInt(10)的范围为0-9，+1变为1-10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java19.gif"/>
</center>

<p>输出的数字的范围在1-10之间，并且输出的数字是随机的。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String这个类是我们最常用的一个类了，因为我们会牵涉到很多的字符串的操作，所以这里要详细讲一下String类。</p>
<h2 id="String类的定义"><a href="#String类的定义" class="headerlink" title="String类的定义"></a>String类的定义</h2><p>String类位于java.lang包中，我们在之前讲过，java.lang是默认导入的，所以我们不需要导入这个包，这也是为什么在之前我们可以直接的使用String这个类。字符串效果上相当于是一个字节数组。</p>
<p>String作为引用类型，所以String对象的创建当然要借助于构造方法了，String的构造方法有很多，这里只讲常见的三种String构造方法。</p>
<ul>
<li>public String()<ul>
<li>创建一个空字符串</li>
</ul>
</li>
<li>public String(char[] array)<ul>
<li>根据一个字符数组来创建一个字符串</li>
</ul>
</li>
<li>public String(byte[] array)<ul>
<li>根据一个字节数组来创建一个字符串</li>
</ul>
</li>
</ul>
<p>下面我将演示通过这三种方法创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(); <span class="comment">//""</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(chars); <span class="comment">//"abc"</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(bytes); <span class="comment">//"abc"</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>因为字符串是在是太常用，通过构造方法创建有点麻烦，所以系统设计出可以通过<code>&quot;&quot;</code>的字面量的形式来创建一个String对象，这也是我们经常使用的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>Java程序中所有字符串的字面值（<code>&quot;&quot;</code>）都是String类的实例</li>
<li>字符串一旦创建不可改变</li>
</ul>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>我们知道可以通过字面量（<code>&quot;&quot;</code>）的形式来创建字符串对象，这样创建对象与使用构造方法创建的对象有什么不同呢? 下面我们来看一个字符串比较的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line">        System.out.println(str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>在这里我们创建了四个字符串，他们的内容都是”abc”，现在我要对它们进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line">System.out.println(str1 == str4);</span><br><span class="line">System.out.println(str3 == str4);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>这里得到的结果可能与你想象的不一样，所以我要详细讲一下。</p>
<p>首先==比较符比较的是什么？由于字符串都是引用类型，所以这里比较的是它们的地址，那按道理说，每创建一个对象，会在堆中开辟一个空间，每个空间的地址都不一样，那么它们比较的值应该都是false，那么为什么通过字面量创建的字符串对象比较出来的结果是true呢？</p>
<p>要解释这一个现象，就需要知道一个东西，那就是常量池。程序中直接用双引号写上的（即通过字面量创建的字符串），都在常量池中，而new出来的对象不再常量池中。现在记住这一句话，我们去内存看看到底怎么回事，由于这次不牵涉到方法区，我们只画出栈内存和堆内存。</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java20.png"/>
</center>

<h2 id="字符串的相关方法"><a href="#字符串的相关方法" class="headerlink" title="字符串的相关方法"></a>字符串的相关方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>之前我们说==比较是基于地址的比较，但是我们如果基于内容比较怎么办？比如说上面的字符串如果进行比较的话，就会返回true。有两个方法，第一个是equals()方法，该方法其实也是基于==比较的，不过String类重写了该方法，只要两个字符串的内容相同就会返回true。这里又提到了重写，不懂没关系，只要知道，字符串调用这个方法是基于内容的比较，而不是基于地址的比较，下面演示一番。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));</span><br><span class="line">        System.out.println(str1.equals(str3));</span><br><span class="line">        System.out.println(str1.equals(str4));</span><br><span class="line">        System.out.println(str3.equals(str4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>equals()方法具有对称性</li>
<li>如果比较的双方一个是常量，一个是变量，推荐使用常量调用方法</li>
</ul>
<p>针对第二条的原因是，如果变量str未被初始化，那么它的初始值是null，null根本没有equals方法，所以调用该方法会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str; <span class="comment">//str = null</span></span><br><span class="line">str.equals(<span class="string">"abc"</span>); <span class="comment">//会报错</span></span><br><span class="line"><span class="string">"abc"</span>.equals(str); <span class="comment">//不会报错，会返回false</span></span><br></pre></td></tr></table></figure>

<p>字符串比较的第二个方法是equalsIgnoreCase()，该方法与equals不同的是，该方法的比较忽略大小写，而equals()是大小写敏感的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello"</span>.equalsIgnoreCase(<span class="string">"Hello"</span>));</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>与字符串截取有关的方法是substring()，该方法有两种常用的重载</p>
<ul>
<li>substring(int index)<ul>
<li>从index截取到末尾</li>
</ul>
</li>
<li>substring(int begin, int end)<ul>
<li>从begin截取到end，左闭右开[begin, end)</li>
</ul>
</li>
</ul>
<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>介绍三个方法</p>
<ul>
<li>toCharArray()<ul>
<li>将字符串转换为char[]</li>
</ul>
</li>
<li>getBytes()<ul>
<li>将字符串转换为byte[]</li>
</ul>
</li>
<li>replace(CharSequence oldString, CharSequence newString)<ul>
<li>这里的CharSequence是接口，这里不懂也没关系，知道这个可以接收字符串类型就可以</li>
<li>这个方法的作用是新的字符串替换旧的字符串</li>
</ul>
</li>
</ul>
<h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>与字符串分割的方法只有一个</p>
<ul>
<li>split(String regex)<ul>
<li>按照regex的规则分割字符串，返回一个字符串数组</li>
</ul>
</li>
</ul>
<p>按照regex的规则分割字符串可能有点难以理解，其实这里的regex是正则表达式，不懂的话看懂下面的例子就可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"a,b,c"</span>;</span><br><span class="line"></span><br><span class="line">        String[] strings = str.split(<span class="string">","</span>); <span class="comment">//按照逗号的分割字符串，得到的是["a","b","c"]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">            System.out.println(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>如果要按”.”规则分割的话，不能写”.”，要写成”\.”，因为.在正则表达式中有特殊的含义，所以需要转义。</li>
</ul>
<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>Arrays位于java.util包中。这个类提供了很多的静态方法，实现数组的常见操作。在这里我们介绍两个常用的方法</p>
<ul>
<li>toString<ul>
<li>接收一个数组参数</li>
<li>将参数数组变成字符串 [元素1，元素2， …]</li>
</ul>
</li>
<li>sort<ul>
<li>按默认升序（从小到大）对数组进行排序</li>
<li>对于String，按字母在Unicode表中的大小排序</li>
<li>对于自定义的类型，需要Comparable或Comparator接口的支持</li>
</ul>
</li>
</ul>
<p>下面演示两个方法的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个整型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays.toString() 我们不用遍历数组打印了</span></span><br><span class="line">        System.out.println(Arrays.toString(arrays));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对数组进行排序 这里不是返回一个新的数组 而是对原有数组进行排序</span></span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        <span class="comment">//将排序后的数组打印出来</span></span><br><span class="line">        System.out.println(Arrays.toString(arrays));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>Math类位于java.util包中，该类包含了很多与数学计算相关的静态方法。这里介绍几个与整数操作有关的方法</p>
<ul>
<li>abs()<ul>
<li>取绝对值</li>
<li>abs(-2) = 2</li>
</ul>
</li>
<li>ceil()<ul>
<li>向上取整</li>
<li>ceil(2.1) = 3，ceil(-2.1) = -2</li>
</ul>
</li>
<li>floor()<ul>
<li>向下取整</li>
<li>·floor(2.1) = 2，floor(-2.1) = -3</li>
</ul>
</li>
<li>round()<ul>
<li>四舍五入</li>
<li>round(2.1) = 2，round(-2.1) = -2</li>
</ul>
</li>
</ul>
<p>当然Math类还包含很多的方法，具体的可以查阅资料。</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object类是所有类的父类，所有类都默认继承了（直接或间接）Object类。所以所有的类都默认有Object类中的成员方法。这里介绍两个比较重要的Object类的成员方法</p>
<ul>
<li>toString()</li>
<li>equals(Object object)</li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>我们在之前一直有用System.out.println()语句打印信息到控制台，当我们传入一个引用类型变量的时候，它会调用该对象的toString()方法，由于Object类的toString方法是默认打印堆内存的地址值，所以这也是为什么我们在打印数组时，打印出的是地址值。而我们打印String类型时，打印出的却是它的内容，这时因为String重写toString()方法。</p>
<p>为了验证我们的猜想，我们看下面这么一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在创建一个Person对象，并且打印出来，然后调用toString()方法，在打印一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestToString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(per);</span><br><span class="line">        System.out.println(per.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person@<span class="number">4554617</span>c</span><br><span class="line">Person@<span class="number">4554617</span>c</span><br></pre></td></tr></table></figure>

<p>我们发现结果是一样的，现在我们在Person类中重写toString()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm a Person object"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行一遍，输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m a Person object</span></span><br><span class="line"><span class="string">I'</span>m a Person object</span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>在前面我们比较字符串时，我们说==是对象的地址值进行比较，而equals方法是基于内容的比较。事实上，Object类的equals方法也是进行对象地址值的比较，只不过是<strong>String类重写了equals方法</strong>。</p>
<p>我们可以通过重写equals方法来设置怎样两个对象才是相等的。比如还是以Person类进行举例，它有姓名和年龄两个成员变量，我们认为如果两个人的姓名和年龄都是一样的，那么我们就认为这两个人的对象是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为要使用Person对象的name和age属性，所以要向下转型</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person person = (Person) obj;</span><br><span class="line">            <span class="comment">//如果姓名和年龄相同，就认为对象是相同的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.name == person.name &amp;&amp; <span class="keyword">this</span>.age == person.age) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在测试类类中测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>,<span class="number">20</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>,<span class="number">28</span>);</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.equals(person2));  <span class="comment">//年龄和姓名不一样，返回false</span></span><br><span class="line">        System.out.println(person1.equals(person3)); <span class="comment">//名字和年龄一样，返回true</span></span><br><span class="line">        System.out.println(person1 == person3); <span class="comment">//地址值是不同的，所以是false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>Date是有关于日期的类，它位于java.util包中。现在主要介绍它的两种常用的构造方法，以及一个有关于格式化输出的类SimpleDateFormat。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();  <span class="comment">//默认得到的是当前时间的日期</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="keyword">long</span> l); <span class="comment">//接收一个毫秒值，该毫秒值代表的是距离时间原点消耗的毫秒值</span></span><br></pre></td></tr></table></figure>

<p>时间原点规定为1970年1月1日的<code>00:00:00</code>时刻。现在简单演示Date类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sat Jul <span class="number">20</span> <span class="number">19</span>:<span class="number">26</span>:<span class="number">26</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>

<p>可见Date类重写了toString()方法。</p>
<p>Date类有一个getTime的方法，它可以获得该date对象对应的毫秒值，现在我们通过这个方法获得一个毫秒值，然后利用该毫秒值作为第二个构造函数的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> ms = date.getTime();</span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(ms);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sat Jul <span class="number">20</span> <span class="number">19</span>:<span class="number">29</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br><span class="line">Sat Jul <span class="number">20</span> <span class="number">19</span>:<span class="number">29</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>

<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>上面的时间输出其实不符合我们的使用习惯，所以我们可以让输出的日期符合我们的使用习惯。DateFormat这个类是为此而存在的，不过它是一个抽象类，SimpleDateFormat类继承了该类，我们可以使用该类格式化日期输出。</p>
<p>首先就是如何创建一个对象，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(模式);</span><br></pre></td></tr></table></figure>

<p>可能这里还不能理解模式是个什么鬼，那么就要看下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日"</span>);</span><br></pre></td></tr></table></figure>

<p>“yyyy年MM月dd日”就是模式，差不多就是模板吧，也就是你想要格式化输出的格式，其中yyyy代表年，MM代表月，dd代表日，HH代表小时，mm代表分，ss代表秒。</p>
<p>这里主要介绍它的两个方法</p>
<ul>
<li>format<ul>
<li>接收一个日期对象，返回一个字符串，这个字符串的格式与你上面定义的模式相同</li>
</ul>
</li>
<li>parse<ul>
<li>接收一个字符串，这个字符串的格式必须与你定义的模式相同，否则会报错</li>
<li>方法一个Date对象</li>
<li>parse方法会抛出一个异常，对于抛出异常的方法，要么继续抛出异常，要么使用try-catch处理</li>
</ul>
</li>
</ul>
<p>下面介绍这个类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;  <span class="comment">//parse方法有可能抛出这个异常，这里我们不处理，继续抛出</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();  <span class="comment">//创建一个Date对象作为后面format方法的参数</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>); <span class="comment">//定义输出格式</span></span><br><span class="line">        String formatDate = simpleDateFormat.format(date);  <span class="comment">//获得由date转化得到的格式化输出字符串</span></span><br><span class="line">        System.out.println(formatDate);</span><br><span class="line"></span><br><span class="line">        Date dateAgain = simpleDateFormat.parse(<span class="string">"2017年5月13日 15:23:14"</span>); <span class="comment">//根据指定的格式解析出一个Date对象</span></span><br><span class="line">        System.out.println(dateAgain); <span class="comment">//打印该Date对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>年<span class="number">07</span>月<span class="number">20</span>日 <span class="number">19</span>:<span class="number">43</span>:<span class="number">18</span></span><br><span class="line">Sat May <span class="number">13</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">14</span> CST <span class="number">2017</span></span><br></pre></td></tr></table></figure>

<h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><p>Calendar是一个有关于日期的类，它提供了一些操作日历的方法，它是一个抽象类，所以不能创建Calendar对象，我们可以通过它的静态方法getInstance()得到它的一个子类对象，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<p>这里仅简单介绍它的四个方法</p>
<ul>
<li>get(int field)<ul>
<li>根据指定field值获取日历信息，field值一般为Calendar类的静态常量，如get(Calendar.YEAR)可以获得有关于年份的信息</li>
</ul>
</li>
<li>set(int field, int value)<ul>
<li>设置指定的field为指定的value</li>
</ul>
</li>
<li>add(int field, int amount)<ul>
<li>为指定field加上amount</li>
<li>这里需要注意的是，如果加上数值之后超过范围之后，会有进位。比如现在为7月，我给MONTH加上了10，那么现在年份会加1年，并且此时的月份为7 + 10 -12 = 5。</li>
</ul>
</li>
<li>getTime()<ul>
<li>返回当前日历对应得Date对象</li>
</ul>
</li>
</ul>
<p>下面简单演示方法的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCalendar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        System.out.println(calendar); <span class="comment">//打印出的不是地址，可见Calendar也重写了toString()方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH) + <span class="number">1</span>); <span class="comment">//西方的月份是从0开始的，所以这里我加1</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.DATE));</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); <span class="comment">//与上面DATE的效果是一样的</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(calendar.get(Calendar.SECOND));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============="</span>);</span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2020</span>);  <span class="comment">//设置年份为2020年</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        calendar.add(Calendar.MONTH,<span class="number">10</span>);  <span class="comment">//给月份加10个月，现在为2021年5月了</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH) + <span class="number">1</span>);</span><br><span class="line">        Date dateAgain = calendar.getTime();  <span class="comment">//得到一个日期对象</span></span><br><span class="line">        System.out.println(dateAgain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.GregorianCalendar[time=<span class="number">1563623852127</span>,areFieldsSet=<span class="keyword">true</span>,areAllFieldsSet=<span class="keyword">true</span>,lenient=<span class="keyword">true</span>,zone=sun.util.calendar.ZoneInfo[id=<span class="string">"Asia/Shanghai"</span>,offset=<span class="number">28800000</span>,dstSavings=<span class="number">0</span>,useDaylight=<span class="keyword">false</span>,transitions=<span class="number">29</span>,lastRule=<span class="keyword">null</span>],firstDayOfWeek=<span class="number">1</span>,minimalDaysInFirstWeek=<span class="number">1</span>,ERA=<span class="number">1</span>,YEAR=<span class="number">2019</span>,MONTH=<span class="number">6</span>,WEEK_OF_YEAR=<span class="number">29</span>,WEEK_OF_MONTH=<span class="number">3</span>,DAY_OF_MONTH=<span class="number">20</span>,DAY_OF_YEAR=<span class="number">201</span>,DAY_OF_WEEK=<span class="number">7</span>,DAY_OF_WEEK_IN_MONTH=<span class="number">3</span>,AM_PM=<span class="number">1</span>,HOUR=<span class="number">7</span>,HOUR_OF_DAY=<span class="number">19</span>,MINUTE=<span class="number">57</span>,SECOND=<span class="number">32</span>,MILLISECOND=<span class="number">127</span>,ZONE_OFFSET=<span class="number">28800000</span>,DST_OFFSET=<span class="number">0</span>]</span><br><span class="line"><span class="number">2019</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">57</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line">=============</span><br><span class="line"><span class="number">2020</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Thu May <span class="number">20</span> <span class="number">19</span>:<span class="number">57</span>:<span class="number">32</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<h1 id="System"><a href="#System" class="headerlink" title="System"></a>System</h1><p>System是有关于系统的类，这里不会介绍那么高深的内容，主要介绍两个静态方法</p>
<ul>
<li>currentTimeMillis()<ul>
<li>获得当前系统距时间原点的毫秒值</li>
<li>这个方法可以用来计算程序损耗的实践</li>
<li>在程序开始执行前获取一个时间，在程序执行完成获取一个时间，两个时间相减就可以知道程序执行的时间，就可以知道程序的哪一部分最耗时，从而做出优化</li>
</ul>
</li>
<li>arraycopy()<ul>
<li>该方法的作用是将源数组从指定位置开始复制，有一个参数规定了复制的长度，复制到另一个数组，这个数组也规定了起始的位置</li>
<li>该方法接收五个参数</li>
<li>第一个参数是一个源数组src，第二个参数是源数组的起始位置，第三个参数是目的数组，第四个参数是目的数组的起始位置，第五个参数是复制的长度</li>
<li>如果你在这里没有理解，请看下面的例子</li>
</ul>
</li>
</ul>
<p>下面简单演示这两个方法的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis(); <span class="comment">//循环执行前获取一次时间</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123; <span class="comment">//1000万次</span></span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();  <span class="comment">//循环结束后获取一次时间</span></span><br><span class="line">        <span class="keyword">double</span> time = (end - start) / <span class="number">1000.0</span>;  <span class="comment">//将单位转化为s</span></span><br><span class="line">        System.out.println(<span class="string">"共花费"</span> + time + <span class="string">"s"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们将源数组的前三个元素替换目的数组的前三个元素</span></span><br><span class="line">        <span class="keyword">int</span>[] array1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;      <span class="comment">//源数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;     <span class="comment">//目的数组</span></span><br><span class="line">        System.out.println(<span class="string">"转换前"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">        System.arraycopy(array1, <span class="number">0</span>, array2, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">//前三个元素，所以都是从索引0开始</span></span><br><span class="line">        System.out.println(<span class="string">"转换后"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">共花费<span class="number">0.011</span>s</span><br><span class="line">转换前</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">转换后</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>可见程序是执行的相当的快。</p>

    

        <a href="https://lastknightcoder.gitee.io/Java%E5%B8%B8%E7%94%A8API/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-Java集合与泛型"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-07-08 00:00:00" datetime="2019-07-07T16:00:00.000Z"  itemprop="datePublished">2019-07-08</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/Java%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/">Java集合与泛型</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是集合的意思，你可以把它看做一种装东西的容器，就像数组一样。它是一个接口，有很多的类实现了它，比如Arralist，LinkedList，HashMap，等等很多。不同的类使用不同的方法去实现，所以他们之间的某些性能是不同的。</p>
<h3 id="Collection中的方法"><a href="#Collection中的方法" class="headerlink" title="Collection中的方法"></a>Collection中的方法</h3><p>我们这次学习的是Collection接口中的方法，虽然实现它的类很多，但是它们实现的方法的功能都是一样。这里介绍七个方法</p>
<ul>
<li>add(E e)<ul>
<li>添加元素</li>
</ul>
</li>
<li>clear()<ul>
<li>清空集合中的所有元素</li>
</ul>
</li>
<li>remove(E e)<ul>
<li>删除元素</li>
</ul>
</li>
<li>contains(E e)<ul>
<li>查看是否包含某个元素</li>
</ul>
</li>
<li>isEmpty()<ul>
<li>查看数组是否为空</li>
</ul>
</li>
<li>size()<ul>
<li>返回集合的长度，即元素的个数</li>
</ul>
</li>
<li>toArray<ul>
<li>返回一个Onject类型的数组</li>
</ul>
</li>
</ul>
<p>下面我们以ArrayList为例来学习上面的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//多态写法</span></span><br><span class="line">        <span class="comment">//测试add</span></span><br><span class="line">        collection.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        collection.add(<span class="string">"令狐冲"</span>);</span><br><span class="line">        collection.add(<span class="string">"郭靖"</span>);</span><br><span class="line">        collection.add(<span class="string">"杨过"</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//测试contains</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">"杨过"</span>));</span><br><span class="line">        <span class="comment">//测试size</span></span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line">        <span class="comment">//测试remove</span></span><br><span class="line">        collection.remove(<span class="string">"杨过"</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//测试toArray</span></span><br><span class="line">        Object[] objects = collection.toArray();</span><br><span class="line">        System.out.println(Arrays.toString(objects));</span><br><span class="line">        <span class="comment">//测试clear</span></span><br><span class="line">        collection.clear();</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到我们创建Collection对象时，与一般类相比创建多了&lt;&gt;，这个叫做泛型。是什么意思呢? 我们定义数组的话有不同的数据类型，来定义保存什么类型的数据，同样的Collection也有不同的数据类型，来决定里面保存的是什么类型的数据。而数据类型就是写在里面，目前我们就这么理解泛型，有关泛型更加详细的用法，下面会进行介绍。在=号的右边也有&lt;&gt;号，从JDK 1.7开始，右边的&lt;&gt;里面可以什么都不写，之前里面也要写数据类型，但是和右边的一样，所以没必要在写一遍。另一个需要注意的是，泛型（也就是&lt;&gt;里面的数据类型）必须是引用类型，不能是基本类型。</p>
<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张无忌, 令狐冲, 郭靖, 杨过]</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[张无忌, 令狐冲, 郭靖]</span><br><span class="line">[张无忌, 令狐冲, 郭靖]</span><br><span class="line">[]</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>我们对集合一个重要的操作就是对集合进行遍历，不同于数组，集合不是所有的都是有序的，所以无法通过索引对集合进行遍历，那我们就只能通过迭代器Iterator来遍历集合，Iterator也是一个接口，集合有一个iterator()方法，可以获取迭代器实现类的对象。迭代器主要有两个方法</p>
<ul>
<li>hasNext()<ul>
<li>判断集合中是否还有下一个元素，有则返回true</li>
</ul>
</li>
<li>next()<ul>
<li>取出集合中的下一个元素，如何集合中没有元素，使用该方法会抛出异常，所以应该先进行判断是否还有下一个元素</li>
</ul>
</li>
</ul>
<p>下面我们来示例使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//HashSet是一个无序的集合</span></span><br><span class="line">        Collection&lt;String&gt; collection = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        collection.add(<span class="string">"亚瑟"</span>);</span><br><span class="line">        collection.add(<span class="string">"妲己"</span>);</span><br><span class="line">        collection.add(<span class="string">"安其拉"</span>);</span><br><span class="line">        collection.add(<span class="string">"狄仁杰"</span>);</span><br><span class="line">        collection.add(<span class="string">"李白"</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[李白, 妲己, 狄仁杰, 亚瑟, 安其拉]</span><br></pre></td></tr></table></figure>

<p>可见HashSet是一个无序的集合，所以不能通过索引去获取集合中的元素，我们使用迭代器去遍历集合中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = collection.iterator(); <span class="comment">//由集合的iterator()方法创建迭代器</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">//判断集合中是否还有下一个元素</span></span><br><span class="line">    String string = iterator.next(); <span class="comment">//取出下一个元素，每取出一个元素，指针向后移动</span></span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">李白</span><br><span class="line">妲己</span><br><span class="line">狄仁杰</span><br><span class="line">亚瑟</span><br><span class="line">安其拉</span><br></pre></td></tr></table></figure>

<h3 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h3><p>我们知道不能通过一般的for循环去遍历集合，所以Java中有一个增强的for循环，利用它可以遍历集合和数组，它的实现原理就是迭代器的原理，不过使用的是for循环的形式，我们把它叫做foreach循环，格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 变量名 : 集合)</span><br></pre></td></tr></table></figure>

<p>它会自动的取出集合中的元素，并且赋值给变量，然后你就可以在foreach循环中对取出的元素进行操作了，还是以上面的集合为例，演示如何使用foreach循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String string : collection) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">李白</span><br><span class="line">妲己</span><br><span class="line">狄仁杰</span><br><span class="line">亚瑟</span><br><span class="line">安其拉</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>泛型我们之前在使用Collection集合时就已经接触过，那么为什么会使用泛型，比如你正在写一个集合给别人使用，但是你不知道别人会保存什么数据类型，你不能写死了说只能保存String类型，这个时候我就会使用泛型，保存什么类型的数据由别人自己觉得，就像数组一样。</p>
<p>如果省略泛型的话，那么默认为Object类型，比如下面我创建一个ArrayList集合，没有写泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"AA"</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AA</span><br><span class="line"><span class="number">2</span></span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>这个时候ArrayList集合的对象能够添加任何的数据类型，因为所有的类都继承了Object类，而基本数据类型会进行自动装箱操作转化为对应的包装类。其实上面就是多态的写法，而多态的写法我们也知道它的弊端，他不能调用子类特有的方法，如果我们需要调用子类的方法的话就需要向下转型，这很容易发生异常，并且在编译时不会报错。并且一般我们在集合保存相同的数据类型，所以这个时候我们可以使用泛型。使用泛型的话至少有这两个优点</p>
<ul>
<li>避免了类型转换的麻烦</li>
<li>编译时就可以看到错误<ul>
<li>如果一个String的ArrayList添加Integer数据，那么编译时就会报错</li>
</ul>
</li>
</ul>
<h3 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>泛型定义在类中的格式应该如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中E就代表泛型，它会在创建对象的时候确定E是什么类型，比如ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();，那么这个时候E就是String。这么定义以后，我们就可以在类中的方法中使用E，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以让它作为方法的参数和返回值，如果在创建对象的时候传入的E是String，那么这些方法的参数或者返回全部都是String类型的。我们可以看做E是一个接收类类型的变量。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法中定义泛型，格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型&gt; 返回值 方法名(参数列表) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如下面这么定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(M m)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型会在调用方法时确定，比如传入的是一个String类型的参数，那么M就是String。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在接口中定义的格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类实现接口可以指定泛型是什么或者不指定，就是这个意思</p>
<ul>
<li>指定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现类 implements InterfaceName&lt;String&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不指定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现类&lt;E&gt; implements InterfaceName&lt;E&gt;</span><br></pre></td></tr></table></figure>

<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>假设我要写一个方法，输入一个ArrayList对象，要求打印输入列表的所有元素，但是ArrayList是什么类型的不知道，所以方法参数类型不能写死，不能这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们在上面学了方法的泛型，所以我们可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(ArrayList&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java停供了一种更加方面的写法，即使用通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中?代表的就是通配符，指的就是能够匹配任何的数据类型。</p>
<p>不仅如此我们还能够对通配符进行限定，如</p>
<ul>
<li>? extends E<ul>
<li>说明参数的类型必须是<code>E</code>的子类或者<code>E</code>本身</li>
</ul>
</li>
<li>? super E<ul>
<li>说明参数的类型必须是<code>E</code>的父类或者<code>E</code>本身</li>
</ul>
</li>
</ul>
<p>比如下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTongpeifu</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收的类型必须为Number类的子类或者Number类本身</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(ArrayList&lt;? extends Number&gt; list)</span> </span>&#123; </span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//接收的类型必须为Number类的父类或者Number类本身</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(ArrayList&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Number&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        show(list1); <span class="comment">//Interger是Number的子类，可以</span></span><br><span class="line">        show(list2); <span class="comment">//String类与Number类没有关系，报错</span></span><br><span class="line">        show(list3); <span class="comment">//Object不是Number的子类，报错</span></span><br><span class="line">        show(list4); <span class="comment">//Number本身，可以</span></span><br><span class="line"></span><br><span class="line">        show2(list1); <span class="comment">//Interger是子类，报错 </span></span><br><span class="line">        show2(list2); <span class="comment">//String没关系，报错</span></span><br><span class="line">        show2(list3); <span class="comment">//Object是父类，可以</span></span><br><span class="line">        show2(list4); <span class="comment">//Number本身，可以</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java21.png"/>
</center>

<p>与我们分析的一致。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口是Collection的子接口，实现它的类有ArrayList和LinkedList，ArrayList的底层实现原理是数组，所以它的查询速度快，但是它的增删操作很慢，LinkedList的底层实现原理是链表，所以它的查询操作很慢，它的增删操作很快。</p>
<h3 id="List集合的特点"><a href="#List集合的特点" class="headerlink" title="List集合的特点"></a>List集合的特点</h3><p>List接口的特点有</p>
<ul>
<li>有序，所以可以通过索引访问元素</li>
<li>集合中的元素允许重复</li>
</ul>
<p>因为List接口可以有索引，所以除了Collection中的方法，List还有其特有的方法如下</p>
<ul>
<li>add(int index, E e)<ul>
<li>在指定索引中的位置添加元素，后面的元素向后推移</li>
</ul>
</li>
<li>remove(int index)<ul>
<li>删除指定索引的元素，并且返回删除的元素</li>
</ul>
</li>
<li>get(int index)<ul>
<li>获得指定索引处的元素</li>
</ul>
</li>
<li>set(int index, E e)<ul>
<li>将索引处为元素替换为e</li>
</ul>
</li>
</ul>
<p>下面示例上面的四个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//[1, 5, 7]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//add(int index, E e)</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">8</span>); <span class="comment">//在索引为2的地方插入8</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[1, 5, 8, 7]</span></span><br><span class="line">        <span class="comment">//get(int index)</span></span><br><span class="line">        <span class="keyword">int</span> num1 = list.get(<span class="number">1</span>); <span class="comment">//获得索引为1的元素</span></span><br><span class="line">        System.out.println(num1); <span class="comment">//5</span></span><br><span class="line">        <span class="comment">//set(int index, E e)</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">//设置索引为0的元素为4</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[4, 5, 8, 7]</span></span><br><span class="line">        <span class="keyword">int</span> num2 = list.remove(<span class="number">2</span>); <span class="comment">//删除索引为2的元素</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[4, 5, 7]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p>因为List集合是有序的，所以有三种方法可以进行遍历</p>
<ul>
<li>普通for循环</li>
<li>迭代器</li>
<li>增强for循环</li>
</ul>
<p>下面进行示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通for写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器写法</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Integer i = iterator.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for写法</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList在之前我们讲解Collection时就有接触到，所以这里就简单的介绍它。ArrayList集合的使用非常的简单，在上面已经演示过了，并且它的方法都是实现List里面的方法，而这些方法的使用在上面已经了解了，下面看看ArrayList简单例子即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList对象 里面保存的都是String类型</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向列表中添加三个元素</span></span><br><span class="line">        list.add(<span class="string">"张三"</span>);</span><br><span class="line">        list.add(<span class="string">"李四"</span>);</span><br><span class="line">        list.add(<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印列表</span></span><br><span class="line">        System.out.println(list);  <span class="comment">//ArrayList对toString()方法重写了，所以打印输出不是地址值</span></span><br><span class="line">        <span class="comment">//获取列表里面的元素</span></span><br><span class="line">        System.out.println(<span class="string">"列表的第一个元素为："</span> + list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">"列表的第二个元素为："</span> + list.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"列表的第三个元素为："</span> + list.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"列表的长度为："</span> + list.size());  <span class="comment">//获取列表的长度</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        System.out.println(<span class="string">"删除的元素为："</span> + list.remove(<span class="number">1</span>)); <span class="comment">//删除第二个元素，即删除李四</span></span><br><span class="line">        System.out.println(<span class="string">"列表的长度为："</span> + list.size()); <span class="comment">//列表的长度</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[张三, 李四, 王五]</span><br><span class="line">列表的第一个元素为：张三</span><br><span class="line">列表的第二个元素为：李四</span><br><span class="line">列表的第三个元素为：王五</span><br><span class="line">列表的长度为：<span class="number">3</span></span><br><span class="line">===============</span><br><span class="line">删除的元素为：李四</span><br><span class="line">列表的长度为：<span class="number">2</span></span><br><span class="line">[张三, 王五]</span><br></pre></td></tr></table></figure>

<p>上面代码的注释已经详细说明上面代码的功能，这里说一下一个特别的地方。当我们打印数组名时，会得到数组的地址，但是当我们打印ArrayList对象，输出的不是地址，而是里面的元素，这是因为ArrayList重写了toString()方法，当System.out.println()里面传入的是引用类型时，会调用该引用类型的toString方法，由于ArrayList重写了toString()方法，所以打印输出的不是地址，没有重写该方法的类，打印输出默认是地址。如果在这里你搞不懂什么重写，toString()方法都是什么，那么没关系，你只要知道<strong>直接打印ArrayList对象名，输出的不是地址，而是里面包含的所有元素</strong>，具体重写是什么，toString()是什么，在后面的继承部分将会有阐述。</p>
<p>需要注意的是，泛型只能是引用类型，不能是基本数据类型，那么如果我们想要保存基本数据类型怎么办。当然是有办法的，Java中为每一个基本数据类型提供了一个包装类，它虽然是一个类，但是你在使用时完全把它当做基本数据类型就可以，因为泛型里面不能是基本数据类型，才会有这么一个包装类。下表是基本数据类型与包装类对应的名称</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>上面除了int和char对应的包装类不只是首字母大写，其他都是只要首字母大写即可。下面我将演示如何存储基本数据类型，以int类型为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDataToArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把Integer当做int看待即可，我们不需要new 一个Integer对象 编译器会帮我们做处理，我们不需要担心</span></span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">25</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印列表</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">100</span>, <span class="number">25</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure>

<p>在基本数据类型与包装类之间有自动装换，基本数据类型转换为包装类的过程叫做<strong>装箱</strong>，包装类转化为基本数据类型的过程叫做<strong>拆箱</strong>，从JDK 1.5开始就支持自动装箱和自动拆箱。即我们可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interger a = <span class="number">12</span>; <span class="comment">//自动装箱 int -- Interger</span></span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">//自动拆箱 Interger -- int</span></span><br></pre></td></tr></table></figure>

<p>所以我们在使用时把Interger看做int就可以了。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是List的实现类，它的底层原理是基于链表实现的，所以除了List接口中的方法，它还提供了很多与头尾有关的方法，如</p>
<ul>
<li>addFirst</li>
<li>addLast</li>
<li>removeFirst</li>
<li>removeLast</li>
<li>getFirst</li>
<li>getLast</li>
<li>push<ul>
<li>同addFirst一样</li>
</ul>
</li>
<li>pop<ul>
<li>同removeFirst</li>
</ul>
</li>
</ul>
<p>下面进行示范</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="string">"AAA"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"BBB"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//addFirst 在"AAA"前面添加元素"CCC"</span></span><br><span class="line">        linkedList.addFirst(<span class="string">"CCC"</span>);</span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[CCC, AAA, BBB]</span></span><br><span class="line">        <span class="comment">//push 在"CCC"前面添加"DDD"</span></span><br><span class="line">        linkedList.push(<span class="string">"DDD"</span>);</span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[DDD, CCC, AAA, BBB]</span></span><br><span class="line">        <span class="comment">//pop 删除"DDD"</span></span><br><span class="line">        System.out.println(linkedList.pop()); <span class="comment">//DDD</span></span><br><span class="line">        <span class="comment">//获得第一个元素 getFirst</span></span><br><span class="line">        System.out.println(linkedList.getFirst()); <span class="comment">//CCC</span></span><br><span class="line">        <span class="comment">//removeFirst 删除第一个元素</span></span><br><span class="line">        System.out.println(linkedList.removeFirst()); <span class="comment">//CCC</span></span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[AAA, BBB]</span></span><br><span class="line">        <span class="comment">//removeLast 删除最后一个元素</span></span><br><span class="line">        System.out.println(linkedList.removeLast()); <span class="comment">//BBB</span></span><br><span class="line">        System.out.println(linkedList); <span class="comment">//[AAA]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型与包装类"><a href="#基本类型与包装类" class="headerlink" title="基本类型与包装类"></a>基本类型与包装类</h2><p>在前面我们就讲过这个概念，不过当时讲的不够详细，现在深入讲解。首先我们知道包装类是什么，因为基本数据类型它不是引用类型，而由于泛型必须是引用类型，所以才有包装类。包装类就是将基本数据类型包装为一个类，这个类我们完全可以当做基本数据类型使用，并且包装类除此之外，还提供了一些方法用法操作基本数据类型，这是基本数据类型所没有的。</p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>首先我们将如何进行装箱操作，即将基本数据类型转换为对象的包装类，下面全部以Integer为例，其余的同理，Integer对象的创建有两种方法，一种是通过构造方法，一种是通过Integer的一个静态方法</p>
<ul>
<li>构造方法<ul>
<li>Interger(int value)<ul>
<li>接收一个int类型的数值</li>
</ul>
</li>
<li>Interger(String str)<ul>
<li>接收一个字符串，该字符串要符合规定的格式，如”100”</li>
</ul>
</li>
</ul>
</li>
<li>静态方法<ul>
<li>valueOf()<ul>
<li>接收的参数同构造方法，也可以接收字符串类型的参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面演示如何创建Interger对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer in1 = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">Integer in2 = <span class="keyword">new</span> Integer(<span class="string">"20"</span>);</span><br><span class="line">Integer in3 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">Integer in4 = Integer.valueOf(<span class="string">"2000"</span>);</span><br><span class="line">System.out.println(in1 + <span class="string">" "</span> + in2 + <span class="string">" "</span> + in3 + <span class="string">" "</span> + in4);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">20</span> <span class="number">200</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>那如何通过包装类得到一个基本数据类型呢？通过intValue方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = in1.intValue();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>自从JDK 1.5以后就实现了自动装箱和拆箱，可以直接把基本数据类型赋值给包装类，也可以把包装类直接赋值给基本数据类型，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer num = <span class="number">10</span>; <span class="comment">//自动装箱 相当于 Integer num = new Interger(10)  不过现在是自动进行的了</span></span><br><span class="line"><span class="keyword">int</span> i = num; <span class="comment">//自动拆箱 相当于 int i = num.intValue()</span></span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型与字符串类型相互转换"><a href="#基本数据类型与字符串类型相互转换" class="headerlink" title="基本数据类型与字符串类型相互转换"></a>基本数据类型与字符串类型相互转换</h3><p>基本数据类型转换为字符串类型</p>
<ul>
<li>基本数据类型 + “”,如100 + “”得到”100”</li>
<li>包装类的toString(参数)，这个不是Onject的toString()方法，因为它有参数，不是重写<ul>
<li>如Integer.toString(100)得到”100”</li>
</ul>
</li>
<li>String类的valueOf(参数)方法，如String.valueOf(100)得到”100”</li>
</ul>
<p>字符串转基本数据类型</p>
<ul>
<li>包装类的parseXxx，如Integer.parseInt(“100”)得到基本数据类型100</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set接口也是Collection的子接口，它的实现类有HaseSet，LinkedHashSet，HashSet是无序的，LinkedHashSet是有序的。</p>
<h3 id="Set集合的特点"><a href="#Set集合的特点" class="headerlink" title="Set集合的特点"></a>Set集合的特点</h3><ul>
<li>集合中的元素不能重复</li>
<li>没有索引</li>
</ul>
<p>下面看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">//无序且不能重复 [1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见集合的顺序与添加的顺序无关，并且添加重复的元素是不行的。</p>
<blockquote>
<p>Set集合不能添加重复元素的原理：Set集合的底层原理是Hash表，首先会根据要添加的元素计算出它的哈希值，根据哈希值添加到数组中，数组中存储的是链表或者红黑树，元素会添加到数组里面的链表或者红黑树中。一般不同的元素会添加到数组的不同索引中，即不同的链表或红黑树中，但是也有可能虽然元素不同，但是它们的哈希值相同，这个就叫做哈希冲突。如果发生了哈希冲突，那么会使用equals()方法判断该链表或红黑树中是否存在与这个元素相同的元素，如果有，那么就不添加，如果没有，那么就添加。</p>
</blockquote>
<p>所以如果你要添加自定义的类型，那么就要重写Object类的hashCode()方法和equals()方法。</p>
<h3 id="Set集合的遍历"><a href="#Set集合的遍历" class="headerlink" title="Set集合的遍历"></a>Set集合的遍历</h3><p>Set由于它是无序的，所以它不能使用普通for循环遍历，所以只能使用</p>
<ul>
<li>迭代器</li>
<li>增强for</li>
</ul>
<p>由于与List差不多，这里就不在演示了。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet是HashSet的子类，但是它是有序的。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">"aaa"</span>);</span><br><span class="line">        set.add(<span class="string">"ccc"</span>);</span><br><span class="line">        set.add(<span class="string">"bbb"</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">//[aaa, ccc, bbb] 与添加的顺序相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数指的方法能够接受的参数可以为多个，定义格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型... 变量名</span><br></pre></td></tr></table></figure>

<p>它的底层原理是数组，会把这多个元素放到一个数组中。假设下面方法接受多个整数类型的参数，但是不知道能接受多少个，然后打印出这些数的和，那么就可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestKebiancanshu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... ints)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ints就是一个数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            sum += ints[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//可以传入多个参数，也可以不传 </span></span><br><span class="line">        sum(<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>一个方法只能有一个可变参数</li>
<li>一个方法如果有多个参数，可变参数要写在末尾</li>
</ul>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections是一个工具类，它提供了很多的静态方法用来对Collection集合进行操作。我们下面就简单介绍Collections类的三个方法</p>
<ul>
<li>addAll(Collection&lt;? super T&gt; c, T… elements)<ul>
<li>接收两个参数，第一个为Collection集合，第二个参数为可变参数</li>
<li>为集合添加多个元素，如addAll(list, 1, 2, 3)</li>
</ul>
</li>
<li>shuffle(List&lt;?&gt; list)<ul>
<li>接收一个List集合，将集合里面的元素随机打乱</li>
</ul>
</li>
<li>sort(List&lt;T&gt; list)<ul>
<li>接收一个list集合，将按照默认升序的规则排序</li>
<li>如果集合里面装的是自定义的类的对象，那么该类要实现Comaprable接口，并且要重写compareTo()方法</li>
</ul>
</li>
<li>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)<ul>
<li>接收一个List集合和一个实现Comparator接口的类的对象，可以传入匿名类</li>
</ul>
</li>
</ul>
<p>下面演示方法的使用</p>
<ul>
<li>addAll</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArratList&lt;&gt;();</span><br><span class="line">Collections.addAll(list1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(list1); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>shuffle</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">Collections.shuffle(list2);</span><br><span class="line">System.out.println(list2);  <span class="comment">//[6, 4, 3, 5, 2, 1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sort(List&lt;T&gt; list)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先演示对Integer类的排序</span></span><br><span class="line">List&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list3, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">Collections.sort(list3);</span><br><span class="line">System.out.println(list3); <span class="comment">//[1, 4, 5, 6, 7, 10]</span></span><br></pre></td></tr></table></figure>

<p>下面演示自定义类的排序，首先我们定义一个Person类，它有name和age属性，我们根据age的大小进行升序排序，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age; <span class="comment">//降序o.age - this.age</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试该类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>, <span class="number">18</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"刘亦菲"</span>, <span class="number">21</span>);</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list4, p1, p2, p3);</span><br><span class="line">Collections.sort(list4);</span><br><span class="line">System.out.println(list4);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Person&#123;name=<span class="string">'迪丽热巴'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'古力娜扎'</span>, age=<span class="number">20</span>&#125;, Person&#123;name=<span class="string">'刘亦菲'</span>, age=<span class="number">21</span>&#125;]</span><br></pre></td></tr></table></figure>

<ul>
<li>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</li>
</ul>
<p>这次我们不需要实现Comparable接口，只需要传入一个Comparator的实现类对象就可以，该类重写Comparator中的compare方法，在该方法中规定了排序的规则，我们可以传入一个匿名类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list5 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list5, p1, p2, p3);</span><br><span class="line">Collections.sort(list5, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list5);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Person&#123;name=<span class="string">'迪丽热巴'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'古力娜扎'</span>, age=<span class="number">20</span>&#125;, Person&#123;name=<span class="string">'刘亦菲'</span>, age=<span class="number">21</span>&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>之前我们介绍的集合如List，Set都是单列集合，下面我们将介绍双列集合Map，它是通过键K去寻找值V的，所以说它是一个双列集合。它是一个接口，它的常用子类有HashMap和LinkedHashMap。其中HashMap是无序的，即在集合中存储的顺序与你添加的顺序是不一致的。LinkedHashMap是有序，即添加顺序与保存的顺序相同。LinkedHashMap是HashMap的子类。我们之前介绍的HashSet类是调用HashMap实现的，它只利用了HashMap的K。</p>
<h3 id="Map集合的方法"><a href="#Map集合的方法" class="headerlink" title="Map集合的方法"></a>Map集合的方法</h3><p>下面介绍Map集合的常用方法</p>
<ul>
<li>put(key, value)<ul>
<li>向Map中添加一对键值对，由于Map集合中的key是不能重复的，如果Map中已经存在该key，那么将集合中该key所对应的value值替换为添加的value，即相当于更新，并且返回被替换的value值，如果该集合中不存在该key，那么将该键值对添加，并且返回null</li>
</ul>
</li>
<li>get(key)<ul>
<li>通过键值来获得对应的value值，如果集合不存在该key，那么返回null</li>
</ul>
</li>
<li>remove(key)<ul>
<li>根据键来删除该键值对，如果该key不存在，那么返回null，如果存在，那么返回对应的value值</li>
</ul>
</li>
<li>containsKey(key)<ul>
<li>判断集合中是否存在键key，有则返回true，否则返回false</li>
</ul>
</li>
</ul>
<p>下面简单演示这四个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里已经有"迪丽热巴"这个键了，所以对应的值会被更改为20，并将该值18返回</span></span><br><span class="line">        <span class="comment">//这里最好使用Integer接收，因为可能返回null 而基本数据类型不能被赋值为null</span></span><br><span class="line">        Integer val1 = map.put(<span class="string">"迪丽热巴"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(val1); <span class="comment">//18</span></span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;佟丽娅=20, 迪丽热巴=20, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过键去获得值</span></span><br><span class="line">        Integer val2 = map.get(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        System.out.println(val2); <span class="comment">//19</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除键"佟丽娅"对于的键值对</span></span><br><span class="line">        Integer val3 = map.remove(<span class="string">"佟丽娅"</span>);</span><br><span class="line">        System.out.println(val3); <span class="comment">//20</span></span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;迪丽热巴=20, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否包含键"佟丽娅"</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">"佟丽娅"</span>)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历Map集合"><a href="#遍历Map集合" class="headerlink" title="遍历Map集合"></a>遍历Map集合</h3><p>主要有两个方法用来遍历Map集合</p>
<ul>
<li>keySet<ul>
<li>该方法会返回Set集合，里面是key的值，然后我们可以遍历该Set集合来遍历Map集合</li>
</ul>
</li>
<li>entrySet<ul>
<li>该方法也返回一个Set集合，不过这个集合里面的是Entry对象，Entry是Map的内部类，该类会在添加键值对时创建一个Entry对象保存相应的key和value的信息，我们可以通过Entry对象的getKey()和getValue()方法来获得键和值。同样我们可以遍历该Set集合来遍历Map集合</li>
</ul>
</li>
</ul>
<p>下面演示两个方法的使用</p>
<ul>
<li>keySet</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">"迪丽热巴"</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">"古力娜扎"</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">"佟丽娅"</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得key的Set集合</span></span><br><span class="line">        Set&lt;String&gt; set1 = map.keySet();</span><br><span class="line">        <span class="comment">//遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span> (String set: set1) &#123;</span><br><span class="line">            System.out.println(set + <span class="string">"="</span> + map.get(set));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Entry对象组成的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set2 = map.entrySet();</span><br><span class="line">        <span class="comment">//遍历该集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; set : set2) &#123;</span><br><span class="line">            System.out.println(set.getKey() + <span class="string">"="</span> + set.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">佟丽娅=<span class="number">20</span></span><br><span class="line">迪丽热巴=<span class="number">18</span></span><br><span class="line">古力娜扎=<span class="number">19</span></span><br><span class="line">佟丽娅=<span class="number">20</span></span><br><span class="line">迪丽热巴=<span class="number">18</span></span><br><span class="line">古力娜扎=<span class="number">19</span></span><br></pre></td></tr></table></figure>


<h2 id="斗地主案例练习"><a href="#斗地主案例练习" class="headerlink" title="斗地主案例练习"></a>斗地主案例练习</h2><p>该案例模拟斗地主的发牌和看牌过程，加强对集合的使用。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们要使用Map&lt;Integer, String&gt;集合来保存一副扑克，Integer是索引，String是对应的扑克牌。我们通过索引去找牌，到时候把索引发给玩家就可以，这样因为玩家拿到的是索引，那么就可以进行排序。我们首先要创建一副扑克，可以使用两个String数组，一个保存花色，一个保存数字，然后通过循环组合两个数组来组合一副扑克牌。因为我们要进行排序，所以Integer的大小和牌的大小要一一对应，即0对应大王，1对应小王，2-5对应四个2，以此类推。洗牌我们可以使用Collections的shuffle()方法，由于该方法要求传入List集合，我们要创建一个List集合，该集合要保存Integer索引。发牌就把索引发给玩家，玩家通过索引去Map集合中看牌。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doudizhu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用两个数组组合形成一幅扑克牌</span></span><br><span class="line">        String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line">        String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将扑克牌存储到Map集合中，键为整数索引，方便排序，值为牌，通过索引拿牌</span></span><br><span class="line">        Map&lt;Integer,String&gt; poker = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为使用Collections.shuffle方法洗牌，所以要使用List集合存储索引</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将大小王添加到Map中，并将索引添加到List中</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        poker.put(index,<span class="string">"大王"</span>);</span><br><span class="line">        list.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        poker.put(index,<span class="string">"小王"</span>);</span><br><span class="line">        list.add(index);</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个数组组合形成一副牌</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                poker.put(index,color+number);</span><br><span class="line">                list.add(index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; player1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发牌，将索引发给玩家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipai.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                player1.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                player2.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                player3.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给牌排序</span></span><br><span class="line">        Collections.sort(player1);</span><br><span class="line">        Collections.sort(player2);</span><br><span class="line">        Collections.sort(player3);</span><br><span class="line">        Collections.sort(dipai);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看牌</span></span><br><span class="line">        lookPoker(player1,poker,<span class="string">"刘德华"</span>);</span><br><span class="line">        lookPoker(player2,poker,<span class="string">"周润发"</span>);</span><br><span class="line">        lookPoker(player3,poker,<span class="string">"周星驰"</span>);</span><br><span class="line">        lookPoker(dipai,poker,<span class="string">"底牌"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看牌方法 通过玩家的索引去Map集合中找到对应的牌  并打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookPoker</span><span class="params">(ArrayList&lt;Integer&gt; list, Map&lt;Integer,String&gt; poker,String name)</span> </span>&#123;</span><br><span class="line">        System.out.print(name + <span class="string">"的牌是： "</span>);</span><br><span class="line">        <span class="comment">//通过玩家的索引，去poker中取牌</span></span><br><span class="line">        <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">            System.out.print(poker.get(number) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java22.gif"/>
</center>


    

        <a href="https://lastknightcoder.gitee.io/Java%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-Java面向对象"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-07-05 00:00:00" datetime="2019-07-04T16:00:00.000Z"  itemprop="datePublished">2019-07-05</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">Java面向对象</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <p>在最初的开始，人们编写程序的基于过程的，那时候的编程方式是面向过程的。但是人们发现，随着代码规模的扩大，编写大规模的程序使用面向过程的方法十分的困难，这时候人们必须提出一种新的编程思想，使得编写大型程序变得简单。这种思想就是面向对象的思想。</p>
<p>就像我们学习数学一样，随着我们学习的深入，我们一直在进行抽象，比如从数抽象到代数，并且不断提出新的概念，提出很多的定理，方便我们的学习研究。面向对象也是一样，它把实际中的事物抽象出来，这个事物可以是我们见到的实物，比如椅子，桌子，手机，也可以是我们我们看不见的东西，比如某个系统。这个抽象出来的东西我们叫做类，我们利用类的概念，可以清楚的把握类与类之间的关系，使得程序的结构十分的清晰，便于管理，便于开发大型的程序。</p>
<p>我们把抽象出来的东西叫做类，那么一个类的实例就是对象。比如，我们把人抽象为了一个类，这是一个抽象的概念，那么小明这个具体的人就是该类的一个实例，也叫做对象。我们把椅子抽象为一个类，一个具体的椅子就是一个对象。类可以看做是对象的模板，对象可以看做是类的具体实现。</p>
<p>我们可以通过两个方面是描述一个事物，一个是属性，比如说对于人这个类，它的属性就有姓名，身高，年龄等等，这些都是它的属性，另一个就是行为，比如说人的行为有吃饭，睡觉等等。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类使用关键字class进行定义，我们在之前用过很多次，但是我们之前不知道这是什么，比如在HelloWorld案例中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中HelloWorld表示的就是类名。类定义的格式是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面我们有提到，一个事物可以由属性和行为两部分描述，表现在程序书写中为成员变量和成员方法，其中变量用来描述类的属性，方法用来描述类的行为，前面加上成员二字以表示与局部变量的不同，例如下面定义了一个Person类，它有姓名，年龄属性，有吃和睡的行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃吃吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡睡睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到成员变量时定义在类当中的，并且成员方法没有使用关键字static修饰。</p>
<p>我们定义了一个类，那我们怎么使用它呢? 从前面我们了解到，类是一个抽象的概念，是一个模板，我们要将它具体化才能够使用它，类是不能够直接使用的，而具体化的过程就是创建一个对象。创建对象的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名称 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>例如下面创建一个per的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃吃吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡睡睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Person per = <span class="keyword">new</span> Person(); <span class="comment">//创建一个名为per的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建这个对象的模板是Person类，那么它就应该有name, age属性和eat, sleep行为，那么我们怎么去使用这些东西呢? 方法就是通过点语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.属性 <span class="comment">//使用属性</span></span><br><span class="line">对象名.方法() <span class="comment">//使用方法</span></span><br></pre></td></tr></table></figure>

<p>例如下面我们打印出per对象的属性值，并且调用它的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person per = <span class="keyword">new</span> Person(); <span class="comment">//创建一个名为per的对象</span></span><br><span class="line">    System.out.println(per.name);</span><br><span class="line">    System.out.println(per.age);</span><br><span class="line">    per.eat();</span><br><span class="line">    per.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">吃吃吃</span><br><span class="line">睡睡睡</span><br></pre></td></tr></table></figure>

<p>我们发现per.name的值是null，per.age的值是0，实际上我们并没有给per.name和per.age赋值，系统在创建对象时会有默认值，规则和数组的一样。</p>
<h2 id="类的内存模型"><a href="#类的内存模型" class="headerlink" title="类的内存模型"></a>类的内存模型</h2><p>我们来看看执行下面的代码，在内存中发生了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃吃吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡睡睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person(); <span class="comment">//创建一个名为per的对象</span></span><br><span class="line">        System.out.println(per.name);</span><br><span class="line">        System.out.println(per.age);</span><br><span class="line">        per.eat();</span><br><span class="line">        per.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器首先会在方法区中找main方法，然后将它推入栈中</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java08.png"/>
</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>这行语句会在main中创建一个per变量，接着会在堆中开辟出一块空间，存储的是per这个对象，这个对象是以方法区中的类为模板的，该对象具有成员变量和成员方法。但是注意的是，对象的成员方法是地址值，指向方法区中的方法的信息，当调用方法时，会根据该地址值去方法区中寻找该方法。由于每个对象的行为都是一样的，只是属性不同，所以不需要在堆中为每一个对象都开辟空间来保存方法的信息，只需要保存一个地址值即可。这样做可以节省内存空间。</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java09.png"/>
</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(per.name);</span><br><span class="line">System.out.println(per.age);</span><br><span class="line">per.eat();</span><br><span class="line">per.sleep();</span><br></pre></td></tr></table></figure>

<p>上面的语句是访问对象的成员变量和成员方法，首先会根据per对象保存的地址值，去堆中寻找对应的保存地址，然后根据成员变量名去访问数据。调用成员方法，分为了四步，第一步是根据per对象的地址值找到堆中的方法；第二步，堆中的方法保存的地址值，根据堆中的地址值去方法区中查找方法的信息；第三步，将方法压入栈中，栈会为该方法开辟一块空间；第四步，方法执行完毕，方法被栈移除。</p>
<h2 id="对象与方法"><a href="#对象与方法" class="headerlink" title="对象与方法"></a>对象与方法</h2><p>对象作为一种数据类型，它也可以作为方法的参数和返回值。与数组一样，传递的是地址值，返回的也是地址值。</p>
<h3 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printObject</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line">    System.out.println(per.name);</span><br><span class="line">    System.out.println(per.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象作为返回值"><a href="#对象作为返回值" class="headerlink" title="对象作为返回值"></a>对象作为返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPersonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person per = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><p>成员变量与局部变量的区别</p>
<ul>
<li><strong>定义的位置不一样</strong><ul>
<li>局部变量：定义在方法中</li>
<li>成员变量：定义在方法之外，定义在类中</li>
</ul>
</li>
<li><strong>作用范围不一样</strong><ul>
<li>局部变量：只能在方法中使用</li>
<li>成员变量：在类中都可以使用</li>
</ul>
</li>
<li><strong>默认值</strong><ul>
<li>局部变量：没有默认值</li>
<li>成员变量：有默认值，规则同数组</li>
</ul>
</li>
<li>在内存中的位置不一样<ul>
<li>局部变量：在栈内存中</li>
<li>成员变量：在堆内存中</li>
</ul>
</li>
<li>生命周期<ul>
<li>局部变量：随着方法的进栈而产生，随着方法的出栈而消失</li>
<li>成员变量：随着对象的创建而产生，随着对象的被垃圾回收而消失</li>
</ul>
</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象有三大特性，分别为</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<p>下面详细讲述其中的封装。</p>
<p>我们知道，当我们创建了一个对象之后，可以通过点(.)语法去访问成员变量，也可以为它赋值，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.name = <span class="string">"李四"</span>;</span><br><span class="line">        per.age = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我叫做：李四，我：<span class="number">20</span>岁。</span><br></pre></td></tr></table></figure>

<p>但是一旦我们将成员变量使用修饰符private修饰的话，那么我们就不能通过.语法访问成员变量了，如下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.name = <span class="string">"李四"</span>; <span class="comment">//编译成功</span></span><br><span class="line">        per.age = <span class="number">20</span>; <span class="comment">//编译成功</span></span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现怎么使用private修饰的变量怎么还可以访问，不是说不可以访问了吗? 这是因为main方法是Person类的方法，在一个类里面是可以随便访问的，现在有一个Test类，然后我们去访问数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.name = <span class="string">"李四"</span>; <span class="comment">//编译失败</span></span><br><span class="line">        per.age = <span class="number">20</span>; <span class="comment">//编译失败</span></span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private就是私有的意思，意味的这个变量的私密的，外部不可以访问，如果要访问的话，只能通过getter和setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String who)</span></span>&#123;</span><br><span class="line">        name = who;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在Test类中创建Person对象访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person();</span><br><span class="line">        per.setName(<span class="string">"李四"</span>); <span class="comment">//通过setter方法去设置成员变量的值</span></span><br><span class="line">        per.setAge(<span class="number">20</span>); <span class="comment">//通过setter方法去设置成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">"我叫做："</span> + per.name +<span class="string">"，我："</span> + per.age + <span class="string">"岁。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我叫做：李四，我：<span class="number">20</span>岁。</span><br></pre></td></tr></table></figure>

<p>明显可见，下面的代码量比上面大了很多，感觉这么做是多此一举，那么为什么要这么做呢？考虑下面这么一种情况，如果没有进行封装，那么我们可以使用<code>.</code>语法为age变量赋值，我们可以赋值为-20，这明显是不合理的，但是可以进行赋值，如果我们进行封装，那么我们可以在setter方法中进行判断，使得一些不合理的，有害的操作不能够正常赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getter方法和setter方法的格式一般为”get变量名”或”set变量名”，根据驼峰命名法，变量名首字母需要大写，如上面的setAge, getAge。但是如果getter方法的返回值是boolean类型的话，我们一般写成isXxx的形式。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>考虑上例我们的setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String who)</span></span>&#123;</span><br><span class="line">    name = who;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我一直想写成这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的想法是第一个name是成员变量name，第二个name是传入的参数，但是这样不行，因为这时的两个name都被看做是传入的参数，那有什么办法可以解决成员变量与局部变量重名的问题吗？方法就是使用this关键字，修改上面代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时this.name就代表的是成员变量name。那么this到底是个什么东西？<strong>哪个对象调用这个方法，那么this就是调用这个方法的对象</strong>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">per.setName(<span class="string">"李四"</span>);</span><br></pre></td></tr></table></figure>

<p>per这个对象调用setName方法，那么这时的this就是per。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法其实就是创建对象的方法，用new在创建对象，就是在调用这个方法。还记得我们是怎么创建对象的吗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>其中Person()就是构造方法。</p>
<h3 id="构造方法的定义"><a href="#构造方法的定义" class="headerlink" title="构造方法的定义"></a>构造方法的定义</h3><p>构造方法定义的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>构造方法名要与类名的完全一样，包括大小写</li>
<li>不要写返回值类型，void也不要写</li>
<li>不能return一个具体的返回值</li>
</ul>
<p>构造方法同成员方法一样，是定义在类中的，但是我们好像到现在从来没有定义过构造方法，但是我们却可以使用，这时为什么？</p>
<ul>
<li>如果我们没有编写构造方法，那么编译器会为我们自动生成一个构造方法，该构造方法没有参数，方法体为空，比如像这样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是一旦当我们定义了一个构造方法，那么编译器不会自动生成一个构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>,name = name;</span><br><span class="line">    <span class="keyword">this</span>,age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义个一个构造方法，此时总共就这一个构造方法，编译器不会自动生成。但是我们一般还会写一个无参的构造方法，继承那里会讲到为什么。</p>
<ul>
<li>构造方法也可以进行重载，在上面我们已经演示了</li>
</ul>
<h3 id="利用构造方法进行初始化"><a href="#利用构造方法进行初始化" class="headerlink" title="利用构造方法进行初始化"></a>利用构造方法进行初始化</h3><p>我们一般可以利用构造方法进行初始化，注意我们之前初始化都是这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person();</span><br><span class="line">per.setName(<span class="string">"李四"</span>);</span><br><span class="line">per.setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们定义一个有两个参数的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以这么调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>这一行的代码与上面三行代码的效果是一样的。</p>
<h2 id="一个标准的类"><a href="#一个标准的类" class="headerlink" title="一个标准的类"></a>一个标准的类</h2><p>一个标准的类应该满足一下特点</p>
<ul>
<li>所有的成员变量都使用private修饰</li>
<li>为每一个成员变量编写一个setter,getter方法</li>
<li>编写一个无参构造函数</li>
<li>编写一个有参构造函数</li>
</ul>
<p>一个标准的类也叫做Java Bean。</p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>所谓的匿名对象，指的就是没有名字的对象。即在创建对象时，并没有为它赋予变量名。由于它没有名字，没有变量保存它的地址，所以它只能够使用一次，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().age;</span><br></pre></td></tr></table></figure>

<p>如果某个对象只使用一次的话，我们可以考虑使用匿名对象。</p>
<h3 id="匿名对象作为方法的参数"><a href="#匿名对象作为方法的参数" class="headerlink" title="匿名对象作为方法的参数"></a>匿名对象作为方法的参数</h3><p>匿名对象也是对象，当然可以作为方法的参数。匿名对象传入方法的是地址值，下面举一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getNum方法接收一个Scanner对象，返回一个int类型的数值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(Scanner sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入了一个匿名对象</span></span><br><span class="line">        <span class="keyword">int</span> num = getNum(<span class="keyword">new</span> Scanner(System.in));</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行效果为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java10.gif"/>
</center>

<h3 id="匿名对象作为方法的返回值"><a href="#匿名对象作为方法的返回值" class="headerlink" title="匿名对象作为方法的返回值"></a>匿名对象作为方法的返回值</h3><p>匿名对象也可以作为方法的返回值，返回的也是地址值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个Scanner对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">getScannerObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//GetScannerObject方法返回一个Scanner对象</span></span><br><span class="line">        Scanner sc = getScannerObject();</span><br><span class="line">        String str = sc.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行效果为</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java11.gif"/>
</center>

<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static关键字我们在之前见到过很多次了，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在定义方法时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都用到static，而在成员方法中却没有用到static，所以这里我们就来看看static到底是什么，它有什么用。</p>
<h3 id="static修饰符的作用"><a href="#static修饰符的作用" class="headerlink" title="static修饰符的作用"></a>static修饰符的作用</h3><p>一旦被static修饰，不管是变量还是方法，那么这么变量或方法不再是属于某个对象的，而是属于类，相当于说被static修饰之后，就不是某个人的私有财产，而是大家的公共财产。被static修饰的变量和方法分别叫做静态变量和静态方法。</p>
<p>访问static修饰的变量或方法，可以通过.语法，可以通过类名.，也可以通过对象名.。以前我们调用成员变量和成员方法就是通过对象名<code>.</code>出来的。但是这里推荐使用类名.，这样大家一眼就可以看出这是共有财产而不是私有财产。而且即使你使用了对象名.，在编译器编译时也会自动转换为类名.。</p>
<p>为了理解static修饰符，我们来看这么一个例子。假设有一个Student类，里面有一个id成员变量，我们希望每当创建一个对象时，会自动赋予id变量一个值，比如说，如果one第一个创建的学生，那么它的id就是1，以此类推。我们可以使用一个static变量idCounter来计数，每创建一个对象它就加一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idCounter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每创建一个对象，id计数器加一，并且赋给id</span></span><br><span class="line">        <span class="keyword">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">//每创建一个对象，id计数器加一，并且赋给id</span></span><br><span class="line">        <span class="keyword">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student one = <span class="keyword">new</span> Student(<span class="string">"one"</span>);</span><br><span class="line">        System.out.println(<span class="string">"我的名字是："</span> + one.name + <span class="string">"我的id是："</span>  + one.id);</span><br><span class="line">        Student two = <span class="keyword">new</span> Student(<span class="string">"two"</span>);</span><br><span class="line">        System.out.println(<span class="string">"我的名字是："</span> + two.name + <span class="string">"我的id是："</span>  + two.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我的名字是：one我的id是：<span class="number">1</span></span><br><span class="line">我的名字是：two我的id是：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这里我要解释一下，为什么有的方法使用static修饰了，我们知道，如果使用static修饰，该方法就可以通过类<code>.</code>出来，如果这个方法是本类的，那么类名可以省略不写。比如这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在这里调用add方法，属于同一个类，可以省略类名</span></span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要直接在main方法中直接使用这个方法，我们就会使用static修饰。这里只是解释前面为什么有的方法要使用static修饰，因为我们希望直接调用。</p>
<p>这里有关static有几个需要注意的事项</p>
<ul>
<li>静态只能访问静态，静态不能访问非静态。即在静态方法里面，不能访问成员变量，也不能调用成员方法。这时因为在内存中，先有静态内容，后有非静态内容。”先人不知后人，后人知道先人”。</li>
<li>静态方法中不能使用this。我们知道，谁调用这个方法，那么this就是这个对象。但是调用静态方法是类，而不是对象，即使使用对象调用静态方法，编译器在编译时也会转换为类调用。</li>
</ul>
<h3 id="static的内存图"><a href="#static的内存图" class="headerlink" title="static的内存图"></a>static的内存图</h3><p>在方法区中有一块内存空间，专门用以保存静态变量的</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java12.png"/>
</center>

<p>从上面的图可以看出来，静态变量与对象没有任何关系。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块的格式是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码块写在类中。它的特点是在第一次创建对象的时候执行唯一的一次。后面在创建对象不会再执行。它先于构造方法的执行。它的作用一般是为了初始化静态变量。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承，主要解决的是共性抽取。子类继承了父类，就拥有父类所有的成员变量和成员方法。除此之外，子类还可以拥有自己的内容。子类与父类的关系，可以这么理解：子类就是一个父类。比如父类是人，子类是学生，子类就是父类说的就是<strong>学生是人</strong>。也叫is-a关系。</p>
<h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>子类通过extends关键字基础父类，而父类的定义与一般类的定义相同，现在假设有一个父类Person和一个子类Student。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//子类拥有父类的成员变量和成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类访问父类成员变量"><a href="#子类访问父类成员变量" class="headerlink" title="子类访问父类成员变量"></a>子类访问父类成员变量</h3><p>上面讲过，一旦子类继承了父类，那么子类就拥有子类的所有成员变量和成员方法。那么子类怎么访问父类的成员变量，这里分为重名和不重名两种</p>
<ul>
<li>不重名<ul>
<li>这种情况最简单，这时是直接用子类对象<code>.</code>父类的成员变量就可以访问</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.name;</span><br><span class="line">stu.age;</span><br></pre></td></tr></table></figure>

<ul>
<li>重名<ul>
<li>直接<ul>
<li>如果使用子类对象<code>.</code>的话，访问的就是子类的成员变量</li>
</ul>
</li>
<li>间接<ul>
<li>间接指的就是通过成员方法访问，此时举个例子说明</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>假设父类有一个<code>int num;</code>，子类也有一个<code>int num;</code>。现在父类有一个showA方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果子类对象调用这个方法的话，那么使用的就是父类的num。现在如果子类有一个showB方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子类对象调用这个方法，那么使用就是子类的num。简而言之，方法属于谁，就用谁的。</p>
<h3 id="区分三种变量"><a href="#区分三种变量" class="headerlink" title="区分三种变量"></a>区分三种变量</h3><p>这三种变量指的就是</p>
<ul>
<li>父类的成员变量</li>
<li>子类的成员变量</li>
<li>局部变量</li>
</ul>
<p>之前我们讲过区分局部变量和成员变量，我们使用this关键字加以区分。现在假设在子类的一个成员方法中，父类，子类有成员变量name，而该方法也有一个局部变量，这时我们这么区分，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.name;      <span class="comment">//父类的name</span></span><br><span class="line"><span class="keyword">this</span>.name;       <span class="comment">//子类的name</span></span><br><span class="line">name             <span class="comment">//局部变量name</span></span><br></pre></td></tr></table></figure>

<p>同理，如果子类有成员方法和父类的一个成员方法重名的话，如果我们想在子类的某个成员方法中使用父类的这个成员方法的话，我们可以使用super.父类方法()调用。super这个关键字指的就是父类对象。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>之前我们有多次提到重写的概念，那么重写是什么? 重写指的就是子类的某个方法与父类的方法的方法名称一样，参数列表也一样，相当于把父类的这个方法覆盖了。当我们使用子类对象.这个方法时，优先使用子类的方法。</p>
<p>重写的方法需要满足一定的要求，如下：</p>
<ul>
<li>必须父子类方法名相同，参数列表相同</li>
<li>子类方法的返回值范围要小于父类方法(Object &gt; String)</li>
<li>子类方法的权限必须大于等于父类的权限操作符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权限修饰符的大小熟悉怒</span></span><br><span class="line"><span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; (<span class="keyword">default</span>) &gt; <span class="keyword">private</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>有一个注解，@Override，把它放在要重写的方法前面，可以检查是否重写正确，比如你重写的方法漏掉了一个字母，这相当于你自己有了一个新的成员方法，并不是重写，编译器不会报错，这可能会造成问题，因为你是想重写的。但是你如果在方法前面加上@Override，它会检查这个方法是不是重写，如果不是会报错。这个是可选的，但是推荐使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>    <span class="comment">//写在方法的前面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承中的构造方法"><a href="#继承中的构造方法" class="headerlink" title="继承中的构造方法"></a>继承中的构造方法</h3><p>为了讲解清楚，假设有两个类，一个是Person类，是父类，另一个是Student类，是子类。两个方法的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的构造方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我要讲的是，在子类构造方法的第一行，默认有<code>super();</code>，这个代表调用父类的构造方法，即在调用子类构造方法时，会先调用父类的无参构造方法，现在我们创建一个Student对象，看看打印输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtends</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是父类的构造方法</span><br><span class="line">我是子类的构造方法</span><br></pre></td></tr></table></figure>

<p>可见是默认会调用父类的无参构造方法。所以我们在之前建议为类写一个无参的构造方法，因为在创建子类对象时会先调用父类的无参构造方法，如果父类没有的话，会报错。</p>
<p><strong>注意：</strong></p>
<ul>
<li>super调用必须是第一个语句，比如下面会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是子类的构造方法"</span>);</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//会报错，因为不是第一个语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这也意味着在方法中只能调用一次super()方法，因为第二个super不是第一个语句了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"name"</span>,<span class="number">12</span>);  <span class="comment">//假设父类有一个有参构造方法 由于不是第一个语句，报错</span></span><br><span class="line">                       <span class="comment">//这意味着只能调用一个super()方法</span></span><br><span class="line">    System.out.println(<span class="string">"我是子类的构造方法"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>this()可以调用本类的构造方法，this()也必须是第一个语句，所以this()和super()不能同时出现。</li>
<li>如果父类有有参数的构造方法，我们可以在子类的构造方法中显式的调用该方法，如上面super(“name”,12)，这个时候就不会默认调用无参的构造方法。所以父类中没有无参的构造方法不一定会报错。建议最好还是写一个吧，即使什么都没有，有特殊需求的除外。</li>
</ul>
<h3 id="继承的三个特征"><a href="#继承的三个特征" class="headerlink" title="继承的三个特征"></a>继承的三个特征</h3><ul>
<li>Java语言是单继承的，只能有一个直接父类</li>
<li>可以有多级继承，继承的源头是Object</li>
<li>一个子类的直接父类是唯一的，但是可以有多个子类</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽样方法：使用关键字abstract修饰的方法，抽象方法没有方法体，直接大括号结束。抽样方法所在的类必须是抽样类，抽样类的定义是在class前面加abstract。</p>
<p>如下定义了一个抽样类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eat(), sleep()方法是抽样方法，没有方法体，直接分号结束。</p>
<p><strong>注意：</strong></p>
<ul>
<li>不能直接创建抽象类对象，应当用一个类继承该抽象类，该类必须重写所有的抽象方法，如果该类没有重写所有的抽象方法，那么该类也必须是抽象类。</li>
<li>抽象类可以有构造方法，给抽象类的成员变量初始化</li>
<li>抽样类不一定要有抽象方法，但是含抽象方法的类必须是抽象类</li>
</ul>
<p>如下创建一个Dog类继承抽象类Animal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪汪..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"呼呼呼..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">汪汪汪...</span><br><span class="line">呼呼呼...</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是公共的规范标准。</p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>我们类的定义是使用class关键字，而接口的定义是使用interface关键字。如下定义了一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口里面可以有什么，这与版本有关。</p>
<ul>
<li>Java 7<ul>
<li>常量</li>
<li>抽象方法</li>
</ul>
</li>
<li>Java 8(新增)<ul>
<li>默认方法</li>
<li>静态方法</li>
</ul>
</li>
<li>Java 9(新增)<ul>
<li>私有方法</li>
</ul>
</li>
</ul>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ul>
<li>接口不能够直接使用，需要一个类去实现它。我们在之前使用extends去继承一个类，而实现一个接口使用implements关键字，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现必须实现接口中的所有抽样方法。如果没有全部实现，那么该类必须为抽样类</li>
<li>创建实现类对象使用</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>接口中的抽样方法的修饰符必须是public abstract，所这两个关键字可以省去，如下的写法都是对的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//不省略</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//只省略public</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;   <span class="comment">//只省略abstract</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;          <span class="comment">//两个都省略</span></span><br></pre></td></tr></table></figure>

<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>默认方法的定义为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值 方法名(参数列表) &#123; <span class="comment">//修饰符必须是public，所以public可以省略</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认方法就要解决的是升级问题。假设你要升级一个接口，如果你添加一个抽象方法的话，那么由于实现类没有实现该抽象方法，那么实现类就不能使用，这样是不合理的。但是添加默认方法的话，实现类不需要实现该方法，实现类可以正常的使用，并且可以通过实现类对象调用该默认方法。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法的定义为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值 方法名(参数列表)&#123; <span class="comment">//同default方法，public可以省略</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类不能直接调用静态方法，只能通过接口<code>.</code>静态方法调用。因为一个实现类是可以同时实现多个接口的，如何多个接口有相同的静态方法，那么通过实现类调用静态方法，那么调用哪个呢？所以实现类是不能直接调用静态方法的。不同于继承，因为继承只有一个直接父类。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>私有方法是为解决代码重复问题的。假设有两个默认方法，这两个默认方法的代码重复很多，那我们想着可以把重复的代码抽出来形成一个新的方法，然后在这两个默认方法中调用这个新方法就可以。但是这个新方法是一个中间方法，应当是只能在接口内才能够被调用，所以不能是默认方法。这个方法应该被定义为私有方法。</p>
<p>私有方法分为两类</p>
<ul>
<li>普通私有方法<ul>
<li>解决默认方法代码重复问题，只使用private修饰</li>
</ul>
</li>
<li>静态私有方法<ul>
<li>解决静态方法代码重复问题，使用private static修饰</li>
</ul>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>接口中也能定义”成员变量”，只不过必须使用public static final修饰，final代表的就是不可变的意思，所以就相当于是一个常量。接口中的常量必须进行赋值，不能不赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>；</span><br></pre></td></tr></table></figure>

<p>对于常量，我们采用所有字母大写，并且单词之间使用下划线分割。接口使用常量的方法是接口<code>.</code>常量，原因同静态方法一样。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>接口没有静态代码块和构造方法</li>
<li>一个类可以同时实现多个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">... implements 接口<span class="number">1</span>，接口<span class="number">2</span>，...</span><br></pre></td></tr></table></figure>

<ul>
<li>如果实现的两个接口有相同的抽象方法，只需要实现一个即可</li>
<li>不能没有实现所有的抽象方法，那么就必须是抽象类</li>
<li>如果实现的两个接口有重复的默认方法，那么实现类必须重写该默认方法</li>
<li>一个类的直接父类与接口的默认方法重复的话，优先使用直接父类的方法</li>
<li>接口与接口之间多继承的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口 extends 接口<span class="number">1</span>，接口<span class="number">2</span>，...</span><br></pre></td></tr></table></figure>

<p>如果继承的多个接口默认方法重复，那么必须重写，且重写的方法必须为默认方法。如果抽象方法重复，只继承一个。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>继承和实现接口是多态的基础。</p>
<h3 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h3><p>多态的定义就是父类引用指向子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类 对象名 = <span class="keyword">new</span> 子类();</span><br><span class="line">接口 对象名 = <span class="keyword">new</span> 实现类();</span><br></pre></td></tr></table></figure>

<p>如假设有一个父类Person和一个子类Student如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name = <span class="string">"父类"</span>;	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name = <span class="string">"子类"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我使用多态的写法，创建一个Student对象指向Person引用，并且调用show方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muti</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Student();</span><br><span class="line">        per.show();</span><br><span class="line">        </span><br><span class="line">        System.out.println(per.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时的输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是子类的show方法</span><br><span class="line">父类</span><br></pre></td></tr></table></figure>

<p>是不是有点难以理解上面的输出，下面讲解一下为什么会有上面的输出。</p>
<h3 id="多态访问成员变量和成员方法的规则"><a href="#多态访问成员变量和成员方法的规则" class="headerlink" title="多态访问成员变量和成员方法的规则"></a>多态访问成员变量和成员方法的规则</h3><h4 id="访问成员方法的规则"><a href="#访问成员方法的规则" class="headerlink" title="访问成员方法的规则"></a>访问成员方法的规则</h4><ul>
<li>如果多态写法创建的对象，调用成员方法时，在编译时看左边，即看父类有没有这个方法，如果父类没有，那么会报错，如下面我在Student中新建了一个子类特有的方法，如果使用per对象调用的话，将会发生错误。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"子类"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAgain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类特有的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java13.jpg"/>
</center>

<p>我们观察到程序报错了，因为父类并没有这个方法。</p>
<ul>
<li>在运行时看右边，即如果这个方法子类重写了，那么调用子类的方法，我们在上面也看到了，输出的是子类的方法</li>
<li>口诀：”编译看左边，运行看右边”</li>
</ul>
<h4 id="访问成员变量的规则"><a href="#访问成员变量的规则" class="headerlink" title="访问成员变量的规则"></a>访问成员变量的规则</h4><p>访问成员变量的规则与访问成员方法的规则不同。</p>
<ul>
<li>访问成员变量时，编译时的规则也一样，如果父类没有该变量，则访问不了该变量。访问不了子类的变量。</li>
<li>即使子类中的成员变量与父类中的成员变量重名，那么访问的也是父类的成员变量，在上面我们已经看到了，我们在打印输出name是输出的是父类的成员变量。</li>
<li>口诀：”编译看左边，运行也看左边”</li>
</ul>
<h3 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h3><p>对象转型分为向上转型和向下转型。</p>
<h4 id="对象向上转型"><a href="#对象向上转型" class="headerlink" title="对象向上转型"></a>对象向上转型</h4><p>多态就是向上转型，因为是子类对象指向父类的引用。创建的是子类的对象，但是使用却是当做父类对象使用。多态有一个明显的弊端就是无法使用子类特有的方法和子类的成员变量。</p>
<h4 id="对象向下转型"><a href="#对象向下转型" class="headerlink" title="对象向下转型"></a>对象向下转型</h4><p>我们提到了多态的弊端，但是我就是要使用子类的特有方法怎么办，这个时候我们可以使用向下转型，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu = (Student) per; <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure>

<p>这样我们就可以使用Student对象特有的方法了，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        Student stu = (Student) per;</span><br><span class="line">        stu.showAgain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是子类特有的方法</span><br></pre></td></tr></table></figure>

<p>但是，向下转型要注意，我原来是Student对象才能转为Student对象，我如果原来不是，那么运行时会抛出异常，如下面我创建一个Teacher继承了Person，现在我要把per强行转型为Teacher对象</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java14.png"/>
</center>

<p>我们观察到，在编译时并没有报错，现在我们来运行一下</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java15.png"/>
</center>

<p>抛出了ClassCastException异常，意思是类型转换异常。所以向下转型不安全。</p>
<p>那我们为什么不直接创建一个子类对象指向子类呢？何必多次一举使用多态写法然后又给转回来呢? 我们来看这么一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Person per)</span></span></span><br></pre></td></tr></table></figure>

<p>这个类的方法参数只要求是Person就可以，它不管你是Student还是Teacher，所以如果我们把Student对象传进去，这是不是多态的写法，如果我们在里面要用到Student特有的方法，我们是不是要向下转型。</p>
<p>其实常常我们使用接口作为参数，表示的意思就是我才不管你是什么，你只有实现我的接口就可以了，那么我就可以使用你了。比如有一个接口叫做USB，那么传进来的参数，你只要实现了我们USB接口就可以，不管你是鼠标实现了还是键盘实现了，你只要实现了，我就可以用。这就是多态的用法啊。</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>上面我们说了，对象的向下转型是有风险的，因为如果我不是Student你给我转给Student那么会抛出异常的。现在instanceof关键字可以解决这个问题，他可以判断多态创建的父类引用为哪个子类。具体用法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">多态创建的父类引用 <span class="keyword">instanceof</span> 子类</span><br></pre></td></tr></table></figure>

<p>该表达式返回一个boolean值，如果多态创建的父类引用是这个子类，那么返回true，否则返回false。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person per = <span class="keyword">new</span> Student();</span><br><span class="line">per <span class="keyword">instanceof</span> Student; <span class="comment">//true</span></span><br><span class="line">per <span class="keyword">instanceof</span> Teacher; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>现在考虑这么一个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Person per)</span></span></span><br></pre></td></tr></table></figure>

<p>我们现在就在方法中根据per instanceof Xxx的结果进行安全的向下转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (per <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">        Student student = (Student) per;</span><br><span class="line">        <span class="comment">//实现Student对象特有的操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (per <span class="keyword">instanceof</span> Teacher) &#123;</span><br><span class="line">        Teacher teacher = (Teacher) per;</span><br><span class="line">        <span class="comment">//实现Teacher对象特有的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final关键字可以修饰</p>
<ul>
<li>一个类<ul>
<li>修饰一个类时，该类不能够被继承</li>
<li>所以final不能和abstract关键字一起使用，因为抽象类不能自己创建对象，只能被继承</li>
</ul>
</li>
<li>方法<ul>
<li>修饰一个方法时，子类不能重写该方法</li>
</ul>
</li>
<li>局部变量<ul>
<li>修饰一个局部变量时，这个变量不能进行更改</li>
<li>下面两种写法都可以</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>成员变量<ul>
<li>因为成员变量有默认值，所以要手动赋值</li>
<li>要么直接赋值，要么在构造方法中进行赋值，在构造方法中赋值时，所有的构造方法都要进行赋值，即使是无参构造方法，也要进行赋值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//下面的写法是错误的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Xxx</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>权限修饰符总共有四种，权限从大到小的顺序为</p>
<ul>
<li>public</li>
<li>protected</li>
<li>(default)，就是什么都不写</li>
<li>private</li>
</ul>
<p>下表列出了不同修饰符下的访问规则</p>
<table>
<thead>
<tr>
<th></th>
<th>同一个类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>不同包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>能</td>
<td>能</td>
<td>能</td>
<td>能</td>
</tr>
<tr>
<td>protected</td>
<td>能</td>
<td>能</td>
<td>能</td>
<td><strong>不能</strong></td>
</tr>
<tr>
<td>(default)</td>
<td>能</td>
<td>能</td>
<td><strong>不能</strong></td>
<td><strong>不能</strong></td>
</tr>
<tr>
<td>private</td>
<td>能</td>
<td><strong>不能</strong></td>
<td><strong>不能</strong></td>
<td><strong>不能</strong></td>
</tr>
</tbody></table>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是一个很重要的概念，主要分为两类</p>
<ul>
<li>成员内部类</li>
<li>局部内部类<ul>
<li>匿名内部类</li>
</ul>
</li>
</ul>
<p>下面我们来看一下内部类的使用</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类就像成员变量和成员方法一样定义在类里面，比如有一个叫做Body，内部还有一个类叫做Heart。我们可以这么定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类可以随意的访问外部类的成员变量和成员方法，但是外部类要访问内部类要借助内部类对象。</p>
<p>如何使用成员内部类</p>
<ul>
<li>在外部类的方法中使用内部类，然后在main方法中调用外部类的方法。</li>
<li>直接创建内部类的对象，创建格式为</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类 对象名 = <span class="keyword">new</span> 外部类().<span class="keyword">new</span> 内部类();</span><br></pre></td></tr></table></figure>

<p>比如上面我想创建一个Heart对象就可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Body.Heart heart = <span class="keyword">new</span> Body().<span class="keyword">new</span> Heart();</span><br></pre></td></tr></table></figure>

<p>内部类变量与外部类变量重名问题，假设外部类有一个成员变量num，内部类也有一个成员变量num，在内部类的成员方法中也有一个局部变量num，现在在内部类的这个方法中怎么访问外部类的成员变量，怎么访问内部类的成员变量。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">this</span>.num <span class="comment">//内部类的成员变量</span></span><br><span class="line">外部类名.<span class="keyword">this</span>.name <span class="comment">//外部类的成员变量</span></span><br></pre></td></tr></table></figure>

<p>现在来看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">//外部类的num</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">//内部类的num</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            System.out.println(num); <span class="comment">//打印局部变量</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">//打印内部类的成员变量</span></span><br><span class="line">            System.out.println(Body.<span class="keyword">this</span>.num); <span class="comment">//打印外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Body.Heart heart = <span class="keyword">new</span> Body().<span class="keyword">new</span> Heart();</span><br><span class="line">        heart.showNum(<span class="number">30</span>); <span class="comment">//局部变量num</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类就是定义在方法内部的类，定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 局部内部类名 </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不要写任何的修饰符。这并不代表它的修饰符权限是(default)，因为修饰符没有意义，类定义在方法的内部，只有在方法内部在能够访问。</p>
<p>我们在这里适时的总结一下修饰符修饰类</p>
<ul>
<li>外部类<ul>
<li>只能是public, (default)</li>
</ul>
</li>
<li>内部类<ul>
<li>成员内部类<ul>
<li>可以是四种修饰符的任意一种</li>
</ul>
</li>
<li>局部内部类<ul>
<li>什么都不能写</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>局部内部类如果想访问方法中的局部变量，那么这个变量必须是局部final的，什么叫做有效final呢？指的就是没有使用final修饰符修饰（当然你使用final修饰更加的保险），但是变量的值没有发生改变。比如下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testlocalInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的num虽然没有使用final修饰符修饰，但是它只进行了一次赋值，所以是有效final的，所以在局部内部类中可以访问该变量。假设num又进行了赋值，那么将会编译失败。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是相当重要的概念了。如果接口实现类(或者是父类的子类)只使用一次，那么这种情况可省略掉该类的定义，而改为使用匿名内部类。</p>
<p>比如有一个接口，叫做USB好了，然后在一个Computer类中要使用该接口，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useUsb</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">        usb.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们创建一个类去实现USB接口，然后创建对象，传入Computer的这个方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpUSB</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开USB设备"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭USB设备"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useUsb</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">        usb.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        ImpUSB impUSB = <span class="keyword">new</span> ImpUSB();</span><br><span class="line">        computer.useUsb(impUSB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打开USB设备</span><br><span class="line">关闭USB设备</span><br></pre></td></tr></table></figure>

<p>但是这样写未必太麻烦了，这个类只使用了一次，但是为了使用这个接口，我却要写一个类去实现该接口，然后创建对象使用，未必有点麻烦。Java提供了更加方便的方法，那就是匿名内部类。</p>
<p>匿名内部类的定义格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称() &#123;</span><br><span class="line">    <span class="comment">//在这里覆盖重写接口所有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们匿名内部类来实现上面同样的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">    <span class="comment">//创建匿名内部类</span></span><br><span class="line">    USB usb = <span class="keyword">new</span> USB() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"花式打开USB设备"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"花式关闭USB设备"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    computer.useUsb(usb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">花式打开USB设备</span><br><span class="line">花式关闭USB设备</span><br></pre></td></tr></table></figure>

<p>在这里我们并没有创建一个实现类去实现USB接口，而是创建了一个匿名内部类，这个类没有名字（这也是为什么叫做匿名内部类），所以它不能通过它在创建新的对象。正如匿名对象一样，只能调用一次方法。</p>
<p>匿名内部类的注意事项</p>
<ul>
<li>匿名内部类在创建对象时，只能使用唯一的一次</li>
<li>匿名对象在调用方法只能调用唯一的一次</li>
<li>匿名内部类是省略了类的名称，匿名对象是省略了对象的名称</li>
</ul>

    

        <a href="https://lastknightcoder.gitee.io/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-Java基础知识介绍"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-07-04 00:00:00" datetime="2019-07-03T16:00:00.000Z"  itemprop="datePublished">2019-07-04</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/">Java基础知识</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="第一个程序-HelloWorld"><a href="#第一个程序-HelloWorld" class="headerlink" title="第一个程序: HelloWorld"></a>第一个程序: HelloWorld</h2><p>下面将书写Java的第一个程序，它的作用是在命令行输出Hello World!。新建一个文件，文件名为HelloWorld.java，使用记事本或其他代码编辑工具打开，敲入以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在命令行中输入</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>

<p>然后就可以在命令行中看到Hello World!输出了。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>class后面的HelloWorld要与文件名一样，包括大小写</li>
<li>在命令行使用javac或者java命令时，要保证所处的路径与文件HelloWorld.java在同一个路径，否则会报错，解决办法有两种<ul>
<li>第一种，使用cd命令切换到HelloWorld.java文件的目录</li>
<li>第二种，javac或者java命令后跟上HelloWorld.java的完整路径名称</li>
</ul>
</li>
<li>javac命令后面有后缀.java，java命令后面没有任何的后缀</li>
</ul>
<p>现在稍微解释上面程序的意思，因为刚刚起步，很多东西现在都解释不了，所以在这里并不要求弄懂。第一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br></pre></td></tr></table></figure>

<p>这里，我们只需要记住HelloWorld必须与文件名<strong>相同</strong>。第二行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure>

<p>这个是固定的写法，几乎每个程序都是这么写的，这个是程序的入口，程序从这里开始执行。第三行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure>

<p>这个语句是关键的程序，它的作用就是向屏幕输出字符，这里我们输入的是Hello World!，注意输出的语句需要被双引号括起来。</p>
<h2 id="标识符与命名规范"><a href="#标识符与命名规范" class="headerlink" title="标识符与命名规范"></a>标识符与命名规范</h2><p>标识符的命名规范</p>
<ul>
<li>由数字、字母、下划线和美元符组成</li>
<li>不能由数字开头</li>
<li>不能是关键字</li>
</ul>
<p>上面是标识符命名的硬性规范，即如果不按照上面的来做，那么程序在编译时不能够通过，下面介绍软性规范，意思就是如果你不按照下面的来，编译器不会报错，但是软性规范是大家约定俗成的，大家都遵守的，所以我们要按照下面的来</p>
<ul>
<li>类名：大驼峰命名法，即首字母<strong>全部大写</strong>，如HelloWorld</li>
<li>变量名与方法名：小驼峰命名法，即第一个首字母小写，后面的首字母全部大写，如helloWorld</li>
</ul>
<h2 id="Java中的常量"><a href="#Java中的常量" class="headerlink" title="Java中的常量"></a>Java中的常量</h2><p>Java中的常量分为：</p>
<ul>
<li>字符串常量：使用双引号括起来的，如”Hello World!”</li>
<li>整型常量：其实就是整数，如5</li>
<li>浮点数：小数，如2.5</li>
<li>字符常量：用单引号括起来的，单引号里面必须有一个字符，不可以没有，也不可以多于一个，如’ab’,’’都是错误的，另外这个字符可以是中文，如’中’</li>
<li>布尔常量：只有两个值true和false</li>
<li>空常量：null，这个在这里不多做介绍</li>
</ul>
<p>在前面我们学习了向屏幕输出Hello World!，类似的，在这里我们可以尝试着把常量输出出来，新建一个文件为Constant.java，注意前面提及的命名规范，Constant是类名，所以首字母需要大写，然后在该文件中敲入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下面我将输出一些常量</span></span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>); <span class="comment">//输出字符串常量</span></span><br><span class="line">        System.out.println(<span class="number">5</span>); <span class="comment">//输出整型常量</span></span><br><span class="line">        System.out.println(<span class="number">2.5</span>); <span class="comment">//输出浮点型常量</span></span><br><span class="line">        System.out.println(<span class="string">'a'</span>); <span class="comment">//输出字符型常量</span></span><br><span class="line">        System.out.println(<span class="keyword">true</span>); <span class="comment">//输出布尔型常量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>不能打印出null，如System.out.println(null)会报错</li>
<li>上面//后面的内容为注释，编译器会自动的忽略，注释是对程序的解释，是为了帮助人看懂程序的</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中的数据类型分为基本数据类型和引用数据类型，引用数据类型暂且不提，这里的重点是掌握基本数据类型，基本数据类型分为四类：</p>
<ul>
<li>整型</li>
<li>浮点型</li>
<li>字符型</li>
<li>布尔类型</li>
</ul>
<p>整型可以细分为：</p>
<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
</ul>
<p>上面整型数据类型都表示整数，只是表示的范围大小不一样，byte使用<strong>一个字节</strong>即8bit来表示一个整数的大小，表示的范围为-128~127，short使用<strong>两个字节</strong>来表示，范围比byte大一点，大约在几万左右，int使用<strong>四个字节</strong>来表示，是最常用的数据类型，因为它的范围已经大到足够我们日常使用了，long使用<strong>八个字节</strong>来表示，比int的范围还要大，但是由于使用int已经足够了，从节省空间的角度讲，没必要用long。</p>
<p>浮点型可以分为</p>
<ul>
<li>float</li>
<li>double</li>
</ul>
<p>float使用<strong>四个字节</strong>来表示小数，虽然使用的是四个字节，但是表示的范围比使用八个字节的long更大，double使用<strong>八个字节</strong>来表示小数，所以使用double表示小数更精确，我们在平常使用最多的就是double。</p>
<p>字符型没法细分，只有一个，那就是char类型，使用两个字节表示。</p>
<p>布尔型也没有办法细分，只有一个，那就是boolean，使用一个字节表示，它只有两个值true和false。</p>
<p><strong>注意：</strong></p>
<ul>
<li>字符串不是基本数据类型，它是引用类型，这个后面详细阐述。</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的命名需要服从前面所讲的标识符所需遵从的硬性或软性的规定。变量的声明方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型 变量名</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure>

<p>上面是对变量的声明，但是没有对变量进行赋值，没有被赋值的变量是不能被使用的，否则会报错，下面举一些例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> by = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">122222222222222L</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.2F</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>对float变量进行赋值时，后面需要加上F</li>
<li>对long类型的变量进行赋值时，后面需要加上L(大小写都可以，不过小写的l像1，所以建议使用大写)，当右边常量的值的大小小于int类型的范围时，L可以省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java中，整型常量的类型默认为int，浮点型常量的类型默认为double</li>
<li>在一个花括号内部，变量名不能相同</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>数据类型转换分为两种：</p>
<ul>
<li>自动类型转换，也称为隐型转换</li>
<li>强制类型转换</li>
</ul>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>当将某数据类型的值赋值给某个能够表示更大范围的数据类型的变量时，会发生自动类型转换，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a = b;</span><br></pre></td></tr></table></figure>

<p>上面的b是byte类型，a是int类型，int类型的范围更加的大，所以将b赋值给a时会自动类型转换，将20转化为int类型赋值给a，但是b还是byte类型。但是不能将大范围的数据类型的值赋值给更小范围数据类型的变量，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">byte</span> b = a; <span class="comment">//不行，编译器会报错</span></span><br></pre></td></tr></table></figure>

<p>范围从小到大的顺序为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java01.png"/>
</center>

<p>箭头代表可以转换。</p>
<p>在前面我们提及到，当将一个整数赋值给long类型的变量时，如果表示的范围没有超过int，那么可以不写后面的L，这时因为发生了自动类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = <span class="number">12</span>; <span class="comment">//后面没有加L，Java默认整数类型为int，这里发生了自动类型转换</span></span><br></pre></td></tr></table></figure>

<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>上面提及到大范围不能转向小范围，但是我们可以强行转换，比如我想将int类型的数值转化为byte类型的数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) a;</span><br></pre></td></tr></table></figure>

<p>在要转换的数据前面加上(byte)就可以强行转化为byte类型。</p>
<p>虽然可以将大范围转化为小范围，但是我们在平常时不会这么干，因为往往将大范围的数转化为小范围的数时，会有精度损失，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) d; <span class="comment">//结果为3，小数点后面的数直接舍去，并不是四舍五入</span></span><br></pre></td></tr></table></figure>

<p>我们知道Java的整数默认为int，那么下面的语句为什么没有报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">20</span>; <span class="comment">//20是int类型，int不能转byte，为什么没有报错</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">30</span>; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<p>这是因为，在编译时，编译器会检查右边数值的范围，如果没有超过byte或者short能够表示的大小，那么编译器会自动帮我们强制类型转换为byte或short，相当于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> s = (<span class="keyword">short</span>) <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<h3 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h3><ol>
<li>char,short,byte类型在进行计算时，会自动提升为int类型参与计算</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//下面这行语句会报错</span></span><br><span class="line"><span class="keyword">byte</span> num3 = num1 + num2; <span class="comment">//在计算时，num1和num2会自动的提升为int类型，而int类型不能转为byte，所以会报错</span></span><br></pre></td></tr></table></figure>

<p>但是，下面的写法是正确的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>当右边全是常量时，编译器在编译时会直接计算，相当于下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>由于3没有超出byte能够表示的范围，所以会被强制转换为byte。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">//下面这行语句会输出一个数字</span></span><br><span class="line">System.out.println(c + <span class="number">0</span>); <span class="comment">//65</span></span><br></pre></td></tr></table></figure>

<p>我们知道char是一个字符，那么为什么字符可以进行计算呢？这是因为计算机在底层是使用数字表示字符的，比如上面’A’就是使用数字65表示的，上面的字符与数字0进行计算，会自动提升为int类型，所以最后输出的就是数字。</p>
<p>我们需要知道几个特殊字符对应的数字</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII码</th>
</tr>
</thead>
<tbody><tr>
<td>‘0’</td>
<td>48</td>
</tr>
<tr>
<td>‘A’</td>
<td>65</td>
</tr>
<tr>
<td>‘a’</td>
<td>97</td>
</tr>
</tbody></table>
<p>大写字母与小写字母之间差32。</p>
<ol>
<li>boolean类型不能进行数据类型转换</li>
</ol>
<p>例如，下面将对boolean类型进行转换，是错误的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = i; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (<span class="keyword">boolean</span>) i; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> i1 = b; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> i2 = (<span class="keyword">int</span>) b; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Java中的运算符分为以下几种：</p>
<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>三元运算符</li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符包括以下几种：</p>
<ul>
<li>+，加法</li>
<li>-，减法</li>
<li>*，乘法</li>
<li>/，除法</li>
<li>%，取余</li>
<li>++，自增</li>
<li>–，自减</li>
</ul>
<p>不同类型的数据之间进行运算，得到的结果的数据类型为范围最大的那个数据类型，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">2</span> + <span class="number">3.5</span>; <span class="comment">//int + double ==&gt; double</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span> + <span class="number">3.5</span>; <span class="comment">//该写法错误</span></span><br></pre></td></tr></table></figure>

<p>加法有两种作用：</p>
<ul>
<li>两数字间进行加法运算</li>
<li><strong>字符串的连接</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">3</span> + <span class="number">5</span>;  <span class="comment">//进行加法运算，结果为8</span></span><br><span class="line">String s = <span class="string">"Hello"</span> + <span class="string">"World"</span>; <span class="comment">//拼接为HelloWorld</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：任何数据类型与字符串连接时，会自动变成字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="number">1</span> + <span class="string">"Hello"</span>; <span class="comment">//1Hello</span></span><br></pre></td></tr></table></figure>

<p>除法需要注意的是，<strong>两个整数相除，得到的还是整数</strong>，即使除不尽，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>/<span class="number">3</span>; <span class="comment">//a = 3</span></span><br></pre></td></tr></table></figure>

<p>下面重点介绍++和–，由于二者十分的相似，这里只介绍++。++的作用是自动加1，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">a++; <span class="comment">//相当于a = a + 1 a变为了4</span></span><br></pre></td></tr></table></figure>

<p>其中++可以在变量的前面，也可以在变量的后面，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a++;</span><br><span class="line">++a;</span><br></pre></td></tr></table></figure>

<p>二者的作用均是使变量a加1，当二者如上单独使用时，二者没有区别，但是当混合使用时，有区别，具体表现如下</p>
<ul>
<li>++a：先将a进行+1，然后使用a</li>
<li>a++：先使用a，再将其进行+1</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">b = a++; <span class="comment">//先使用a，即先将a的值赋值给b，所以b=3，然后+1，所以最后a=4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">b = ++a; <span class="comment">//先将a+1，即a=4，然后将a赋值给b，所以b=4</span></span><br></pre></td></tr></table></figure>

<p>–的作用是减1，其用法同++一模一样，这里不多加介绍。</p>
<p><strong>注意：</strong></p>
<ul>
<li>常量不能进行++,–运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span>++;  <span class="comment">//该写法是错误的</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符分为基本赋值运算符和复合赋值运算符</p>
<ul>
<li>基本赋值运算符<ul>
<li>=</li>
</ul>
</li>
<li>复合赋值运算符<ul>
<li>+=</li>
<li>-=</li>
<li>*=</li>
<li>/=</li>
<li>%=</li>
</ul>
</li>
</ul>
<p>基本赋值运算符的作用就是把右边的值赋给左边的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>; <span class="comment">//把3赋给变量a</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>常量是不变的，不能被赋值，所以常量不能出现在赋值运算符的左边</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span> = <span class="number">30</span>; <span class="comment">//该写法是错误的</span></span><br></pre></td></tr></table></figure>

<p>复合赋值运算符，这里介绍+=，其他与它类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">a += <span class="number">3</span>; <span class="comment">//相当于a = a + 3</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">//相当于a = a * 3</span></span><br><span class="line"><span class="comment">// 其他的同理可以知道... ...</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>复合赋值运算符隐含了强制类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">s += <span class="number">2</span>; <span class="comment">//这里暗含了强制类型转换，s + 2得到的是一个int类型，被强制转换为了short类型，所以相当于s = (short) (s + 2);</span></span><br></pre></td></tr></table></figure>

<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符对操作数进行比较，得到一个boolean数据类型的值，比较运算符包含以下：</p>
<ul>
<li>==：判断两个数是否相等</li>
<li>&gt;</li>
<li>&lt;</li>
<li>&gt;=：大于等于</li>
<li>&lt;=</li>
<li>!=：判断两个数是否不相等</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>在判断某变量属于某区间，比如是否大于3小于5时，不能写成3 &lt; x &lt; 5，应当使用后面提及的逻辑运算符3 &lt; x &amp;&amp; x &lt; 5</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符的对象是boolean数据类型的值，包含下面三个操作</p>
<ul>
<li>&amp;&amp;：与操作，当两个操作数同时为true时，结果才为true</li>
<li>||：或操作，两个操作数中有一个操作数为true时，结果就为true</li>
<li>!：非操作，!true = false, !false = true</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>逻辑运算符的操作对象为boolean，所以如果操作对象不为boolean类型时，会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="number">5</span> &amp;&amp; <span class="number">2</span>; <span class="comment">//会报错</span></span><br><span class="line"><span class="keyword">boolean</span> b = <span class="number">5</span> &amp;&amp; <span class="keyword">true</span>; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>短路</strong><ul>
<li>表达式1 &amp;&amp; 表达式2：当表达式1为假时，已经可以判断出结果为假，所以不会对表达式2进行判断，不会执行表达式2</li>
<li>表达式1 || 表达式2：当表达式1为真时，已经可以判断出结果为真，同上。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">System,out.println(<span class="keyword">false</span> &amp;&amp; a++ &lt; <span class="number">100</span>); <span class="comment">//此时进行了短路运算，a++ &lt; 100没有得到执行，所以a = 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span> || a++ &lt; <span class="number">100</span>); <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>这里的三元指的是有三个操作数，上面我们介绍的运算符的操作数要么是一个的，如++,–,!，要么是两个的，如+,-,…，三元运算符的格式是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量 = 条件判断 ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>首先会进行条件判断，如果条件判断得到的结果为true，那么会将表达式1的结果赋值给变量，此时表达式2不会得到执行；否则将表达式2的结果赋值为变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">4</span> &gt; <span class="number">3</span> ? a : b++; <span class="comment">//c = 3，表达式2没有执行，b = 4</span></span><br><span class="line">System.out.println(b);   <span class="comment">//输出为4</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>变量的类型必须与表达式的结果的类型一致，否则会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">4</span> &gt; <span class="number">3</span> ? <span class="number">2</span> : <span class="number">2.5</span>; <span class="comment">//该语句是错的，2.5是double类型，不能转化为int</span></span><br></pre></td></tr></table></figure>

<p>可能有的人会说返回的2，为什么会报错，因为在实际中，判断语句的结果不是确定的，否则直接将2赋值给c好了，根本不需要判断，因此两个表达式的结果都有可能赋值给变量，编译器会检查表达式得到的数据类型。</p>
<ul>
<li>单独写三元表达式是错误的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>; b = <span class="number">3</span>;</span><br><span class="line">a &gt; b ? a : b; <span class="comment">//这么单独写是错误的</span></span><br></pre></td></tr></table></figure>

<p>但是可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a &gt; b ? a : b); <span class="comment">//这么写是对的</span></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程指的就是程序执行的顺序，写过汇编的同学都知道，用汇编写程序的流程控制都是jump的，各种跳来跳去，这会导致程序的流程极其的不清楚，当出现bug时，极其的难以调试，我们称这种程序为“意大利面条”，意思就是像意大利面条一样交缠在一起，极其混乱。</p>
<p>后来人们发现，只需要三种结构就可以写出任何的程序，这三种结构就是<strong>顺序结构，选择结构，循环结构</strong>，使用这三种结构使得程序条理清晰，结构清晰。下面就详细的介绍这三种结构。</p>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构指的就是程序从上到下，按照顺序执行，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"我是第一条语句"</span>);</span><br><span class="line">System.out.println(<span class="string">"我是第二条语句"</span>);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是第一条语句</span><br><span class="line">我是第二条语句</span><br></pre></td></tr></table></figure>

<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>有时候我们需要根据某种状态来判断哪段程序应该执行，比如用户输入用户名和密码，根据是否输入正确来决定程序的行为。</p>
<p>选择结构分为两大类，一个与关键字if,else有关，一个与关键字switch,case有关，下面详细进行介绍。</p>
<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><h5 id="单独一个if"><a href="#单独一个if" class="headerlink" title="单独一个if"></a>单独一个if</h5><p>使用方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断语句) &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对判断语句进行判断，如果结果为真，则执行if里面的代码，如果为假，则跳过整个语句。</p>
<h5 id="if-else语句-1"><a href="#if-else语句-1" class="headerlink" title="if-else语句"></a>if-else语句</h5><p>上面if语句是当结果为真时执行语句块，但是当结果为假却什么都不干，我们希望当结果为假时，也能有相应的操作，那么就要用到if-else语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断语句) &#123;</span><br><span class="line">    <span class="comment">//if语句块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//else语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当结果为真时，执行if语句块，结果为假时，执行else语句块。</p>
<h5 id="if-else-if-else语句级联"><a href="#if-else-if-else语句级联" class="headerlink" title="if-else-if else语句级联"></a>if-else-if else语句级联</h5><p>有时候，我们不仅需要的是一次判断，而是多个判断，比如有一个分段函数，根据函数的不同取值，选择不同的函数，比如<br>$$<br>y =<br>\begin{cases}<br>2x - 1, &amp;x &lt; 1 \\<br>2x, &amp;1 \leq x &lt; 2 \\<br>2x + 1, &amp;x \geq 2<br>\end{cases}<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> &lt;= x &amp;&amp; x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//x &gt;= 2</span></span><br><span class="line">    y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch-case语句"></a>switch-case语句</h4><p>switch-case语句的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> 常量n:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段程序的执行过程为，首先计算switch表达式的结果，然后将表达式的结果与常量1,常量2,…比较，看是否相等，如果与其中某个常量相等，则会执行相应的语句块。如果与所有的case常量都不相等，那么就会执行default中的语句。</p>
<p><strong>注意：</strong></p>
<ul>
<li>多个case的常量不能相同</li>
<li>switch表达式的结果只能是下面的几种类型<ul>
<li>基本数据类型：byte,short,char,int</li>
<li>引用类型：String，枚举类型</li>
</ul>
</li>
<li>case的顺序可以发生改变</li>
</ul>
<p>另外，比较重要的是，其实break不是必须的，可以省略，如果省略的话，由于没有break，程序会继续执行下去，直到遇到break或者程序执行结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="number">1</span>); <span class="comment">//不会退出程序，继续执行</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">break</span>;                 <span class="comment">//在这里遇到break，退出</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>循环指的就是重复执行某段程序，一般循环由下面四部分组成</p>
<ul>
<li>初始化</li>
<li>条件判断</li>
<li>循环体</li>
<li>循环控制语句</li>
</ul>
<p>循环有三种，分别是</p>
<ul>
<li>for循环</li>
<li>while循环</li>
<li>do-while循环</li>
</ul>
<p>下面详细介绍。</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句; 条件判断; 循环控制) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的顺序为，先执行初始化语句，然后进行条件判断，如果结果为真，那么进入循环体，如果结果为假，那么退出循环，执行完循环体后，接着执行循环控制语句，然后进行条件判断，循环往复。如下面的例子打印出1-100的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123; <span class="comment">//注意，这个i只能在for循环里面用，在外面不能用</span></span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (判断语句) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会对判断语句进行判断，真就执行循环体，假就退出循环。执行完循环体，接着进行判断，循环往复。下面的例子计算1-100的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//初始化语句</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123; <span class="comment">//判断语句</span></span><br><span class="line">    sum = sum + i; <span class="comment">//循环体</span></span><br><span class="line">    i++; <span class="comment">//循环控制语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>do-while循环的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125; <span class="keyword">while</span> (条件判断);</span><br></pre></td></tr></table></figure>

<p>首先会执行一次循环体，然后进行条件判断，真就继续执行循环体，否则退出循环。</p>
<p>do-while循环与while循环的区别是，do-while一定会执行一次循环体，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="循环控制break和continue"><a href="#循环控制break和continue" class="headerlink" title="循环控制break和continue"></a>循环控制break和continue</h4><p>当在循环体中执行到break时，会直接退出循环，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;      <span class="comment">//当i = 2时退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>当在循环体中执行到continue时，退出此次循环，直接进行下一次循环，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//退出此次循环，后面的代码不执行了，直接执行循环控制语句i++，进入下一次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>当循环一直进行下去，不能退出，那么就成为了死循环，例如下面就是一个死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123; <span class="comment">//省略了条件判断语句，默认为真，是死循环</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123; <span class="comment">//省略了循环控制语句，i一直为0，条件判断一直为真，为死循环</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环里面可以嵌套着一个循环，例如输出九九乘法表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%d*%d=%2d  "</span>,j,i,j*i); <span class="comment">//类似于C语言，格式化输出，以便对齐</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>*<span class="number">1</span>= <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>= <span class="number">2</span>  <span class="number">2</span>*<span class="number">2</span>= <span class="number">4</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>= <span class="number">3</span>  <span class="number">2</span>*<span class="number">3</span>= <span class="number">6</span>  <span class="number">3</span>*<span class="number">3</span>= <span class="number">9</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>= <span class="number">4</span>  <span class="number">2</span>*<span class="number">4</span>= <span class="number">8</span>  <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">5</span>= <span class="number">5</span>  <span class="number">2</span>*<span class="number">5</span>=<span class="number">10</span>  <span class="number">3</span>*<span class="number">5</span>=<span class="number">15</span>  <span class="number">4</span>*<span class="number">5</span>=<span class="number">20</span>  <span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>= <span class="number">6</span>  <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>= <span class="number">7</span>  <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>= <span class="number">8</span>  <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>= <span class="number">9</span>  <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure>


<h2 id="方法入门"><a href="#方法入门" class="headerlink" title="方法入门"></a>方法入门</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>方法定义的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数) &#123;</span><br><span class="line">    代码 ...;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中修饰符目前固定为public static，方法要符合之前在标识符里面的规定。</p>
<p>注意：</p>
<ul>
<li>方法不能定义在方法里面</li>
<li>方法定义的前后顺序无所谓</li>
<li>方法应在class和main方法之间定义</li>
<li>return的作用有两个，第一个是终止程序退出方法，第二个是返回值</li>
<li>如果返回值的类型时void，可以只写return;，代表退出方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义了一个方法，该方法的作用是计算两个int整数的和，并返回一个int类型的值</span></span><br><span class="line">    <span class="comment">//该方法接收两个int类型的参数，返回一个int类型的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main方法的顺序可以和上面add方法的顺序颠倒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... ...</span></span><br><span class="line">        <span class="comment">//不能在里面定义方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数);</span><br></pre></td></tr></table></figure>

<p>例如，在main方法中调用上面定义的add方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用add方法，其中2 和 3是参数，必须是int类型，否则会报错</span></span><br><span class="line">        <span class="keyword">int</span> c = add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//使用变量c来接受方法返回的结果，此时c = 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载指的是两个方法的方法名相同，但是参数列表不同，参数列表不同包括三个方面</p>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同</li>
</ul>
<p>例如，下面的方法是重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, intj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> i, <span class="keyword">double</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> i, intj)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>判断方法是否是重载，关键是看方法名是否相同，参数列表是否不同，与修饰符，返回值没有任何的关系</li>
</ul>
<p>例如，下面的方法不是重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">//与修饰符无关，参数列表相同，所以不是重载，编译会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">int</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">//与返回值无关，参数列表相同，所以也不是重载，编译会报错</span></span><br></pre></td></tr></table></figure>

<p>下面举一个注意事项，假设有下面这么一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> j)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在main方法中，我们可以这么调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">//我们可以传入两个整数，因为会进行自动类型转换为double</span></span><br></pre></td></tr></table></figure>

<p>然后我们对该方法重载了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">//参数列表的顺序不同，是重载</span></span><br></pre></td></tr></table></figure>

<p>如果我们还在main方法中传入两个整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add (<span class="number">2</span>, <span class="number">2</span>); <span class="comment">//这时会报错</span></span><br></pre></td></tr></table></figure>

<p>因为在调用这个方法时，发现两个方法都可以，所以编译器就会感到模糊，不知道调用哪一个方法，就会报错。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>假设你要保存一组学生的成绩，我们会考虑每个学生用不同的变量保存，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> score2 = <span class="number">80</span>;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>这样写的话代码很长，并且不利于批量操作，比如如果我要给每个学生加上十分，那我们只能这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">score1 = score1 + <span class="number">10</span>;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>这只是体力活。</p>
<p>Java中专门有一类数据类型用来保存这样的数据，它叫做数组，下面我们将详细介绍。</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>数组的初始化分为两组，分别为动态初始化（指定长度）和静态初始化（指定内容）。</p>
<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>动态初始化的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure>

<p>例如，下面声明了一个长度为3的int类型的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>动态初始化其实可以分为两部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array = <span class="keyword">new</span> array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>静态初始化的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[] &#123;内容&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，下面创建了一个String类型的数组，里面有3个字符串，内容之间使用逗号隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[]&#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>编译器会自动计算内容的个数来确定数组的长度。静态初始化还有省略格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;内容&#125;;</span><br></pre></td></tr></table></figure>

<p>例如上面的例子用省略格式重写为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>静态初始化也可以看做是由两部分组成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str;</span><br><span class="line">str = <span class="keyword">new</span> String[] &#123;  <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span>  &#125;;</span><br></pre></td></tr></table></figure>

<p>但是省略格式不能这样看，例如下面的写法是错误的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str;</span><br><span class="line">str = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!!!"</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>数组的长度在程序运行期间是固定的，不能够发生改变</li>
<li>可以通过数组名.length来得到数组的长度</li>
<li>静态初始化会根据内容来自动推算出数组的长度</li>
</ul>
<h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>我们通过数组名[索引]的方式来访问数组里面的内容，这里需要注意的是索引值是从0开始的，所以索引的范围为<strong>0~数组长度-1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrays[<span class="number">0</span>]);  <span class="comment">//访问数组中的第一个元素，输出1</span></span><br><span class="line">System.out.println(arrays[<span class="number">1</span>]);  <span class="comment">//访问数组中的第二个元素，输出2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>索引的范围不能超过数组的长度，否则会报错</li>
</ul>
<p>例如对于上面定义的数组，下面的代码会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array[<span class="number">3</span>]; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>动态初始化有默认值，不同类型的默认值不同，如下</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>整型(byte,short,int,long)</td>
<td>0</td>
</tr>
<tr>
<td>浮点型(float和double)</td>
<td>0.0</td>
</tr>
<tr>
<td>字符(char)</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>布尔型(boolean)</td>
<td>false</td>
</tr>
<tr>
<td>引用内容</td>
<td>null</td>
</tr>
</tbody></table>
<ul>
<li>静态初始化其实也有默认值，不过马上又被赋值被覆盖了</li>
</ul>
<h3 id="Java的内存模型"><a href="#Java的内存模型" class="headerlink" title="Java的内存模型"></a>Java的内存模型</h3><p>Java的内容模型分为五部分，分别是</p>
<ul>
<li>栈(Stack)<ul>
<li>存放的都是局部变量，变量一旦超出作用域，立刻从栈内存中消失</li>
<li>当调用方法运行时，栈会为方法开辟一块空间</li>
</ul>
</li>
<li>堆(Heap)<ul>
<li>凡是new出来的，都在堆中</li>
<li>堆内存里面的东西都有一个地址值</li>
<li>堆内存里的数据都有默认值，同数组的默认值</li>
</ul>
</li>
<li>方法区(Method Area)<ul>
<li>存储class相关的信息，包括方法的信息</li>
</ul>
</li>
<li>本地方法栈(Native Method Stack)<ul>
<li>与操作系统相关</li>
</ul>
</li>
<li>寄存器(PC Register)<ul>
<li>与CPU相关，速度非常的快</li>
</ul>
</li>
</ul>
<p><strong>目前我们需要关注的前三个</strong>。</p>
<h3 id="数组的内存图"><a href="#数组的内存图" class="headerlink" title="数组的内存图"></a>数组的内存图</h3><p>下面我们来看一段代码，然后从内存的角度看看发生了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(array1); <span class="comment">// 猜猜打印出什么</span></span><br><span class="line">    </span><br><span class="line">    array1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    System.out.println(array1[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] array2 = array1;</span><br><span class="line">    System.out.println(array2); </span><br><span class="line">    array2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    System.out.println(array1[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[I@<span class="number">15</span>db9742</span><br><span class="line"><span class="number">10</span></span><br><span class="line">[I@<span class="number">15</span>db9742</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>下面将从内存的角度解释，首先第一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure>

<p>该方法的信息会保存在方法区中，如果方法区中没有该方法，那么程序会报错。然后找到<code>main</code>方法后，这时会把main推入栈中，栈内存会为main方法开辟一块空间</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java02.png"/>
</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>这一行是动态初始化数组，首先会在main方法中分配一块空间保存变量array1的值，在堆中会开辟一块空间，空间的大小为3个int的大小，里面的默认值为0，在堆中存放的东西都有一个地址，array1保存的就是这个地址。访问数组就是通过这个地址去访问在堆中保存的数据的。</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java03.png"/>
</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(array1);</span><br></pre></td></tr></table></figure>

<p>这一行打印变量array1的值，我们知道array1保存的是数组在堆中的地址，所以输出的是[I@15db9742，其中[代表类型为数组，I代表是int类型，@符号后面的十六进制数字是地址的哈希值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(array1[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>第一行是对数组中的第一个元素赋值为10，原来数组中的元素默认为0，现在改变为了10。在内存中的过程为，首先根据array1保存的地址去寻找在堆中的数组，然后根据索引值去寻找对应的位置，然后对数据进行修改</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java04.png"/>
</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array2 = array1;</span><br><span class="line">System.out.pritnln(array2);</span><br></pre></td></tr></table></figure>

<p>这行语句声明了一个数组变量array2，它的值与array1的值相同，所以输出结果为[I@15db9742。这表示两个数组变量指向在堆中的同一个数组</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java05.png"/>
</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">System.out.println(array1[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>上面的语句表示通过array2修改数组中的元素array2[1]为200，由于array1和array2指向的是同一个数组，所以array2对数组进行修改也会影响到array1。所以输出的结果是200而不是0。</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java06.png"/>
</center>

<h3 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h3><p>学习了数组的内容之后，我们做几个练习巩固一下知识。</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>遍历数组指的就是访问数组中的每一个元素。我们使用for循环，将数组中的每一个元素打印出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="找到数组中的最大值"><a href="#找到数组中的最大值" class="headerlink" title="找到数组中的最大值"></a>找到数组中的最大值</h4><p>思路为，想象为这是一个打擂台，数组中的元素就是挑战者，首先让数组中的第一个元素为擂主，后面的挑战者（数组元素）去挑战，比擂主强的话就成为新的擂主，比擂主弱那么擂主就继续在台上，那么最后所有人都挑战完了，那么此刻的擂主就是最强的男人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max = array[<span class="number">0</span>]; <span class="comment">//擂主为第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123; <span class="comment">//挑战者不断挑战</span></span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">        max = array[i];      <span class="comment">//如果挑战者比擂主强，那么换擂主，否则擂主不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max); <span class="comment">//此刻的擂主就是最强的</span></span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><p>所谓的数组反转就是相对应的位置调换顺序，比如索引为0与索引为array.length-1（最后一个元素）调换位置，一般的索引为i的元素与索引为array.length-1-i的元素交换位置，那么交换的条件就是i &lt; array.length -1 - i得到i &lt; (array.length -1) / 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = array.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[len -<span class="number">1</span> -i];</span><br><span class="line">    array[len -<span class="number">1</span> -i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="数组与方法"><a href="#数组与方法" class="headerlink" title="数组与方法"></a>数组与方法</h3><p>数组可以作为函数的参数，也可以作为函数的返回值返回。</p>
<h4 id="方法作为函数参数"><a href="#方法作为函数参数" class="headerlink" title="方法作为函数参数"></a>方法作为函数参数</h4><p>下面定义一个方法，该方法的作用是打印出数组里面的所有的元素，该方法接收一个整型的数组参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span> <span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在main方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">printArray(array);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>数组传递的是地址值，所以printArray方法中的array与main方法中的array指向的是同一个数组，所以如果在printArray方法中对数组元素进行修改的话，会影响到main方法中的array。</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/Java07.png"/>
</center>
</li>
<li><p>随着printArray方法的执行完成，在栈内存中会将为printArray开辟的空间出栈，此时printArray方法中的array变量会立即消失。</p>
</li>
<li><p>不仅是数组，引用类型作为方法的参数，传递的都是地址值</p>
</li>
</ul>
<h4 id="数组作为方法返回值"><a href="#数组作为方法返回值" class="headerlink" title="数组作为方法返回值"></a>数组作为方法返回值</h4><p>下面有一个方法，该方法接收一个数组，返回该数组的所有数字之和及平均数，由于return语句只能返回0或1个值，要返回两个值的话，我们可以返回一个数组，数组的第一个值表示和，第二个值表示平均数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] getSumAndAvg (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123; <span class="comment">//求和</span></span><br><span class="line">        sum = sum + array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> avg = sum / array.length; <span class="comment">//得到平均数</span></span><br><span class="line">    <span class="keyword">double</span>[] result = &#123; sum, avg &#125;;  <span class="comment">//创建一个数组，第一个值为sum 第二个值为avg</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span>[] resArr = getSumAndAvg(array);    <span class="comment">//得到数组</span></span><br><span class="line">System.out.println(<span class="string">"Sum is "</span> + resArr[<span class="number">0</span>]); <span class="comment">//打印输出和</span></span><br><span class="line">System.out.println(<span class="string">"Average is "</span> + resArr[<span class="number">1</span>]); <span class="comment">//打印输出平均数</span></span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sum is <span class="number">26.0</span></span><br><span class="line">Average is <span class="number">5.2</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>方法返回时数组的地址值，内存分析过程同上类似</li>
<li>返回引用数据类型，返回的也是地址值</li>
</ul>

    

        <a href="https://lastknightcoder.gitee.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-Java环境搭建"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-07-01 00:00:00" datetime="2019-06-30T16:00:00.000Z"  itemprop="datePublished">2019-07-01</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Java/Element/">Element</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/Java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Java开发环境搭建</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <p>Java环境搭建分为三步：</p>
<ul>
<li>下载JDK</li>
<li>安装JDK</li>
<li>环境变量配置</li>
</ul>
<p>下面将详细介绍安装的步骤。</p>
<h2 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h2><p>首先进入<a href="www.oracle.com">Oracle官网</a>进行下载</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down1.png"/>
</center>

<p>点击Downloads</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down2.png"/>
</center>

<p>点击Java</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down3.png"/>
</center>

<p>选择Java(JDK) for Developers</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down4.png"/>
</center>

<p>这是JDK 12，是最新版的，目前主流的是JDK 8，我们往下翻</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down5.png"/>
</center>

<p>点击JDK DOWNLOAD</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down6.png"/>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down7.png"/>
</center>

<p>选择合适自己机器的版本下载，一般现在的机器都是<code>64</code>为，选择下载即可，但我们点击下载时，它要我们登录</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down8.png"/>
</center>

<p>这里提供一个账号</p>
<ul>
<li>用户名：<a href="mailto:2696671285@qq.com">2696671285@qq.com</a></li>
<li>密码：Oracle123</li>
</ul>
<p>登录成功后就开始下载了</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down9.png"/>
</center>

<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>安装JDK就是一直点next即可，因为JDK是包含JRE的，所以JRE可以不必安装。这里需要注意的是，不要将安装目录安装在中文目录下，因为可能会碰到各种各样的问题，我们将它扼杀在摇篮里即可。这里需要记住安装的路径，比如我安装的路径是</p>
<ul>
<li>G:\java</li>
</ul>
<p>安装好以后里面是这样的</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down10.png"/>
</center>

<h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>现在要进行环境变量的配置，可能你不知道为什么需要进行配置。我们看这么一个情况，你在命令行输入一个命令，比如notepad(它会打开一个记事本)，但是当你输入一串乱七八糟的字符时，它会提示你</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down11.png"/>
</center>

<p>那命令行怎么知道notepad是一个命令，而你乱输入的字符不是命令呢? 因为当你输入字符后，命令行会去一个路径找是否有这个命令，如果有那么执行该命令，没有就会报出上面那样的错误。为了我们能够在命令行中使用有关于Java的命令，我们就要将有关Java的命令添加到路径中，这个路径就是我们要去配置的东西。那么与Java有关的命令放在哪里，首先打开你安装的那个目录</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down10.png"/>
</center>

<p>然后进入bin文件夹，这个文件夹里面就是有关Java的各种命令</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down12.png"/>
</center>

<p>比如我的路径为</p>
<ul>
<li>G:\java\bin</li>
</ul>
<p>现在来到桌面，右键我的电脑，点击属性</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down13.png"/>
</center>

<p>然后按照以下步骤</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down14.png"/>
</center>

<p>会进入下面这个界面</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down15.png"/>
</center>

<p>点击新建，将你刚刚复制的路径粘贴上去</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down16.png"/>
</center>

<p>现在大功告成了。为了检验是否配置成功，我们打开命令行，输入java和javac命令，如果出现下面的界面就说明成功了</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down17.png"/>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/down18.png"/>
</center>

<p>如果提示命令找不到之类的，说明配置失败了，就要回头仔细看看是不是漏掉了什么。</p>

    

        <a href="https://lastknightcoder.gitee.io/Java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/" rel="tag">软件安装及配置</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-CSS基础"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-02-12 00:00:00" datetime="2019-02-11T16:00:00.000Z"  itemprop="datePublished">2019-02-12</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Web/">Web</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Web/CSS/">CSS</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/CSS%E5%9F%BA%E7%A1%80/">CSS基础</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h1><p>之前我们学习过HTML的基本知识，对于网页来说，HTML搭建的只是框架，而对于网页的美容，则需要用到CSS，CSS就可以看做是网页的美容师。CSS的全称叫做Cascading Style Sheets,中文名字叫层叠样式表。我们可以用CSS设置字体的颜色，字体的大小以及图片外形，排版布局等等”美颜”的工作。</p>
<h2 id="CSS的书写位置"><a href="#CSS的书写位置" class="headerlink" title="CSS的书写位置"></a>CSS的书写位置</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>CSS的书写位置有三个，第一个是行内，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">style</span>=<span class="string">"属性1:属性值1; 属性2:属性值2 ..."</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面就是把这个一级标题设置为红色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span> = <span class="string">"color:red"</span>&gt;</span>CSS入门<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="内嵌式"><a href="#内嵌式" class="headerlink" title="内嵌式"></a>内嵌式</h3><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        选择器&#123;属性1:属性值1; 属性2:属性值2; ...&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>比如下面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是把所有的h1标签的文字颜色设置为红色。</p>
<h3 id="外链式"><a href="#外链式" class="headerlink" title="外链式"></a>外链式</h3><p>外链式指的是HTML文件与CSS文件分开写，在实际工作中就是这么干的。但是为了方便，我在介绍CSS的使用的时候一般会用内嵌式。外链式的写法如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"CSS文件的路径"</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span>/ &gt;</span></span><br></pre></td></tr></table></figure>

<p>link标签是单标签，它是放在head标签内的。在使用link标签时，必须指定link标签的三个属性,如下:</p>
<ul>
<li>href:定义所链接外部样式表文件的URL,可以是相对路径，也可以是绝对路径。</li>
<li>type:定义所链接文档的类型，在这里需要指定为”text/CSS”,表示链接的外部文件为CSS样式表。</li>
<li>rel:定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个样式表文件。</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>使用HTML的标签名作为选择器，为HTML的某一标签指定统一的<code>CSS</code>样式。比如上面的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>
<p>就是标签选择器，使用h1作为选择器，所有的h1标签包含的文字都被设置为红色。</p>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>类选择器是最常用的选择器，类选择器使用.（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名&#123;</span><br><span class="line">    属性:属性值;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标签在调用CSS样式时，使class=”类名”即可，比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.red</span>&#123;</span></span><br><span class="line">            color : red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>CSS入门<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们声明了一个类选择器，类名叫做red,在h1标签中，我们通过class=”red”调用了该类，所以h1标签所包含的文字设置成了红色。</p>
<h3 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h3><p>如果我们在标签中需要调用多个类怎么办，比如有两个类分别为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line">.font14&#123;</span><br><span class="line">    font-size=14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果加入h1标签要调用这两个类的话，写法如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span> = <span class="string">"red font14"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就叫做多类名选择器。</p>
<p>还有一个问题就是，如果调用的多个类有冲突怎么办?比如调用的两个类一个设置颜色为红色，一个设置颜色为蓝色，是如何处理这种冲突?</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line">.blue&#123;</span><br><span class="line">    color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设h1调用如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"blue red"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你觉得会是蓝色还是红色的?答案是蓝色的，虽然调用时blue写在red前面，你想red会覆盖blue,所以会是红色，实际上最终的效果与调用的顺序无关，而与CSS书写的顺序有关，由于CSS书写时red在blue的上面，所以只有最后的blue生效。</p>
<h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>与类选择器很相似，不管调用方式是通过id来调用的，并且书写方式上有差别，即将.改为了#。如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>名&#123;</span><br><span class="line">    属性:属性值;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式同类调用方式，不过用的不是class=””而是id=””。与类选择器不同的是，由于id是唯一的，不同的标签的id不能相同，所以该种方法只能给唯一的一个id设置样式。并且id选择器能做到的，类选择器也能做到，所以实际上类选择器是用的最多的。</p>
<h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>书写方式如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    属性:属性值;</span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>*</code>就是通配符，代表所有标签的意思，意思是所有的标签都会被设置成这样的样式，该种方法在开发几乎不用。</p>
<h1 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h1><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p>font-size属性是用来设置字体大小的，字体大小的单位有很多，其中最常用的就是px,代表的是像素，1px代表的就是一个像素的大小。比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>

<p>在网页中普遍使用14px+,并且尽量用偶数大小，因为奇数可能在低版本的浏览器中出现莫名的问题。</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>font-family属性是用来设置字体的，比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-family</span>: "楷体";</span><br></pre></td></tr></table></figure>
<p>英文字体可以不加引号，但是如果英文字体含有空格，则需要加上引号，比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-family</span>: "<span class="selector-tag">Times</span> <span class="selector-tag">New</span> <span class="selector-tag">Roman</span>";</span><br></pre></td></tr></table></figure>
<p>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。</p>
<p>在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、UTF-8等)不匹配时会产生乱码的错误。xp系统不支持类似微软雅黑的中文。解决办法是可以使用CSS Unicode字体表示，比如 <code>font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;</code> 就表示设置字体为微软雅黑。其中 <code>\5FAE\8F6F\96C5\9ED1</code> 就是Unicode字体。常见中文对应的Unicode字体如下:</p>
<table>
<thead>
<tr>
<th>字体名称</th>
<th>英文名称</th>
<th>Unicode 编码</th>
</tr>
</thead>
<tbody><tr>
<td>宋体</td>
<td>SimSun</td>
<td>\5B8B\4F53</td>
</tr>
<tr>
<td>新宋体</td>
<td>NSimSun</td>
<td>\65B0\5B8B\4F53</td>
</tr>
<tr>
<td>黑体</td>
<td>SimHei</td>
<td>\9ED1\4F53</td>
</tr>
<tr>
<td>微软雅黑</td>
<td>Microsoft YaHei</td>
<td>\5FAE\8F6F\96C5\9ED1</td>
</tr>
<tr>
<td>楷体_GB2312</td>
<td>KaiTi_GB2312</td>
<td>\6977\4F53_GB2312</td>
</tr>
<tr>
<td>隶书</td>
<td>LiSu</td>
<td>\96B6\4E66</td>
</tr>
<tr>
<td>幼园</td>
<td>YouYuan</td>
<td>\5E7C\5706</td>
</tr>
<tr>
<td>华文细黑</td>
<td>STXihei</td>
<td>\534E\6587\7EC6\9ED1</td>
</tr>
<tr>
<td>细明体</td>
<td>MingLiU</td>
<td>\7EC6\660E\4F53</td>
</tr>
<tr>
<td>新细明体</td>
<td>PMingLiU</td>
<td>\65B0\7EC6\660E\4F53</td>
</tr>
</tbody></table>
<h2 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h2><p>font-weight属性是用来设置字体粗细的，可选属性值有normal, bold, older, lighter,除了有着四种值可选外，其值还可以是数字，范围为100-900并且必须为100的倍数。normal相当于是400,bold相当于是700,一般建议用数字。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-weight</span>: 400;</span><br></pre></td></tr></table></figure>

<h2 id="字体风格"><a href="#字体风格" class="headerlink" title="字体风格"></a>字体风格</h2><p>font-style属性是用来设置字体风格的，有两种值可选，分别是normal对于正常的字体风格，另一个是italic对应的是斜体风格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-style</span>: <span class="selector-tag">italic</span>;</span><br></pre></td></tr></table></figure>

<h2 id="综合连写"><a href="#综合连写" class="headerlink" title="综合连写"></a>综合连写</h2><p>假如我们设置字体的时候，四个都要设置，假如我要设置字体大小为20px,字体为微软雅黑，字体粗细为500,字体风格为斜体，我们会这样写:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"\5FAE\8F6F\96C5\9ED1"</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">500</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于字体样式写的比较频繁，这么写的话过于的繁琐，所以CSS规定可以对其综合连写，如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: italic <span class="number">500</span> <span class="number">20px</span> <span class="string">"\5FAE\8F6F\96C5\9ED1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中书写顺序必须为font-style, font-weight, font-size, font-family,其中font-size和font-family不可以省略。</p>
<h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>color属性用以设置文本的颜色，其取值有三种方法:</p>
<ul>
<li>red,green,blue…等内置的颜色</li>
<li>使用十六进制，比如#FF0000，其中十六进制的前两位代表三基色中的红色，中间两位代表绿色，后两位代表蓝色。所以#FF0000代表的就是红色。</li>
<li>使用RGB代码，比如红色为rgb(255,0,0)。</li>
</ul>
<p>其中第二种方法使用的最多，如果十六进制的三对每两位是相同的，则可以缩写为一个，比如#FF0000可以缩写为#F00。#FFDD66可以缩写为#FD6。</p>
<h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><p>line-height属性用以设置行高，比如对一个段落来说，其行与行之间的距离太小了，则可以通过设置行高来调整行间的距离。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h2><p>text-align用以设置文本的水平对齐方式，可选值有三个，分别为left, right, center。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure>

<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>text-indent用以设置段落首行的缩进距离，一般设置为2em即两个字的距离：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-indent</span>: 2<span class="selector-tag">em</span>;</span><br></pre></td></tr></table></figure>

<h2 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h2><p>text-decoration属性用来修饰文本，有一下几个值可选:</p>
<ul>
<li>none：取消文本修饰或无修饰</li>
<li>underline：下划线</li>
<li>overline：上划线</li>
<li>line-through：删除线</li>
</ul>
<h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>假如有下面这么一个例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>后代选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>开心<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>快乐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>乐观<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们希望将开心和快乐变成红色，而不影响乐观，即将div标签下的p标签设置为红色，但不是所有的p标签设置为红色，所以不能这么写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你们可能会写一个类，然后让这两个p标签去调用，但是假设div下有很多这样的p标签的话，这样做就不现实，我这里使用的是后代选择器，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即设置div标签下的p标签设置为红色。因为乐观所处的p标签不在div标签下，所以乐观不受影响。效果如下:</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css02.png"/>
</center>

<h2 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h2><p>假设有这么一个案例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>子代选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>一级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>一级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>一级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>二级菜单<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们希望一级菜单变为红色，而二级菜单不受到影响，如果我们使用后代选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul li a &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么li标签下的所有a标签都会受到影响，二级菜单也会受到影响，这个时候我们需要用子代选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul&gt;li&gt;a &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面便是子代选择器的写法，与后代选择器不同，子代只包括”儿子”,而后代则是包括后代所有的。所以使用子代选择器，受到影响的只有li标签下的a标签，二级菜单没有受到影响。效果为:</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css03.png"/>
</center>

<h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><p>假设有下面这么一个案例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>交集选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们希望将第三个div标签中的文字设置为红色。很简单的一个方法就是这样</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让第三个div标签去调用，但是我们这里做出要求，当p标签去调用这个类时，它的颜色不会改变。这个时候我们就要用到交集选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div.red &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的选择器表明，只有div标签调用这个类才会生效，其他标签调用这个类不会生效，这就是交集选择器。</p>
<h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>假设又有下面这个案例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>并集选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>123<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们希望div,p.h1标签都设置为红色，其他的不变，我们可以这样写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">h1 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用并集选择器可以使上面的代码大大减少</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div, p, h1 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用逗号将标签或者类名隔开。</p>
<h2 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h2><p>什么是伪类选择器，伪类选择器是向某些选择器添加特殊效果，比如为链接添加特殊效果,链接伪类选择器有四个，分别为</p>
<ul>
<li>link：未访问过的链接状态</li>
<li>visited：已访问过的链接状态</li>
<li>hover：鼠标放上去时的链接状态</li>
<li>active：鼠标按下时的链接状态</li>
</ul>
<p>类选择器使用点.,而伪类选择器使用冒号:。现在我们有这个需要，当未访问链接时，链接字体为25px,无下划线，当鼠标放上去时，颜色变为红色，当按下时颜色变为橙色，当访问后，颜色为绿色。CSS样式按如下写</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;     <span class="comment">/*取消下划线*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css05.gif"/>
</center>

<p>当未按下链接时，链接为蓝色，按把鼠标放上去时，链接变为红色，当按下链接时，链接变为橙色，当访问完链接后，链接变为了绿色。需要<strong>注意</strong>的一点是，伪类选择器的顺序必须按照lvha的顺序来，否则会达不到想要的效果。在实际的开发中，一般只用到hover,不会写的这么复杂，即我们只需要当鼠标放上去变颜色就行，如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标签显示模式"><a href="#标签显示模式" class="headerlink" title="标签显示模式"></a>标签显示模式</h1><p>我们把标签分为三类，一类为块级(block)标签，一类为行内(inline)标签,最后一类为二者的综合，为行内块(inline-block)标签。每个块标签通常都会独自占据一整行或多整行，可以对其设置<strong>宽度、高度、对齐</strong>等属性，常用于网页布局和网页结构的搭建。常见的块级标签包括</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>~<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">ul</span>&gt;</span>、<span class="tag">&lt;<span class="name">ol</span>&gt;</span>、<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>行内标签（内联标签）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般<strong>不可以</strong>设置<strong>宽度、高度、对齐</strong>等属性，常用于控制页面中文本的样式。常见的行内标签包括</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">strong</span>&gt;</span>、<span class="tag">&lt;<span class="name">b</span>&gt;</span>、<span class="tag">&lt;<span class="name">em</span>&gt;</span>、<span class="tag">&lt;<span class="name">i</span>&gt;</span>、<span class="tag">&lt;<span class="name">del</span>&gt;</span>、<span class="tag">&lt;<span class="name">s</span>&gt;</span>、<span class="tag">&lt;<span class="name">ins</span>&gt;</span>、<span class="tag">&lt;<span class="name">u</span>&gt;</span>、<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设我们对行内标签设置其宽高属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做是没有效果的。链接a的宽高属性不会改变。</p>
<p>在行内元素中有几个特殊的标签——<code>&lt;img /&gt;</code>、<code>&lt;input /&gt;</code>、<code>&lt;td&gt;</code>，<strong>可以对它们设置宽高和对齐属性</strong>，有些资料可能会称它们为行内块标签。那么标签的这种显示模式可不可以转换呢? 答案是可以，我们可以使用display属性对其进行转换，如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span>;       <span class="comment">/*将块级标签转换为行内标签*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>;        <span class="comment">/*将行内标签转换为块级标签*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>; <span class="comment">/*将块级标签或者行内标签转换为行内块标签*/</span></span><br></pre></td></tr></table></figure>

<p>我们来看一个例子，假设有下面的程序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标签显示模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            a &#123;</span><br><span class="line"><span class="css">                <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;  <span class="comment">/*取消下划线*/</span></span></span><br><span class="line"><span class="css">                <span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;       <span class="comment">/*设置背景颜色，用以观察该标签显示模式的转换*/</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为标签a是行内标签，所以这三个标签是显示在一行内的，如下:</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css06.png"/>
</center>

<p>并且无法对其设置宽高以及对齐属性。现在我们将标签<code>a</code>的显示模式改为块级模式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css07.png"/>
</center>

<p>可见链接已经变为了块级标签，一个标签占据一整行，并且我们可以对其设置宽高属性以及对其方式，如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css08.png"/>
</center>

<p>可见链接a的宽高发生了变化，并且其内的文字水平居中对齐了。我们可以把所有的标签看做是一个盒子，有的盒子是占据一行的，并且可以设置其大小，有的盒子只能在行内，并且不能设置其大小，还有的盒子虽然在行内，但是可以设置其大小。我们就用CSS对盒子进行操作，或摆放，或修饰，或改变盒子的显示模式等等。</p>
<h1 id="导航栏练习"><a href="#导航栏练习" class="headerlink" title="导航栏练习"></a>导航栏练习</h1><p>现在我们要做一个导航栏，其最终效果如下</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css09.gif"/>
</center>

<p>我们要求导航栏的布局居中显示，并且其内的文字也要居中对齐。并且当鼠标放在网站导航上，其背景图片发生变换。</p>
<p>首先第一步便是显示着六个链接，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css10.png"/>
</center>

<p>第二步，取消下划线，并且设置字体颜色为白色，并且添加背景图片，由于链接标签a是行内标签，其大小不可以改变，为了使添加的背景图片吻合，还需要改变其显示模式为display: inline-block,然后设置其宽高属性为图片宽高的大小。如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none; <span class="comment">/*取消下划线*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>; <span class="comment">/*设置字体颜色为白色*/</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(bg.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，为了只影响导航栏的链接标签，这里我们用了后代选择器。效果如下:</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css11.png"/>
</center>

<p>这个时候我们发现导航栏没有居中对齐，并且里面的文字没有居中对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设置.nav类里的文字居中对齐，但是div里面的是链接，text-align属性还有用吗? 答案是可以，链接在块类标签里面可以当做是文字处理，这是一个知识点，记住了。效果如下：</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css12.png"/>
</center>

<p>我们发现导航栏居中对齐了现在我们需要将链接里面的文字水平居中对齐和垂直居中对齐，在.nav a加入如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>;  <span class="comment">/*当行高等于标签设置的高度时，会使文字垂直居中对齐*/</span></span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css13.png"/>
</center>

<p>现在最后一步就是将鼠标放上去，背景图片改变，我们使用伪类hover,如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"bgc.png"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为了只对导航栏的链接生效，这里也用了后代选择器，效果如下:</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css14.gif"/>
</center>

<p>到这里我们已经完整的实现了导航栏的案例，下面贴出完整的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>导航栏案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>; <span class="comment">/*取消下划线*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>; <span class="comment">/*设置字体颜色为白色*/</span></span></span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 120px;</span><br><span class="line">            height: 50px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">bg</span><span class="selector-class">.png</span>);</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>("<span class="selector-tag">bgc</span><span class="selector-class">.png</span>");</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.nav</span> &#123;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>网站导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="行高-1"><a href="#行高-1" class="headerlink" title="行高"></a>行高</h1><p>在之前我们有提到这个属性line-height，该属性用来设置行高，并且我们用它来设置过行间距。为了明白行高指的是什么之间的距离，我们需要明白下面这个图</p>
<center>
    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/css15.png"/>
</center>

<p>一个文本内容被四条线划分，而行高指的就是基线与基线之间的距离，当不设置行高时，行高的大小为字体的大小，所以行与行之间是紧贴着的。</p>
<p>在导航栏练习中，为了使文字能够垂直居中对齐，我们让line-height的大小等于盒子的大小，为了解释这一现象，我们先看一下盒子的组成，盒子的高度由上距离，下距离和文本内容的高度组成，上距离的大小为(行高-内容高度)/2,下距离的高度=盒子高度-上距离的高度-内容高度。当文本垂直居中显示时，上距离的高度等于下距离的高度，这时上距离的高度=(盒子高度-内容高度)/2,对比于上距离高度的公式，得到此时行高等于盒子的高度。所以这就解释了为什么当行高等于盒子高度时，文字会垂直水平居中，当行高增大时，上距离的高度增大，文字会向下移动。</p>

    

        <a href="https://lastknightcoder.gitee.io/CSS%E5%9F%BA%E7%A1%80/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-HTML入门"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2019-02-08 00:00:00" datetime="2019-02-07T16:00:00.000Z"  itemprop="datePublished">2019-02-08</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Web/">Web</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.gitee.io/categories/Web/HTML/">HTML</a></li></ul></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="https://lastknightcoder.gitee.io/HTML%E5%85%A5%E9%97%A8/">HTML基础</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="需要的开发工具"><a href="#需要的开发工具" class="headerlink" title="需要的开发工具"></a>需要的开发工具</h2><p>由于目前的市场上Google的占有率最高，所以我们用Chorme作为开发用的浏览器，而写代码的工具有很多，我一般用WebStorm。</p>
<h2 id="第一个HTML页面"><a href="#第一个HTML页面" class="headerlink" title="第一个HTML页面"></a>第一个HTML页面</h2><p>一般新入手一个语言，都是先敲一个代码，然后在解释这个代码，按照惯例都是显示<code>Hello World</code>,所以这里就在网页中显示<code>Hello World</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上的程序可以写在任何文本编辑器中，然后将后缀名改为<code>.html</code>，用浏览器打开即可。</p>
<p>一般写html的格式应该如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;html&gt;,&lt;head&gt;</code>等等称为标签，在html中，内容都是由标签来呈现的，而标签分为双标签和单标签，一般我们遇到的都是双标签，比如上面的<code>&lt;html&gt;&lt;/html&gt;</code>是双标签，<code>&lt;html&gt;</code>是开始标签，<code>&lt;/html&gt;</code>是结束标签。单标签比如<code>&lt;br /&gt;</code>是换行标签，它的作用是换行。</p>
<p>其中<code>&lt;body&gt;&lt;/body&gt;</code>标签里写的东西才是网页呈现的内容，比如上面的<code>Hello World</code>就是写在<code>body</code>标签里面的,而<code>&lt;head&gt;&lt;/head&gt;</code>标签里写的东西都不会呈现在网页中，一般写的都是网页的信息，比如所用的编码，网页的标题，网页的版权等等。</p>
<p>我们一般会在第一行加上<code>&lt;!DOCTYPE html&gt;</code>,这个是用来告诉浏览器我们使用的浏览器版本，这么写的话就代表我们使用的是html5的版本。</p>
<h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在<code>html</code>中共有6种标题，分别是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">... ...</span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中h1为最大的标题，称为一级标题，<code>h6</code>称为六级标题，上面的标题标签都是双标签。</p>
<p>我们在网页中看看标题的效果:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示显示效果：</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html01.png"/>
</center>

</center>

<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落标签是用<code>&lt;p&gt;&lt;/p&gt;</code>标签来呈现的，在<code>&lt;p&gt;</code>标签内部的内容视为一个段落，该标签会根据浏览器窗口的大小自动换行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。</span><br><span class="line">        予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，</span><br><span class="line">        亭亭净植，可远观而不可亵玩焉。(甚爱 一作：盛爱)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。</span><br><span class="line">        噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人?牡丹之爱，宜乎众矣!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示显示效果：</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html02.png"/>
</center>

<p>在<code>html</code>代码中进行换行操作时，在网页显示时不会进行换行操作，<code>html</code>中所有的功能都是由标签实现的，所以换行也需要换行标签实现。</p>
<p>我们可以见到，段落之间会自动换行，并且段落之间还隔有一个空行。</p>
<h3 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h3><p>水平线标签<code>&lt;hr /&gt;</code>是一个单标签，它的作用是显示一条水平线。</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>换行标签为<code>&lt;br /&gt;</code>,也是一个单标签，它的作用是换行，换行之后，不会像段落一样之间还有一个空行，而是两行会紧贴着。</p>
<h3 id="两个无语义化的标签"><a href="#两个无语义化的标签" class="headerlink" title="两个无语义化的标签"></a>两个无语义化的标签</h3><p><code>&lt;div&gt;&lt;/div&gt;</code>和<code>&lt;span&gt;&lt;/span&gt;</code>,这两个标签没有实际的功能，在后面主要是配合<code>CSS</code>进行布局，所以这里就不要管它好了。</p>
<p><code>&lt;div&gt;</code>标签会实现自动换行，所以一行只能有一个<code>&lt;div&gt;</code>标签，<code>&lt;span&gt;</code>不会自动换行，所以一行可以有多个<code>&lt;span&gt;</code>标签。</p>
<p>我们来看一个简单的例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>会自动换行<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>不会自动换行<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>可以有多个<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示显示效果：</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html03.png"/>
</center>

<h2 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h2><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><p>加粗标签有两个，分别为<code>&lt;b&gt;&lt;/b&gt;</code>和<code>&lt;strong&gt;&lt;/strong&gt;</code>,二者都能进行加粗，不过<code>&lt;strong&gt;</code>标签比较有语义，所以用的比较多。</p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>斜体标签也有两个，分别为<code>&lt;i&gt;&lt;/i&gt;</code>和<code>&lt;em&gt;&lt;/em&gt;</code>,同样的，<code>&lt;em&gt;</code>用的比较多。</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>同样也有两个，分别为<code>&lt;s&gt;&lt;/s&gt;</code>和<code>&lt;del&gt;&lt;/del&gt;</code>,后面的有语义，用的多。</p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>两个，分别为<code>&lt;u&gt;&lt;/u&gt;</code>和<code>&lt;ins&gt;&lt;/ins&gt;</code>,后面的有语义，为<code>insert</code>的缩写，用的较多。</p>
<p>简单的演示一下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">del</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ins</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示显示效果：</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html04.png"/>
</center>

<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><p>向网页中添加图片的方法为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片的路径"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是一个单标签，<code>src</code>称为标签<code>&lt;img&gt;</code>的属性，它的值应该为图片的路径。</p>
<p>而路径又分为绝对路径和相对路径,下面将简单介绍一下二者，假设有如下的目录结构</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">磁盘<span class="selector-tag">C</span></span><br><span class="line">    <span class="selector-tag">file1</span>文件夹</span><br><span class="line">        <span class="selector-tag">html</span><span class="selector-class">.md</span></span><br><span class="line">        <span class="selector-tag">p1</span><span class="selector-class">.png</span></span><br><span class="line">        <span class="selector-tag">image</span>文件夹</span><br><span class="line">            <span class="selector-tag">p2</span><span class="selector-class">.png</span></span><br><span class="line">    <span class="selector-tag">p3</span><span class="selector-class">.png</span></span><br></pre></td></tr></table></figure>

<p>现在我打开的是html.md文件,如果我要与绝对路径插入p1.png, p2.png, p3.png这三张图片，那么方法是这样的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"C:/file1/p1.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"C:/file1/image/p2.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"C:/p3.png"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果以相对路径插入图片，那么图片相对于该文件的位置就很重要，下面演示如何以相对路径插入图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"p1.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/p2.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../p3.png"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>p1.png和文件html.md处于同一级目录，所以直接写src=”p1.png”即可，而p2.png位于image文件夹，该文件夹与html.md文件处于同一目录，所以写为src=”image/p2.png”,而p3.png位于上级目录，<code>..</code>表示上一级目录，所以写为src=”../p3.png”。</p>
<p>图像标签除了有<code>src</code>属性外，还有其他的属性，如下</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alt</td>
<td align="left">图像不能显示时的替换文本</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">鼠标悬停显示的内容</td>
</tr>
<tr>
<td align="left">width, height</td>
<td align="left">宽度和高度，设置其中一个就可以，会等比例的缩放</td>
</tr>
<tr>
<td align="left">border</td>
<td align="left">添加边框，其值为边框的粗细</td>
</tr>
</tbody></table>
<p>下面给一个示例写法:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"p1.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span> <span class="attr">title</span>=<span class="string">"p1.png"</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><p>我们碰到，当我们点击一句话就可以跳转到一个网页，或者点击一张图片跳转。那么这个就是用链接标签实现的。链接标签为:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接地址"</span>&gt;</span>跳转的文字或图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如你<a href="https://www.baidu.com" target="_blank" rel="noopener">点击这里</a>就会跳转到百度。比较需要注意的是，跳转到外部的网页要写成<a href="https://www.baidu.com，而不要写成www.baidu.com。" target="_blank" rel="noopener">https://www.baidu.com，而不要写成www.baidu.com。</a> 另外，注意这个跳转是在本页面打开的，而不是新打开一个页面，如果需要在新页面打开，则可以改变其属性target的值，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> <span class="attr">target</span> = <span class="string">"_blank"</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>target有两种值可选，分别为_self和_blank,默认为_self，即在本页面打开。除了可以跳转到外链，也可以在页面内进行跳转，你可以给一个标签设定一个id值,比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.png"</span> <span class="attr">id</span> = <span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我给这张插入的图片设了id值为1,那么我可以通过下面的语句跳转到这张图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#1"</span>&gt;</span>跳转到1.png<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过id跳转前面要加#号。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>该种列表在实际中使用的较多,效果大概是这样</p>
<ul>
    <li>足球</li>
    <li>篮球</li>
</ul>

<p>无序列表的标签为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意:<code>&lt;ul&gt;&lt;/ul&gt;</code>标签里面只能放<code>&lt;li&gt;&lt;/li&gt;</code>标签，而<code>&lt;li&gt;&lt;\li&gt;</code>能放任何内容。</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表也经常用，其标签与无序的很相似</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果是这样</p>
<ol>
    <li>足球</li>
    <li>篮球</li>
</ol>

<p>注意事项同无序。</p>
<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>使用以下格式定义自定义列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>球类<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<dl>
    <dt>球类</dt>
    <dd>足球</dd>
    <dd>篮球</dd>
</dl>

<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格在网页中也很常见，其写法为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>物理<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>99<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其效果为</p>
<table>
    <tr>
        <td>学科</td>
        <td>分数</td>
    </tr>
    <tr>
        <td>物理</td>
        <td>99</td>
    </tr>
</table>

<p><code>&lt;table&gt;&lt;/table&gt;</code>标签就表示表格，而<code>&lt;tr&gt;&lt;/tr&gt;</code>表示一行，<code>&lt;td&gt;&lt;/td&gt;</code>表示一个单元格。table标签有很多的属性，如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>align</td>
<td>该属性设定对齐方式，有left,center,right三个值可选</td>
</tr>
<tr>
<td>cellspacing</td>
<td>单元格与单元格之间的距离，默认为2</td>
</tr>
<tr>
<td>cellpadding</td>
<td>单元格内的字与单元格之间的距离，默认为1</td>
</tr>
</tbody></table>
<p>一般我们设置table的以下三个属性为0，这三个属性分别为cellspacing, cellpadding, border，称之为”三参为0”。我们还可使用<code>&lt;caption&gt;&lt;/caption&gt;</code>标签设置表格的标题，如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>物理<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>99<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
    <caption>成绩单</caption>
    <tr>
        <td>学科</td>
        <td>分数</td>
    </tr>
    <tr>
        <td>物理</td>
        <td>99</td>
    </tr>
</table>

<p>因为表头比较特殊，所以有的时候我们在表头中不用td，使用th,该标签会加粗居中，我们改动如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果为</p>
<table>
    <caption>成绩单</caption>
    <tr>
        <th>学科</th>
        <th>分数</th>
    </tr>
    <tr>
        <td>物理</td>
        <td>99</td>
    </tr>
</table>

<p>下面讲的这个在实际中也经常遇到的是单元格合并。假如有下面这个表格</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>123</td>
        <td>123</td>
        <td>123</td>
    </tr>
    <tr>
        <td>123</td>
        <td>123</td>
        <td>123</td>
    </tr>
    <tr>
        <td>123</td>
        <td>123</td>
        <td>123</td>
    </tr>
</table>

<p>我希望将最后一行的后两列合并成一个单元格,首先我们要知道单元格的合并分为行和并rowspan和列合并colspan,行合并是自左而右的，列合并是自上而下的。将最后一行的后两列合并为一个，所以是列和并，并且是两个合并成一个，所以colspan = “2”,所以上面的程序改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果为</p>
<table>
    <tr>
        <td>123</td>
        <td>123</td>
        <td>123</td>
    </tr>
    <tr>
        <td>123</td>
        <td>123</td>
        <td>123</td>
    </tr>
    <tr>
        <td>123</td>
        <td colspan="2">123</td>
    </tr>
</table>

<p>在第三个tr(代表第三行)的第二个td处设置colspan=”2”,因为要合并最后一列，所以要删去最后一个td。</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>现实中会经常提交表单，比如在注册邮箱时，你就需要提交表单，表单由三部分组成，表单控件，提示文本和表单域。</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html05.png"/>
</center>

<p>现在重点介绍表单控件，因为这个包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。与表单有关的标签是<code>&lt;input/ &gt;</code>,<code>&lt;input/ &gt;</code>是一个单标签，根据其属性type设置不同的值，可以指定不同的控件类型，如:</p>
<table>
<thead>
<tr>
<th>type的值</th>
<th>控件</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>单行文本输入框</td>
</tr>
<tr>
<td>password</td>
<td>密码输入框</td>
</tr>
<tr>
<td>radio</td>
<td>单选按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>复选框</td>
</tr>
<tr>
<td>button</td>
<td>普通按钮</td>
</tr>
<tr>
<td>submit</td>
<td>提交按钮</td>
</tr>
<tr>
<td>reset</td>
<td>重置按钮</td>
</tr>
<tr>
<td>image</td>
<td>图像形式的提交按钮</td>
</tr>
<tr>
<td>file</td>
<td>文件域</td>
</tr>
</tbody></table>
<p><code>&lt;input/ &gt;</code>还有其他的属性配合type属性使用，如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>控件的名称</td>
</tr>
<tr>
<td>value</td>
<td>控件的默认文本值</td>
</tr>
<tr>
<td>size</td>
<td>控件在页面中的显示宽度，只能为正整数</td>
</tr>
<tr>
<td>checked</td>
<td>定义选择控件默认被选中的项</td>
</tr>
<tr>
<td>maxlength</td>
<td>控件允许输入的最大字符数</td>
</tr>
</tbody></table>
<p>这里我想说一下单选按钮，假设有两个单选按钮，比如男和女让你选，按道理只能选一个，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以发现两个都可以选到，解决办法将二者的name属性设置为相同的，比如sex,相同的name代表他们是同一组的，对于单选按钮，同一组的只能选中一个。</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html06.gif"/>
</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个时候你只能选一个。</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html07.gif"/>
</center>

<p>下面要介绍一个<code>&lt;label&gt;&lt;/label&gt;</code>标签，当label与一个表单控件绑定时，点击该label会获得该控件的输入焦点,那么如何与表单控件绑定呢?使用for属性,如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"word"</span>&gt;</span>Sex<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"word"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你点击Sex,会自动获得输入焦点。效果如下:</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html08.gif"/>
</center>

<p>text只能输入一行的文本，事实上，我们在网页中经常见可以输入多行文本的输入框，比如在我们发表评论时的输入框，多行输入的标签是textarea,使用方法如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"每行中的字符数"</span> <span class="attr">rows</span>=<span class="string">"显示的行数"</span>&gt;</span></span><br><span class="line">  默认显示文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<center>
<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/html09.png"/>
</center>

<p>最后一个要介绍的就是下拉菜单，下拉菜单的标签是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下所示</p>
<center>
<select>
    <option>北京</option>
    <option>上海</option>
    <option>青岛</option>
</select>
</center>

<p>当option中设置selected属性为selected=”selected”,那么这个option是默认选中项。比如我要设置上海为默认选中项那么</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>
<select>
    <option>北京</option>
    <option selected="selected">上海</option>
    <option>青岛</option>
</select>
</center>

    

        <a href="https://lastknightcoder.gitee.io/HTML%E5%85%A5%E9%97%A8/" class="post-more waves-effect waves-button">
            阅读全文…
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/HTML/" rel="tag">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </div>
    
</article>

        </li>
    
    </ul>

    
<nav id="page-nav">
    <div class="inner">
    <a class="extend prev" rel="prev" href="https://lastknightcoder.gitee.io/page/3/">上一页</a><a class="page-number" href="https://lastknightcoder.gitee.io/">1</a><a class="page-number" href="https://lastknightcoder.gitee.io/page/2/">2</a><a class="page-number" href="https://lastknightcoder.gitee.io/page/3/">3</a><span class="page-number current">4</span>
    </div>
</nav>


</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="https://lastknightcoder.gitee.io/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>熊滔 &copy; 2019 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.gitee.io/page/4/&title=Coder&pic=https://lastknightcoder.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.gitee.io/page/4/&title=Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.gitee.io/page/4/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=Coder&url=https://lastknightcoder.gitee.io/page/4/&via=https://lastknightcoder.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.gitee.io/page/4/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABzklEQVR42u3aS27DMAwFQN//0u62QBv7kbRUFxitjCRQRl4Q/Og44nV+Wz8/T35/fljHioWLizvmnpfrJ+uakhzjes+bI+Hi4m7k5lsngWnyfGPDxcV9JTdJUHp74uLi/kduHpKSwgYXF/f93CRlyVm9lOjhWg0XF3fAzbuU656X9HdxcXFb3LO4eoGv1yT9ZQdcXNwt3PkopVcUXSdANwkTLi7uYm5vWJL/ZfLL5EoHLi7ufm5ehFxvnXxbbc5+zMhwcXGXcfMwNC+Kqk0QXFzcd3KTw1RTmV6L5EhAuLi4j3KfolQHJPmrwcXF/StuslH16lV1yBo1UnFxcRdze8lH/ibyBmt0JFxc3I3c3pWpXqmTl0MfAxkuLu5ibm9AUr2UmQ9To5eFi4u7hZsXLdUxan7s6lUtXFzc1dzkLydhaF4y3ZRAuLi4i7mTixG9Yz+QkeHi4j7KPYur0LwoXumI2qm4uLhbuL3g1Wt/TJovuLi4+7l58JpfwcxTpZviBxcXdwu32jBN0pdJ7IwuYeDi4r6GmwSp3rGjtiwuLu4ruXnxUz1Y1ELFxcXdyM2Ln+pINS+EorEKLi7uFm45lAyapNXRy6i/i4uL2+F+Aa3w2FdMVdcAAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://lastknightcoder.gitee.io/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
