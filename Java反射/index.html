<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="熊滔"><meta name="description" content="人生天地间，忽如远行客"><link rel="alternative" href="/atom.xml" title="Coder" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Java反射 - Coder</title>
<link rel="stylesheet" href="https://lastknightcoder.gitee.io/css/main.css">

<link rel="stylesheet" href="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="https://lastknightcoder.gitee.io/js/jquery-3.1.1.min.js"></script>

<script src="https://lastknightcoder.gitee.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="https://lastknightcoder.gitee.io/">Coder</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://lastknightcoder.gitee.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-07-19T16:00:00.000Z">2019-07-20 00:00:00</time><h1 class="post__title"><a href="https://lastknightcoder.gitee.io/Java%E5%8F%8D%E5%B0%84/">Java反射</a></h1><div class="post__main echo"><p>反射是框架设计的灵魂，通过反射我们可以在程序运行时读取配置文件动态的创建一个类，也可以通过读取注解来达到我们想到的功能。与反射有关的类是Class类。</p>
<a id="more"></a>

<h3 id="Class类对象的获取方法"><a href="#Class类对象的获取方法" class="headerlink" title="Class类对象的获取方法"></a>Class类对象的获取方法</h3><p>Class类对象的获取方法有三种</p>
<ul>
<li>Class.forName(String name)<ul>
<li>参数是类的全类名(包名+类名)，可以获得该类的Class对象</li>
</ul>
</li>
<li>类名.class<ul>
<li>通过类的静态属性class可以获取Class对象</li>
</ul>
</li>
<li>对象.getClass()<ul>
<li>通过对象的getClass()方法可以获取Class对象</li>
</ul>
</li>
</ul>
<p>假设一个Animal类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat "</span> + string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sleep ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在要通过上面的三种方法获取该类的Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过全类名获取Class对象</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"Animal"</span>);</span><br><span class="line"><span class="comment">//通过类的静态属性class获取Class对象</span></span><br><span class="line">Class cls2 = Animal<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//通过对象的getClass()获取静态对象</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">Class cls3 = animal.getClass();</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，通过上面三种方法获取的Class对象是同一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cls1 == cls2); <span class="comment">//true</span></span><br><span class="line">System.out.println(cls1 == cls3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="Class类的常见成员方法"><a href="#Class类的常见成员方法" class="headerlink" title="Class类的常见成员方法"></a>Class类的常见成员方法</h3><h4 id="与成员变量有关的方法"><a href="#与成员变量有关的方法" class="headerlink" title="与成员变量有关的方法"></a>与成员变量有关的方法</h4><ul>
<li>getFields()<ul>
<li>获取public修饰的所有成员变量，返回一个Field[]</li>
</ul>
</li>
<li>getField(String name)<ul>
<li>获取指定名称被public修饰的成员变量</li>
</ul>
</li>
<li>getDeclaredFields()<ul>
<li>同getFields()，不过任意修饰符修饰的都可以获取</li>
</ul>
</li>
<li>getDeclaredField(String name)<ul>
<li>同getField(String name)，不过任意修饰符修饰的都可以获取</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields1 = cls1.getFields();</span><br><span class="line"><span class="comment">//public java.lang.String Animal.name</span></span><br><span class="line"><span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">Field[] fields2 = cls1.getDeclaredFields();</span><br><span class="line"><span class="comment">//public java.lang.String Animal.name</span></span><br><span class="line"><span class="comment">//private int Animal.age</span></span><br><span class="line"><span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">Field field1 = cls1.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//private int Animal.age</span></span><br><span class="line">System.out.println(field1);</span><br></pre></td></tr></table></figure>

<p>可以通过set(Object obj, Object value)方法对指定的对象设定值，也可以通过get(Object obj)方法来获取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field field2 = cls1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">field2.set(animal,<span class="string">"Dog"</span>);</span><br><span class="line">System.out.println(animal.name); <span class="comment">//Dog</span></span><br><span class="line">System.out.println(field2.get(animal)); <span class="comment">//Dog</span></span><br></pre></td></tr></table></figure>

<p>如果我们要对age进行赋值，因为age变量是private修饰的，是不能在类外面直接访问的，我们可以调用setAccessible(true)方法，来忽略访问修饰符的安全检查(暴力反射)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field field1 = cls1.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(animal,<span class="number">10</span>);</span><br><span class="line">System.out.println(field1.get(animal)); <span class="comment">//10</span></span><br><span class="line"><span class="comment">//System.out.println(animal.age); //会报错，不能这么访问</span></span><br></pre></td></tr></table></figure>

<h4 id="与构造方法有关的方法"><a href="#与构造方法有关的方法" class="headerlink" title="与构造方法有关的方法"></a>与构造方法有关的方法</h4><ul>
<li>getConstructors()<ul>
<li>得到由public修饰的所有构造方法</li>
</ul>
</li>
<li>getConstructor()<ul>
<li>获取指定参数的构造函数，如<ul>
<li>getConstructor()：获取无参构造函数</li>
<li>getConstructor(String.class, int.class)：获得第一个参数类型为String类型和第二个参数类型为int类型的构造方法</li>
</ul>
</li>
</ul>
</li>
<li>cls1.getDeclaredConstructors()<ul>
<li>参照Field</li>
</ul>
</li>
<li>cls1.getDeclaredConstructor()<ul>
<li>参照Field</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得无参的构造方法</span></span><br><span class="line">Constructor cons1 = cls1.getConstructor();</span><br><span class="line">Stream.of(cons1).forEach(System.out::println); <span class="comment">//public Animal()</span></span><br><span class="line"><span class="comment">//获得参数类型分别为String类型和int类型的构造方法</span></span><br><span class="line">Constructor cons2 = cls1.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Stream.of(cons1).forEach(System.out::println); <span class="comment">//public Animal()</span></span><br></pre></td></tr></table></figure>

<p>现在获得了构造方法，那么构造方法的作用就是创造对象，我们可以通过Contructor对象的的newInstance()方法创建一个对象，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//newInstance方法返回的是一个Object对象</span></span><br><span class="line">Animal animal1 = (Animal) cons1.newInstance();</span><br><span class="line">Animal animal2 = (Animal) cons2.newInstance(<span class="string">"Cat"</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(animal1);</span><br><span class="line">System.out.println(animal2);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal&#123;name=<span class="string">'null'</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Animal&#123;name=<span class="string">'Cat'</span>, age=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果想创建一个无参的对象，可以直接通过Class对象的newInsatance()方法创建，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal3 = (Animal) cls1.newInstance();</span><br></pre></td></tr></table></figure>

<h4 id="与成员方法有关的方法"><a href="#与成员方法有关的方法" class="headerlink" title="与成员方法有关的方法"></a>与成员方法有关的方法</h4><ul>
<li>getMethods<ul>
<li>获取所有public修饰的方法</li>
</ul>
</li>
<li>getMethod()<ul>
<li>通过方法名和参数类型(区别重载的方法)获取public修饰的指定方法</li>
</ul>
</li>
<li>getDeclaredMethods<ul>
<li>忽略修饰符</li>
</ul>
</li>
<li>getDeclaredMethod<ul>
<li>忽略修饰符</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取不带参数的eat方法</span></span><br><span class="line">Method eat1 = cls1.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"><span class="comment">//获取带一个参数类型为String的eat方法</span></span><br><span class="line">Method eat2 = cls1.getMethod(<span class="string">"eat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//获取private修饰的sleep方法</span></span><br><span class="line">Method sleep = cls1.getDeclaredMethod(<span class="string">"sleep"</span>);</span><br></pre></td></tr></table></figure>

<p>获取到了方法，那么接下来就是怎么使用的问题，我们可以使用invoke()方法来执行方法，需要传入相应的对象和需要的参数，如果方法不需要参数，那么可以不传，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat1.invoke(animal);</span><br><span class="line"><span class="comment">//需要传入参数</span></span><br><span class="line">eat2.invoke(animal,<span class="string">"饭"</span>);</span><br><span class="line"><span class="comment">//因为sleep是private修饰的，要执行就要执行下面这一步</span></span><br><span class="line">sleep.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">sleep.invoke(animal);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat ...</span><br><span class="line">eat 饭</span><br><span class="line">sleep ...</span><br></pre></td></tr></table></figure>

<p>我们还可以通过getName()方法获得方法名，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(eat1.getName()); <span class="comment">//eat</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过Class对象的getName()方法获得该类的全类名(包名+类名)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cls1.getName()); <span class="comment">//Animal</span></span><br></pre></td></tr></table></figure>

<h3 id="使用反射读取配置文件动态创建任意的对象"><a href="#使用反射读取配置文件动态创建任意的对象" class="headerlink" title="使用反射读取配置文件动态创建任意的对象"></a>使用反射读取配置文件动态创建任意的对象</h3><p>我们现在有这么一个需求，那就是希望创建任意一个类的对象，并且调用相应的方法，要求不能更改代码，而只需要更改配置文件即可。现在我们创建一个config.properties的配置文件，内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">className=Animal</span><br><span class="line">methodName=eat</span><br></pre></td></tr></table></figure>

<p>我们要做的就是读取配置文件，然后根据配置文件创建相应类的对象并且调用其方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建Properties读取配置文件</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        pro.load(<span class="keyword">new</span> FileReader(<span class="string">"G:\\JavaProject\\Fourth\\src\\config.properties"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得类名和方法名</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据类名获取Class对象</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//使用无参构造方法创建对象</span></span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们运行一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eat ...</span><br></pre></td></tr></table></figure>

<p>现在我们要创建什么类的对象并且要调用什么方法，只需要修改配置文件就可以了，不用修改代码了。虽然还有很多的问题，比如只能使用无参构造方法创建对象，只能调用无参的方法，不过即使是这样也让我们感受到了反射的强大。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/Java/">Java</a></li><li class="post__tag__item"><a class="post__tag__link" href="https://lastknightcoder.gitee.io/tags/%E5%8F%8D%E5%B0%84/">反射</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="https://lastknightcoder.gitee.io/img/wechatpay.png" title="微信"><img src="https://lastknightcoder.gitee.io/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2019 - 2020 熊滔</div></footer>
<script src="https://lastknightcoder.gitee.io/js/scroller.js"></script>

<script src="https://lastknightcoder.gitee.io/js/main.js"></script>
</body></html>