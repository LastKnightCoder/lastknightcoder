<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Node.js之EventEmitter | Coder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="EventEmitter">
    <meta name="description" content="EventEmitter 的使用EventEmitter 为我们提供了事件订阅机制，通过引入 events 模块来使用它。 const &amp;#123;EventEmitter&amp;#125; &#x3D; require(&quot;events&quot;);const eventEmitter &#x3D; new EventEmitter();&#x2F;&#x2F; 监听 data 事件eventEmitter.on(&quot;data&quot;, () &#x3D;&gt; &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js之EventEmitter">
<meta property="og:url" content="https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/">
<meta property="og:site_name" content="Coder">
<meta property="og:description" content="EventEmitter 的使用EventEmitter 为我们提供了事件订阅机制，通过引入 events 模块来使用它。 const &amp;#123;EventEmitter&amp;#125; &#x3D; require(&quot;events&quot;);const eventEmitter &#x3D; new EventEmitter();&#x2F;&#x2F; 监听 data 事件eventEmitter.on(&quot;data&quot;, () &#x3D;&gt; &amp;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-11T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-11T16:00:00.000Z">
<meta property="article:author" content="熊滔">
<meta property="article:tag" content="EventEmitter">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="Coder" href="https://lastknightcoder.github.io/lastknightcoder/atom.xml">
    
    <link rel="shortcut icon" href="https://lastknightcoder.github.io/lastknightcoder/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://lastknightcoder.github.io/lastknightcoder/img/brand.jpg)">
      <div class="brand">
        <a href="https://lastknightcoder.github.io/lastknightcoder/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">熊滔</h5>
          <a href="mailto:2223106858@qq.com" title="2223106858@qq.com" class="mail">2223106858@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/LastKnightCoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Node.js之EventEmitter</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Node.js之EventEmitter</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-03-11T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2021-03-12
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.github.io/lastknightcoder/categories/Node/">Node</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EventEmitter-的使用"><span class="post-toc-number">1.</span> <span class="post-toc-text">EventEmitter 的使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#on、addListener"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">on、addListener</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#执行顺序"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">执行顺序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#重复添加"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">重复添加</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#传递参数"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">传递参数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#同步执行"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">同步执行</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#off、removeListener"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">off、removeListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#once"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">once</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#prependListener、prependOnceListener"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">prependListener、prependOnceListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#removeAllListeners"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">removeAllListeners</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#eventNames"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">eventNames</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#listenerCount"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">listenerCount</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#setMaxLsiteners、getMaxListeners"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">setMaxLsiteners、getMaxListeners</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#listeners、rawListeners"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">listeners、rawListeners</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现一个-EventEmitter"><span class="post-toc-number">2.</span> <span class="post-toc-text">实现一个 EventEmitter</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#on、addListener-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">on、addListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#emit"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">emit</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#prependListener"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">prependListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#off、removeListener-1"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">off、removeListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#once、prependOnceListener"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">once、prependOnceListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#removeAllListeners-1"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">removeAllListeners</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#eventNames-1"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">eventNames</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#listenerCount-1"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">listenerCount</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文献"><span class="post-toc-number">3.</span> <span class="post-toc-text">参考文献</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Node.js之EventEmitter"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Node.js之EventEmitter</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-03-12 00:00:00" datetime="2021-03-11T16:00:00.000Z"  itemprop="datePublished">2021-03-12</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.github.io/lastknightcoder/categories/Node/">Node</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="EventEmitter-的使用"><a href="#EventEmitter-的使用" class="headerlink" title="EventEmitter 的使用"></a>EventEmitter 的使用</h2><p>EventEmitter 为我们提供了事件订阅机制，通过引入 <code>events</code> 模块来使用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 data 事件</span></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 data 事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码我们使用 <code>on</code> 方法来为事件绑定回调函数，使用 <code>emit</code> 方法来触发一个事件。</p>
<h3 id="on、addListener"><a href="#on、addListener" class="headerlink" title="on、addListener"></a>on、addListener</h3><p>我们可以通过 <code>on</code> 和 <code>addListener</code> 方法来为某事件添加一个监听器，二者的使用是一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.addListener(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第一个参数为事件名，第二个参数为对应的回调函数，当 EventEmitter 实例对象调用 <code>emit</code> 触发相应的事件时便会调用该回调函数，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.addListener(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>在控制台会打印出两次 <code>data</code></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面的例子也可以看出，可以为同一事件绑定多个回调函数。</p>
</blockquote>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>当使用 <code>on</code> 或 <code>addListener</code> 绑定多个回调函数时，触发的顺序就是添加的顺序，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>会在控制台依次打印出</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> 1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> 2</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> 3</span></span><br></pre></td></tr></table></figure>

<h4 id="重复添加"><a href="#重复添加" class="headerlink" title="重复添加"></a>重复添加</h4><p>并且使用 <code>on</code> 方法绑定事件时，并不会做去重检查</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listener = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"lsitener"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, listener);</span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, listener);</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台的打印结果为</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lsitener</span></span><br><span class="line"><span class="attribute">lsitener</span></span><br></pre></td></tr></table></figure>

<p>上面的程序为事件绑定了两次 <code>listener</code> 这个函数，但是内部并不会检查是否已经添加过这个回调函数，然后去重，所以上面在控制台打印出了两次 listener。</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>另外回调函数还可以接收参数，参数通过 <code>emit</code> 触发事件时传入，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为回调函数传入参数 HelloWorld!</span></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>, <span class="string">"HelloWorld!"</span>);</span><br></pre></td></tr></table></figure>

<p>上面我们使用 <code>emit</code> 触发事件时，还传递了额外的参数，这个参数会被传递给回调函数。</p>
<h4 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h4><p>另外一个比较关心的问题，事件的触发是同步的还是异步的，我们做一个实验</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"触发了 data 事件！"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure>

<p>上面我们我们在触发事件前后都向控制台打印了信息，如果触发事件后是异步执行的，那么后面的打印语句就会先执行，否则如果是同步的话，就会先执行事件绑定的回调函数。执行结果如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">触发了 data 事件！</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>可见事件触发是同步执行的。</p>
<h3 id="off、removeListener"><a href="#off、removeListener" class="headerlink" title="off、removeListener"></a>off、removeListener</h3><p><code>off</code> 与 <code>removeListener</code> 方法的作用同 <code>on</code> 和 <code>addLsitener</code> 的作用是相反的，它们的作用是为某个事件删除对应的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> listener1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"listener1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> listener2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"listener2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, listener1);</span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次触发，两个回调函数否会执行</span></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br><span class="line"></span><br><span class="line">eventEmitter.off(<span class="string">"data"</span>, listener1);</span><br><span class="line"><span class="comment">// 第二次触发，只会执行 listener2</span></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台打印结果为</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">liste<span class="symbol">ner1</span></span><br><span class="line">liste<span class="symbol">ner2</span></span><br><span class="line">liste<span class="symbol">ner2</span></span><br></pre></td></tr></table></figure>

<p>第一次触发事件时，两个事件都会触发，然后我们为事件删除了 listener1 这个回调函数，所以第二次触发时，只会触发 listener2。</p>
<blockquote>
<p>注意：如果我们使用 <code>on</code> 或者 <code>addListener</code> 绑定的是一个匿名函数，那么便无法通过 <code>off</code> 和 <code>removeListener</code> 去解绑一个回调函数，因为它会通过比较两个函数的引用是否相同来解绑函数的。</p>
</blockquote>
<h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><p>使用 <code>once</code> 可以绑定一个只执行一次的回调函数，当触发一次之后，该回调函数便自动会被解绑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.once(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码我们使用 <code>once</code> 为 <code>data</code> 事件绑定了一个回调函数，然后使用 <code>emit</code> 方法触发了两次，因为使用 <code>once</code> 绑定的回调函数只会被触发一次，所以第二次触发，回调函数不会执行，所以在控制台只打印了一次 data。</p>
<p>另外同 <code>on</code> 绑定的回调函数一样，我们同样可以通过 <code>emit</code> 方法向回调函数传递参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.once(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台打印结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<h3 id="prependListener、prependOnceListener"><a href="#prependListener、prependOnceListener" class="headerlink" title="prependListener、prependOnceListener"></a>prependListener、prependOnceListener</h3><p>使用 <code>on</code> 或者 <code>addListener</code> 为事件绑定的回调函数会被根据添加的顺序执行，而使用 <code>prependLsitener</code> 绑定的事件回调函数会在其他回调函数之前执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"on"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.prependListener(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"prepend"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>上述代打我们先用控制台的打印结果为</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">prepend</span><br><span class="line"><span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<p><code>prependOnceListener</code> 同 <code>prependListener</code>，不过它绑定的回调函数只会被执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"on"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.prependOnceListener(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"prepend once"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>上面我们使用 <code>prependOnceListener</code> 绑定了一个回调函数，当触发事件时，该回调函数会在其他函数之前执行，并且只会执行一次，所以当第二次我们触发函数时，该回调函数不会执行，控制台打印结果为</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">prepend once</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line"><span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<h3 id="removeAllListeners"><a href="#removeAllListeners" class="headerlink" title="removeAllListeners"></a>removeAllListeners</h3><p><code>removeAllListeners([event])</code> 方法可以删除事件 <code>event</code> 绑定的所有回调函数，如果没有传入 <code>event</code> 参数的话，那么该方法就会删除所有事件绑定的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br><span class="line">eventEmitter.removeAllListeners(<span class="string">"data"</span>);</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>上面程序为 <code>data</code> 事件绑定了两个回调函数，并且在调用 <code>removeAllListeners</code> 方法之前分别触发了一次 <code>data</code> 事件，第二次触发 <code>data</code> 事件时，不会有任何的回调函数被执行，<code>removeAllListeners</code> 删除了 <code>data</code> 事件绑定的所有回调函数。控制台的打印结果为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> 1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> 2</span></span><br></pre></td></tr></table></figure>

<h3 id="eventNames"><a href="#eventNames" class="headerlink" title="eventNames"></a>eventNames</h3><p>通过 <code>eventNames</code> 方法我们可以知道为哪些事件绑定了回调函数，它返回一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"start"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.on(<span class="string">"error"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eventEmitter.eventNames()); <span class="comment">// [ 'start', 'end', 'error' ]</span></span><br></pre></td></tr></table></figure>

<p>如果我们将某事件的所有回调函数删除后，此时 <code>eventNames</code> 便不会返回该事件了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventEmitter.removeAllListeners(<span class="string">"error"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventEmitter.eventNames()); <span class="comment">// [ 'start', 'end' ]</span></span><br></pre></td></tr></table></figure>

<h3 id="listenerCount"><a href="#listenerCount" class="headerlink" title="listenerCount"></a>listenerCount</h3><p><code>listenerCount</code> 方法可以得到某个事件绑定了多少个回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eventEmitter.listenerCount(<span class="string">"data"</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="setMaxLsiteners、getMaxListeners"><a href="#setMaxLsiteners、getMaxListeners" class="headerlink" title="setMaxLsiteners、getMaxListeners"></a>setMaxLsiteners、getMaxListeners</h3><p><code>setMaxListeners</code> 是用来设置最多为每个事件绑定多少个回调函数，但是实际上是可以绑定超过设置的数目的回调函数的，不过当你绑定超过指定数目的回调函数时，会在控制台给出一个警告</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置只能为每个回调函数绑定 1 个回调函数</span></span><br><span class="line">eventEmitter.setMaxListeners(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 data 事件绑定了三个回调函数</span></span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.on(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data 3"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行上述程序，控制台打印结果为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data <span class="number">1</span></span><br><span class="line">data <span class="number">2</span></span><br><span class="line">data <span class="number">3</span></span><br><span class="line">(node:<span class="number">36928</span>) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. <span class="number">2</span> data listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit</span><br></pre></td></tr></table></figure>

<p>可见事件绑定的三个回调函数都可以被触发，并且在控制台打印出了一条警告信息。</p>
<p><code>getMaxListeners</code> 是获得能为每个事件绑定多少个回调函数的方法，使用 <code>setMaxListeners</code> 设置的值时多少，返回的值就是多少</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.setMaxListeners(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eventEmitter.getMaxListeners()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果没有使用 <code>setMaxLsiteners</code> 进行设置，那么默认能够为每个事件最多绑定 <code>10</code> 个回调函数，可以通过 <code>EventEmitter</code> 的 <code>defaultMaxListeners</code> 属性获得该值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(EventEmitter.defaultMaxListeners); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="listeners、rawListeners"><a href="#listeners、rawListeners" class="headerlink" title="listeners、rawListeners"></a>listeners、rawListeners</h3><p>当我们使用 <code>once</code> 绑定一个回调函数时，不会直接为该事件绑定该函数，而是会使用一个函数包装该函数，这个包装函数称为 <code>wrapper</code>，然后为该事件绑定 <code>wrapper</code> 函数，在 <code>wrapper</code> 函数内部，设定了当执行一次之后将自己解绑的逻辑。</p>
<p><code>listeners</code> 返回指定事件绑定的回调函数组成的数组，而 <code>rawListeners</code> 也是返回指定事件绑定的回调函数组成的数组，与 <code>listeners</code> 不同的是，对于 <code>once</code> 绑定的回调函数返回的是 <code>wrapper</code>，而不是原生绑定的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.once(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"once"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fns = eventEmitter.listeners(<span class="string">"data"</span>);</span><br><span class="line"><span class="comment">// once 绑定的函数，不是 wrapper，内部没有解绑的逻辑，所以后面触发 data 事件时还会执行 once 绑定的函数</span></span><br><span class="line">fns[<span class="number">0</span>]()</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台打印结果为</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure>

<p>下面将上面的 <code>listeners</code> 替换为 <code>rawListeners</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;EventEmitter&#125; = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.once(<span class="string">"data"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"once"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fns = eventEmitter.rawListeners(<span class="string">"data"</span>);</span><br><span class="line"><span class="comment">// 因为返回的是 once 绑定函数的 wrapper，其内部有执行一次后解绑的逻辑</span></span><br><span class="line"><span class="comment">// 所以后面触发事件时 once 绑定的函数不会再执行</span></span><br><span class="line">fns[<span class="number">0</span>]()</span><br><span class="line">eventEmitter.emit(<span class="string">"data"</span>);</span><br></pre></td></tr></table></figure>

<p>控制台的打印结果为</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure>

<h2 id="实现一个-EventEmitter"><a href="#实现一个-EventEmitter" class="headerlink" title="实现一个 EventEmitter"></a>实现一个 EventEmitter</h2><p>在这个小节将从零实现一个 EventEmitter，来加深对该模块的理解。首先我们需要准备一个 <code>listeners</code> 来存储所有绑定的回调函数，它是一个 <code>Map</code> 对象，键是事件名，而值是一个数组，数组中保存的是该事件绑定的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="on、addListener-1"><a href="#on、addListener-1" class="headerlink" title="on、addListener"></a>on、addListener</h3><p>使用 <code>on</code> 绑定回调函数时，我们先判断 <code>Map</code> 集合中是否有为该事件绑定回调函数，如果有取出对应数组，并添加该回调函数进数组，没有则新建一个数组，添加该回调函数，并添加进 <code>Map</code> 集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on(event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    fns.push(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addListener</code> 的功能与 <code>on</code> 是一样的，我们直接调用 <code>on</code> 方法即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addListener(event, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.on(event, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h3><p>当我们使用 <code>emit</code> 触发事件时，我们从 <code>Map</code> 取出对应的回调函数组成的数组，然后依次取出函数执行。另外我们还可以通过 <code>emit</code> 传递参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">emit(event, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> fn <span class="keyword">of</span> fns) &#123;</span><br><span class="line">        values.push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> values) &#123;</span><br><span class="line">        fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里你可能会觉得我写的有点复杂，所以你会觉得直接这么写更好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">emit(event, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> fns) &#123;</span><br><span class="line">        fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我也是这么写的，但是因为 <code>once</code> 绑定的函数它在执行完毕后将自己从数组中移除，并且是同步的，所以在执行循环的时候，数组是在不断变化的，使用上述的方式会使得一些回调函数会被漏掉，所以我才会先将数组中的函数复制到另一个数组，然后遍历这个新的数组，因为 <code>once</code> 绑定的函数它只会删除原数组中的函数，而不会删除新的这个数组，所以新数组的长度在遍历的过程不会改变，也就不会发生漏掉函数未执行的情况。</p>
</blockquote>
<h3 id="prependListener"><a href="#prependListener" class="headerlink" title="prependListener"></a>prependListener</h3><p>实现 <code>prependListener</code> 的逻辑同 <code>on</code> 一样，不过我们是往数组的最前方添加回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prependListener(event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    fns.unshift(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="off、removeListener-1"><a href="#off、removeListener-1" class="headerlink" title="off、removeListener"></a>off、removeListener</h3><p>使用 <code>off</code> 方法是用来解绑事件的，在数组中找到指定的函数，然后删除即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">off(event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    <span class="comment">// 找出数组中的回调函数，然后删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fns[i] === callback) &#123;</span><br><span class="line">            fns.splice(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果删除回调函数后，数组为空，则删除该事件</span></span><br><span class="line">    <span class="keyword">if</span> (fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.delete(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>removeListener</code> 同 <code>off</code> 的作用一样，我们在内部直接调用 <code>off</code> 方法即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">removeListener(event, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.off(event, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="once、prependOnceListener"><a href="#once、prependOnceListener" class="headerlink" title="once、prependOnceListener"></a>once、prependOnceListener</h3><p>使用 <code>once</code> 绑定一个只执行一次的函数，所以我们需要将绑定的回调函数使用一个函数包装一下，然后添加进数组中，这个包装函数我们称之为 <code>wrapper</code>。在包装函数中，当执行一遍后会将自己从数组中删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">once(event, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        callback(...args);</span><br><span class="line">        <span class="keyword">this</span>.off(event, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    fns.push(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prependOnceListener</code> 的实现同 <code>once</code>，只是向数组的开头插入函数，将上面代码中的 <code>push</code> 换为 <code>unshift</code> 即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prependOnceListener(event, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        callback(...args);</span><br><span class="line">        <span class="keyword">this</span>.off(event, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    fns.unshift(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="removeAllListeners-1"><a href="#removeAllListeners-1" class="headerlink" title="removeAllListeners"></a>removeAllListeners</h3><p>直接从删除对应的事件，如果没有传入具体事件的话，则需要删除所有的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">removeAllListeners(event) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 event，则删除所有事件</span></span><br><span class="line">    <span class="keyword">if</span> (event === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.listeners.delete(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="eventNames-1"><a href="#eventNames-1" class="headerlink" title="eventNames"></a>eventNames</h3><p>获得已经绑定了哪些事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> [...this.listeners.keys()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listenerCount-1"><a href="#listenerCount-1" class="headerlink" title="listenerCount"></a>listenerCount</h3><p>获得某事件绑定可多少个回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">listenerCount(event) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listeners.get(event).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述的实现有一个 bug，那就是无法删除使用 <code>once</code> 绑定的函数，我的想法是使用一个 <code>Map</code> 将 <code>once</code> 绑定的函数同对应的 <code>wrapper</code> 对应，删除时即可根据 <code>once</code> 的回调函数找到对应的 <code>wrapper</code> 然后删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.listeners = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 保存 once 的回调函数与对应的 wrapper </span></span><br><span class="line">    <span class="keyword">this</span>.onceToWrapper = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">once(event, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        callback(...args);</span><br><span class="line">        <span class="comment">// 删除之前，删除 callback 和 wrapper 的关系</span></span><br><span class="line">        <span class="keyword">this</span>.onceToWrapper.delete(callback);</span><br><span class="line">        <span class="keyword">this</span>.off(event, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    <span class="comment">// 添加之前，绑定 callback 和 wrapper 的关系</span></span><br><span class="line">    <span class="keyword">this</span>.onceToWrapper.set(callback, wrapper);</span><br><span class="line">    fns.push(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prependOnceListener(event, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        callback(...args);</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">this</span>.onceToWrapper.delete(callback);</span><br><span class="line">        <span class="keyword">this</span>.off(event, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">this</span>.onceToWrapper.set(callback, wrapper);</span><br><span class="line">    fns.unshift(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off(event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">    <span class="comment">// 先从 onceToWrapper 中查找是否有对应的 wrapper，如果有说明是 once 绑定的</span></span><br><span class="line">    callback = <span class="keyword">this</span>.onceToWrapper.get(callback) || callback;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fns[i] === callback) &#123;</span><br><span class="line">            fns.splice(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners.delete(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>全部代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        <span class="keyword">this</span>.onceToWrapper = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">        fns.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addListener(event, callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.on(event, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">        <span class="keyword">let</span> values = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> fn <span class="keyword">of</span> fns) &#123;</span><br><span class="line">            values.push(fn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> values) &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prependListener(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">        fns.unshift(callback);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">        callback = <span class="keyword">this</span>.onceToWrapper.get(callback) || callback;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fns[i] === callback) &#123;</span><br><span class="line">                fns.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners.delete(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeListener(event, callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.off(event, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    once(event, callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(...args);</span><br><span class="line">            <span class="keyword">this</span>.onceToWrapper.delete(callback);</span><br><span class="line">            <span class="keyword">this</span>.off(event, wrapper);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">        <span class="keyword">this</span>.onceToWrapper.set(callback, wrapper);</span><br><span class="line">        fns.push(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prependOnceListener(event, callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(...args);</span><br><span class="line">            <span class="keyword">this</span>.onceToWrapper.delete(callback);</span><br><span class="line">            <span class="keyword">this</span>.off(event, wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners.has(event)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners.set(event, []);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.listeners.get(event);</span><br><span class="line">        <span class="keyword">this</span>.onceToWrapper.set(callback, wrapper);</span><br><span class="line">        </span><br><span class="line">        fns.unshift(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeAllListeners(event) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners.delete(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> [...this.listeners.keys()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenerCount(event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listeners.get(event).length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.freecodecamp.org/news/how-to-code-your-own-event-emitter-in-node-js-a-step-by-step-guide-e13b7e7908e1/" target="_blank" rel="noopener">How to code your own event emitter in Node.js: a step-by-step guide</a></li>
<li><a href="https://nodejs.org/api/events.html" target="_blank" rel="noopener">Nodejs|Events</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-03-11T16:00:00.000Z" itemprop="dateUpdated">2021-03-12 00:00:00</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://lastknightcoder.github.io/lastknightcoder">
            <img src="https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" alt="熊滔">
            熊滔
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.github.io/lastknightcoder/tags/EventEmitter/" rel="tag">EventEmitter</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/&title=《Node.js之EventEmitter》 — Coder&pic=https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/&title=《Node.js之EventEmitter》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Node.js之EventEmitter》 — Coder&url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/&via=https://lastknightcoder.github.io/lastknightcoder" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="https://lastknightcoder.github.io/lastknightcoder/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">盛水最多的容器</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="https://lastknightcoder.github.io/lastknightcoder/ES6%EF%BC%9A%E7%94%A8%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">ES6：用模块封装代码</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'lastknightcoder';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
</section>



















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://lastknightcoder.github.io/lastknightcoder/img/wechatpay.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://lastknightcoder.github.io/lastknightcoder/img/wechatpay.png" data-alipay="https://lastknightcoder.github.io/lastknightcoder/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="https://lastknightcoder.github.io/lastknightcoder/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>熊滔 &copy; 2019 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/&title=《Node.js之EventEmitter》 — Coder&pic=https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/&title=《Node.js之EventEmitter》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Node.js之EventEmitter》 — Coder&url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/&via=https://lastknightcoder.github.io/lastknightcoder" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.github.io/lastknightcoder/Node.js%E4%B9%8BEventEmitter/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuUlEQVR42u3aQVLDQAwEwPz/01DFCQq8GUlWyKF9okLideewq4z0eMTXx9d1/u/39/x+JV/l6rPVuz3w8PDw1ngfx+v3rc/vPH81+SP2nuGP++Ph4eGt8ZLHOm/WyVeTHwOTe+Lh4eG9D6+6fH6c9Ep2PDw8vPfnXR0M58L3apXJpo+Hh4f3Drxk407K3/z9eXSbHzN4eHh4r+FVG2Dv8Pdifw8PDw9v0FWvxqzJ63kwMb/w8PDwNnjnmKA6XJVs3L0WWhKOXK6Oh4eHt8BLCtnqYFYOq4YRzeIbDw8P7yZe/vM+Pzx6x0CvnfaklMfDw8Nb4FVL1d4o1XzsoNqEw8PDw9vm9VpN1WU2yvEbOnh4eHh4RV5e1E6C2vkB0yv68fDw8LZ5yU/9aiBbLZGrrbgnxwYeHh7eAm/Sku9FA8mmXwU/eRI8PDy8NV7SrMrBeVybRwyjlBoPDw9vjTcfhDofNtV2V2/I4JHX+3h4eHhFXjS0FLegesFBdWigcJzg4eHhLfPySDdvX823+97R8iOlxsPDw7uVVx1y2ggLqgNV5RgXDw8P71ZestVWt+le46oac0SHBB4eHt4CL9/cJ82wQrE7KO6j0w8PDw9vzKtu8fnCeU07Z1+uiIeHh7fMy8viarncK6YnA2F4eHh427z5aGmv9TVJmqPwFw8PD2+Zly+QBATVB7rrkChPRuDh4eEVefMyOo995/fJk2k8PDy8Pd4kdJhs5fmRM/oUHh4e3jIvuSbFdx5b9KJePDw8vNfw8qvKqDb+t8cO8PDw8O7lldOLeLG7BhF6o2B4eHh427zqcEAewlaj2OoYQfS7AQ8PD++feNVb9wKL3tjBDQcDHh4e3gt5+fv3Rrsu74yHh4e3xusVx9WwoNoMS2BPAg48PDy8Bd7op/4gzugFDev9PTw8PLzT6p9gF3OoAWOV/AAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://lastknightcoder.github.io/lastknightcoder/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
