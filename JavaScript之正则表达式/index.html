<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JavaScript之正则表达式 | Coder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,正则表达式">
    <meta name="description" content="JavaScript正则表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript之正则表达式">
<meta property="og:url" content="https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
<meta property="og:site_name" content="Coder">
<meta property="og:description" content="JavaScript正则表达式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200527135642.png">
<meta property="article:published_time" content="2020-05-27T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-27T16:00:00.000Z">
<meta property="article:author" content="熊滔">
<meta property="article:tag" content="JavaScript 正则表达式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200527135642.png">
    
        <link rel="alternate" type="application/atom+xml" title="Coder" href="https://lastknightcoder.github.io/lastknightcoder/atom.xml">
    
    <link rel="shortcut icon" href="https://lastknightcoder.github.io/lastknightcoder/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://lastknightcoder.github.io/lastknightcoder/img/brand.jpg)">
      <div class="brand">
        <a href="https://lastknightcoder.github.io/lastknightcoder/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">熊滔</h5>
          <a href="mailto:2223106858@qq.com" title="2223106858@qq.com" class="mail">2223106858@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lastknightcoder.github.io/lastknightcoder/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/LastKnightCoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaScript之正则表达式</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaScript之正则表达式</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-05-27T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2020-05-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.github.io/lastknightcoder/categories/JavaScript/">JavaScript</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正则对象"><span class="post-toc-number">1.</span> <span class="post-toc-text">正则对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正则对象中的属性"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">正则对象中的属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正则对象中的方法"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">正则对象中的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#test"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">test</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#exec"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">exec</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构造函数RegExp的属性"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">构造函数RegExp的属性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符串方法"><span class="post-toc-number">2.</span> <span class="post-toc-text">字符串方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#replace"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">replace</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#match"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">match</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符匹配"><span class="post-toc-number">3.</span> <span class="post-toc-text">字符匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符组"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">字符组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#量词"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">量词</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#贪婪匹配与惰性匹配"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">贪婪匹配与惰性匹配</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分支"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">分支</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#括号的作用"><span class="post-toc-number">4.</span> <span class="post-toc-text">括号的作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分组与分支"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">分组与分支</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#捕获数据"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">捕获数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RegExp的属性-1…"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">RegExp的属性$1…</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#括号嵌套"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">括号嵌套</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#反向引用"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">反向引用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#位置匹配"><span class="post-toc-number">5.</span> <span class="post-toc-text">位置匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#相关元字符"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">相关元字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#千位分隔符案例"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">千位分隔符案例</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多行模式"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">多行模式</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JavaScript之正则表达式"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaScript之正则表达式</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-05-28 00:00:00" datetime="2020-05-27T16:00:00.000Z"  itemprop="datePublished">2020-05-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://lastknightcoder.github.io/lastknightcoder/categories/JavaScript/">JavaScript</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>在字符串的处理中，我们经常要进行字符串的匹配，校验等等操作。比如校验字符串的格式是否符合邮箱，电话号码的格式，校验密码是否符合要求，密码中是否包含数字和字母等等；又或者匹配得到某种规则的字符串。这一些操作如果使用常规的方法进行字符串操作，会花费较大的代价，包括时间和精力。</p>
<p>正则表达式是用来表达字符串的规则，它可以检验字符串是否符合某个特定的规则，或者匹配字符串中符合规则的字符，在一般的使用中，正则表达式一般用来匹配字符串中的字符或者字符串中特定的位置。</p>
<h2 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h2><p><code>JavaScript</code> 正则对象的创建有两种常见的方法，一是使用 <code>RegExp</code> 构造函数进行创建，二是使用字面量的方法进行创建，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'hello'</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> regex2 = <span class="regexp">/hello/g</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>hello</code> 表示字符串的规则，用来匹配字符串中的<code>&quot;hello&quot;</code>，<code>g</code> 表示进行全局匹配(<code>global</code>)，像这样的标志还有两个，<code>m</code> 表示进行多行匹配(<code>multiline</code>)，<code>i</code> 表示忽略大小写(<code>ignoreCase</code>)，这三个标志互不冲突，可以同时使用，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/igm</span>;</span><br></pre></td></tr></table></figure>

<p>具体标志的作用在后面讲解。在实际的使用中，我们一般会使用字面量的形式创建正则对象，相对于使用构造函数，字面量的创建比较简便，不过如果需要动态的创建正则对象，或者根据字符串创建正则对象，那么可以考虑使用构造函数的方式。</p>
<h3 id="正则对象中的属性"><a href="#正则对象中的属性" class="headerlink" title="正则对象中的属性"></a>正则对象中的属性</h3><ul>
<li><code>global</code>：布尔值，是否设置了 <code>g</code> 标志</li>
<li><code>ignoreCase</code>：布尔值，是否设置了 <code>i</code> 标志</li>
<li><code>lastIndex</code>：整数，从字符串的某个位置开始匹配，默认为 <code>0</code></li>
<li><code>multiline</code>：布尔值，是否设置了 <code>m</code> 标志</li>
<li><code>source</code>：正则表达式的字符串表示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d&#123;3&#125;hello$/ig</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.global); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.source); <span class="comment">// \d&#123;3&#125;hello$</span></span><br></pre></td></tr></table></figure>

<h3 id="正则对象中的方法"><a href="#正则对象中的方法" class="headerlink" title="正则对象中的方法"></a>正则对象中的方法</h3><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><code>test()</code>，该方法接收一个字符串参数，返回一个布尔值，用来判断该字符串是否符合正则对象的规则，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec()</code> 方法是用来捕获匹配到的字符，该方法接收一个字符串，返回一个数组，数组的第一项表示与整个模式匹配的字符串，第二项表示第一个捕获组(捕获组的概念如果不懂，可以看了括号的作用在回来看)，第三项表示第二个捕获组，以此类推。返回的数组与普通数组不同的是，该数组还有三个属性，<code>index</code> 、 <code>input</code> 和 <code>groups</code>，<code>index</code> 表示匹配到的字符在原始字符串中的位置，从 <code>0</code> 开始；<code>input</code> 表示输入的原始字符串，<code>groups</code> 表示捕获组的名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(he)(ll)(o)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"so hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200527135642.png" width="80%"/>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">3</span>,</span><br><span class="line">  input: <span class="string">'so hello'</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果正则对象的标志有 <code>g</code> 的话，那么在执行 <code>exec()</code> 方法后会改变 <code>lastIndex</code> 为匹配字符串后字符的 <code>index</code>，接下来再次执行 <code>exec()</code> 方法时将会从 <code>lastIndex</code> 处开始匹配，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"ab abc abc"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/ab/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 0</span></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">regex.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">regex.exec(string); <span class="comment">// 匹配不到会返回 null</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.lastIndex); <span class="comment">// 重新变为 0</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数RegExp的属性"><a href="#构造函数RegExp的属性" class="headerlink" title="构造函数RegExp的属性"></a>构造函数RegExp的属性</h3><p>构造函数 <code>RegExp</code> 中有一些静态属性，这些属性会保存最近一次正则对象操作的一些信息，并且这些属性有两种方法访问，一种是具有语义的长属性名，一种是简短的短属性名，具体如下：</p>
<ul>
<li><code>input</code>：短属性名为 <code>$_</code>，最近一次要匹配的字符串</li>
<li><code>lastMatch</code>：<code>$&amp;</code>，最近一次的匹配项</li>
<li><code>leftContext</code>：$`， <code>input</code> 中 <code>lastMatch</code> 的左边部分</li>
<li><code>rightContext</code>：<code>$&#39;</code>，<code>input</code> 中 <code>lastMatch</code> 的右边部分</li>
<li><code>$1, $2, ...</code>：后面介绍</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"he hello llo"</span>;</span><br><span class="line">regex.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input); <span class="comment">// he hello llo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// he_ (从_表示空格)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// _llo</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>在字符串中，有许多的方法也是与正则表达式有关的，如 <code>replace</code>，<code>match</code>，下面就简单介绍一下。</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p><code>replace()</code> 方法的作用是使用新的字符串替换字符串中的某些内容，该方法接收两个参数，第一个参数表示字符串中要被替换的内容，它可以是一个具体的字符串或者是一个正则对象，第二个参数为一个字符串，这个参数是用来替换第一个参数的，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"gello"</span>;</span><br><span class="line">string = string.replace(<span class="string">'g'</span>, <span class="string">'h'</span>); <span class="comment">// 将 string 中的 g 替换为 h</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"abc"</span>;</span><br><span class="line">string = string.replace(<span class="regexp">/[ab]/g</span>, <span class="string">'#'</span>); <span class="comment">// 将字符串中的 a 或 b 替换为 #</span></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// ##c</span></span><br></pre></td></tr></table></figure>

<p>在上面中使用了 <code>[ab]</code>，这个表示 <code>a</code> 或者 <code>b</code>，具体会在元字符那里讲解。</p>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>match</code> 方法的作用与 <code>exec</code> 的作用差不多，不过一个是 <code>RegExp</code> 对象的方法，一个是 <code>String</code> 对象的方法。<code>match</code> 方法接收一个正则对象，它返回一个数组，根据正则对象是否设置了 <code>g</code> 标志，返回的结果也不相同。</p>
<p>如果没有设置 <code>g</code> 标志，即不会全局匹配，只会匹配一次，那么它返回的结果与 <code>exec</code> 返回的结果相同，数组的第一个元素表示匹配的字符串，后面的元素表示捕获组，并且也有 <code>input</code>，<code>index</code>，<code>groups</code>等属性，表示的含义也痛 <code>exec</code>，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(<span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'he'</span>,</span><br><span class="line">  <span class="string">'ll'</span>,</span><br><span class="line">  <span class="string">'o'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello'</span>,</span><br><span class="line">  groups: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">h</span>: <span class="string">'he'</span>, <span class="attr">l</span>: <span class="string">'ll'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这次的正则表达式跟以往的不同，这次我设置了捕获组的名称，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?<span class="xml"><span class="tag">&lt;<span class="name">h</span>&gt;</span>he)</span></span><br></pre></td></tr></table></figure>

<p>即将捕获组 <code>(he)</code> 的名称设置为了 <code>h</code>，设置捕获组名称的格式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(?&lt;捕获组名称&gt;捕获组内容)</span><br></pre></td></tr></table></figure>

<p>为捕获组设置名称，可以方便在后面进行引用。</p>
<p>如果设置了 <code>g</code> 标志，这时返回值与 <code>exec</code> 方法就不同了，它会将字符串中所有符合正则表达式规则的内容都匹配出来，并放入数组中，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello' ]</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">"hello helloworld"</span>;</span><br><span class="line">result = string.match(re);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure>

<p>这时设置的捕获组的信息就提取不到了，所以从某种程度上说，<code>exec</code> 的功能比 <code>match</code> 更加的强大，不过 <code>exec</code> 并不能一次提取出字符串中所有符合规则的内容，而是需要做一个循环，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello helloworld"</span>;</span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 当 re.exec()不为 null 时</span></span><br><span class="line"><span class="keyword">while</span> (result = re.exec(string)) &#123;</span><br><span class="line">    results.push(result[<span class="number">0</span>]); <span class="comment">// result 中还包含了捕获组的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// [ 'hello', 'hello' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><p>上面使用正则表达式进行匹配都是进行精确的匹配，如 <code>/hello/</code>，匹配字符串中的 <code>hello</code> 内容，这样我们根本无法领会到正则表达式的强大，正则表达式正是强大在它模糊匹配的能力，比如我们在 <code>Windows</code> 中进行文件查找，有时我们不记得文件的具体名称，比如忘了某个字母，这个时候我们会用 <code>.</code> 去表示任意的字母去进行查找。现在我们就来讲讲正则表达式模糊匹配的能力。</p>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>在进行匹配的时候，如果我们不确定某个位置的字符是什么，我们可以使用表示特定含义的字符来占据这个位置，比如 <code>[abc]</code> 表示这个位置是 <code>a</code>，<code>b</code>，<code>c</code> 中的某个字符。如果我们想表示这个字符是小写字母，按照上面的写法，你可能会这么写 <code>[abcdefghijklmnopqrstuvwxyz]</code>，这样的写法有点反人类，我们可以使用范围表示法来代替上面的写法，如 <code>[a-z]</code> 的写法就表示所有的小写字母，同理 <code>[A-Z]</code> 就表示所有的大写字母，<code>[0-9]</code> 就表示数字，<code>[0-9a-zA-Z]</code> 表示这个位置可以是数字，小写字母，大写字母。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let re = /[a-zA-Z0-<span class="number">9</span>]/;</span><br><span class="line">console.log(re.test(<span class="string">'0'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'s'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'S'</span>)); <span class="comment">// true</span></span><br><span class="line">console.log(re.test(<span class="string">'?'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>[]</code> 中加入 <code>^</code> 表示取反，如 <code>[^0-9]</code> 表示非数字，即它可以匹配所有的非数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/[^0-9]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"?"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用<strong>元字符</strong>来占据位置，比如 <code>\d</code> 就代表数字，它的作用与 <code>[0-9]</code> 是一样的，常见的元字符如下所示(不包含表示位置的元字符，表示位置的元字符在后面介绍)</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>表示数字</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>表示空白字符，包括空格，回车，制表符等等</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>表示数字，大小写字母和下划线，相当于 <code>[0-9a-zA-Z_]</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>表示任意一个字符</td>
</tr>
</tbody></table>
<p>来看几个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示数字</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空白字符</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\s/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示大小写字母，数字和下划线</span></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\w/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"2"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"a"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"A"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"_"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与在 <code>[]</code> 中加入 <code>^</code>表示取反，上面的元字符也有对应的元字符表示取反的概念</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\D</code></td>
<td>与 <code>\d</code> 相反，表示非数字</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>与 <code>\s</code> 相反，表示非空白字符</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>与 <code>\w</code> 相反，表示非单词</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"2"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"\n"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/\S/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">" "</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"9"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re3 = <span class="regexp">/\W/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"0"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re3.test(<span class="string">"\t"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>现在我们假设使用正则表达式去匹配电话号码，假设电话号码就是 <code>11</code> 位数字，所以写出来的正则表达式是这样的 <code>\d\d\d\d\d\d\d\d\d\d\d</code>，这种写法也相当的反人类，不仅难读(需要一个个数才知道有多少个数)，而且写起来也麻烦，我们可以使用量词来简写上面的表达式，如 <code>\d{11}</code> 就表示 <code>\d</code> 连续出现 <code>11</code> 次，常见的量词写法如下</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>{n}</code></td>
<td>表示连续出现 <code>n</code> 次</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>表示连续出现 <code>m-n</code>，最少出现 <code>m</code>，最多出现 <code>n</code> 次</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>表示连续出现最少 <code>n</code> 次(包括 <code>n</code> 次)</td>
</tr>
<tr>
<td><code>*</code></td>
<td>表示连续出现<strong>任意</strong>多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>表示连续出现 <code>1</code> 次或 <code>1</code> 次以上</td>
</tr>
<tr>
<td><code>?</code></td>
<td>表示出现 <code>0</code> 次或 <code>1</code> 次</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 5 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;5&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"123 1234 12345 654321"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12345', '65432' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现的 2-3 位数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;2,3&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '12', '123', '123' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配连续出现 4 位及 4 位以上的数字</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4,&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"12 123 1234 12345"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ '1234', '12345' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 可以出现任意次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab*c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ac', 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 1 次或 1 次以上</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abc', 'abbc', 'abbbc' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 出现 0 次或 1 次</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab?c/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"ac abc abbc abbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re));</span><br></pre></td></tr></table></figure>

<h3 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h3><p>所谓的贪婪匹配就是尽可能的多匹配，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'abbbb' ]</span></span><br></pre></td></tr></table></figure>

<p>明明匹配 <code>ab</code> 也可以，但是它会尽可能多的匹配，这就是贪婪模式，与此相对的是惰性匹配，惰性匹配就是在满足条件的情况下会尽可能的少匹配，如上例就会匹配 <code>ab</code>，在默认的情况下是贪婪匹配，要使用惰性匹配就要使用惰性量词</p>
<table>
<thead>
<tr>
<th>贪婪</th>
<th>惰性</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>+?</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>*?</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>??</code></td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td><code>{n,m}?</code></td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td><code>{n,}?</code></td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+?/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"abbbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(re)); <span class="comment">// [ 'ab' ]</span></span><br></pre></td></tr></table></figure>

<p>现在考虑根据 <code>html</code> 字符串获得某 <code>id</code> 属性，如 <code>&lt;div id=&quot;container&quot; class=&quot;active&quot;&gt;&lt;/div&gt;</code>，如果我们使用贪婪匹配的话，考虑这样的匹配规则 <code>/id=&quot;.*&quot;/</code>，那么捕获到的并不是我们想要的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container" class="active"</span></span><br></pre></td></tr></table></figure>

<p>我们发现匹配到的是 <code>id=&quot;container&quot; class=&quot;active&quot;</code>，因为在贪婪模式下再符合条件的情况下会尽可能多的匹配，所以会直接匹配到最后一个双引号，解决办法有两种，其中简单的解决办法就是使用惰性匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id=".*?"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure>

<p>另一种办法就比较 <code>trick</code>，我觉得只可意会，难以言传</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/id="[^"]*"/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div id=\"container\" class=\"active\"&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// id="container"</span></span><br></pre></td></tr></table></figure>

<p>仔细体会上面的写法吧，我觉得很好用，比如获得某标签的标签名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/&lt;[^&gt;]*&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"&lt;div&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.exec(string)[<span class="number">0</span>]); <span class="comment">// &lt;div&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>有时候我们需要在多个分支之间进行选择，比如匹配十六进制表示的颜色，有两种表示，一种是 <code>#F4E242</code> 六位的，一种是简写的 <code>#FFF</code> 三位表示的，我们可以使用 <code>|</code> 来表示或的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> string1 = <span class="string">"#FFF"</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">"#F34E23"</span></span><br><span class="line"><span class="built_in">console</span>.log(string1.match(regex)); <span class="comment">// [ '#FFF' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(string2.match(regex)); <span class="comment">// [ '#F34E23' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><h3 id="分组与分支"><a href="#分组与分支" class="headerlink" title="分组与分支"></a>分组与分支</h3><p>假设我们要匹配 <code>I love Java</code> 和 <code>I love C</code> 这两句话，你可能会写出这样的正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love Java|C/</span><br></pre></td></tr></table></figure>

<p>但是这个正则表达式表示的是 <code>I love Java</code> 或者 <code>C</code> 而不是 <code>I love C</code>，正确的写法应该是这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/I love (Java|C)/</span><br></pre></td></tr></table></figure>

<p><code>Java</code> 和 <code>C</code> 选其一。</p>
<h3 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h3><p>假设我们要匹配一个格式为 <code>yyyy-mm-dd</code> 格式的日期，并且希望获得年月日，那么可能会这么写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string)[<span class="number">0</span>]; <span class="comment">// 2020-05-27</span></span><br><span class="line"><span class="keyword">let</span> results = result.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + results[<span class="number">0</span>]); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + results[<span class="number">1</span>]); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + results[<span class="number">2</span>]); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure>

<p>其实我们可以通过添加括号来捕获数据，对于被括号包起来的数据，其匹配的内容会被提取出来，添加到返回的数组中，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + result[<span class="number">1</span>]); <span class="comment">// 第一个捕获组 \d&#123;4&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + result[<span class="number">2</span>]); <span class="comment">// 第二个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + result[<span class="number">3</span>]); <span class="comment">// 第三个捕获组 \d&#123;2&#125; 匹配的内容</span></span><br></pre></td></tr></table></figure>

<p>上面我们对年月日的规则使用括号包了起来，在进行匹配时，对应被匹配到的数据会添加到数组中，在介绍 <code>exec</code> 方法时，其返回的数组，第一个元素表示匹配到的字符串，后面的元素表示捕获组(括号包起来)中捕获的内容。</p>
<h4 id="RegExp的属性-1…"><a href="#RegExp的属性-1…" class="headerlink" title="RegExp的属性$1…"></a>RegExp的属性$1…</h4><p>除了可以根据返回的数组 <code>result</code> 来得到捕获的数据，还可以通过在上面提过一嘴的 <code>RegExp</code> 构造函数的属性 <code>$1, $2, $3 ...</code> 等等来获得所捕获的内容，其中 <code>$1</code> 表示第一个捕获组所匹配的内容，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"2020-05-27"</span>;</span><br><span class="line"><span class="keyword">let</span> result = re.exec(string);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"year:"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// year:2020</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"month:"</span> + <span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// month:05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"day:"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// day:27</span></span><br></pre></td></tr></table></figure>

<p>每次在使用正则表达式进行匹配时，<code>RegExp</code> 中的 <code>$1, $2, $3 ...</code> 也会相应的更新。</p>
<h4 id="括号嵌套"><a href="#括号嵌套" class="headerlink" title="括号嵌套"></a>括号嵌套</h4><p>现在考虑如果括号有嵌套的情况，比如上面日期格式捕获更精准的表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(\d&#123;<span class="number">4</span>&#125;)-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))-((<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>])|([<span class="number">1</span><span class="number">-2</span>]\d)|(<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>]))/</span><br></pre></td></tr></table></figure>

<p>上面括号嵌套的很复杂，在原理上，被括号包起来的规则所匹配的内容都会被捕获，那么嵌套带来的问题就是，捕获的顺序哪个在前，哪个在后，其实也很简单，根据左括号来，比如上式中的捕获顺序为</p>
<ol>
<li><code>(\d{4})</code></li>
<li><code>((0\d)|(1[0-2]))</code></li>
<li><code>(0\d)</code></li>
<li><code>(1[0-2])</code></li>
<li><code>((0[1-9])|([1-2]\d)|(3[0-1]))</code></li>
<li><code>(0[1-9])</code></li>
<li><code>([1-2]\d)</code></li>
<li><code>(3[0-1])</code></li>
</ol>
<p>所以如果使用上面的正则表达式进行捕获得到年月日的信息，根据分析年是第一捕获组，月是第二捕获组，日是第五捕获组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">5</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>由于无用的捕获组太多，导致想要提取包含信息的捕获组获取困难，其实仔细观察，里面的大多数括号主要是为分支做准备的，对于这些捕获组，我们可以考虑不捕获，仅仅作为分支使用，我们在括号里面的前方加入 <code>?:</code> 表示该括号匹配的内容不进行捕获，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\d&#123;4&#125;)-((?:0[1-9])|(?:1[0-2]))-((?:0[1-9])|(?:[1-2]\d)|(?:3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>], result[<span class="number">2</span>], result[<span class="number">3</span>]); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>如果作为分支的括号太多，为每一个分支添加 <code>?:</code> 也比较费力，那么可以考虑给包含信息的捕获组命名，命名的方法在上面有提到过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;(0[1-9])|(1[0-2]))-(?&lt;day&gt;(0[1-9])|([1-2]\d)|(3[0-1]))/</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-05-27"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = re.exec(date);</span><br><span class="line"><span class="keyword">let</span> groups = result.groups;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groups.year, groups.month, groups.day); <span class="comment">// 2020 05 27</span></span><br></pre></td></tr></table></figure>

<p>通过给捕获组命名，可以方便的通过 <code>groups</code> 对象得到想要的数据。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>现在再次考虑匹配日期，已知下面这三种日期格式都可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-12</span></span><br><span class="line"><span class="number">2017</span> <span class="number">02</span> <span class="number">12</span></span><br><span class="line"><span class="number">2017</span>/<span class="number">02</span>/<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>所以你可能会写出这样的正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d&#123;<span class="number">4</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;(-| |\/)\d&#123;<span class="number">2</span>&#125;/</span><br></pre></td></tr></table></figure>

<p>经过测试，发现能符合要求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是你会发现一些意外的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>前后的分隔符不一致的情况也能够匹配，而我们要求的是前后的分隔符是一样的，这个时候我们可以通过引用分组，使得前面和后面的分隔符是一样的，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/\d&#123;4&#125;(-| |\/)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02-17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02 17"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017/02/17"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02/17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017-02 17"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"2017 02-17"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>注意到我们对于后面的分组，我们使用了 <code>\1</code> 去进行替代，<code>\1</code> 的意思就是代表引用第一个分组，这样就可以做到这个地方与前面的分组相同。同理我们也可以使用 <code>\2</code> 表示引用第二个分组(如果有的话，如果没有就单纯的表示匹配字符串 <code>&quot;\2&quot;</code>)。</p>
<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="相关元字符"><a href="#相关元字符" class="headerlink" title="相关元字符"></a>相关元字符</h3><p>正则表达式中的最后一个内容就是关于位置的匹配，与字符匹配不同，位置匹配时匹配字符间的位置，常见有关位置的元字符如下</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>开头位置</td>
</tr>
<tr>
<td><code>$</code></td>
<td>结尾位置</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>单词边界，即 <code>\w</code> 与 <code>\W</code> 之间的位置</td>
</tr>
<tr>
<td><code>(?=p)</code></td>
<td>匹配 <code>p</code> 模式前面的位置，具体见例子</td>
</tr>
<tr>
<td><code>(?&lt;=p)</code></td>
<td>匹配 <code>p</code> 模式后面的位置</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/^/</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[JS] hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/$/</span>, <span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/\b/g</span>, <span class="string">"#"</span>); <span class="comment">// \b 是 \w 与 \W 之间的位置，表示单词的边界</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [#JS#] #hello#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 前面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] #hello</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;=hello)/</span>, <span class="string">"#"</span>); <span class="comment">// hello 后面的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [JS] hello#</span></span><br></pre></td></tr></table></figure>

<p>同理，也有元字符表示与上面相反的意义</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\B</code></td>
<td>与 <code>\b</code> 相反，表示非单词边界</td>
</tr>
<tr>
<td><code>(?!p)</code></td>
<td>与 <code>(?=p)</code> 相反，表示不是 <code>p</code> 前面位置的所有位置</td>
</tr>
<tr>
<td><code>(?&lt;!p)</code></td>
<td>与 <code>(?&lt;=p)</code> 相反，表示不是 <code>p</code> 后面位置的所有位置</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"[JS] hello"</span>;</span><br><span class="line"><span class="keyword">let</span> result = string.replace(<span class="regexp">/\B/g</span>,<span class="string">"#"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[J#S]# h#e#l#l#o</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 前面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# h#e#l#l#o#</span></span><br><span class="line"></span><br><span class="line">result = string.replace(<span class="regexp">/(?&lt;!hello)/g</span>, <span class="string">"#"</span>); <span class="comment">// 不是 hello 后面位置的所有位置</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// #[#J#S#]# #h#e#l#l#o</span></span><br></pre></td></tr></table></figure>

<h3 id="千位分隔符案例"><a href="#千位分隔符案例" class="headerlink" title="千位分隔符案例"></a>千位分隔符案例</h3><p>现在来做一个案例，将数字转化为千位分隔符表示法，如 <code>12345678</code> 转化为 <code>12,345,678</code>，我们首先找到后三位数字的前面位置，然后添加逗号，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 12345,678</span></span><br></pre></td></tr></table></figure>

<p>进一步弄出所有的逗号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>); <span class="comment">// 12,345,678</span></span><br></pre></td></tr></table></figure>

<p>但是还是有一个小小问题，测试的数字个数是三的倍数的时候，在开头也会添加一个逗号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"123456789"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// ,123,456,789</span></span><br></pre></td></tr></table></figure>

<p>我们可以修改正则表达式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = string.replace(<span class="regexp">/(?=(?!^)(\d&#123;3&#125;)+$)/g</span>,<span class="string">","</span>);</span><br></pre></td></tr></table></figure>

<p>其中 <code>(?!^)</code> 表示不是开头的位置。如果希望支持更多的格式，比如 <code>1234567 12345678</code> 转换为 <code>1,234,567 12,345,678</code>，只要将上面的表达式中的开头，结尾替换为 <code>\b</code> 即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"1234567 12345678"</span>;</span><br><span class="line">result = string.replace(<span class="regexp">/(?=(?!\b)(\d&#123;3&#125;)+\b)/g</span>,<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1,234,567 12,345,678</span></span><br></pre></td></tr></table></figure>

<p>考虑到 <code>(?!\b)</code> 就相当于 <code>\B</code>，所以上面的表达式也可简写如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(?=\B(\d&#123;<span class="number">3</span>&#125;)+\b)/g</span><br></pre></td></tr></table></figure>

<h3 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h3><p>正则表达式有三个常见的标志，分别为全局模式 <code>g</code>，表示进行全局匹配，如果不设置该标志，那么只会匹配一次，如果字符串后面还要符合规则的字符串，是不会被匹配的，对于 <code>exec()</code> 方法，非全局模式下不会更改 <code>lastIndex</code>，即 <code>lastIndex</code> 始终是 <code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"hello hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非全局替换 只会替换匹配到的第一个 hello</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re1, <span class="string">"#"</span>)); <span class="comment">// # hello</span></span><br><span class="line"><span class="comment">// 全局替换 字符串中所以的 hello 都会被替换</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(re2, <span class="string">"#"</span>)); <span class="comment">// # #</span></span><br></pre></td></tr></table></figure>

<p>第二标志 <code>i</code> 很好理解，即忽略大小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/hello/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(string)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(string)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第三个标志 <code>m</code> 表示多行模式，它只会影响 <code>^,$</code>，如果不是多行模式，那么 <code>^, $</code> 就表示字符串的开头和结尾，如果是多行模式，那么 <code>^,$</code> 就表示每一行的开头和结尾。</p>
<p>非多行模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 非多行 ^,$ 表示字符串的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/g</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#I </span></span><br><span class="line"><span class="attribute">love</span> </span><br><span class="line">java<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>多行模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"I \nlove \njava"</span>;</span><br><span class="line"><span class="comment">// 多行模式 ^,$ 表示每一行的开头和结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(string.replace(<span class="regexp">/^|$/gm</span>, <span class="string">"#"</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#I #</span><br><span class="line">#love #</span><br><span class="line">#java#</span><br></pre></td></tr></table></figure>








        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-05-27T16:00:00.000Z" itemprop="dateUpdated">2020-05-28 00:00:00</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://lastknightcoder.github.io/lastknightcoder">
            <img src="https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" alt="熊滔">
            熊滔
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://lastknightcoder.github.io/lastknightcoder/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/&title=《JavaScript之正则表达式》 — Coder&pic=https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/&title=《JavaScript之正则表达式》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript之正则表达式》 — Coder&url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/&via=https://lastknightcoder.github.io/lastknightcoder" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="https://lastknightcoder.github.io/lastknightcoder/TypeScript%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">TypeScript入门指南</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="https://lastknightcoder.github.io/lastknightcoder/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Spring常见注解</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'lastknightcoder';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
</section>



















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://lastknightcoder.github.io/lastknightcoder/img/wechatpay.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://lastknightcoder.github.io/lastknightcoder/img/wechatpay.png" data-alipay="https://lastknightcoder.github.io/lastknightcoder/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="https://lastknightcoder.github.io/lastknightcoder/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>熊滔 &copy; 2019 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/&title=《JavaScript之正则表达式》 — Coder&pic=https://lastknightcoder.github.io/lastknightcoder/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/&title=《JavaScript之正则表达式》 — Coder&source=人生天地间，忽如远行客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript之正则表达式》 — Coder&url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/&via=https://lastknightcoder.github.io/lastknightcoder" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lastknightcoder.github.io/lastknightcoder/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD6UlEQVR42u3aS27bQBAFQN3/0s42RkDqve6hbCDFVUCJw5mKgVZ/Xq/4+vrrurrz7/ev7lytc3/dr3a1w9cTFw4cOHDgiI96v/Q9Qb7dnHL/VL0HHDhw4MBxiCN5QR6GZzRJML6/k3z65uw4cODAgeOHOO6TqzYwzxKzNs3DgQMHDhy/k2MWIFuU5Kn8Uxw4cODA8XmOTUKV3J9hzdK2D9VKceDAgQNHF++KoPv7//3IfAcOHDhw4AiSpc3wQV5S3CR4LUdxOhw4cODAsebIA9ImzdsEvzxdnL0LBw4cOHCc5cgfaNtC+/vJ+slAQwJX/13gwIEDB44gS8oPOUNsm0NtQ6tN/OqxBhw4cODAMeLIA1VemJslh7PiYJLmRf/BOHDgwIFjxDFbqB1Ka5tSeUBti4bDhhMOHDhw4Fhw5AMN7bPJkfI2Urt+dAocOHDgwHGI41Rga1O4fOghSRoP7BMHDhw4cBziSBbKg2Kywqa0lydpyYm+3cGBAwcOHB/haAPkZoht01jKm2SX38eBAwcOHIc42kDYFuNmranNiMNwHRw4cODAcZRjlvzkgTM5wD6U5iu/qZXiwIEDB44Rx+aB2XhBPWSw/nEwC9I4cODAgWPGcTZZGnrHB05C72r/OHDgwIHjEEcePvNNzw42S/DaAYjLt+DAgQMHjjVHUvKbjRfk290cLEn2kv2/+RvBgQMHDhwlR1vC2xfvZoE2J1sFWhw4cODAcTRnmRX1ZmG4HWI4NUjx5qQ4cODAgWPBsTlGO0i9aWW149p5+neZy+LAgQMHjgVHW0RrIdpEa//9WTkSBw4cOHDsOWZtnnxMLQmf7TFmV7EaDhw4cOBYcJwNtO1I3Cz1emI/j/zuwIEDB47/kiNpCM1GGfLwnI+vFUeKy4tRuMWBAwcOHCVH+/AmwUvQ9yMOeSp4uRoOHDhw4FhwbFo7szGF54JuMgDxZp84cODAgWPNMQuuszJiPoLQlvzaAbvodwcOHDhw4DhUJcvDWHvsWaqWpF5tmwoHDhw4cDzBsQlpbbKUh9h9gG/bZjhw4MCB4yxHPuiQ38m3W/fHykZU/i4cOHDgwLHnaItosxCbf5qUC59AwYEDBw4cpzjOlvlOHTUvDrbpXzHZgQMHDhw4Rhz51Ya6TdmubXGdWh8HDhw4cJziaF82C4ptIGzbVMcCLQ4cOHDgOMSRVxP3cG1oP/yr4R4LBw4cOHB8nGO23c3owyyBnI1W4MCBAweOz3PkraOcLwmZSQOs/fSyF4cDBw4cONYc+RBD21LKR+j2YXj/Xhw4cODAsefIS2n7Abv2AEnTqE0ak58FOHDgwIFjxPEH08deYCOFTQAAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://lastknightcoder.github.io/lastknightcoder/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
