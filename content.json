[{"title":"Vue.js 入门","date":"2021-03-28T16:00:00.000Z","path":"/Vue.js入门/","text":"本篇文章的目的是快速的入门 Vue.js，力求能够通过本篇文章了解 Vue.js 的基本用法，但是并不会覆盖 Vue.js 的方方面面，在读完本篇文章之后，便可阅读 Vue.js 的官方教程，进一步的了解 Vue 的进阶内容。 Vue 带来的开发思维的改变假设有这么一个要求，要我们根据一个数组渲染出一个列表，对于下面的数组 const courses = ['语文', '数学', '英语']; 要求渲染出下面的 HTML 结构 &lt;ul&gt; &lt;li&gt;语文&lt;/li&gt; &lt;li&gt;数学&lt;/li&gt; &lt;li&gt;英语&lt;/li&gt;&lt;/ul&gt; 所以我们会写出这样的代码 const courses = ['语文', '数学', '英语'];const ulEle = document.getElementsByTagName(\"ul\")[0];courses.forEach(item =&gt; &#123; const liEle = document.createElement('li'); liEle.innerText = item; ulEle.append(liEle);&#125;) 如果数组的内容发生改变，我们还需要手动更新上述的 HTML 结构。所以传统的开发方式为更新数据，根据数据操作 DOM 树。 那么使用 Vue 会有什么不同，来看一个使用 Vue 的方式来实现上述的功能 &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"course in courses\" :key=\"course\"&gt;&#123;&#123;course&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#app', data() &#123; return &#123; courses: ['语文', '数学', '英语'] &#125; &#125;, &#125;)&lt;/script&gt; 上面的程序可能看不懂，毕竟还没有开始学，所以不必担心。从代码量上看，二者似乎相差不大，可能还有点多，但是当我们更新数组时，我们不必操作 DOM 树来更新页面了，当数据发生变化时，Vue 自动地帮我们更新页面，这种模式我们称为 MVVM，其中的 V 表示 View，而 M 表示 Model，数据与视图进行了绑定，当数据发生变化时，视图也会相应的更新，如下图 所以 Vue 给我们带来开发思维上的改变就是，我们只需要操作数据即可，而更新页面的工作不需要我们来做了。 Hello World安装 Vue安装 Vue 当然是选择官网了，当然我们也可以选择通过 CDN 引入文件，例如 &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; Hello World下面就是经典的 Hello World 程序，新建一个 HTML 文件，内容如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World!' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面上显示的内容如下： 发生了什么我们先简单的捋一捋发生了什么，一切先从下面的代码说起 const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World!' &#125; &#125;&#125;) 上面我们创建了一个 Vue 的实例 new Vue()，并且向其中传入一个对象，包括这么两个属性： el：绑定的 DOM 元素 data：返回一个对象的函数，返回对象中的数据与视图进行了绑定，当修改数据时，相应的视图也会发生更新 当我们创建一个 Vue 实例时，首先它会根据 el 属性指定的选择器找到相应的 DOM 元素，我们称这个 DOM 结果为模板(template)，例如上例根据 #app 选择器我们找到 &lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 接着便会解析该模板，例如上面将 {{message}} 替换为了 data 中定义的数据 `message` 的对应的值，即 Hello World!，解析完毕后便会渲染页面，我们便在页面上看到了 Hello World!。 因为 Vue 对 data 属性中定义的数据进行了拦截，一旦我们改变对象属性的值，Vue 便会对用到该属性的模板进行解析、渲染。 拦截数据是通过 Object.definePropety() 来做到的，可以通过 MDN 来了解该方法的使用。 Vue实例上面我们使用变量 vm 接收了 new Vue() 返回的 Vue 实例，现在我们看看里面有什么。 $el模板经过 Vue 解析、渲染以后，然后根据该模板生成一个 DOM 元素挂载在页面中，而这个 DOM 元素我们可以通过 vm.$el 进行访问得到 $data通过 vm.$data 可以得到 data 属性返回的对象 我们可以通过 vm.$data 来修改数据 上面我们修改数据 message 为 Hello Vue，页面便发生了变化，进一步证实了数据与视图的绑定。 为了方便通过 vm 操作数据，所有的数据都被挂载到了 vm 上，即我们可以直接通过 vm 访问以及修改数据，而不必通过 vm.$data 上面我们通过 vm.message 直接修改了数据，页面也立即发生了变化。 无论我们是通过 vm.message 还是 vm.$data.message 修改数据，它们之间是互相影响的。即当我们通过 vm.xxx 修改数据，那么 vm.$data.xxx 的值也会发生改变，反之亦然。 模板语法本小节主要讲如何在模板中引用在 data 属性中定义的数据。 插值 在模板中通过 {{}} 插值语法便可引用在 data 中定义的数据，正如上例中的 {{message}}，除此以外，{{}} 内部可以是任何的 JavaScript 表达式，如 &#123;&#123;1 + 2&#125;&#125;&#123;&#123;message === 'xxx' ? 'foo' : 'bar'&#125;&#125;&#123;&#123;message.split('').reverse().join('')&#125;&#125; {{}} 中的内容会被解析，然后被替换为相应的内容。 指令v-bind如果我们想让模板中的属性与数据进行动态绑定，我们便需要借助于 v-bind 属性，有下面的模板以及数据 &lt;div id=\"app\"&gt; &lt;p title=\"message\"&gt;Hello World&lt;/p&gt;&lt;/div&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World!' &#125; &#125;&#125;) 当我们将鼠标放置在 p 标签上时，显示的 title 是 message，而不是数据 Hello World!，说明 title 属性并没有与 message 进行绑定，因为图比较难截，所以自己试验一下。不过从渲染后的 DOM 元素可以证明这一点 我们希望 p 标签的 title 属性与 data 中定义的 massage 进行绑定，我们只需要在属性 title 签名加上 v-bind: 即可 &lt;div id=\"app\"&gt; &lt;p v-bind:title=\"message\"&gt;Hello World&lt;/p&gt;&lt;/div&gt; 这时将鼠标放在 p 标签，这时显示的便是 Hello World!，从渲染后的 DOM 元素可以证明这一点 并且这时我们对数据进行更改，相应的数据也会发生变化 因为 v-bind: 比较常用，所以它有一个缩写 :，上述模板可以改为 &lt;div id=\"app\"&gt; &lt;p :title=\"message\"&gt;Hello World&lt;/p&gt;&lt;/div&gt; class 属性与 style 属性也可以使用 v-bind 绑定属性，不过类与样式实在太过特殊，所以 Vue 对其有做一些特殊的扩展，可以参见官网。 v-on指令 v-on 可以绑定一个事件 &lt;div id=\"app\"&gt; &lt;p v-on:click=\"clear\"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World!' &#125; &#125; &#125;)&lt;/script&gt; 在上面我们为 p 标签添加了一个点击事件 v-on:click=&quot;clear&quot;，当我们点击 p 标签时会触发一个叫 clear 的方法，该方法需要在 methods 选项中进行定义，如下 const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World!' &#125; &#125;, methods: &#123; clear() &#123; this.message = \"\" &#125; &#125;&#125;) clear 的方法会将 message 数据设置为空字符串 当我们点击 p 标签时，message 数据变为空字符串，相应的页面也会发生改变。 绑定事件也是一个很常见的操作，所以也有缩写，上面的 v-on: 可以替换为 @ &lt;div id=\"app\"&gt; &lt;p @click=\"clear\"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt; 除了使用 v-on 指令绑定 methods 中的事件，除此之外，我们也可以内联操作数据 &lt;div id=\"app\"&gt; &lt;p&gt; &lt;!-- 直接内联修改数据 --&gt; &lt;button @click=\"message = 'Hello'\"&gt;Hello&lt;/button&gt; &lt;button @click=\"message = 'Hi'\"&gt;Hi&lt;/button&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; message: \"Hello Vue!\" &#125; &#125;, &#125;)&lt;/script&gt; 在内联的写法中，我们可以通过 $event 访问到 event 事件对象。 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的操作，Vue 为 v-on 提供了事件修饰符 .stop：阻止事件继续传播 .prevent：阻止默认行为 .capture：使用捕获模式 .once：事件只执行一次 在监听键盘事件时，我们一般需要检测按下了哪个键，Vue 可以在监听事件时添加按键修饰符 &lt;input @keyup.enter=\"submit\"&gt; 处理函数只会在 event.key 等于 enter 被调用，Vue 提供如下按键修饰符 .enter .tab .delete .esc .space .up .down .left .right 在监听鼠标点击事件时，有时也会判断按下了鼠标的哪个按钮，Vue 也提供了相应的鼠标修饰符 .left .right .middle 在日常的使用，我们经常使用快捷键进行快捷操作，设置快捷键一般需要系统按键符配合，如 ctrl，因此 Vue 也为我们提供了系统按键符，包括 .ctrl .alt .shift &lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件 &lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact=\"onClick\"&gt;A&lt;/button&gt; v-if、v-showv-if 和 v-show 指令可以控制元素是否渲染 &lt;div id=\"app\"&gt; &lt;p v-if=\"show\"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World!', show: true &#125; &#125;, methods: &#123; toggle() &#123; this.show = !this.show; &#125; &#125;, &#125;)&lt;/script&gt; 上面我们为 p 标签使用了 v-if 指令，指定了它的值为 show，当数据 show 为 true 才会显示标签 p，为 false 时则不会显示。在页面中还有一个按钮，当点击按钮时，会触发 toggle 方法，而该方法是将 show 进行取反，也就是说当我们点击按钮时，如果 p 标签显示，那么点击按钮时它会从页面消失，反之亦然 使用 v-show 也会达到相同的效果，我们将模板中的 v-if 修改为 v-show &lt;div id=\"app\"&gt; &lt;p v-show=\"show\"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/div&gt; 那么二者有何不同? v-show 是控制元素的 display 属性来控制元素是否显示与否的，而 v-if 则是从 DOM 树上移除元素或者添加元素，并且 v-if 是惰性的，所谓惰性指的是如果一开始渲染条件为 false，那么什么也不做，只有当条件第一次为真时，才会开始渲染。 所以当元素频繁切换时，v-if 每次都需要创建元素，相对于 v-show 来说有较大的开销，所以对于这种场景，我们选择 v-show，如果在运行时条件很少改变，因此 v-if 相当于 v-show 有更低的初始渲染开销，所以这时我们选择 v-if。 另外 v-if 可以与 v-else-if 以及 v-else 配合使用，参考下面的代码 &lt;div id=\"app\"&gt; &lt;p v-if=\"count % 3 === 0\"&gt;&#123;&#123;count&#125;&#125;: 3n&lt;/p&gt; &lt;p v-else-if=\"count % 3 === 1\"&gt;&#123;&#123;count&#125;&#125;: 3n + 1&lt;/p&gt; &lt;p v-else&gt;&#123;&#123;count&#125;&#125;: 3n + 2&lt;/p&gt; &lt;button @click=\"inc\"&gt;INC&lt;/button&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; inc() &#123; this.count++; &#125; &#125;, &#125;)&lt;/script&gt; 在 data 数据中，我们定义了一个 count 变量，并且定义了一个方法 inc，该方法对数据 count 进行递增。在模板中 &lt;p v-if=\"count % 3 === 0\"&gt;&#123;&#123;count&#125;&#125;: 3n&lt;/p&gt;&lt;p v-else-if=\"count % 3 === 1\"&gt;&#123;&#123;count&#125;&#125;: 3n + 1&lt;/p&gt;&lt;p v-else&gt;&#123;&#123;count&#125;&#125;: 3n + 2&lt;/p&gt; 我们对三个标签使用了 v-if v-else-if v-else 三个指令，根据 count 对 3 余数的值来决定显示哪一个 v-for假设有一个数组数据，我们需要将它渲染为一个列表，尝试如下写法 &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;courses[0]&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;courses[1]&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;courses[2]&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; courses: ['语文', '数学', '英语'] &#125; &#125; &#125;)&lt;/script&gt; 虽然上面的代码可以达到我们的功能，但是实在不够灵活： 数据发生改变时，页面不能发生改变，例如像 courses 数组中添加元素时，页面的内容不会发生改变 代码重复，上面我们是一项一项的写出要显示的内容，如果数组很大，有一万个元素，难道我们要写一万行吗，不仅难以维护，而且很丑 使用 v-for 可以轻易的解决上述的问题，我们修改模板代码如下 &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"course in courses\" :key=\"course\"&gt;&#123;&#123;course&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 我们在 li 标签上面添加了 v-for 指令，Vue 会帮我们从数组中取出元素，然后对于每一个元素都渲染出一个 li 标签，这样一来，当数组发生改变时，页面也会相应的改变，另外，无论数组中有多少项，代码都不需要更改。 仔细观察，我们还为 li 标签绑定了一个 key 属性，它是作为 li 属性的唯一标识，那么它有什么用呢? 假设我们向更改了数组(增加、删除、改变元素的值)，我们需要重新渲染所所有的 li 标签吗? 当然不需要，我们只要渲染那些更改了 li 标签就可以了，而识别哪些标签更改了，正是需要通过 key 属性办到，所以当我们使用 v-for 指令时，最好同时设置 key 属性。 官网推荐不要同时使用 v-for 与 v-if 指令，如果同时使用了 v-for 与 v-if，那么 v-for 的优先级更高。 v-modelv-model 指令一般用于表单，它可以将 data 中定义的数据与表单的 value 值进行双向绑定，所谓的双向绑定指的是： 数据改变，表单的值也会发生变化 表单接收用户的输入，表单的值发生改变，使得数据也会发生改变 &lt;div id=\"app\"&gt; &lt;p&gt;&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/p&gt; &lt;p&gt;&lt;button @click=\"reverse\"&gt;reverse&lt;/button&gt;&lt;/p&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: '' &#125; &#125;, methods: &#123; reverse() &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;, &#125;)&lt;/script&gt; 上面我们在 input 中使用了 v-model 指定，它与数据 message 进行了绑定，这就意味着当我们输入字符时，数据 message 会发生改变，当我们改变数据 message 时，输入框中的内容也会发生改变 v-model 其实就是一个语法糖 &lt;input type=\"text\" v-model=\"message\"&gt; 相当于 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"&gt; 计算属性与监听器计算属性我们可以在模板的插值中使用任何的 JavaScript 表达式，这可以使得我们的代码更加的灵活 &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;message.split('').reverse().join('')&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World' &#125; &#125;, &#125;)&lt;/script&gt; 在上面的代码中，我们在模板的插值中使用了一个较为复杂的表达式，可能需要一定的时间才能明白我们做的事情：翻转字符串。在模板中使用比较复杂的插值表达式，会使得模板过重，难以维护，我们可以使用计算属性来完成上面的目的 &lt;div id=\"app\"&gt; &lt;p&gt;message: &#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World' &#125; &#125;, computed: &#123; reversedMessage() &#123; return this.message.split('').reverse().join(''); &#125; &#125; &#125;)&lt;/script&gt; 在创建 Vue 实例时，我们新增了一个 computed 属性，该属性包含多个方法，这些方法我们称为计算属性，我们可以直接在模板中直接引用这些属性，例如我们在 p 标签中直接引用了该计算属性 &lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt; 当 Vue 解析模板时，会使用 reversedMessage 方法的返回值来替代模板中引用的计算属性。在计算属性中我们依赖了在 data 中定义的数据，当 data 中的数据发生改变时，计算属性也会相应的发生改变，所以计算属性也是与视图进行绑定的。 另外值得一提的是，计算属性是有缓存的，如果在多处访问计算属性，只会调用一次 computed 中定义的方法，然后将其结果缓存起来 ，如果在模板中有多处使用计算属性，除了第一次需要计算，后面直接使用缓存即可，所以对于一些计算复杂，耗时的任务我们便可以使用计算属性 &lt;div id=\"app\"&gt; &lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt; &lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt; &lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; message: 'Hello World', count: 0 &#125; &#125;, computed: &#123; reversedMessage() &#123; this.count++; return this.message.split('').reverse().join(''); &#125; &#125; &#125;)&lt;/script&gt; 在上面的代码中，我们在模板中引用了三次计算属性 &lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;&lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;&lt;p&gt;reversedMessage: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt; 并且我们新增了一个数据项 count，当我们每次调用 computed 属性中的 reversedMessage 便会对 count 进行递增，虽然我们在模板中引用了三次计算属性，但是因为计算属性有缓存，所以 count 的计数应该为 1，页面显示如下 计算属性也会被挂载到 Vue 实例 vm 上，所以我们可以直接通过 vm.xxx 的形式访问计算属性 监听器handler在创建 Vue 实例时，我们还可以添加一个选项 watch，它可以监听 data 中定义的数据，当监听的数据发生变化时，便会执行相应的操作 &lt;div id=\"app\"&gt; &lt;p&gt;&lt;input type=\"text\" v-model=\"question\"&gt;&lt;/p&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; question: '', message: '' &#125; &#125;, watch: &#123; question: &#123; handler() &#123; this.message = this.question.split('').reverse().join('') &#125; &#125; &#125; &#125;)&lt;/script&gt; 上面的代码我们监听了数据 question watch: &#123; question: &#123; handler() &#123; this.message = this.question.split('').reverse().join('') &#125; &#125;&#125; 当我们向输入框输入数据时，question 就会发生改变，就会执行上述 question 中的 handler 方法，在这个方法中我们将数据 message 设置为 question 的翻转 监听器还可以接收两个参数，分别为更新前的值与更新后的值 watch: &#123; question: &#123; handler(oldValue, newValue) &#123; this.message = this.question.split('').reverse().join('') &#125; &#125;&#125; 如果监听的数据只有 handler 方法，则可以简写为如下 watch: &#123; question() &#123; this.message = this.question.split('').reverse().join('') &#125;&#125; immediate继续看一个很简单的代码 &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; message: 'Hello World!', reversedMessage: '' &#125; &#125;, watch: &#123; message() &#123; this.reversedMessage = this.message.split('').reverse().join('') &#125; &#125; &#125;)&lt;/script&gt; 上面的代码很简单，我们设置了两个属性 message 与 reversedMessage，并且我们监听了 message，当 message 发生变化时，便会将 reversedMessage 设置为 message 的翻转。此时的页面显示为 reversedMessage 的内容为空，并不是 message 的翻转，这是因为只有当 message 发生变化时，watch 中的方法才会执行。如果我们希望立即执行，那么我们便要设置 immediate 参数为 true watch: &#123; message: &#123; immediate: true, handler() &#123; this.reversedMessage = this.message.split('').reverse().join('') &#125; &#125;&#125; 此时页面显示为 deep当我们监听一个对象或数组时，可能需要用到 deep 属性。考虑下面的场景 &lt;div id=\"app\"&gt; &lt;p @click=\"changeName\"&gt;username: &#123;&#123;user.username&#125;&#125;&lt;/p&gt; &lt;p&gt;gender: &#123;&#123;user.gender&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; user: &#123; username: 'Alice', gender: 'female' &#125; &#125; &#125;, methods: &#123; changeName() &#123; this.user.username = \"Bob\"; &#125; &#125;, watch: &#123; user: &#123; handler() &#123; this.user.gender = 'male' &#125; &#125; &#125; &#125;)&lt;/script&gt; 在 data 中我们定义了一个数据 user，它是一个对象，包含两个字段 username 和 gender；在模板中，我们使用插值语法使用了这两个数据，并且当我们点击 username 时，会修改 username 的值；在 watch 中我们监听了 user，当 user 发生改变时，会设置 gender 的值 上面我们点击 username 时，username 的值的确发生了改变，但是 gender 并没有发生改变，这是为什么? 这个也很容易理解，我们使用 watch 监听 user，但是当我们修改 user.username 的时候，user 根本没有发生改变，如果我们希望修改对象的属性也能被监听到，那么我们应该设置 deep 属性为 true watch: &#123; user: &#123; deep: true, handler() &#123; this.user.gender = 'male' &#125; &#125;&#125; 计算属性与监听器： 监听器的作用是监听数据的变化，然后触发一个行为，例如异步操作、请求数据 计算属性是根据当前数据计算得到一个值 由于计算属性具有缓存功能，所以我们一般考虑使用计算属性。 生命周期对于一个 Vue 实例，从创建到被销毁，会经历一系列的阶段，就如同人一样，从出生到死亡，会经历幼年、青年、中年、老年等一系列的阶段。Vue 为我们提供了一些钩子函数，例如 beforeCreate 函数，当初始化数据之前会调用这个方法，又如 created 函数，当初始化数据之后会调用这个函数。 Vue 实例的完整生命周期如下图所示，现在你不需要弄懂所有的东西，但随着对 Vue 使用的深入，它的参考价值会越来越高 上图牵涉到如下钩子函数： beforeCreate：初始化数据之前调用该函数，在该函数中不能通过 vm.xxx 访问数据 created：初始数据之后调用该函数，这时可以访问到数据 beforeMount： 渲染 $el 之前调用该函数 mounted：渲染 $el 之后调用该函数 beforeUpdate：数据更新之前执行该函数 updated：数据更新之后执行该函数 beforeDestroy：Vue 实例销毁之前执行该函数 destroyed：Vue 实例销毁之后执行该函数 &lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; message: 'Hello Vue!' &#125; &#125;, beforeCreate() &#123; // 数据未初始化，无法访问 console.log(\"在 beforeCreate 中访问数据：\", this.message); // undefined &#125;, created() &#123; // 数据初始化完毕，可以访问 console.log(\"在 created 中访问数据：\",this.message); // Hello Vue! // 此时还没创建 $el，所以无法访问到 $el console.log(\"在 created 中访问 $el\", this.$el); // undefined &#125;, beforeMount() &#123; // 模板语法中的表达式未被渲染 console.log(\"在 beforeMount 中访问 $el\", this.$el); &#125;, mounted() &#123; // 模板语法中的表达式已经被替换为了数据 console.log(\"在 mounted 中访问 $el\", this.$el); &#125; &#125;)&lt;/script&gt; 上述代码中的钩子函数会按照 beforeCreate created beforeMount mounted 的顺序执行，控制台打印结果如下 当我们更新数据的时候，会重新渲染页面，在渲染页面之前会调用 beforeUpdate 函数，渲染之后会调用 updated 函数(这两个钩子函数的用处不大，很少使用)。 经过实验我发现无法在 updated 钩子函数中访问 $el。 比较常用的钩子函数有两个： created：这里可以向后端请求数据 mounted：在这里可以操作 DOM 元素 组件一个页面一般由很多个部分组成，例如 header main footer 等部分 我们把这些部分称之为组件，通过使用组件搭建页面，就像搭积木一样搭建页面，组件可以在不同的页面直接复用(包括样式以及逻辑)，复用性得到了增强，并且易于维护。 定义组件、使用组件组件分为两种： 全局组件 局部组件 通过 Vue.component 可以构建一个全局组件，下面给出一个示例 Vue.component(\"my-list\", &#123; template: `&lt;ul&gt;&lt;li v-for=\"c in courses\" :key=\"c\"&gt;&#123;&#123;c&#125;&#125;&lt;/li&gt;&lt;/ul&gt;`, data() &#123; return &#123; courses: ['语文', '数学'] &#125; &#125;, methods: &#123; &#125;,&#125;) 第一个参数 my-list 是组件的名称，我们可以在其他组件中通过 &lt;my-list&gt;&lt;/my-list&gt; 使用该组件。第二个参数是一个对象，包含如下选项： template：该组件对应的模板 data：组件包含的数据 methods：组件包含的方法 … 该对象需要设置的字段与我们创建 Vue 实例设置的字段差不多。下面给出一个使用该组件的例子 &lt;div id=\"app\"&gt; &lt;!-- 使用组件 --&gt; &lt;my-list&gt;&lt;/my-list&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; // 创建组件 Vue.component(\"my-list\", &#123; template: `&lt;ul&gt;&lt;li v-for=\"c in courses\" :key=\"c\"&gt;&#123;&#123;c&#125;&#125;&lt;/li&gt;&lt;/ul&gt;`, data() &#123; return &#123; courses: ['语文', '数学', '英语'] &#125; &#125;, methods: &#123; &#125;, &#125;) const vm = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 我们还可以通过如下声明一个局部组件 const myList = &#123; template: `&lt;ul&gt;&lt;li v-for=\"c in courses\" :key=\"c\"&gt;&#123;&#123;c&#125;&#125;&lt;/li&gt;&lt;/ul&gt;`, data() &#123; return &#123; courses: ['物理', '化学', '生物'] &#125; &#125;,&#125; 要使用局部组件，需要事先在 components 属性进行声明 const vm = new Vue(&#123; el: '#app', components: &#123; \"my-list\": myList &#125;&#125;) 这样才可以在模板中使用组件 my-list &lt;div id=\"app\"&gt; &lt;my-list&gt;&lt;/my-list&gt;&lt;/div&gt; props在上面我们创建一个 my-list 组件，my-list 组件展示的数据是在其内部的 data 中定义的，但是它作为一个通用组件，它展示的内容应该由使用该组件的组件传入，本节讲述的便是如何向组件传入数据。 父子组件 如果一个组件 A 在其内部使用了组件 B ，那么我们就称 A 是 B 的父组件，B 是 A 的子组件。 传递数据如果我们想要给组件 my-list 传入数据，我们需要通过属性 (props) 进行传入 &lt;div id=\"app\"&gt; &lt;!-- 传递数据 --&gt; &lt;my-list :courses=\"courses\"&gt;&lt;/my-list&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-list', &#123; // 在 props 中声明接收的数据 props: ['courses'], template: `&lt;ul&gt;&lt;li v-for=\"c in courses\" :key=\"c\"&gt;&#123;&#123;c&#125;&#125;&lt;/li&gt;&lt;/ul&gt;`&#125;)const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; courses: ['语文', '数学', '英语'] &#125; &#125;,&#125;)&lt;/script&gt; 在上面的代码中，我们通过为 my-list 组件的 courses 属性绑定数据来传递数据，而在 my-list 组件中要是用传入的数据，则需要在它的 props 属性中进行声明，这样才可以使用传入的数据。 传递一个对象的所有属性 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post： post: &#123; id: 1, title: 'My Journey with Vue'&#125; 下面的模板： &lt;component v-bind=\"post\"&gt;&lt;/component&gt; 等价于 &lt;component :id=\"post.id\" :title=\"post.title\"&gt;&lt;/component&gt; 类型检查props 除了可以是一个数组以外，还可以是一个对象 props: &#123; courses: Array&#125; 上面的意思是，接收到的 courses 属性必须为数组。除此之外还可以对传入参数做更多的验证 props: &#123; courses: &#123; type: Array, required: true, // 对象或数组默认值必须从一个函数返回 default: function() &#123; return ['物理', '化学', '生物']; &#125;, validator(value) &#123; return value.length &gt; 2 &#125; &#125;&#125; type：规定传入属性的类型，可以有如下取值 String Number Boolean Array Object Date Function Symbol Promise required：是否是必须的 default：如果不传入数据，则使用该默认值 validator：函数，对传入的数据进行校验 如果传入的数据没有通过验证的话，就会在控制台打印错误，例如我们不向组件 my-list 传入数据 &lt;my-list &gt;&lt;/my-list&gt; 因为没有传入数据，所以使用默认值，并且因为我们要求必须传入数据 required: true，所以在控制台给出了一个警告。 注意： props 参数的验证是在实例化组件之前，因此无法在 default 和 validator 中访问组件中定义的数据(如 data computed 等) 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态，所以不要在子组件中修改 prop $attrs如果我们向组件传入了一个属性，但是在组件中并没有在 props 中声明这个属性，那么这个属性会被默认添加到组件的根元素上 Vue.component('my-list', &#123; template: `&lt;div&gt;&lt;p&gt;my-list&lt;/p&gt;&lt;/div&gt;`,&#125;) 如上我们定义了一个全局组件，它没有在 props 中声明需要接收的数据，如果我们向其传递数据，那么传递的数据会被放在根元素上，也就是 div 元素上 &lt;div id=\"app\"&gt; &lt;my-list :title=\"title\"&gt;&lt;/my-list&gt;&lt;/div&gt; const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; title: 'Vue' &#125; &#125;,&#125;) 如果不希望根元素直接继承属性，那么可以在组件的选项中设置 inheritAttrs: false Vue.component('my-list', &#123; template: `&lt;div&gt;&lt;p&gt;my-list&lt;/p&gt;&lt;/div&gt;`, inheritAttrs: false&#125;) 这时我们发现根元素上没有继承传入的属性了。但是我们可以通过 $attrs 获得父组件传入的属性，它是一个对象，我们可以自己决定将属性赋予哪个元素 Vue.component('my-list', &#123; template: `&lt;div&gt;&lt;p v-bind=\"$attrs\"&gt;my-list&lt;/p&gt;&lt;/div&gt;`, inheritAttrs: false&#125;) 上面我们决定将所有接收到的且未在 props 中声明的属性全部放在 p 标签上 注意：在 props 中已经声明的属性不会在 $attrs 中出现。 自定义事件上面讲述了父组件向子组件传递数据，那么子组件如何向父组件传递数据呢? 假设有一个父组件，它维护着一个 courses 的数组，它有两个子组件 course-add：用以向 courses 中添加一个数据 course-display：用以展示 courses 中的数据 &lt;div id=\"app\"&gt; &lt;course-add&gt;&lt;/course-add&gt; &lt;course-display :courses=\"courses\"&gt;&lt;/course-display&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('course-add', &#123; template: ` &lt;div&gt; &lt;p&gt;&lt;input type=\"text\" v-model=\"course\"&gt;&lt;/input&gt;&lt;/p&gt; &lt;p&gt;&lt;button @click=\"add\"&gt;添加课程&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; `, data() &#123; return &#123; course: '' &#125; &#125;, methods: &#123; add() &#123; &#125; &#125;, &#125;); Vue.component('course-display', &#123; props: &#123; courses: Array &#125;, template: ` &lt;ul&gt; &lt;li v-for=\"c in courses\" :key=\"c\"&gt;&#123;&#123;c&#125;&#125;&lt;/li&gt; &lt;/ul&gt; ` &#125;) const vm = new Vue(&#123; el: '#app', data() &#123; return &#123; courses: ['Node.js', 'Vue', 'React'] &#125; &#125;, &#125;)&lt;/script&gt; 我们希望当我们点击添加课程的按钮时，向父组件的 courses 添加一门课程，也就是如何将子组件的数据传递到父组件。要做到这件事情，只能通过回调函数的方式将数据传递给父组件，首先我们为组件 course-add 绑定一个自定义的事件 &lt;course-add @add-course=\"addCourse\"&gt;&lt;/course-add&gt; 我们为组件 course-add 绑定了 add-course 这个自定义事件，要触发该自定义事件，可通过 this.$emit(&#39;add-course&#39;) 触发，点我们点击按钮时我们便触发该事件，即 // course-addmethods: &#123; add() &#123; // 通过后续参数将数据传递 this.$emit('add-course', this.course); this.course = ''; &#125;&#125; 因为我们为 add-course 这个自定义事件绑定了父组件的 addCourse 方法，所以当触发 add-course 这个自定义事件时，便会调用父组件的 addCourse 方法 // 父组件methods: &#123; addCourse(course) &#123; // 将子组件传递的数据加入到 courses 数组中 this.courses.push(course); &#125;&#125; 我们再次捋一捋流程： 点击按钮，触发子组件的 add 方法 在 add 方法中，触发自定义事件 add-course，并传递数据 自定义事件 add-course 绑定的处理函数为父组件的 addCourse 方法 在父组件的 addCourse 方法中我们拿到子组件传递的数据，并添加到 courses 中 踩坑：HTML 的属性大小写是不敏感的，会一律转化为小写。如果你为组件添加如下自定义事件 addCourse，那么它会被转化为小写的形式，即 addcourse，所以如果你通过 this.$emit(&#39;addCourse&#39;) 触发事件的话是不会成功的，所以一律推荐使用 kebab-case 命名，即 add-course。 双向绑定如果我们为组件绑定 v-model 时，它实际上自动绑定了 value 属性，以及添加了一个名为 input 的自定义事件 Vue.component('base-input', &#123; props: &#123; value: String &#125;, template: `&lt;input type=\"text\" :value=\"value\" @input=\"input\"&gt;`, methods: &#123; input(event) &#123; this.$emit('input', event.target.value); &#125; &#125;,&#125;) 我们下面可以向使用正常表单一样使用该组件 &lt;div id=\"app\"&gt; &lt;base-input v-model=\"message\"&gt;&lt;/base-input&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt; const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; message: '' &#125; &#125;,&#125;) 因为向单选框、复选框这样的输入控件可能会将 value 用于不同的目的，我们可以通过 model 属性避免这样的冲突 Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" :checked=\"checked\" @change=\"$emit('change', change)\" &gt; `, methods: &#123; change(event) &#123; this.$emit('change', event.target.checked); &#125; &#125;&#125;) 上面我们在 model 属性中声明绑定的属性为 checked 以及绑定的自定义事件为 change。 动态组件我们可以通过 &lt;component&gt; 以及 :is 属性来动态的切换组件 &lt;div id=\"app\"&gt; &lt;input type=\"radio\" name=\"component\" @click=\"currentComponent = 'component-a'\" checked&gt;A &lt;input type=\"radio\" name=\"component\" @click=\"currentComponent = 'component-b'\"&gt;B &lt;component :is=\"currentComponent\"&gt;&lt;/component&gt;&lt;/div&gt; 当我们点击单选框时，会修改 currentComponent 的值，而 component 会根据 currentComponent 选择展示什么组件，例如当我们点击第一个单选框时，currentComponent 的值会被设置为 component-a，因此 &lt;component&gt; 会展示 component-a 这个组件。在下面我们定义用到的组件 Vue.component('component-a', &#123; template: `&lt;p&gt;component-a&lt;/p&gt;`&#125;)Vue.component('component-b', &#123; template: `&lt;p&gt;component-b&lt;/p&gt;`&#125;)const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; currentComponent: \"component-a\" &#125; &#125;,&#125;) 插槽插槽内容除了可以通过 prop 向组件传递数据，我们还可以通过插槽向组件传递数据，例如 &lt;layout&gt; content&lt;/layout&gt; 其中 content 便是传递的数据，它会被分发到 layout 组件中特定的位置中。假设 layout 组件的模板如下 &lt;div&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt; 那么该模板会被渲染为 &lt;div&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; content &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt; content 会替换 layout 中的 &lt;slot&gt;&lt;/slot&gt; 标签，slot 便是插槽的意思，它就是一个占位置的。 后备插槽如果没有组件传入分发的内容，我们希望使用默认值，这时便可以使用后背插槽 &lt;div&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt; slot 标签中的内容就是默认值，当我们没有为 layout 组件传入内容时便会使用默认值，如 &lt;layout&gt;&lt;/layout&gt; 会被渲染为 &lt;div&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; 默认内容 &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt; 具名插槽有时候我们需要多个插槽，有如下 layout 组件 &lt;div&gt; &lt;header&gt; &lt;!-- 这个地方放头部 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 这个地方放内容 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 这个地方放页脚 --&gt; &lt;/footer&gt;&lt;/div&gt; 这个时候我们就要为 slot 标签指定 name 属性，以区别不同的插槽 &lt;div&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 上述我们没有为 main 中的 slot 指定 name 属性，它会有一个默认的名称 default。接下来我们如下使用 layout 组件进行组件分发 &lt;layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;这是一个 Header&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;small&gt;这是页脚&lt;/small&gt; &lt;/template&gt;&lt;/layout&gt; layout 组件最终会被渲染为 &lt;div&gt; &lt;header&gt; &lt;h1&gt;这是一个 Header&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;small&gt;这是页脚&lt;/small&gt; &lt;/footer&gt;&lt;/div&gt; 同 v-on 与 v-bind 一样，v-slot 也有缩写，我们可以把上述的 v-slot: 替换为 # &lt;layout&gt; &lt;template #header&gt; &lt;h1&gt;这是一个 Header&lt;/h1&gt; &lt;/template&gt; &lt;template #default&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;small&gt;这是页脚&lt;/small&gt; &lt;/template&gt;&lt;/layout&gt; 作用域插槽如果能在插槽中访问子组件才有的数据是很有用的，假设有如下的 &lt;current-user&gt; 组件 &lt;span&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; 我们希望能够访问 current-user 组件中的 user 数据 &lt;current-user&gt; &#123;&#123;user.firstName&#125;&#125;&lt;/current-user&gt; 但是上述访问的是 current-user 父组件的数据，所以上面的代码不会正常工作。为了访问到子组件的数据，我们可以为 slot 元素绑定一个属性 &lt;span&gt; &lt;slot :user=\"user\"&gt;&lt;/slot&gt;&lt;/span&gt; 接着我们便可以以下面的方式访问 current-user 的数据了 &lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; &#123;&#123;slotProps.user.firstName&#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 如果 current-user 中只有默认插槽的话，上面的代码可以简写为 &lt;current-user v-slot=\"slotProps\"&gt; &#123;&#123;slotProps.user.firstName&#125;&#125;&lt;/current-user&gt; 另外我们可以通过结构语法，从 slotProps 中解构出 user，如 &lt;current-user v-slot=\"&#123;user&#125;\"&gt; &#123;&#123;user.firstName&#125;&#125;&lt;/current-user&gt; 动画Vue 在插入、更新、移除 DOM 元素时，提供不同的方式应用过渡效果。 transitionVue 提供了 transition 组件，可以为任何组件以及元素提供进入、离开过渡，下面给出一个例子 &lt;div id=\"app\"&gt; &lt;p v-if=\"show\"&gt;Hello World!&lt;/p&gt; &lt;p&gt;&lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data() &#123; return &#123; show: true &#125; &#125;, methods: &#123; toggle() &#123; this.show = !this.show; &#125; &#125;, &#125;)&lt;/script&gt; 现在点击按钮没有任何的过渡效果，现在我们为 p 标签外面添加 transition 组件 &lt;div id=\"app\"&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;Hello World!&lt;/p&gt; &lt;/transition&gt; &lt;p&gt;&lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/p&gt;&lt;/div&gt; 为元素包裹 transition 组件以后，Vue 会做如下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行 CSS 动画如果我们使用了 CSS 动画，在元素插入之前， trasnition 组件会为包裹元素添加 v-enter 类，其中 v 就是在 transition 指定的 name 属性值，如上面的 name 属性值为 fade，所以会添加 fade-enter 类，该类用以定义动画的初始状态，在元素插入之后会被移除；在插入的过程中，会添加一个 v-enter-active 以及 v-enter-to类，v-enter-active 为元素定义过渡状态，在动画完成之后被移除， v-enter-to 用以定义过渡结束时的状态，也是在动画完成之后被移除。 对于离场动画也是同理，在离场之前会添加一个 v-leave 类，用以定义动画的初始状态，动画开始后被移除，在离场的过程中会添加 v-leave-active 和 v-leave-to 类，分别用以动画的过渡状态以及动画最终状态。 .fade-enter, .fade-leave-to &#123; opacity: 0;&#125;.fade-enter-active, .fade-leave-active &#123; transition: opacity 0.5s;&#125;.fade-enter-to, .fade-leave &#123; opacity: 1;&#125; 效果如下： 除了可以使用 transition 属性定义过渡状态，还可以使用 animation 动画，例如 .bounce-in-enter-active&#123; animation: bounce-in 0.5s;&#125; .bounce-in-leave-active &#123; animation: bounce-in 0.5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 使用 CSS 动画库我们可以通过以下属性自定义过渡类名： enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 这些类的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用 &lt;link href=\"https://cdn.jsdelivr.net/npm/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"app\"&gt; &lt;transition name=\"bounce-in\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;Hello&lt;/p&gt; &lt;/transition&gt; &lt;p&gt;&lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data() &#123; return &#123; show: true &#125; &#125;, methods: &#123; toggle() &#123; this.show = !this.show; &#125; &#125;, &#125;)&lt;/script&gt; 使用 JS 动画库Vue 过渡系统还提供了一系列的钩子函数： before-enter：进入之前 enter：进入的时候 after-enter：进入完成 before-leave：离开之前 leave：离开时 after-leave：离开之后 这些钩子函数会在特定的阶段触发，我们可以配合 JS 动画库来实现动画效果 &lt;div id=\"app\"&gt; &lt;p&gt;&lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/p&gt; &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;p v-if=\"show\"&gt;Hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; show: true &#125; &#125;, methods: &#123; toggle() &#123; this.show = !this.show; &#125;, beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.transformOrigin = 'left' &#125;, enter: function (el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: '1.4em' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: '1em' &#125;, &#123; complete: done &#125;) &#125;, leave: function (el, done) &#123; Velocity(el, &#123; translateX: '15px', rotateZ: '50deg' &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: '100deg' &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;, &#125;)&lt;/script&gt; 参考文献 Vue官方文档","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Vue/"},{"name":"框架","slug":"框架","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%A1%86%E6%9E%B6/"},{"name":"前端","slug":"前端","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"合并K个升序链表","date":"2021-03-25T16:00:00.000Z","path":"/合并K个升序链表/","text":"题目描述给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 解题思路我一开始的解题思路就是将两个链表一一合并，思路如下： list1 + list2 -&gt; list list3 + list -&gt; list list4 + list -&gt; list … 所以第一版的代码如下 public ListNode mergeKLists(ListNode[] lists) &#123; ListNode root = null; if (lists.length == 0) &#123; return root; &#125; root = Arrays.stream(lists).reduce(null, this::mergeTwoList); return root;&#125;// 合并两个链表private ListNode mergeTwoList(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode p1 = l1; ListNode p2 = l2; ListNode dummyNode = new ListNode(0); ListNode cuerNode = dummyNode; while (p1 != null &amp;&amp; p2 != null) &#123; if (p1.val &lt;= p2.val) &#123; cuerNode.next = p1; cuerNode = cuerNode.next; p1 = p1.next; &#125; else &#123; cuerNode.next = p2; cuerNode = cuerNode.next; p2 = p2.next; &#125; &#125; if (p1 == null) &#123; cuerNode.next = p2; &#125; else &#123; cuerNode.next = p1; &#125; return dummyNode.next;&#125; 然后一提交，发现只超过了 24% 的人 说明肯定有更快的算法，我便去找题解，在题解中发现发现使用分治的思路可以更快的得到排序好的数组。由于老弟我归并排序已经写得炉火纯青了，很快得到了第二版的代码 public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) &#123; return null; &#125; return mergeKLists(lists, 0 , lists.length - 1);&#125;private ListNode mergeKLists(ListNode[] lists, int left, int right) &#123; if (left == right) &#123; return lists[left]; &#125; ListNode leftList = null; ListNode rightList = null; int mid = left + (right - left) / 2; leftList = mergeKLists(lists, left, mid); rightList = mergeKLists(lists, mid + 1, right); return mergeTwoList(leftList, rightList);&#125;// 合并两个链表的代码同上，这里便不列出 再次提交 已经打败 87% 的人了，时间从 120ms 降到了 2ms，再次感受到了算法的魅力。 在最后我稍微分析归并的方法为什么比一个个合并较快，从合并的次数看，一个个合并需要合并 $n - 1$ 次，而归并排序需要合并$$\\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots + 1$$为了方便计算，不妨假设 $n = 2^i$，即 $n$ 为 $2$ 的整数次幂，则上次可以改为$$\\sum_{i = 1}^{\\log_2 n} \\frac{n}{2^i} \\approx n - 1$$所以从合并的次数上看，几乎是相当的。但是注意到一一合并得到的链表越来越长 list + listi -&gt; list list + list(i + 1) -&gt; list … 链表 list 越来越长，合并需要的时间就越多。但是对于归并合并，它先将链表数组划分为两个一组然后合并，这两个一组的链表都是较短的，所需合并的速度较快。所以虽然他们合并的次数相差不大，但是归并合并的链表较一一合并短很多，所以便会较快。 参考链接 合并K个升序链表","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/leetcode/"},{"name":"罗马数字","slug":"罗马数字","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"}]},{"title":"三数之和","date":"2021-03-17T16:00:00.000Z","path":"/三数之和/","text":"题目描述给你一个包含 $n$ 个整数的数组 nums，判断 nums 中是否存在三个元素 $a$，$b$，$c$ ，使得 $a + b + c = 0$ 。请你找出所有和为 $0$ 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 解题思路如果只是单纯的三数之和，那么就是一道很简单的题，首先对数组进行排序，接着固定一个数，然后在剩下的数中查找有无两个数字与这个固定的数字加起来为 $0$，有则找到一对，使用双指针即可，具体可以参考两数之和。但是题目要求找到所有的不重复的三元组，这就使得题目有点不一样了。正是因为在这里耗费了大量的时间，我才决定将此题记录下来。 一开始我的想法就是先找到所有的三元组，然后去重。找到所有的三元组容易，但是去重难，一开始我想使用 Set 集合进行去重。但是因为每一个三元组都是一个 List 集合，去重比较的是地址值，所以直接添加 List 集合到 Set 集合中是无法去重。因此我产生了一个大胆的想法，因为它比较的是地址值，所以我想写一个类继承 List 类，然后重写它的 hashCode 与 equals 方法(我不知道 Set 是不是靠这两个判重的)，但是最后还是失败了。 后来我就去看题解，但是因为陷入了牛角尖，无法理解，觉得人家讲的不对，后来我就试图复现人家的代码，因为代码是根据别人的思路，但是按照自己的理解写的，所以写的不对，通过对比人家的代码，发现有一个地方写错了，这个地方正是我陷入误区的地方，所以通过纠正我就明白别人的算法，也就明白了如何去重。 算法去重的核心就是如果当前固定的数与上一个数相同，那么就跳过这个数。我一开始不理解的原因有两个： 没有意识到题目要求所有的三元组，而我之前的算法还是两数之和的逻辑，找到一个符合条件的三元组则结束，这就导致我没有意识到每一次都会找到所有与固定数有关的所有三元组，这就意味着下面那个数如果与它之前的数相同的话，它就没有查找的必要，否则就会重复。 另一个原因就是我看成了如果下一个数与当前数相同，则跳过当前数，直接来到下一个数，这个算法肯定是错的，怪自己没有看清 另一个有可能重复的情况，先举个例子，给定数组 [-1, 0, 0, 1, 1 ]，首先固定数 -1 此时我们找到了一个三元组 [-1, 0, 1] 使得三数之和为 $0$，但是因为要找到所有的三元组，所以要继续寻找 这时我们发现又找到一个三元组 [-1, 0, 1]，但是我们发现这个三元组与之前那个三元组重复了，其重复的原因就是 nums[start] == nums[start + 1] || nums[end] == nums[end - 1]，所以我们只要遇到上述情况直接跳过当前数，例如当 nums[start] == nums[start + 1] 的时候，直接 start++。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (nums.length &lt; 3) &#123; return results; &#125; // 首先进行排序 Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; int target = nums[i]; // 因为是升序，如果当前的数 &gt; 0，说明后面的数全大于 0，不可能加起来为 0 if (target &gt; 0) &#123; break; &#125; // 不足三个数，break if (i + 2 &gt;= nums.length) &#123; break; &#125; // 如果当前数与前一个数相同，防止重复，跳过 if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue; int start = i + 1; int end = nums.length - 1; while (start &lt; end) &#123; if (nums[start] + nums[end] + target == 0) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); res.add(target); res.add(nums[start]); res.add(nums[end]); results.add(res); // 防止重复 while (start &lt; end &amp;&amp; nums[start] == nums[start + 1]) start++; while (start &lt; end &amp;&amp; nums[end] == nums[end - 1]) end--; start++; end--; &#125; else if (nums[start] + nums[end] + target &lt; 0) &#123; start++; &#125; else &#123; end--; &#125; &#125; &#125; return results; &#125;&#125; 参考链接 三数之和","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/leetcode/"}]},{"title":"罗马数字与数字的转换","date":"2021-03-16T10:00:00.000Z","path":"/罗马数字与数字的转换/","text":"罗马数字转数字题目描述罗马数包含以下七种字符 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字，输入确保在 1 到 3999 的范围内。 解题思路将罗马数字在每个位置的所有可能的取值列出，例如对于个位有如下情况 \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" 以上字符分别对应 0-9，然后取出个位的数字，根据数字的大小选择对应的字符，接着取出十位上的数字，找到对应的字符，以此类推 import java.util.Stack;public class Solution &#123; public String intToRoman(int num) &#123; // 列出每个位置的所有情况 String[][] maps = new String[4][]; maps[0] = new String[]&#123;\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"&#125;; maps[1] = new String[]&#123;\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"&#125;; maps[2] = new String[]&#123;\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"&#125;; // 题目规定数字范围在 1-3999，所以这里列到 3000 即可 maps[3] = new String[]&#123;\"\", \"M\", \"MM\", \"MMM\"&#125;; StringBuilder stringBuilder = new StringBuilder(); Stack&lt;String&gt; stack = new Stack(); // 依次取出个位，十位 ... int index = 0; while (num != 0) &#123; int n = num % 10; num /= 10; stack.push(maps[index][n]); index++; &#125; while (!stack.isEmpty()) &#123; stringBuilder.append(stack.pop()); &#125; return stringBuilder.toString(); &#125;&#125; 另一种思路是贪心法，想想我们是怎么找零钱的，每次都找面值最大的，我们找 154 元，我们首先找面值最大的 100 块，然后剩 54，接着找面值最大的 50，剩 4 元，找 4 个硬币。 如果我们把要转化的数字看做是要找的零钱，罗马数字就是对应的钞票，我们把罗马数字对应的钞票有多种情况列出来，然后按照找零钱的规则找钱即可 import java.util.Stack;public class Solution &#123; public String intToRoman(int num) &#123; // 罗马\"钞票\"的面值大小依次排列 int[] nums = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] roma = &#123;\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"&#125;; int index = 0; StringBuilder stringBuilder = new StringBuilder(); while (num != 0) &#123; // 使用目前最大的面值 if (num &gt;= nums[index]) &#123; stringBuilder.append(roma[index]); num -= nums[index]; continue; &#125; index++; &#125; return stringBuilder.toString(); &#125;&#125; 数字转罗马数字题目描述罗马数字与数字的转换规则如上题介绍，这道题的要求是将罗马数字转化为数字。 解题思路如果还是将罗马数字看做钞票，将其转化为数字的过程，不就是相当于数钱吗！将钞票转化为对应的数值，然后加起来即可 public class Solution &#123; public int romanToInt(String s) &#123; // 为了处理方便，将两位的罗马数字转为一位的字符 s = s.replace(\"IV\", \"a\"); s = s.replace(\"IX\", \"b\"); s = s.replace(\"XL\", \"c\"); s = s.replace(\"XC\", \"d\"); s = s.replace(\"CD\", \"e\"); s = s.replace(\"CM\", \"f\"); int sum = 0; // 将罗马数字对应的数值加起来即可 for (char c: s.toCharArray()) &#123; sum += romaToNum(c); &#125; return sum; &#125; // 罗马数字对应的数值 private int romaToNum(char c) &#123; switch (c) &#123; case 'I' : return 1; case 'V': return 5; case 'X': return 10; case 'L': return 50; case 'C': return 100; case 'D': return 500; case 'M': return 1000; case 'a': return 4; case 'b': return 9; case 'c': return 40; case 'd': return 90; case 'e': return 400; case 'f': return 900; default: return 0; &#125; &#125;&#125; 还有一种编程的思路，与上面的贪心法一样，直接检查最大的钞票，然后一直加起来 public class Solution &#123; public int romanToInt(String s) &#123; int[] nums = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] roma = &#123;\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"&#125;; int index = 0; int sum = 0; while (!\"\".equals(s)) &#123; // 依次查找开头的最大钞票，然后加起来 if (s.startsWith(roma[index])) &#123; sum += nums[index]; s = s.substring(roma[index].length()); continue; &#125; index++; &#125; return sum; &#125;&#125; 参考文献 整数转罗马数字 罗马数字转整数","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/leetcode/"},{"name":"罗马数字","slug":"罗马数字","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"}]},{"title":"Node.js之Koa","date":"2021-03-15T16:00:00.000Z","path":"/Node.js之Koa/","text":"Koa 是号称是 Node.js 的下一代 Web 开发框架，它是原 Express 团队设计的新的 Web 开发框架，不像 Express 使用回调函数的开发方式，在 Koa 中使用 asnyc 函数，使用同步的写法写出异步的代码，让开发有更好的开发体验。 入门按照惯例，我们使用 Koa 建立一个简单的 Web 服务器，向前端返回 Hello World!。首先下载 koa npm install koa --save 接着在文件中导入 koa 使用即可 const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = \"Hello World!\";&#125;);app.listen(3000); 上述代码我们引入了 Koa，接着使用 new Koa() 创建了一个服务，并且监听了 3000 端口。当有请求到来时，我们会直接返回 Hello World!。下面使用 Postman 发出一个 GET 请求，响应如下 中间件洋葱模型当请求到来时，需要经过一系列的处理函数进行处理，然后才会对请求进行处理，中间经过的处理函数，我们就称为中间件。这些中间件可以我们添加很多的功能，例如解析请求参数，管理静态资源文件，处理 cookie 等等，这些功能我们都可以抽象为一个中间件。 上述我们说中间件就是一个函数，这个函数接收两个参数： ctx：上下文对象，包含请求信息，也可以使用它写响应信息 next：下一个中间件 我们通过下面这张图来看中间件的执行过程(洋葱模型) 当请求到来时，首先会经过我们添加的中间件，当我们在中间件时调用 next 方法时，便会来到下一个中间件，直到某个中间件没有调用 next 方法便执行完毕，接着便会回到上一个中间件调用 next 处的地方，执行之后的代码。 当经过中间件处理过后，一般中间件会对上下文 ctx 进行设置，我们便根据对 ctx 的设置，产生相应的响应给前端。 const Koa = require('koa');const app = new Koa();// 中间件 1const middleware1 = async (ctx, next) =&gt; &#123; console.log(\"中间件 1 before\"); await next(); console.log(\"中间件 1 after\");&#125;;// 中间件 2const middleware2 = async (ctx, next) =&gt; &#123; console.log(\"中间件 2 before\"); await next(); console.log(\"中间件 2 after\")&#125;;// 中间件 3const middleware3 = async ctx =&gt; &#123; console.log(\"中间件 3\"); ctx.body = \"Hello World!\";&#125;;// 通过 use 方法为应用添加中间件app.use(middleware1);app.use(middleware2);app.use(middleware3);app.listen(3000); 上面我们使用 use 方法添加了三个中间件，根据上面的模型，不难得出控制台的打印结果为 中间件 1 before中间件 2 before中间件3中间件 2 after中间件 1 after 我们在 中间件 3 中设置了 ctx.body 为 Hello World，Koa 便会根据此信息向前端发送 Hello World!。 简易实现为了加深对中间件执行的理解，这里给出简易版的中间件的实现 const http = require('http');class Koa &#123; constructor() &#123; this.middleware = [] &#125; // 添加中间件 use(fn) &#123; this.middleware.push(fn); &#125; // 根据 req 和 res 创建上下文对象 createContext(req, res) &#123; const context = &#123;&#125;; context.req = req; context.res = res; return context; &#125; // 串联所有的中间件 compose(middleware) &#123; return function (ctx) &#123; function dispatch(i) &#123; let fn = middleware[i]; if (!fn) &#123; return Promise.resolve(); &#125; return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1))); &#125; return dispatch(0); &#125; &#125; // 整体的执行流程 callback() &#123; // 串联中间件，当执行返回的函数时，会以洋葱模型形式执行中间件 let fn = this.compose(this.middleware); // 处理请求，生成上下文 --&gt; 执行中间件 --&gt; 产生响应 const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; // 监听端口时创建一个 HTTP 服务器 listen(...args) &#123; const server = http.createServer(this.callback()); return server.listen(...args); &#125; // 如何处理请求 handleRequest(ctx, fnMiddleware) &#123; res.statusCode = 404; const handleResponse = () =&gt; this.respond(ctx); // 执行中间件 --&gt; 产生响应 return fnMiddleware(ctx).then(handleResponse); &#125; // 根据上下文产生响应 respond(ctx) &#123; const res = ctx.res; res.setHeader(\"Context-Type\", \"text/plain\"); res.end(ctx.body); &#125;&#125;module.exports = Koa; 上述代码的执行流程是，当我们调用 listen 方法监听端口时，会利用 Node 内置的 http 模块创建一个服务器，并将 this.callback 返回的函数作为处理函数 listen(...args) &#123; const server = http.createServer(this.callback()); return server.listen(...args);&#125;callback() &#123; let fn = this.compose(this.middleware); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest;&#125; 在 this.callback 函数中，我们首先调用了 compose 方法，这个方法可以将通过 use 方法添加的中间件建模为洋葱模型，返回一个函数 fn，当我们调用这个函数时，便会以洋葱模型执行所有的中间件。 compose(middleware) &#123; return function (ctx) &#123; function dispatch(i) &#123; let fn = middleware[i]; if (!fn) &#123; return Promise.resolve(); &#125; return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1))); &#125; return dispatch(0); &#125;&#125; 在 this.callback 返回处理请求的函数中，首先根据 req 和 res 创建上下文对象 // 演示代码，只是将 req，res 挂载在 ctx 上面createContext(req, res) &#123; const context = &#123;&#125;; context.req = req; context.res = res; return context;&#125; 接着便将上下文对象 ctx 传递给 fn 中间件进行处理， handleRequest(ctx, fnMiddleware) &#123; res.statusCode = 404; const handleResponse = () =&gt; this.respond(ctx); return fnMiddleware(ctx).then(handleResponse);&#125; 中间件处理完成之后，便根据上下文对象作出响应(这里为了演示，只是将 ctx.body 的内容直接返回) respond(ctx) &#123; const res = ctx.res; res.setHeader(\"Context-Type\", \"text/plain\"); // 直接将 ctx.body 的内容返回 res.end(ctx.body);&#125; 上述代码只是为了演示 Koa 整体的执行流程以及中间件是如何执行的，在实现的过程中忽略了错误的处理，上述产生上下文的代码以及根据上下文对象产生响应的代码只是为了演示。 ContextKoa Context 封装了 Node 的 request 和 response 对象，每次请求都会创建一个 Context，并将此 Context 传递给中间件进行处理，例如 const Koa = require('koa');const app = new Koa();// 将 Context 传递给中间件进行处理app.use(async ctx =&gt; &#123; ctx.body = \"Hello World!\"; console.log(ctx);&#125;);app.listen(3000); 下面介绍 Context 的 API。 ctx.req：Node 原生的 Request 对象 ctx.res：Node 原生的 Response 对象 ctx.request：Koa 的 Request 对象 ctx.response：Koa 的 Response 对象 虽然我们可以通过 ctx.res 直接返回结果，但是这种绕过 Koa 的 response 对象的行为，会破坏 Koa 的整体流程，所以不推荐使用如下方法和属性 res.statusCode res.write() res.end() res.writeHead() 其实 ctx 上很多的属性都是 ctx.request 与 ctx.response 的代理 ctx.header ： ctx.request.header ctx.method ： ctx.request.method ctx.body ：ctx.response.body ctx.type ：ctx.response.type … Request以下介绍的属性和方法都属于 ctx.request。 header、headers、get通过 header 获得所有的请求头(也可以通过 ctx.header 获得) const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; // 将请求头返回 ctx.body = ctx.header;&#125;);app.listen(3000); headers 是 header 的别名，二者的值是一样的(header === headers)，也可以通过 ctx.headers 访问。 通过 get() 方法可以获得某一个请求头的信息 app.use(async ctx =&gt; &#123; console.log(ctx.get(\"Host\")); // localhost:3000&#125;); method、url通过 method 与 url 可以知道请求方法以及请求路径，这个两个属性也可以通过 ctx.xxx 直接访问 app.use(async ctx =&gt; &#123; ctx.body = &#123; method: ctx.method, url: ctx.url &#125;;&#125;); origin、protocol、host通过 origin 可以获得协议 (protocol) 和主机 (host) 名 app.use(async ctx =&gt; &#123; ctx.body = &#123; origin: ctx.origin &#125;;&#125;); 协议以及主机名称可以直接通过 protocol 与 host 属性获得 app.use(async ctx =&gt; &#123; ctx.body = &#123; protocol: ctx.protocol, host: ctx.host &#125;;&#125;); href获得全部的请求路径，包括协议、主机和 url，相当于 origin + url app.use(async ctx =&gt; &#123; ctx.body = &#123; origin: ctx.origin, url: ctx.url, href: ctx.href &#125;;&#125;); path、querystring、search通过 path 可以获得请求路径，即 url 中 ? 之前的内容，而 querystring 中保存的是 ? 之后的内容(不包括 ?)，与 querystring 及其相似的一个属性是 search，它保存的也是 ? 之后的内容，不过是包括 ? app.use(async ctx =&gt; &#123; ctx.body = &#123; path: ctx.path, querystring: ctx.querystring, search: ctx.search &#125;;&#125;); Response以下属性都是 ctx.response 的属性，如果在代码中直接通过 ctx 访问如下属性，说明 ctx 对这些属性做了代理。 body通过 body 来设置响应体，它可以是如下几种类型： String Buffer Stream Object null 当我们设置 ctx.body 时，如果状态码还未被设置，会自动的帮我们将状态码设置为 200 或 204。并且根据返回的类型设置 Content-Type 响应头： 类型 Content-Type String text/plain，text/html，默认编码为 utf-8 Buffer application/octet-stream Stream application/octet-stream Object application/json 对于 String 和 Buffer 类型的数据，还会计算内容的长度，并且设置 Content-Length 响应头。 header、headers通过 header 可以获得响应头对象 app.use(async ctx =&gt; &#123; ctx.body = \"Hello World!\"; console.log(ctx.response.header);&#125;); 输出结果为 [Object: null prototype] &#123; 'content-type': 'text/plain; charset=utf-8', 'content-length': '12'&#125; 当我们对 ctx.body 进行设置时，它会根据设置给 ctx.body 的内容，对 content-type 响应头进行设置，并且会计算 ctx.body 的长度，对 content-length 响应头进行设置。 headers 是 header 的别名，二者是一模一样的。 typetype 是用来设置返回的数据类型是什么 app.use(async ctx =&gt; &#123; ctx.body = fs.createReadStream(\"./girl.jpg\");&#125;); 上述我们为前端返回了一张图片的二进制流，它默认的类型为 application/octet-stream，当我们返回给浏览器时，浏览器会自动下载内容，而不是将其解析为图片。这时我们可以通过 type 属性设置返回的数据为图片，这样浏览器便可以对流进行解析然后在页面展示 app.use(async ctx =&gt; &#123; ctx.type = \"jpg\"; ctx.body = fs.createReadStream(\"./girl.jpg\");&#125;); 我们知道浏览器是根据 MIME 类型来是识别数据类型的，但是上面我们设置的类型为 jpg，而不是 jpg 对应的 MIME 类型 image/jpeg，这时因为 Koa 会根据我们设置的类型，找到对应的 MIME 类型然后设置 type 属性 app.use(async ctx =&gt; &#123; ctx.type = \"jpg\"; console.log(ctx.type); // image/jpeg ctx.body = fs.createReadStream(\"./girl.jpg\");&#125;); 还可以直接为 type 属性直接设置为响应的 MIME 类型 app.use(async ctx =&gt; &#123; ctx.type = \"image/jpeg\"; ctx.body = fs.createReadStream(\"./girl.jpg\");&#125;); 在设置 type 属性时，会同时设置 Content-Type 响应头。 length当我们设置 ctx.body 为 String 或者为 Buffer 类型时，会自动设置 Content-Length 响应头，通过 length 属性我们可以知道内容长度为多少，即 Content-Length 对应的值 app.use(async ctx =&gt; &#123; ctx.body = \"Hello World!\"; console.log(ctx.length); // 12&#125;); 我们也可以通过 length 属性来设置 Content-Length 响应头 app.use(async ctx =&gt; &#123; ctx.body = \"Hello World!\"; ctx.length = 10;&#125;); 实际我们发送的内容有 12 个字节，但是我们设置 Conetnt-Length 只有 10 个字节，浏览器根据 Content-Length 的大小来接收数据，这会导致浏览器只接收到 10 个字节的数据 status、message可以通过 status 来设置返回的状态码，通过 message 属性来设置返回的信息。当我们设置状态码时，会自动的帮我们设置 message 的值，例如当我们设置状态码为 200 时，message 的值就会被设置为 OK，当我们设置状态码为 404 时，message 就会被设置为 Not Found app.use(async ctx =&gt; &#123; ctx.status = 404; console.log(ctx.message); // Not Found&#125;); 当我们返回的状态码为 404 并且没有设置 body 属性时，会向前端返回字符串 Not Found。 状态码以及对应的默认 message 如下(不必记忆) 100 “continue” 101 “switching protocols” 102 “processing” 200 “ok” 201 “created” 202 “accepted” 203 “non-authoritative information” 204 “no content” 205 “reset content” 206 “partial content” 207 “multi-status” 208 “already reported” 226 “im used” 300 “multiple choices” 301 “moved permanently” 302 “found” 303 “see other” 304 “not modified” 305 “use proxy” 307 “temporary redirect” 308 “permanent redirect” 400 “bad request” 401 “unauthorized” 402 “payment required” 403 “forbidden” 404 “not found” 405 “method not allowed” 406 “not acceptable” 407 “proxy authentication required” 408 “request timeout” 409 “conflict” 410 “gone” 411 “length required” 412 “precondition failed” 413 “payload too large” 414 “uri too long” 415 “unsupported media type” 416 “range not satisfiable” 417 “expectation failed” 418 “I’m a teapot” 422 “unprocessable entity” 423 “locked” 424 “failed dependency” 426 “upgrade required” 428 “precondition required” 429 “too many requests” 431 “request header fields too large” 500 “internal server error” 501 “not implemented” 502 “bad gateway” 503 “service unavailable” 504 “gateway timeout” 505 “http version not supported” 506 “variant also negotiates” 507 “insufficient storage” 508 “loop detected” 510 “not extended” 511 “network authentication required” 当我们设置 ctx.body 为除 null 以外外的数据时，状态码会被自动设置为 200，对应的消息会会被设置为 OK。当我们设置 ctx.body 为 null 时，状态码会被设置为 204，对应的消息会被设置为 No Content。 lastModified、etag这是用来设置 LastModified 与 ETag 响应头，LastModified 的格式应该为一个 UTC 字符串，你也可以直接为 lastModified 设置为一个 Date 对象，Koa 内部会帮我们转化为 UTC 字符串 app.use(async ctx =&gt; &#123; ctx.lastModified = new Date();&#125;); 虽然 Koa 会将 Date 转化为 UTC 字符串，但是我发现时区不对，目前没有找到解决办法。 通过 etag 属性设置 ETag 响应头，设置的内容会使用 &quot;&quot; 包裹起来 app.use(async ctx =&gt; &#123; ctx.etag = \"hi\";&#125;); get、set、append、remove上述四个方法都是与响应头相关的： get(filed)：获得指定响应头的内容 set：分为两种 set(field, value)：设置一个响应头 set(fields)：设置多个响应头 append(field, value)：向响应头追加内容 remove(field)：删除响应头 app.use(async ctx =&gt; &#123; ctx.set(&#123; \"Content-Type\": \"text/html\", \"Last-Modified\": (new Date()).toUTCString() &#125;); // 删除 Last-Modified 响应头 ctx.remove(\"Last-Modified\"); // 不要使用 ctx.get，这是获取请求头的方法 ctx.body = ctx.response.get(\"Content-Type\");&#125;); redirect通过 redirect(url) 方法重定向到新的路径 app.use(async ctx =&gt; &#123; ctx.redirect(\"http://www.baidu.com\");&#125;); 当我们访问 http://localhost:3000/ 时会被重定向到 http://www.baidu.com，使用 redirect 方法进行重定向，会默认设置状态码为 302，如果需要更改状态码，可以通过 status 属性直接更改，在调用 redirct 方法之前或之后都可以。 attachment 调用 attachment 方法，会设置 Content-Disposition 响应头，浏览器接收到该响应头之后，会对前端返回的内容进行下载。attachment 方法接收一个文件名作为参数 app.use(async ctx =&gt; &#123; ctx.body = fs.createReadStream(\"./girl.jpg\"); ctx.attachment(\"girl.jpg\");&#125;); 当我们使用浏览器访问 http://localhost:3000/ 时，会弹出下面的窗口提示我们进行下载 路由我们应当根据不同的请求路径，产生不同的响应，而路由正是定义这些行为的。我们通过对 url、path、method 等属性进行判断，然后返回不同的响应 class Router &#123; constructor() &#123; this.routers = &#123;&#125; &#125; // 当请求以 method 方法访问 path 路径时，添加对应的处理函数到 routers addHandle(method, path, handle) &#123; this.routers[path] = this.routers[path] || &#123;&#125;; let handles = this.routers[path][method] = this.routers[path][method] || []; handles.push(handle); // 可链式执行 return this; &#125; get(path, handle) &#123; return this.addHandle(\"get\", path, handle); &#125; post(path, handle) &#123; return this.addHandle(\"post\", path, handle); &#125; // 将多个处理函数串联起来 compose(middleware = []) &#123; return function (ctx) &#123; function dispatch(i) &#123; let fn = middleware[i]; if (!fn) &#123; return Promise.resolve(); &#125; return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1))); &#125; return dispatch(0); &#125; &#125; // 返回一个中间件 routes() &#123; return async (ctx, next) =&gt; &#123; // 找到匹配的路径 let matchedPath = this.routers[ctx.path]; // 找到对应方法的处理函数 const handles = matchedPath[ctx.method.toLowerCase()] || []; // 将处理函数串联起来，然后执行 return this.compose(handles)(ctx, next); &#125; &#125;&#125;module.exports = Router; 上面我们写了一个 Router 类，如下使用 const userRouter = new Router();userRouter.get('/user/name', async (ctx, next) =&gt; &#123; ctx.body = \"Alice\"; await next();&#125;); 上面的程序表示，当请求以 get 方法访问 /user/name 路径时，便执行对应的处理函数，并且可以为同一路径添加多个处理函数，会根据添加的顺序依次执行 userRouter.get('/user/name', async (ctx, next) =&gt; &#123; ctx.body = \"Alice\"; await next();&#125;).get('/user/name', async (ctx, next) =&gt; &#123; ctx.type = \"html\"; await next();&#125;); 使用时，调用 Router 实例的 routes 方法就会返回一个中间件，通过 app.use 将该中间件插入即可 const Koa = require('koa');const Router = require('./Router');const queryString = require('querystring');let userRouter = new Router();// 当以 get 方法访问 /user/name 路径时，返回 AliceuserRouter.get('/user/name', async (ctx, next) =&gt; &#123; ctx.body = \"Alice\"; await next();&#125;);// 当以 post 方法访问 /user/name 路径时，将请求参数返回userRouter.post('/user/name', async (ctx, next) =&gt; &#123; const req = ctx.req; const postData = await getPostData(req); ctx.body = postData; await next();&#125;);// 获得 post 请求参数的函数const getPostData = async req =&gt; &#123; return new Promise(resolve =&gt; &#123; let buffers = []; req.on(\"data\", data =&gt; &#123; buffers.push(data); &#125;); req.on(\"end\", () =&gt; &#123; let data = Buffer.concat(buffers).toString(); resolve(queryString.parse(data)); &#125;) &#125;)&#125;;const app = new Koa();// 使用路由中间件app.use(userRouter.routes());app.listen(3000); 发送 get 请求 发送 post 请求 上面是使用了我们自己写了 Router 类，支持的功能不多，我们可以使用官网提供的 Router 插件，首先进行下载 npm i @koa&#x2F;router --save 然后引入 Router const Router = require('@koa/router'); 使用方法同上一样。 获取请求数据通过 ctx.query 可以获得 get 请求的数据 app.use(async ctx =&gt; &#123; const query = ctx.query; ctx.body = query;&#125;); 获取 post 请求的数据需要手动解析请求体 const getPostData = async req =&gt; &#123; return new Promise(resolve =&gt; &#123; let buffers = []; req.on(\"data\", data =&gt; &#123; buffers.push(data); &#125;); req.on(\"end\", () =&gt; &#123; let data = Buffer.concat(buffers).toString(); // 借助了 Node 提供的核心模块 querystring 解析请求参数为对象 resolve(queryString.parse(data)); &#125;); &#125;);&#125;;app.use(async ctx =&gt; &#123; const postData = await getPostData(ctx.req); ctx.body = postData;&#125;); 除了手动解析参数外，我们还可以借助于中间件，这里我们使用 koa-bodyparser，首先进行安装 npm i koa-bodyparser --save koa-bodyparser 解析请求参数之后会将请求参数放在 ctx.request.body 上面，所以我们可以访问 ctx.request.body 来获取 post 请求参数 const bodyParser = require('koa-bodyparser');app.use(bodyParser());app.use(async ctx =&gt; &#123; ctx.body = ctx.request.body;&#125;); 暴露静态资源对于我们在网页里面引用的 JavaScript、CSS、图片等静态资源文件，它也会走我们的路由，所以我们也要为它们写处理函数，其实就是直接将文件返回。我们首先看如果不做处理的情况，首先有这个一个 HTML 文件 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/index.css\"&gt;&lt;/head&gt;&lt;body&gt; Hello World!&lt;/body&gt;&lt;/html&gt; 在 HTML 文件中引用了一个 CSS 文件，CSS 文件内容如下 body &#123; color: red; font-size: 40px;&#125; 上面只是设置了字体的颜色和大小，浏览器会向服务器请求 CSS 文件，但是我们服务器没有对这种静态资源的请求做处理，所以并不能返回 CSS 文件，服务器端代码如下，只是直接返回了一个 HTML 文件 const Koa = require('koa');const fs = require('fs');const app = new Koa();const path = require('path');const Router = require('@koa/router');const router = new Router();router.get('/', async (ctx, next) =&gt; &#123; ctx.type = 'html'; ctx.body = fs.createReadStream(path.resolve('public/index.html')); await next();&#125;);app.use(router.routes());app.listen(3000); 现在我们使用浏览器访问 字体的颜色和大小没有变化，说明没有加载到 CSS 文件，并且控制台也显示文件资源加载失败。现在我们使用一个中间件 koa-static 来处理静态资源，首先进行下载 npm i koa-static --save 使用如下 const Koa = require('koa');const fs = require('fs');const app = new Koa();const path = require('path');const Router = require('@koa/router');// 使用 koa-static 中间件const server = require('koa-static');const router = new Router();router.get('/', async (ctx, next) =&gt; &#123; ctx.type = 'html'; ctx.body = fs.createReadStream(path.resolve('public/index.html')); await next();&#125;);// 将当前目录当做静态服务的根目录app.use(server(path.resolve('.')));app.use(router.routes());app.listen(3000); 再次访问 样式生效了，说明 koa-static 起作用了。上面我们使用当前目录作为静态资源的根目录，如果我们使用 public 目录作为静态资源的根目录 app.use(server(path.resolve('public'))); 那么引用 CSS 文件的方式需要修改为 &lt;link rel=\"stylesheet\" href=\"/css/index.css\"&gt; 文件上传本节研究如何处理上传文件，前端上传文件的代码如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" id=\"upload\"&gt; &lt;script&gt; const upload = document.getElementById(\"upload\"); upload.addEventListener(\"change\", event =&gt; &#123; // 获得上传的文件 let file = event.target.files[0]; // 添加到 FormData 对象中 let data = new FormData(); data.append(\"file\", file); // 上传文件 fetch('http://localhost:3000/upload', &#123; method: 'post', body: data, // 设置上传的文件类型为 multipart/form-data，表示上传的为文件 // headers: &#123; // 'Content-Type': 'multipart/form-data' // &#125; &#125;).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.error(err); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里记录一个坑，在使用 fetch 上传文件时，不要手动设置 &#39;Content-Type&#39;: &#39;multipart/form-data&#39;，因为还需要设置分界字符，这个分界字符是随机生成，所以 Content-Type 头部就由 fetch 自己去生成，否则后端的一些中间件不能解析内容。 为了解析上传的数据，我们首先需要了解 multipart/form-data 的数据格式。这里我们假设上传了两个字段，第一个字段的名称为 file，它是一个文本文件，其中的内容为 Hello World!；第二个字段为 name，它的值为 Alice。那么它们形成的请求体的数据如下 ------WebKitFormBoundaryHdpL0f6HyVyJAFokContent-Disposition: form-data; name=\"file\"; filename=\"hello.txt\"Content-Type: text/plainHello World!------WebKitFormBoundaryHdpL0f6HyVyJAFokContent-Disposition: form-data; name=\"name\"Alice------WebKitFormBoundaryHdpL0f6HyVyJAFok-- 每个字段之间都会使用一个分界线分开，这个分界线的组成是 ------WebKitFormBoundary 加上一个随机的 16 位哈希，在每个字段中也分为两部分，第一部分是字段有关的请求头，例如 Content-Type、Content-Disposition ，第二部分就是字段的具体内容，两部分使用空行进行隔开。 我尝试过自己解析数据，但是花费数个小时，还是没有成功，因此放弃，感兴趣可以尝试自己解析！ 这里介绍使用中间件 koa-body 来获得上传的文件首先进行下载 npm i koa-body --save 然后使用便可以使用了 const koaBody = require('koa-body');app.use(koaBody(&#123; multipart: true&#125;)); koa-body 会将上传的文件设置在 ctx.request.files 属性，我们通过 files.file 属性来获得上传的文件，如果上传的是一个文件，那么它就是一个 File 对象，如果上传多个文件，那么它就是一个由 File 对象组成的数组；其他表单请求字段设置在 ctx.request.body 属性上。 koa-body 会先将文件保存在 C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Temp\\\\ 目录下，具体的路径可以由 File 对象的 path 属性获得，通过 name 属性可以获得上传的文件名，通过 type 属性可得知上传的文件类型 const Koa = require('koa');const Router = require('@koa/router');const koaBody = require('koa-body');const fs = require('fs');const path = require('path');const app = new Koa();const router = new Router();router.post('/upload', async (ctx, next) =&gt; &#123; const file = ctx.request.files.file; // 将接收到的文件保存在当前目录 fs.createReadStream(file.path).pipe(fs.createWriteStream(path.resolve(file.name))); ctx.body = \"上传成功\"; await next();&#125;);app.use(koaBody(&#123; multipart: true&#125;));app.use(router.routes());app.listen(3000); 参考文章 Koa官网 Koa进阶学习笔记 玩转Koa-核心原理分析 手写@koa/router源码 NodeJs koa2实现文件上传 Error when POST file multipart/form-data #505 踩坑篇–使用 fetch 上传文件","tags":[{"name":"中间件","slug":"中间件","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Koa","slug":"Koa","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Koa/"},{"name":"HTTP","slug":"HTTP","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/HTTP/"}]},{"title":"盛水最多的容器","date":"2021-03-14T15:51:00.000Z","path":"/盛水最多的容器/","text":"题目描述给你 $n$ 个非负整数 $a_1, a_2, \\dots, a_n$，每个数代表坐标中的一个点 $(i, a_i)$。在坐标内画出 $n$ 条垂直线，垂直线 $i$ 的两个端点 $(i, a_i)$ 和 $(i, 0)$。找出其中的两条线，使得它们与 $x$ 轴共同构成容器可以容纳最多的水。 说明：不能倾斜容器。 例如，给定如下非负整数 $[1, 8, 6, 2, 5, 4, 8, 3, 7]$ 如图两条红色线形成的蓝色区域能够盛放最多的水，其值为 $7*7=49$。 解题思路最简单的思路就是遍历所有柱之间能够容纳多少流量，然后取最大值 public int maxArea(int[] height) &#123; int max = 0; for (int i = 0; i &lt; height.length - 1; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; max = Math.max(max, (j - i) * Math.min(height[i], height[j])); &#125; &#125; return max;&#125; 现在我们考虑一个更快的算法。我们考虑范围 $[i, j]$ 之间的柱子能够容纳多少水量。首先考虑边界的两个柱子 $(i, a_i)$ 与 $(j, a_j)$ 之间能够容纳多少水量，我们不妨假设 $a_i \\leq a_j$，那么它们之间能够容纳的水为$$a_i * (j - i)$$那么对于任何 $i &lt; k &lt; j$，我们可以确定柱 $(i, a_i)$ 与柱 $(k, a_k)$ 能够容纳的水量一定小于 $a_i * (j - i)$。因为 $x$ 与 $a_k$ 之间最短的边为 $\\min ( a_i, a_k ) \\leq a_i$ 因为$i &lt; k &lt; j$，所以 $k - i &lt; j - i$ 所以 $(i, x)$ 与$(k ,a_k)$ 能够包含的水量$$\\min ( a_i, a_k ) * (k - i) &lt; a_i * (j - i)$$因为找的是能够容纳最大的水量，我们不必考虑 $(i, a_i)$ 与其他柱的配对了，这样可以减少很多的计算量。 将上面的想法转化为算法步骤，我们的目的是计算范围 $[0, length-1]$ 之间的柱子能够容纳多少水量，初始令 i = 0, j = length -1。算法过程为，当我们来到$(i, a_i)$ 与 $(j, a_j)$ 两个柱时： 首先计算它们能够容纳多少水量，如果大于目前的最大值，则更新最大值，否则不更新最大值 如果 $a_i \\leq a_j$，那么不必计算柱 $(i, a_i)$ 与其他柱的配对，执行 i++ 如果 $a_i &gt; a_j$，那么不必计算 $(j, a_j)$ 与其他柱的配对，执行 j-- 当 $i \\geq j$ 时，算法执行结束，此时的最大值即为能够容纳的最大水量。 public int maxArea(int[] height) &#123; int start = 0; int end = height.length - 1; int max= 0; while (start &lt; end) &#123; // 计算两个柱之间能够容纳的水量，如果大于最大值，则更新最大值 int s = (end - start) * Math.min(height[start], height[end]); if (max &lt; s) &#123; max = s; &#125; // 如果 a_i &lt;= a_j，则 i++，否则 j-- if (height[start] &lt;= height[end]) &#123; start++; &#125; else &#123; end--; &#125; &#125; return max;&#125; 参考文献 盛水最多的容器","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"Node.js之EventEmitter","date":"2021-03-11T16:00:00.000Z","path":"/Node.js之EventEmitter/","text":"EventEmitter 的使用EventEmitter 为我们提供了事件订阅机制，通过引入 events 模块来使用它。 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();// 监听 data 事件eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data\");&#125;);// 触发 data 事件eventEmitter.emit(\"data\"); 上述代码我们使用 on 方法来为事件绑定回调函数，使用 emit 方法来触发一个事件。 on、addListener我们可以通过 on 和 addListener 方法来为某事件添加一个监听器，二者的使用是一样 eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data\");&#125;);eventEmitter.addListener(\"data\", () =&gt; &#123; console.log(\"data\");&#125;); 第一个参数为事件名，第二个参数为对应的回调函数，当 EventEmitter 实例对象调用 emit 触发相应的事件时便会调用该回调函数，如 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data\");&#125;);eventEmitter.addListener(\"data\", () =&gt; &#123; console.log(\"data\");&#125;);eventEmitter.emit(\"data\"); 在控制台会打印出两次 data datadata 从上面的例子也可以看出，可以为同一事件绑定多个回调函数。 执行顺序当使用 on 或 addListener 绑定多个回调函数时，触发的顺序就是添加的顺序，如 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 1\");&#125;);eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 2\");&#125;);eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 3\");&#125;);eventEmitter.emit(\"data\"); 会在控制台依次打印出 data 1data 2data 3 重复添加并且使用 on 方法绑定事件时，并不会做去重检查 const &#123;EventEmitter&#125; = require('events');const eventEmitter = new EventEmitter();const listener = () =&gt; &#123; console.log(\"lsitener\");&#125;eventEmitter.on(\"data\", listener);eventEmitter.on(\"data\", listener);eventEmitter.emit(\"data\"); 控制台的打印结果为 lsitenerlsitener 上面的程序为事件绑定了两次 listener 这个函数，但是内部并不会检查是否已经添加过这个回调函数，然后去重，所以上面在控制台打印出了两次 listener。 传递参数另外回调函数还可以接收参数，参数通过 emit 触发事件时传入，如 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", data =&gt; &#123; console.log(data);&#125;);// 为回调函数传入参数 HelloWorld!eventEmitter.emit(\"data\", \"HelloWorld!\"); 上面我们使用 emit 触发事件时，还传递了额外的参数，这个参数会被传递给回调函数。 同步执行另外一个比较关心的问题，事件的触发是同步的还是异步的，我们做一个实验 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"触发了 data 事件！\");&#125;);console.log(\"start\");eventEmitter.emit(\"data\");console.log(\"end\"); 上面我们我们在触发事件前后都向控制台打印了信息，如果触发事件后是异步执行的，那么后面的打印语句就会先执行，否则如果是同步的话，就会先执行事件绑定的回调函数。执行结果如下 start触发了 data 事件！end 可见事件触发是同步执行的。 off、removeListeneroff 与 removeListener 方法的作用同 on 和 addLsitener 的作用是相反的，它们的作用是为某个事件删除对应的回调函数 const &#123;EventEmitter&#125; = require('events');const eventEmitter = new EventEmitter();let listener1 = () =&gt; &#123; console.log(\"listener1\");&#125;let listener2 = () =&gt; &#123; console.log(\"listener2\");&#125;eventEmitter.on(\"data\", listener1);eventEmitter.on(\"data\", listener2);// 第一次触发，两个回调函数否会执行eventEmitter.emit(\"data\");eventEmitter.off(\"data\", listener1);// 第二次触发，只会执行 listener2eventEmitter.emit(\"data\"); 控制台打印结果为 listener1listener2listener2 第一次触发事件时，两个事件都会触发，然后我们为事件删除了 listener1 这个回调函数，所以第二次触发时，只会触发 listener2。 注意：如果我们使用 on 或者 addListener 绑定的是一个匿名函数，那么便无法通过 off 和 removeListener 去解绑一个回调函数，因为它会通过比较两个函数的引用是否相同来解绑函数的。 once使用 once 可以绑定一个只执行一次的回调函数，当触发一次之后，该回调函数便自动会被解绑 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.once(\"data\", () =&gt; &#123; console.log(\"data\");&#125;);eventEmitter.emit(\"data\");eventEmitter.emit(\"data\"); 上述代码我们使用 once 为 data 事件绑定了一个回调函数，然后使用 emit 方法触发了两次，因为使用 once 绑定的回调函数只会被触发一次，所以第二次触发，回调函数不会执行，所以在控制台只打印了一次 data。 另外同 on 绑定的回调函数一样，我们同样可以通过 emit 方法向回调函数传递参数 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.once(\"data\", data =&gt; &#123; console.log(data);&#125;);eventEmitter.emit(\"data\", \"Hello\"); 控制台打印结果 Hello prependListener、prependOnceListener使用 on 或者 addListener 为事件绑定的回调函数会被根据添加的顺序执行，而使用 prependLsitener 绑定的事件回调函数会在其他回调函数之前执行 const &#123;EventEmitter&#125; = require('events');const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"on\");&#125;);eventEmitter.prependListener(\"data\", () =&gt; &#123; console.log(\"prepend\");&#125;);eventEmitter.emit(\"data\"); 上述代打我们先用控制台的打印结果为 prependon prependOnceListener 同 prependListener，不过它绑定的回调函数只会被执行一次 const &#123;EventEmitter&#125; = require('events');const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"on\");&#125;);eventEmitter.prependOnceListener(\"data\", () =&gt; &#123; console.log(\"prepend once\");&#125;);eventEmitter.emit(\"data\");eventEmitter.emit(\"data\"); 上面我们使用 prependOnceListener 绑定了一个回调函数，当触发事件时，该回调函数会在其他函数之前执行，并且只会执行一次，所以当第二次我们触发函数时，该回调函数不会执行，控制台打印结果为 prepend onceonon removeAllListenersremoveAllListeners([event]) 方法可以删除事件 event 绑定的所有回调函数，如果没有传入 event 参数的话，那么该方法就会删除所有事件绑定的回调函数 const &#123;EventEmitter&#125; = require('events');const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 1\");&#125;);eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 2\");&#125;);eventEmitter.emit(\"data\");eventEmitter.removeAllListeners(\"data\");eventEmitter.emit(\"data\"); 上面程序为 data 事件绑定了两个回调函数，并且在调用 removeAllListeners 方法之前分别触发了一次 data 事件，第二次触发 data 事件时，不会有任何的回调函数被执行，removeAllListeners 删除了 data 事件绑定的所有回调函数。控制台的打印结果为： data 1data 2 eventNames通过 eventNames 方法我们可以知道为哪些事件绑定了回调函数，它返回一个数组 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.on(\"start\", () =&gt; &#123; console.log(\"start\");&#125;);eventEmitter.on(\"end\", () =&gt; &#123; console.log(\"end\");&#125;);eventEmitter.on(\"error\", () =&gt; &#123; console.log(\"error\");&#125;);console.log(eventEmitter.eventNames()); // [ 'start', 'end', 'error' ] 如果我们将某事件的所有回调函数删除后，此时 eventNames 便不会返回该事件了 eventEmitter.removeAllListeners(\"error\");console.log(eventEmitter.eventNames()); // [ 'start', 'end' ] listenerCountlistenerCount 方法可以得到某个事件绑定了多少个回调函数 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.on(\"data\", () =&gt; &#123;&#125;);eventEmitter.on(\"data\", () =&gt; &#123;&#125;);console.log(eventEmitter.listenerCount(\"data\")); // 2 setMaxLsiteners、getMaxListenerssetMaxListeners 是用来设置最多为每个事件绑定多少个回调函数，但是实际上是可以绑定超过设置的数目的回调函数的，不过当你绑定超过指定数目的回调函数时，会在控制台给出一个警告 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();// 设置只能为每个回调函数绑定 1 个回调函数eventEmitter.setMaxListeners(1);// 为 data 事件绑定了三个回调函数eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 1\");&#125;);eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 2\");&#125;);eventEmitter.on(\"data\", () =&gt; &#123; console.log(\"data 3\");&#125;); 运行上述程序，控制台打印结果为 data 1data 2data 3(node:36928) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 2 data listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit 可见事件绑定的三个回调函数都可以被触发，并且在控制台打印出了一条警告信息。 getMaxListeners 是获得能为每个事件绑定多少个回调函数的方法，使用 setMaxListeners 设置的值时多少，返回的值就是多少 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.setMaxListeners(1);console.log(eventEmitter.getMaxListeners()); // 1 如果没有使用 setMaxLsiteners 进行设置，那么默认能够为每个事件最多绑定 10 个回调函数，可以通过 EventEmitter 的 defaultMaxListeners 属性获得该值 const &#123;EventEmitter&#125; = require(\"events\");console.log(EventEmitter.defaultMaxListeners); // 10 listeners、rawListeners当我们使用 once 绑定一个回调函数时，不会直接为该事件绑定该函数，而是会使用一个函数包装该函数，这个包装函数称为 wrapper，然后为该事件绑定 wrapper 函数，在 wrapper 函数内部，设定了当执行一次之后将自己解绑的逻辑。 listeners 返回指定事件绑定的回调函数组成的数组，而 rawListeners 也是返回指定事件绑定的回调函数组成的数组，与 listeners 不同的是，对于 once 绑定的回调函数返回的是 wrapper，而不是原生绑定的函数。 const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.once(\"data\", () =&gt; &#123; console.log(\"once\");&#125;)let fns = eventEmitter.listeners(\"data\");// once 绑定的函数，不是 wrapper，内部没有解绑的逻辑，所以后面触发 data 事件时还会执行 once 绑定的函数fns[0]()eventEmitter.emit(\"data\"); 控制台打印结果为 onceonce 下面将上面的 listeners 替换为 rawListeners const &#123;EventEmitter&#125; = require(\"events\");const eventEmitter = new EventEmitter();eventEmitter.once(\"data\", () =&gt; &#123; console.log(\"once\");&#125;)let fns = eventEmitter.rawListeners(\"data\");// 因为返回的是 once 绑定函数的 wrapper，其内部有执行一次后解绑的逻辑// 所以后面触发事件时 once 绑定的函数不会再执行fns[0]()eventEmitter.emit(\"data\"); 控制台的打印结果为 once 实现一个 EventEmitter在这个小节将从零实现一个 EventEmitter，来加深对该模块的理解。首先我们需要准备一个 listeners 来存储所有绑定的回调函数，它是一个 Map 对象，键是事件名，而值是一个数组，数组中保存的是该事件绑定的回调函数。 class EventEmitter &#123; constructor() &#123; this.listeners = new Map(); &#125;&#125; on、addListener使用 on 绑定回调函数时，我们先判断 Map 集合中是否有为该事件绑定回调函数，如果有取出对应数组，并添加该回调函数进数组，没有则新建一个数组，添加该回调函数，并添加进 Map 集合 on(event, callback) &#123; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); fns.push(callback);&#125; addListener 的功能与 on 是一样的，我们直接调用 on 方法即可 addListener(event, callback) &#123; this.on(event, callback);&#125; emit当我们使用 emit 触发事件时，我们从 Map 取出对应的回调函数组成的数组，然后依次取出函数执行。另外我们还可以通过 emit 传递参数 emit(event, ...args) &#123; if(!this.listeners.has(event)) &#123; return; &#125; let fns = this.listeners.get(event); let values = []; for(let fn of fns) &#123; values.push(fn); &#125; for (let fn of values) &#123; fn(...args); &#125;&#125; 这里你可能会觉得我写的有点复杂，所以你会觉得直接这么写更好 emit(event, ...args) &#123; if(!this.listeners.has(event)) &#123; return; &#125; for (let fn of fns) &#123; fn(...args); &#125;&#125; 一开始我也是这么写的，但是因为 once 绑定的函数它在执行完毕后将自己从数组中移除，并且是同步的，所以在执行循环的时候，数组是在不断变化的，使用上述的方式会使得一些回调函数会被漏掉，所以我才会先将数组中的函数复制到另一个数组，然后遍历这个新的数组，因为 once 绑定的函数它只会删除原数组中的函数，而不会删除新的这个数组，所以新数组的长度在遍历的过程不会改变，也就不会发生漏掉函数未执行的情况。 prependListener实现 prependListener 的逻辑同 on 一样，不过我们是往数组的最前方添加回调函数 prependListener(event, callback) &#123; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); fns.unshift(callback);&#125; off、removeListener使用 off 方法是用来解绑事件的，在数组中找到指定的函数，然后删除即可 off(event, callback) &#123; if(!this.listeners.has(event)) &#123; return; &#125; let fns = this.listeners.get(event); // 找出数组中的回调函数，然后删除 for (let i = 0; i &lt; fns.length; i++) &#123; if(fns[i] === callback) &#123; fns.splice(i, 1); break; &#125; &#125; // 如果删除回调函数后，数组为空，则删除该事件 if (fns.length === 0) &#123; this.listeners.delete(event); &#125;&#125; removeListener 同 off 的作用一样，我们在内部直接调用 off 方法即可 removeListener(event, callback) &#123; this.off(event, callback);&#125; once、prependOnceListener使用 once 绑定一个只执行一次的函数，所以我们需要将绑定的回调函数使用一个函数包装一下，然后添加进数组中，这个包装函数我们称之为 wrapper。在包装函数中，当执行一遍后会将自己从数组中删除 once(event, callback) &#123; let wrapper = (...args) =&gt; &#123; callback(...args); this.off(event, wrapper); &#125; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); fns.push(wrapper);&#125; prependOnceListener 的实现同 once，只是向数组的开头插入函数，将上面代码中的 push 换为 unshift 即可 prependOnceListener(event, callback) &#123; let wrapper = (...args) =&gt; &#123; callback(...args); this.off(event, wrapper); &#125; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); fns.unshift(wrapper);&#125; removeAllListeners直接从删除对应的事件，如果没有传入具体事件的话，则需要删除所有的事件 removeAllListeners(event) &#123; // 如果没有传入 event，则删除所有事件 if (event === undefined) &#123; this.listeners = new Map(); return; &#125; this.listeners.delete(event);&#125; eventNames获得已经绑定了哪些事件 eventNames() &#123; return [...this.listeners.keys()];&#125; listenerCount获得某事件绑定可多少个回调函数 listenerCount(event) &#123; return this.listeners.get(event).length;&#125; 上述的实现有一个 bug，那就是无法删除使用 once 绑定的函数，我的想法是使用一个 Map 将 once 绑定的函数同对应的 wrapper 对应，删除时即可根据 once 的回调函数找到对应的 wrapper 然后删除 constructor() &#123; this.listeners = new Map(); // 保存 once 的回调函数与对应的 wrapper this.onceToWrapper = new Map();&#125;once(event, callback) &#123; let wrapper = (...args) =&gt; &#123; callback(...args); // 删除之前，删除 callback 和 wrapper 的关系 this.onceToWrapper.delete(callback); this.off(event, wrapper); &#125; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); // 添加之前，绑定 callback 和 wrapper 的关系 this.onceToWrapper.set(callback, wrapper); fns.push(wrapper);&#125;prependOnceListener(event, callback) &#123; let wrapper = (...args) =&gt; &#123; callback(...args); // 同上 this.onceToWrapper.delete(callback); this.off(event, wrapper); &#125; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); // 同上 this.onceToWrapper.set(callback, wrapper); fns.unshift(wrapper);&#125;off(event, callback) &#123; if(!this.listeners.has(event)) &#123; return; &#125; let fns = this.listeners.get(event); // 先从 onceToWrapper 中查找是否有对应的 wrapper，如果有说明是 once 绑定的 callback = this.onceToWrapper.get(callback) || callback; for (let i = 0; i &lt; fns.length; i++) &#123; if(fns[i] === callback) &#123; fns.splice(i, 1); break; &#125; &#125; if (fns.length === 0) &#123; this.listeners.delete(event); &#125;&#125; 全部代码如下 class EventEmitter &#123; constructor() &#123; this.listeners = new Map(); this.onceToWrapper = new Map(); &#125; on(event, callback) &#123; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); fns.push(callback); &#125; addListener(event, callback) &#123; this.on(event, callback); &#125; emit(event, ...args) &#123; if(!this.listeners.has(event)) &#123; return; &#125; let fns = this.listeners.get(event); let values = []; for(let fn of fns) &#123; values.push(fn); &#125; for (let fn of values) &#123; fn(...args); &#125; &#125; prependListener(event, callback) &#123; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); fns.unshift(callback); &#125; off(event, callback) &#123; if(!this.listeners.has(event)) &#123; return; &#125; let fns = this.listeners.get(event); callback = this.onceToWrapper.get(callback) || callback; for (let i = 0; i &lt; fns.length; i++) &#123; if(fns[i] === callback) &#123; fns.splice(i, 1); break; &#125; &#125; if (fns.length === 0) &#123; this.listeners.delete(event); &#125; &#125; removeListener(event, callback) &#123; this.off(event, callback); &#125; once(event, callback) &#123; let wrapper = (...args) =&gt; &#123; callback(...args); this.onceToWrapper.delete(callback); this.off(event, wrapper); &#125; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); this.onceToWrapper.set(callback, wrapper); fns.push(wrapper); &#125; prependOnceListener(event, callback) &#123; let wrapper = (...args) =&gt; &#123; callback(...args); this.onceToWrapper.delete(callback); this.off(event, wrapper); &#125; if(!this.listeners.has(event)) &#123; this.listeners.set(event, []); &#125; let fns = this.listeners.get(event); this.onceToWrapper.set(callback, wrapper); fns.unshift(wrapper); &#125; removeAllListeners(event) &#123; if (event === undefined) &#123; this.listeners = new Map(); return; &#125; this.listeners.delete(event); &#125; eventNames() &#123; return [...this.listeners.keys()]; &#125; listenerCount(event) &#123; return this.listeners.get(event).length; &#125;&#125; 参考文献 How to code your own event emitter in Node.js: a step-by-step guide Nodejs|Events","tags":[{"name":"EventEmitter","slug":"EventEmitter","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/EventEmitter/"}]},{"title":"ES6：用模块封装代码","date":"2021-03-10T16:00:00.000Z","path":"/ES6：用模块封装代码/","text":"在早期，JavaScript 一般是用来当做独立执行的脚本，它们的程序比较小，随着 JavaScript 的发展，JavaScript 的程序也更加的复杂，所以就需要将程序按模块划分，并且模块之间可以互相导入，由此催生了很多的规范，如 CMD 与 AMD，现如今 ES6 也提供原生的模块机制支持。 模块真正的魔力所在是仅导出和导入你需要的绑定，而不是将所用东西都放到一个文件。只有很好地理解了导出和导入才能理解模块与脚本的区别。 模块的导出通过 export 关键字可以将一个值、函数、对象导出，如 export const a = 1;export function add(x, y) &#123; return x + y;&#125;export const obj = &#123; name: \"Alice\", age: 18&#125;;export class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 模块不支持动态的导出，不能在函数或者 if 语句块内导出 if (condition) &#123; // 这样的语法是不允许的 export ...&#125; 我们导出变量时，可以通过 as 为变量重命名，例如 function add() &#123;&#125;// 将 add 重命名为 sum，后续导入时直接导入 sumexport add as sum 模块的导入通过 import 语法可以在其他模块导出的内容进行导入，例如 a.js 导出如下 // a.jsexport let name = \"Alice\"; 我们在 b.js 中使用 import 语句进行导入 // b.jsimport &#123;name&#125; from \"./a.js\";console.log(name); // Alice 需要注意的是，import 导入为只读导入，即不能修改导入的值 import &#123;name&#125; from \"./a.js\";// 下面的行为将报错，Uncaught TypeError: Assignment to constant variable.name = \"Bob\"; 但是考虑下面的情况 // a.jsexport let name = \"Alice\";export function setName(value) &#123; name = value;&#125; // b.jsimport &#123;name, setName&#125; from \"./a.js\";// 可以通过 setName 修改 namesetName(\"Bob\");console.log(name); // Bob 可以通过 setName 来修改 name 的值。 同样，我们也可以通过 as 语法为导入的变量重命名 // b.jsimport &#123;name as alice&#125; from \"./a.js\";console.log(alice); // Alice 通过 import * 可以导入模块中的所有内容 import * as a from './a.js'console.log(a.name); // Alice 模块的默认值我们可以通过 export default 导出模块的默认值 // a.jsfunction add(x, y) &#123; return x + y;&#125;export default add 通过 export default 导出的变量可以直接通过 import 引用 // b.jsimport add from './a.js' 默认导出还可以写为 export add as default 这种写法同 export default 的效果一致，另外可以通下面的这种方式为默认导入重命名 // 为默认导入重命名import &#123;default as add&#125; from './a.js' 当同时导入默认导出与其他导出时，可以这么写 // a.js// 一般导出export let name = \"Alice\";// 默认导出export default function add() &#123; return x + y;&#125; // b.jsimport add, &#123;name&#125; from './a.js'; 浏览器中使用模块在 script 中使用模块要在 script 标签中使用模块，需要设置 script 标签的 type=”module” &lt;script type=\"module\"&gt; import add from './a.js';&lt;/script&gt;&lt;script type=\"module\" src=\"./b.js\"&gt;&lt;/script&gt; 模块加载顺序如果 script 的 type 属性被设置为了 module，那么会自动为每一个 script 标签添加一个 defer 属性，当解析到此 script 标签时，它会立即下载该模块文件，但是下载完成后不会执行，只有等到文档解析完毕才会执行。 并且执行的顺序与 script 定义的顺序有关，定义在前的 script 标签先执行 &lt;script type=\"module\" src=\"./module1.js\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"./module2.js\"&gt;&lt;/script&gt; 虽然可能 module2.js 先下载完毕，但是 module1.js 定义在签名，所以 module1.js 会先于 module2.js 执行。 一个模块会被多个模块所引用，但是所有的模块只会被执行一次，如果有多个模块导入同一模块，第一次导入时，执行该模块，然后放入缓存，第二个及以后导入该模块时直接从缓存中获得导入的模块，而不会再次执行此模块。 浏览器中的模块说明符当我们使用 import 导入模块时，浏览器要求路径是以下几种格式： . /：从当前目录开始解析 ../：从父目录开始解析 /：从根目录开始解析 所以下面的导入语句在浏览器中是无效的 import add from 'example.js'import sum from 'example/index.js' 因为上述的导入路径不是以 ./ ../ 或者 / 开头，所以无法被浏览器加载。","tags":[{"name":"模块","slug":"模块","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"ES6：Proxy和Reflect","date":"2021-03-09T16:00:00.000Z","path":"/ES6：Proxy和Reflect/","text":"在 ES6 之前我们很难模仿一个内置的对象的行为，例如模仿数组，当添加一个新的元素时，length 的长度 +1，当改变 length 的大小时，也会对数组中的元素产生影响，我们很难通过现有的语法去做到这件事情，在 ES6 中给我们提供了 Proxy，使得开发者能够创建内建的对象。 Proxy 可以为对象做一层代理，拦截对象的一些操作，例如为对象的属性赋值，访问对象的属性值，使用 in 操作判断对象是否存在某个属性等等，这些操作都可以被拦截，从而可以对要访问的属性进行验证从而决定采用什么行为。 let target = &#123;&#125;;let proxy = new Proxy(target, &#123;&#125;);proxy.name = \"Alice\";console.log(proxy.name); // Aliceconsole.log(target.name); // Aliceproxy.name = \"Bob\";console.log(proxy.name); // Bobconsole.log(target.name); // Bob 上述对 proxy 的操作会被无条件的转发到 target，proxy 中并不会存储 name 这个属性，所有的操作都是通过转发到 target 完成的。所以当我们为 proxy.name 赋予一个新值，这个操作会被转发到target，也就是为 target.name 赋予一个新值，当我们访问 proxy.name 属性的时候，这个操作也会被转发到 target，返回的是 target.name 的值。 Proxy 可以拦截下面的一些行为 下面就具体介绍用法。 set当我们为对象的属性赋值时，可以通过 set 方法来拦截这个行为，set 方法接收四个参数： trapTarget：target对象 key：要写入的属性 value：被写入的属性值 receiver：操作发生的对象，例如 proxy.name 设置属性值时，receiver 就是 proxy let target = &#123;&#125;;let proxy = new Proxy(target, &#123; set(trapTarget, key, value, receiver) &#123; if (key === 'name') &#123; return false; &#125; Reflect.set(trapTarget, key, value, receiver); &#125;&#125;); 上面我们拦截了为属性赋值的请求，如果当我们为 name 属性赋值时，那么什么都不做，否则就直接将操作转发给 target，上面 Reflect.set(traptarget, key, value, receiver) 就是将操作转发给target，Reflect.set 接收的参数与 set 方法一样 proxy.name = \"Alice\";console.log(proxy.name); // undefinedconsole.log(target.name); // undefinedproxy.age = 10;console.log(proxy.age); // 10console.log(target.age); // 10 上面我们通过 proxy 为 name 属性赋值，发现并没有成功，打印出的结果是 undefined，因为我们拦截了赋值请求，无法为 name 属性赋值；但是当我们为其他属性赋值时，它会被直接转发到 target，所以赋值时成功的。 get当我们访问对象的属性值时，可以通过 get 方法拦截这个请求，get 方法接收三个参数 trapTarget key receiver 参数的含义同上，不多做解释。 let proxy = new Proxy(target, &#123; // ... get(trapTarget, key, receiver) &#123; if(!(key in receiver))&#123; throw new Error(\"该属性不存在\"); &#125; Reflect.get(trapTarget, key, receiver); &#125;&#125;); 上面我们拦截了访问对象属性值的请求，首先我们会查找对象中是否存在这个属性，如果不存在则会抛出错误(而不是返回 undefined)，如果存在则直接通过 Reflect.get 转发给 target proxy.gender = \"male\";console.log(proxy.sex); has当我们使用 in 操作符判断对象中是否存在某个属性时，我们可以使用 has 方法拦截这个请求，has 方法接收两个参数 trapTarget key let target = &#123; name: \"Alice\", age: 18&#125;;let proxy = new Proxy(target, &#123; has(trapTarget, key) &#123; if (key === 'age') &#123; return false; &#125; return Reflect.has(trapTarget, key); &#125;&#125;); 当查找的 key 的值是 age 时，我们直接返回 false，否则直接转发到 target 上 console.log(\"name\" in proxy); // trueconsole.log(\"age\" in proxy); // false deletePropertydelete 操作用以删除对象的属性，我们可以通过 deleteProperty 来拦截这一行为，deleteProperty 接收两个参数 trapTarget key let target = &#123; name: \"Alice\", age: 18&#125;;let proxy = new Proxy(target, &#123; deleteProperty(trapTarget, key) &#123; if (key === 'age') &#123; return false; &#125; else &#123; return Reflect.deleteProperty(trapTarget, key); &#125; &#125;&#125;); 当我们想删除 age 属性时，直接返回 false 而不做删除操作，表示删除失败，当想删除其他属性时，则将操作转发给 target console.log(proxy.age); // 18console.log(delete proxy.age); // falseconsole.log(proxy.age); // 18 对象原型我们可以通过 Object.setPrototypeOf 和 Object.getPrototypeOf 为对象设置原型以及访问对象的原型，我们可以通过 setPrototypeOf 与 getPrototypeOf 来拦截这个行为。setPrototypeOf 接收两个参数： trapTarget proto：原型 setPrototypeOf 返回 false 表示设置原型失败，返回任一非 false 值 Object.setPrototype 会认为原型设置成功 let target = &#123;&#125;;let proxy = new Proxy(target, &#123; setPrototypeOf(trapTarget, proto) &#123; if (!(\"name\" in proto)) &#123; return false; &#125; return Reflect.setPrototypeOf(target, proto); &#125;&#125;); 上面当我们设置原型时，如果原型对象没有 name 属性，我们返回 false，表示原型设置失败 let proto = &#123; age: 18&#125;;try &#123; Object.setPrototypeOf(proxy, proto);&#125; catch (e) &#123; console.log(\"原型设置失败\"); // √&#125;console.log(Object.getPrototypeOf(proxy) === proto); // false getPrototype 接收一个参数： tarpTarget getPrototype 必须返回一个对象或者 null，否则会报错 let target = &#123; name: 'Alice'&#125;;let proxy = new Proxy(target, &#123; getPrototypeOf(trapTarget) &#123; if (\"name\" in trapTarget) &#123; return null; &#125; return Reflect.getPrototypeOf(trapTarget); &#125;&#125;); 如果对象具有 name 属性，我们就直接返回 null，否则走默认行为 console.log(Object.getPrototypeOf(proxy)); // null 对象扩展Object.isExtensible 是判断对象是否可扩展的，而 Object.preventExtensions 是用来设置对象不可扩展的，我们可以通过 isExtensible 和 preventExtensions 来拦截默认行为，它们都接收一个参数 trapTarget 且返回一个布尔值，isExtensible 返回的布尔值表示十分可扩展，而 preventExtensions 返回的布尔值表示是否设置不可扩展，返回 false 表示不设置不可扩展。 isExtensiable 返回的值一定要与 Object.isExtensible 和 Reflect.isExtensible 返回的值相同，当 preventExtensions 返回 false 时，Object.preventExtensions 会认为设置失败，从而抛出一个错误。 let target = &#123;&#125;let proxy = new Proxy(target, &#123; isExtensible(target) &#123; return Reflect.isExtensible(target); &#125;, preventExtensions(target) &#123; return false; &#125;&#125;);console.log(Object.isExtensible(target)); // trueconsole.log(Object.isExtensible(proxy)); // truetry &#123; console.log(Object.preventExtensions(proxy));&#125; catch (e) &#123; console.log(e); // √&#125;console.log(Object.isExtensible(target)); // trueconsole.log(Object.isExtensible(proxy)); // true 对象描述符当我们调用 Object.defineProperty 时，我们可以通过 defineProperty 来拦截这一行为，defineProperty 接收三个参数 trapTarget key descriptor let target = &#123; name: \"Alice\"&#125;;let proxy = new Proxy(target, &#123; defineProperty(trapTarget, key, descriptor) &#123; if (typeof key === 'symbol') &#123; return false; &#125; return Reflect.defineProperty(trapTarget, key, descriptor); &#125;&#125;); 上述拦截了 defineProperty，当配置的键为 Symbol 类型时，返回 false，表示不可配置，而对于字符串类型的键则调用 Reflect 转发给 target 对象 Object.defineProperty(proxy, \"age\", &#123; value: 18, writable: true, configurable: true, enumerable: true&#125;);console.log(proxy.age); // 18let sym = Symbol();try &#123; // 会抛出错误，因为不可配置 Symbol 类型的键 Object.defineProperty(proxy, sym, &#123; value: \"Hello\" &#125;);&#125;catch (e) &#123; console.log(\"不可配置 Symbol 键\") // √&#125; Object.getOwnPropertyDescriptor 方法使用获得属性的描述符的，同样可以使用 getOwnPropertyDescriptor 进行拦截，它接收两个参数 trapTarget key 返回值可以是 undefined 或者一个对象，如果返回的是一个对象，那么对象中的属性只能包括 enumerable configurable value writable get set 如果返回的对象除了其他的属性，那么Object.getOwnPropertyDescriptor 会抛出一个错误 let proxy = new Proxy(target, &#123; getOwnPropertyDescriptor(trapTarget, key) &#123; if (typeof key === 'symbol') &#123; return null; &#125; return Reflect.getOwnPropertyDescriptor(trapTarget, key); &#125;&#125;); 上面的程序表示，无法获得到键为 Symbol 类型的描述符。 ownKeys当我们调用 Object.keys，Object.getOwnPropertyNames，Object.getOwnPropertySymbols，Object.assign 时，首先会在内部调用 [[OwnPropertyKeys]] 来得到一个数组用于上述方法筛选，Object.keys，Object.getOwnPropertyNames 返回的结果将 Symbol 类型的值排除在外，Object.getOwnPropertySymbols 将字符串类型的值排除在外，Object.assign 两种类型都支持。 我们通过 ownKeys 这个方法来拦截 [[OwnPropertyKeys]] 的行为，它只接受一个参数 trapTarget 返回值必须为数组或者类数组，否则抛出错误。 let target = &#123; _name: \"Alice\", age: 18&#125;;let proxy = new Proxy(target, &#123; ownKeys(trapTarget) &#123; return Reflect.ownKeys(trapTarget).filter(item =&gt; &#123; return typeof item !== 'string' || item[0] !== '_' &#125;) &#125;&#125;);console.log(Object.keys(proxy)); // [ 'age' ] 上面的程序过滤掉了以下划线开头的属性，因为这样的属性表示私有属性，不想被访问到。 apply 和 constructProxy 还可以用来代理函数，可以拦截函数的调用。根据调用的方式不同，有两个拦截的方法 apply：正常调用函数 construct：通过 new 调用函数 apply 方法接收三个参数 trapTarget：执行的函数 thisArgument：函数内部的 this argumentsList：传入函数的参数，以数组的形式显示 construct 方法接收两个参数 trapTarget argumentsList let target = function(...values) &#123; return values.reduce((previousValue, currentValue) =&gt; previousValue + currentValue))&#125;;let proxy = new Proxy(target, &#123; apply(target, thisArg, argArray) &#123; argArray.forEach(item =&gt; &#123; if (typeof item !== 'number') &#123; throw new Error(\"参数必须全部为数字\"); &#125; &#125;) return Reflect.apply(target, thisArg, argArray); &#125;&#125;);const result = proxy(1, 2, 3, 4);console.log(result); 上面的程序利用 apply 截获了函数调用来做参数校验，如果传入的参数不全是数字的话，那么就会抛出错误。 有的时候函数只能通过 new 的方式调用，这个时候我们会判断 new.target 变量来纠正行为，但是我们还可以通过截获普通函数调用，然后返回一个 new 调用的结果 function Person(name) &#123; this.name = name;&#125;let PersonProxy = new Proxy(Person, &#123; apply(target, thisArg, argArray) &#123; return Reflect.construct(target, argArray); &#125;&#125;);let alice = new PersonProxy(\"Alice\");console.log(alice instanceof Person); // truelet bob= PersonProxy(\"Bob\");console.log(bob instanceof Person); // true 这个时候无论是普通调用还是 new 调用，返回的都是 Person 的实例对象。 撤销代理上面创建的代理对象都是不可撤销，就是说它一直代理着目标对象，如果我们希望代理在某个时刻失效，那我们就需要撤销代理，我们可以通过 Promise.revecable 方法创建能够撤销的代理对象，它接收的参数同 Proxy 构造函数相同，返回一个对象，对象中具有两个属性： proxy：可被撤销的代理对象 revoke：调用该方法可撤销代理，调用该方法后代理对象不可用 let target = &#123; name: \"Alice\"&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, &#123; get(target, key, receiver) &#123; return \"Bob\"; &#125;&#125;);console.log(proxy.name); // Bob// 撤销代理，此后不能使用 proxyrevoke();// 报错，TypeError: Cannot read property 'Symbol(nodejs.util.inspect.custom)' of nullconsole.log(proxy);","tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Proxy/"},{"name":"Reflect","slug":"Reflect","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Reflect/"}]},{"title":"ES6：Promise与异步编程","date":"2021-03-08T16:00:00.000Z","path":"/ES6：Promise与异步编程/","text":"异步编程背景JavaScript 是单线程的，意味着同一时刻只有一处代码在执行，所以它的线程不能被阻塞住，为了达到这一个目的，JavaScript 使用任务队列的机制来实现异步编程。异步编程一般有两种模式 事件模型 回调模型 事件模型是指为某事件绑定一个函数，当事件触发时执行此函数，一般在 DOM 编程中比较常见，例如为按钮绑定点击事件 document.getElementById(\"btn\").addEventListener(\"click\", event =&gt; &#123; // 处理点击事件&#125;) 回调模型在 Node.js 的 I/O 操作中比较常见，在读取文件时，我们肯定不能阻塞线程等待文件读取完毕，然后进行操作，这里的解决办法是在调用读取文件的函数时，传入一个函数，这个函数在文件被读取完成时会被调用，并且读取到的数据会作为参数传入该函数 const fs = require(\"fs\");// 第二个参数是处理数据的回调函数，它会在文件读取完毕时执行fs.readFile(\"a.txt\", (err, data) =&gt; &#123; // 处理数据&#125;)// 下面的程序不用等到文件读取完毕即可执行// 如果下面的程序要用到读取到的文件，那么它应该放在回调函数中 当回调函数嵌套较多时，造成代码十分难以阅读，这种情况称之为回调地狱，为了解决这个问题，在 ES6 中提出了 Promise，进一步在 ES7 提出了 async … await 语法。 Promise基础Promise 的基本语法如下 new Promise(fn1).then(fn2) 其中 fn1 和 fn2 都是两个函数，fn1 接收两个参数 resolve 和 reject，这两个参数也都是函数，只有当在 fn1 中调用了 resolve 方法后，fn2 方法才会被执行。所以 Promise 可以保证函数执行的顺序，并且 fn1 向 resolve 传入的参数被被传递给 fn2 let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"Hello\"); &#125;, 1000);&#125;);promise.then(data =&gt; &#123; console.log(data);&#125;); 上述代码会在 1s 后打印出 Hello，因为在 1s 后才执行 resolve 函数，此时 fn2 才会被执行，并且 Hello 会作为参数传入 fn2。 现在我们比较一下回调模型与 Promise 模型 const fs = require(\"fs\");fs.readFile(\"a.txt\", (err, data) =&gt; &#123; if (err) return; fs.writeFile(\"b.txt\", data, err =&gt; &#123; &#125;)&#125;) let promise = new Promise((resolve, reject) =&gt; &#123; fs.readFile(\"a.txt\", (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;)&#125;);promise.then(data =&gt; &#123; fs.writeFile(\"b.txt\", data);&#125;) 上面的版本为回调模型版本，下面的版本为 Promise 版本，从写法上看回调版本是一层嵌套一层以此来保证同步性，如果有较多的嵌套的话，代码肯定十分难读，体验感十分不好；而 Promise 的写法则比较像同步的写法(写法上与同步的写法类似，但是实际上还是异步的)，即使嵌套再多，可读性也十分的好。 错误处理如果在 fn1 中出现了错误怎么办，这个时候就需要我们即将介绍的 reject，其实 Promise 还有一种用法 new Promise(fn1).then(fn2, fn3) then 可以接收两个函数，当在 fn1 中调用 resolve 方法后，fn2 被执行，当在 fn1 中执行 reject 方法后，fn3 被执行。resolve 表示函数正常执行完毕，用于传递数据，而 reject 表示函数出错，一般用于传递错误，向 reject 传递的参数会被传递给 fn3，所以 fn2 是 fn1 成功执行后的处理逻辑，而 fn3 是 fn1 执行出错后的处理逻辑 let promise = new Promise((resolve, reject) =&gt; &#123; fs.readFile(\"a.txt\", (err, data) =&gt; &#123; // 如果出错，则调用 reject 方法，并将错误信息传入 if (err) reject(err) resolve(data) &#125;)&#125;);promise.then(data =&gt; &#123; fs.writeFile(\"b.txt\", data);&#125;, err =&gt; &#123; console.log(err);&#125;); 其实还有一种写法 new Promise(fn1).then(fn2).catch(fn3) 这种写法与上面的写法是一样的 promise.then(data =&gt; &#123; fs.writeFile(\"b.txt\", data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 链式调用下面继续介绍 Promise 的新模式，链式调用 new Promise(fn1).then(fn2).then(fn3).then(fn4) 因为每一个 then 方法都返回一个 Promise 对象，所以可以进行链式的调用 let promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve();&#125;).then(() =&gt; &#123; console.log(2);&#125;).then(() =&gt; &#123; console.log(3);&#125;).then(() =&gt; &#123; console.log(4);&#125;); 上面的程序会依次打印出 1 2 3 4。现在有一个问题是链式调用如何传递值，答案是通过返回值 let promise = new Promise((resolve, reject) =&gt; &#123; resolve(\"Hello\");&#125;).then(data =&gt; &#123; console.log(data); // 通过 return 将数据传递到下面的方法中 return \"World\";&#125;).then(data =&gt; &#123; console.log(data);&#125;) 上述的打印结果为 HelloWorld 我们看一个简单 then 方法的实现来理解上面的逻辑 function then(fn) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = fn(); resolve(result); &#125;) &#125; 上面只是为了理解代码的简单实现，并不是 then 方法的真正实现。 但是如果传入 then 中的函数返回的是一个 Promise 对象的话就有所不同，后面链式调用传入 then 中的函数必须等到返回 Promise 执行 resolve 方法之后才会执行，并且向 resolve 传入的值会被传递 let promise = new Promise(resolve =&gt; &#123; resolve();&#125;).then(() =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"Hello World\"); &#125;, 1000) &#125;)&#125;).then(data =&gt; &#123; console.log(data); // Hello World&#125;) 上面 1s 之后会打印出 Hello World。我们进一步改进 then 方法的实现来理解上述的执行结果 function then(fn) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = fn(); if (result instanceof Promise) &#123; result.then(resolve); &#125; else &#123; resolve(result); &#125; &#125;)&#125; finally在链式调用的最后一般调用 finally 方法，该方法无论上面的链式调用成功执行，或者是链式调用的过程中抛出了错误，传递给 finally 方法的函数最终都会被执行 let promise = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;).then(() =&gt; &#123; console.log(\"then 中函数被执行\"); // √&#125;).catch(() =&gt; &#123; console.log(\"catch 中函数被执行\");&#125;).finally(() =&gt; &#123; console.log(\"finally 中函数被执行\"); // √&#125;) let promise = new Promise((resolve, reject) =&gt; &#123; reject();&#125;).then(() =&gt; &#123; console.log(\"then 中函数被执行\"); &#125;).catch(() =&gt; &#123; console.log(\"catch 中函数被执行\"); // √&#125;).finally(() =&gt; &#123; console.log(\"finally 中函数被执行\"); // √&#125;) 由于这一特性，finally 方法一般被用于进行资源的回收。 静态方法本节讲述 Promise 的静态方法，不过在讲解静态方法之前，我们谈一谈 Promise 对象的状态，Promise 对象有三种状态： pending resolved(有的地方称为 fulfilled) rejected 在调用 resolve 或 reject 方法之前，Promise 对象处于 pending 状态，此时传入 then 中的函数不能被执行，当调用 resolve 方法后，状态由 pending 变为 resolved，当调用 reject 后，状态由 pending 变为 rejected，一旦状态变为 resolved或 rejected 之后，状态不可改变，并且 resolved和 rejected 状态只能由 pending 状态转变而来。 当 Promise 的状态为 resolved时，传入 then 方法的第一个函数就可以执行了，当 Promise 的状态为 rejected 时，传入 then 的第二个函数或者传入 catch 方法的函数就可以执行了。 下面我们介绍 Promise 的静态方法 Promise.resolve Promise.all Promise.allSettled Promise.race Promise.resolvePromise.resolve 返回一个 Promise，根据传入参数的不同，返回不同的值，分为三种情况 传入一个 Promise 对象，直接返回该 Promise 对象 let promise = new Promise((resolve, reject) =&gt; &#123;&#125;)let res = Promise.resolve(promise);console.log(res === promise); // true 传入一个带有 then 方法的对象，首先执行 then 方法，并且将 resolve 和 reject 传入，返回的 Promise 状态由 then 方法是否调用 resolve 与 reject 方法决定，并且向 resolve 和 reject 传递的参数会被传递 Promise.resolve(&#123; then(resolve, reject) &#123; resolve(\"Hello World!\") &#125;&#125;).then(data =&gt; &#123; console.log(data); // Hello World!&#125;) 传入其他值时，返回一个 resolved 状态的 Promise，并且传入的值会作为 resolve 方法的参数被传递 Promise.resolve(3).then(data =&gt; &#123; console.log(data); // 3&#125;) 经过上面的讲解，可以简单写一个 Promise.resolve 的实现 Promise.resolve = value =&gt; &#123; if (value instanceof Promise) &#123; return value; &#125; return new Promise((resolve, reject) =&gt; &#123; if (typeof value === 'object' &amp;&amp; typeof value.then === 'function') &#123; value.then(resolve, reject); &#125; else &#123; resolve(value); &#125; &#125;)&#125; Promise.allPromise.all 接收一个 Promise 对象组成的数组，返回一个 Promise，只有当数组中的所有 Promise 都 resolved 后，返回的 Promise 才会变为 resolved 状态，并且将所有 Promise 传递的结果封装为数组传递下去 let promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);let promise2 = Promise.resolve(2);Promise.all([promise1, promise2]).then(results =&gt; &#123; console.log(results); // 1s 后打印 [ 1, 2 ]&#125;); 一旦数组中的 Promise 有任一个变为 rejected，返回的 Promise 就会变为 rejected 状态 let promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);// rejected 状态的 Promiselet promise2 = Promise.reject(2);Promise.all([promise1, promise2]).then(results =&gt; &#123; console.log(results);&#125;).catch(err =&gt; &#123; console.log(err); // 2，reject传递的参数&#125;); 所以 all 中的 Promise 要么一起执行成功，要么全部失败，我们拿不到部分成功的 Promise 结果。 Promise.allSettledPromise.allSettled 方法是解决 Promise.all 一旦一个 Promise 变为 rejected，其他变为 resolved 状态 Promise 传递的结果就仿佛被吞掉了 Promise.allSettled([promise1, promise2]).then(results =&gt; &#123; console.log(results); // [ // &#123; status: 'fulfilled', value: 1 &#125;, // &#123; status: 'rejected', reason: 2 &#125; // ]&#125;) Promise.allSettled 方法会返回一个 resolved 状态的 Promise，数组中的 Promise 的执行结果会以对象的形式添加到 results 数组中，status 表示 Promise 最终的状态，value 和 reason 分别表示成功执行时传递的值以及执行出错时传递的错误原因。 Promise.racePromise.race 方法也是接收一个 Promise 组成的数组，返回一个 Promise，当数组中有任一 Promise 的状态变为 resolved 或者 rejected，返回的 Promise 就会相应的变为 resolved 或 rejected。正如 race 所暗示的，是多个 Promise 在竞争，最终选择最快的那个 let promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);let promise2 = Promise.resolve(&#123; then(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 2000); &#125;&#125;);// promise1 会率先执行 resolve，所以得到的结果是promise1 传递的结果Promise.race([promise1, promise2]).then(data =&gt; &#123; console.log(data); // 1&#125;); Promise 与生成器上面使用 Promise 编写的异步代码已经与同步代码很相似了，但是我们可以将 Promise 与 生成器结合起来，使得代码的写法看起来更加的像同步的写法，例如 let promise = new Promise((resolve, reject) =&gt; &#123; fetch(\"/id/2\").then(name =&gt; &#123; resolve(name) &#125;)&#125;).then(name =&gt; &#123; return new Promise(resolve =&gt; &#123; fetch(`/name/$&#123;name&#125;`).then(score =&gt; &#123; resolve(score); &#125;) &#125;)&#125;).then(score =&gt; &#123; console.log(score);&#125;); 上面的代码是先根据 id 向服务器请求 name，然后根据 name 向服务器请求获得的分数，最后打印出分数，我们希望能有更加同步的写法，例如 asyncTaskRunner(*() =&gt; &#123; const name = yield fetch(\"id/2\"); const score = yield fetch(`/name/$&#123;name&#125;`); console.log(score);&#125;) 这种写法可以通过 Promise 与 Generator 来做到。asyncTaskRunner 的实现如下 function asyncTaskRunner(generator) &#123; const iterator = generator(); function handle(result) &#123; if(result.done) return; const resultValue = result.value; if (resultValue instanceof Promise) &#123; resultValue.then(data =&gt; &#123; handle(iterator.next(data)); &#125;).catch(err =&gt; &#123; iterator.throw(err); &#125;) &#125; &#125; try &#123; handle(iterator.next()); &#125; catch (err) &#123; iterator.throw(err); &#125;&#125; 在 ES7 中提出了 async … await 语法，它能让我们以同步的方式写出异步代码 (async () =&gt;&#123; const name = await fetch(\"/id/2\"); const score = await fetch(`/name/$&#123;name&#125;`); console.log(score);&#125;)(); 只需要在函数参数列表前加入 async 关键字，将 yield 换为 await 即可以同步方式写出优雅的异步代码。","tags":[{"name":"Promise","slug":"Promise","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Promise/"}]},{"title":"ES6：改进的数组功能","date":"2021-03-06T16:00:00.000Z","path":"/ES6：改进的数组功能/","text":"Array 的新方法Array.of在 JavaScript 中，有两种方法创建一个数组，一个是通过构造函数 Array，另一个是通过字面量 [] 的方式。通过 Array 创建一个数组时，如果传入了一个数字 $n$，表示的是创建一个容量为 $n$ 的数组；如果传入了一个参数，但是不是一个数字，那么会创建一个包含该参数的数组；如果传入多个参数，那么创建一个包含这些参数的数组 let arr = new Array(2); // 创建长度为 2 的数组console.log(arr); // [ &lt;2 empty items&gt; ]arr = new Array(\"2\");console.log(arr); // [ '2' ]arr = new Array(1, 2, 3);console.log(arr); // [ 1, 2, 3 ] 根据参数个数以及类型的不同，创建出的数组也不同，这种行为可能会为开发者带来记忆上的负担，所以在 ES6 中提供了一个 Array.of 方法，它可以接收多个参数，返回一个数组，数组中的元素就是传入的参数，与参数的个数以及类型无关 let arr = Array.of(2);console.log(arr); // [ 2 ]arr = Array.of(1, 2, 3);console.log(arr); // [ 1, 2, 3 ] Array.fromArray.from 方法的作用是将一个类数组转化为真正的数组，例如将 arguments 转化为真正的数组 function translateArray() &#123; let arr = Array.from(arguments); console.log(arr instanceof Array);&#125;translateArray(1, 2); // true 也可以将一个可迭代的对象转化为真正的数组 let obj = &#123; *[Symbol.iterator]() &#123; yield 1; yield 2; yield 3; &#125;&#125;;let arr = Array.from(obj);console.log(arr); // [ 1, 2, 3 ]console.log(arr instanceof Array); // true Array.from 的第二个参数还可以接收一个回调函数，类似于 map 函数 function translateArray() &#123; return Array.from(arguments, item =&gt; item + 1);&#125;let numbers = translateArray(1, 2);console.log(numbers); // [ 2, 3 ] 如果在回调函数中需要用到 this 的话，也可以通过第三个参数传入 this。 find 和 findIndexfind 和 findIndex 都是用来搜索的方法，它们都接收一个回调函数作为条件来进行搜索 let arr = [1, 2, 3, 4, 5];let item = arr.find(i =&gt; i % 2 === 0);let index = arr.findIndex(i =&gt; i % 2 === 0);// 第一个偶数console.log(item); // 2// 第一个偶数出现的下标console.log(index); // 1 可以通过第二个参数传入回调函数中用到的 this。 fillfill 方法的作用是将数组中的所有元素填充为指定值 let arr = new Array(5);console.log(arr); // [ &lt;5 empty items&gt; ]arr.fill(3);console.log(arr); // [ 3, 3, 3, 3, 3 ] fill 方法还可以接收起始位置和终止位置，表示将数组某个部分填充为指定值 arr.fill(5, 0, 3); // 将 [0, 3) 填充为 5console.log(arr); // [ 5, 5, 5, 3, 3 ] copyWithinlet arr = [1, 2, 3, 4, 5];// 复制 [0, 3) 到以下标为 1 开始的位置arr.copyWithin(1, 0, 3);console.log(arr); // [ 1, 1, 2, 3, 5 ] 定型数组在 JavaScript 中数字都是使用浮点数存储的，即使用 64 位来存储数字，但是在一些特殊的场合，例如对于图像，对于每一个像素只需要 8 位来存储即可，如果使用 64 位存储数据，必然会造成内存上的浪费，并且是 8 倍的浪费，所以就 ES6 就提出了定型数组来针对这些特殊的场景。 ArrayBuffer所有定型数组的基础都是 ArrayBuffer，它表示占据一定字节的内存区域，通过调用 ArrayBuffer 构造函数，可以分配指定数目字节的内存 let buffer = new ArrayBuffer(10); // 分配 10 个字节的内存console.log(buffer); 输出为 ArrayBuffer &#123; [Uint8Contents]: &lt;00 00 00 00 00 00 00 00 00 00&gt;, byteLength: 10&#125; DataView我们可以通过 DataView 来查看和操作 ArrayBuffer const buffer = new ArrayBuffer(10);const view = new DataView(buffer); DataView 构造函数接收一个 ArrayBuffer 对象，除此之外还可以接收两个可选参数 byteOffset：偏移量，默认是 0 byteLength：字节长度，默认是 buffer 的长度 // 获得偏移量为 0，长度为 2 字节的 viewconst view = new DataView(buffer, 0, 2); DataView 对象包含如下属性 buffer：传入构造函数的 ArrayBuffer 对象 byteOffset：传入构造函数的 byteOffset byteLength：传入构造函数的 byteLength const buffer = new ArrayBuffer(10);const view1 = new DataView(buffer);const view2 = new DataView(buffer, 2, 5);console.log(view1.buffer === view2.buffer); // trueconsole.log(view1.byteOffset); // 0console.log(view1.byteLength); // 10console.log(view2.byteOffset); // 2console.log(view2.byteLength); // 5 通过下面的方法可以读取和设置 buffer 中的值 getInt8(offset, littleEndian) setInt8(offset, value, littleEndian) getUInt8(offset, littleEndian) setUInt8(offset, value, littleEndian) 以上暂且忽略参数 littleEndian let buffer = new ArrayBuffer(10);let view = new DataView(buffer);// 0000 1010view.setInt8(0, 10);// 1000 1010 补码 1111 0110view.setInt8(1, -10);let s = view.getInt8(0);console.log(s); // 10// 1111 0110 =&gt; 246s = view.getUint8(1);console.log(s); // 246 此外还可以通过下面的方法设置浮点数的值 getFloat32 setFloat32 getFloat64 setFloat64 接收的参数同上面一样 // 3F 80 00 00view.setFloat32(0, 1);// 3F 80 00 00view.setFloat32(2, 1);// 3F 80 00 00 3F 80 00 00res = view.getFloat64(0);console.log(res); // 0.007933616638183594 定型数组一个定型数组其实就是一个指定类型 DataView，具体有如下定型数组 向上图中的构造函数传入一个 buffer 创建定型数组，另外还可以传入 byteOffset 和 byteLength 两个可选参数，这两个可选参数的默认值同 DataView let buffer = new ArrayBuffer(10);let int8 = new Int8Array(buffer, 1, 2);console.log(int8.buffer === buffer); // trueconsole.log(int8.byteOffset); // 1console.log(int8.byteLength); // 2console.log(int8); // Int8Array(2) [ 0, 0 ] byteLength 必须能够整除定型数组表示的元素大小，假如向 Int16Array 传入一个大小为奇数的 byteLength，那么会报错，因为 Int16Array 中每个元素占据两个字节，而奇数不能整除 2，即无法平均分配，所以会报错 let int16 = new Int16Array(buffer, 0, 9); // 9 不能整除 2，会报错 除此以外，还可以直接传入一个数字，表示分配多少字节的内存给字节数组，同理需要注意传入的数字要能够整除定型数组中每个元素的大小 let int16 = new Int16Array(8); 如果没有向构造函数传入任何参数时，默认传入的参数为 0，这时定型数组不能保存数据，因为没有为它分配内存空间。 除此以外，定型数组的构造函数还可以接收如下几种类型的参数 一个定型数组：将定型数组中的元素一个个的复制到新的定型数组中，所以两个定型数组的 buffer 是不同的 一个可迭代的对象：调用对象的默认迭代器，将得到的元素一个个的添加到定型数组中 一个数组 一个类数组，如 arguments let int8 = new Int8Array([25, 50]); // 使用数组作为参数let int16 = new Int16Array(int8); // 使用定型数组作为参数console.log(int8.buffer === int16.buffer); // false 定型数组与一般数组的相似之处在很多的时候，可以把定型数组当做是一般数组 let int8 = new Int8Array([25, 50]);console.log(int8.length); // 2console.log(int8[0]); // 25console.log(int8[1]); // 50 定型数组的长度一旦确定就不能再改变 共同方法定型数组与普通数组有以下共同方法 let int8 = new Int8Array([25, 50]);let newArr = int8.slice(0, 1);console.log(newArr instanceof Int8Array); // truelet res = int8.find(i =&gt; i &gt; 30);console.log(res); // 50 共同的迭代器定型数组也有三个迭代器，即 entries、keys 和 values，这意味着你可以使用展开运算符和 for … of 循环 let arr = [...int8];console.log(arr instanceof Array); // truefor (let v of int8) &#123; console.log(v); // 25 // 50&#125; of 与 from 方法定型数组也有 of 和 from 方法 let int8 = Int8Array.of(3, 56);let float32 = Float32Array.from([1.5, 2.5]);console.log(int8); // Int8Array(2) [ 3, 56 ]console.log(float32); // Float32Array(2) [ 1.5, 2.5 ] 定型数组与一般数组的不同之处行为不同一般数组的长度是可变的，但是定型数组的长度不可变 let int8 = new Int8Array([0, 1]);console.log(int8.length); // 2int8[2] = 5; // 无效，长度不可变console.log(int8.length); // 2 定型数组会检查传入的数据是否有效，如果无效传入的值会被替换为 0 let int8 = new Int8Array([\"hi\"]); // 会被替换为 0console.log(int8.length); // 1console.log(int8[0]); // 0 对定型数组进行修改也会对值的类型进行检查，如果是无效的类型，则值会被替换为 0 let int8 = new Int8Array([1, 2]);let newInt8 = int8.map(i =&gt; \"hi\");console.log(newInt8); // Int8Array(2) [ 0, 0 ] 缺失的方法定型数组没有以下方法 因为上面的方法都会改变数组的长度，所以定型数组没有以上方法是很容易理解的。 新增的方法相比于一般数组，定型数组新增了两个方法 set：将一个数组中的元素复制到定型数组中 subarray：从定型数组中抽取一部分到新的定型数组中 set 方法接收一个数组，以及一个可选的参数，数据插入的偏移量，如果省略第二个参数，那么偏移量默认为 0 let int8 = new Int8Array(4); // 数组长度为 4int8.set([1, 2]); // 将 [1, 2] 复制到定型数组前两个位置int8.set([3, 4], 2); // 将 [3, 4] 复制到定型数组下标以 2 开始的两个位置console.log(int8); // Int8Array(4) [ 1, 2, 3, 4 ] subarray 接收两个可选的参数 start：起始位置，缺省为 0 end：终止位置，缺省为数组的长度 抽取的范围为 [start, end)，左闭右开，返回一个新的定型数组 let int8 = new Int8Array([1, 2, 3, 4]);let arr1 = int8.subarray(); // 缺省，默认是抽取整个数组let arr2 = int8.subarray(1); // 抽取 [1, 4)，4 为数组的长度let arr3 = int8.subarray(1, 2); // 抽取 [1, 2)console.log(arr1); // Int8Array(4) [ 1, 2, 3, 4 ]console.log(arr2); // Int8Array(3) [ 2, 3, 4 ]console.log(arr3); // Int8Array(1) [ 2 ]","tags":[{"name":"Array","slug":"Array","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Array/"}]},{"title":"Node.js之Stream","date":"2021-03-05T16:00:00.000Z","path":"/Node.js之Stream/","text":"引入 Stream假设我们有这么一个需求，我们需要复制一个文件中的内容到另一个文件中，我们会写出以下代码 const fs = require('fs');const path = require('path');const copy = (source, target) =&gt; &#123; fs.readFile(path.resolve(source), (err, data) =&gt; &#123; if(err) &#123; throw new Error(err.toString()); return; &#125; fs.writeFile(path.resolve(target), data, (err) =&gt; &#123; if(!err) &#123; console.log(\"复制成功！\"); &#125; &#125;) &#125;)&#125; 上面的代码很简单，就是先读取 source 文件里面的内容，然后将内容写入到 target 文件中。它的特点是需要读取完 source 里面的所有内容，然后将内容写入到 target 中。 这样做就有一个缺点，当我们读取大文件时，可能会发生内存不够用的情况，因为它会先将文件的所有内容都读取到内存；另外还就是时间，一次性读取一个大文件到内存，是需要比较长的时间的，用户可能会有卡顿的感觉。 另一种解决办法就是边读边写，读取部分文件内容，然后将内容写入到新文件中，这样在内存中的数据只是部分内容，不会占有太多的内存，由于是边读编写，用户可以很快的得到响应，提高用户体验。 在网上找到一幅动图来形象的展示使用流前后数据的流动情况 Node.js 给我们提供 Stream 的 API，它是专门用来处理大文件的。因为数据是一部分一部分的处理，就像是水流一样，所以这个模块的名称就称为 Stream。 const fs = require('fs');function copy(source, target) &#123; const rs = fs.createReadStream(source); const ws = fs.createWriteStream(target); rs.on('data', data =&gt; &#123; ws.write(data); &#125;); rs.on('end', () =&gt; &#123; ws.end(); &#125;);&#125; 上面代码的细节将在后文揭晓。 Stream 的分类Stream 可以分为四类 Readable：可读流，数据的提供者 Writeable：可写流，数据的消费者 Duplex：可写可读流(双工流) Transform：是 Duplex 的特殊情况，转换流，对输入的数据进行处理，然后输出 可读流与可写流是基础，常见的可读流与可写流如下 可读流 可写流 HTTP Request HTTP Reponse fs read streams fs write streams process.stdin process.stdout TCP sockets TCP sockets zlib streams zlib streams crypto streams crypto streams Stream 是 EventEmitter 的实例，有自定义的事件。 Readable Stream可读流有两个模式，暂停模式与流动模式。当我们创建一个流时，如果我们监听了 readable 事件，它就会来到暂停模式，在暂停模式下，它会不断的读取数据到缓冲区，当读取到的数据超过预设的大小时，它由属性 highWaterMark 指定(默认为 64kB)，便会触发 readable 事件，readable 事件的触发有两种情况： 缓存区中的数据达到 highWaterMark 预设的大小 数据源的数据已经被读取完毕 const fs = require('fs');const rs = fs.createReadStream('a.txt', &#123; highWaterMark: 1 // 缓存区最多存储 1 字节&#125;);rs.on('readable', () =&gt; &#123; let data; while(data=rs.read()) &#123; console.log(data.toString()); &#125;&#125;) 上面的程序设置 highWaterMark 为 1，即每次读取到一个字节便会触发 readable 命令，每次当触发 readable 命令时，我们调用可读流的 read([size]) 方法从缓冲区中读取数据(读取到的数据为 Buffer)，然后打印到控制台。 当我们为可读流绑定 data 事件时，可读流便会切换到流动状态，当位于流动状态时，可读流会自动的从文件中读取内容到缓冲区，当缓冲区中的内容大于设定的 highWaterMark 的大小时，便会触发 data 事件，将缓冲区中的数据传递给 data 事件绑定的函数。以上过程会自动不断进行。当文件中的所有内容都被读取完成时，那么就会触发 end 事件。 const fs = require('fs');const rs = fs.createReadStream('a.txt', &#123; highWaterMark: 2&#125;);rs.on('data', data =&gt; &#123; console.log(data.toString());&#125;);rs.on('end', () =&gt; &#123; console.log(\"文件读取完毕！\");&#125;); 暂停模式像是手动步枪，而流动模式则像是自动步枪。暂停模式与流动模式也可以相互切换，通过 pause() 可以从暂停状态切换到流动状态，通过 resume() 则可以从暂停模式切换到流动模式。 可读流的一个经典实例就是 http 中的请求对象 req，下面的程序展示了通过监听 req 的 data 事件来读取 HTTP 请求体中的内容 const http = require('http');const app = http.createServer();app.on('request', (req, res) =&gt; &#123; let datas = []; req.on('data', data =&gt; &#123; datas.push(data); &#125;); req.on('end', () =&gt; &#123; req.body = Buffer.concat(datas); // 当读取完 body 中的内容之后，将内容返回给客户端 res.end(req.body); &#125;);&#125;)app.listen(3000, () =&gt; &#123; console.log(\"服务启动在 3000 端口... ...\");&#125;) Writable Stream可写流与可读流相似，当我们向可写流写入数据时(通过可写流的 write() 方法写数据)，会直接将数据写入到文件中，如果写入的数据比较慢的话，那就就会将数据写入到缓冲区，当缓冲区中的内容达到 highWaterMark 设定的大小时，write 方法就会返回一个 false，表明不能接受更多的数据了。 当缓冲区中的数据全部被消费完了(写入了文件中或者被别的流消费了)，那么就会触发 drain 事件。 const fs = require('fs');const ws = fs.createWriteStream('b.txt', &#123; highWaterMark: 16 * 1024&#125;);function writeMillionTimes(writer, data, encoding, callback) &#123; let i = 10000; write(); function write() &#123; // 表示是否可以向可写流中写入数据 let ok = true; while(i-- &gt; 0 &amp;&amp; ok) &#123; // 当 writer.write() 方法返回 false 表示不可写入数据 ok = writer.write(data, encoding, i === 0 ? callback : null); &#125; if(i &gt; 0) &#123; // 说明 ok 为 false，即不能向缓冲区中写入内容了 console.log(\"drain\", i); // 监听 drain 事件，当队列消费完毕时继续调用 write() 方法写入 writer.once('drain', write); &#125; &#125;&#125;writeMillionTimes(ws, 'simple', 'utf-8', () =&gt; &#123; console.log(\"end\");&#125;) 输出为 drain 7268drain 4536drain 1804end 说明有三次缓冲区中的内容达到了 16KB，可以验算上面的数字之间的差值，在乘以 6(simple 的字节数)，大小大约为 16 * 1024 左右，如 $$(7268 - 4536) * 6 = 16392 \\approx 16384 = 16 * 1024$$ 我们还可以调用可写流的 end() 方法，表示将缓存中的内容清空写入文件，并关闭文件，此时会触发 close 事件 const fs = require('fs');const ws = fs.createWriteStream('b.txt');ws.write('Hello');ws.write('World');ws.end('!');ws.on('close', () =&gt; &#123; console.log(\"close\"); // close&#125;) 当调用 end() 方法之后就不能调用 write() 方法了，否则会报错 const fs = require('fs');const ws = fs.createWriteStream('b.txt');ws.write('Hello');ws.write('World');ws.end('!');ws.write('write again'); // Error [ERR_STREAM_WRITE_AFTER_END]: write after end 当调用 end() 方法之后，并且数据缓冲区中的数据已经写入之后会触发可写流的 finish 事件 const fs = require('fs');const ws = fs.createWriteStream('b.txt');ws.write('Hello');ws.write('World');ws.end('!');ws.on('close', () =&gt; &#123; console.log(\"close\");&#125;);ws.on('finish', () =&gt; &#123; console.log(\"finish\");&#125;); 打印结果是 finishclose 说明 finish 事件会在 close 事件之前被触发。 可写流的经典例子就是 http 模块的响应对象 res，下面的程序演示了当请求到来时，我们读取一个 html 页面返回给客户端 const http = require('http');const fs = require('fs');const app = http.createServer();app.on('request', (req, res) =&gt; &#123; const rs = fs.createReadStream('index.html'); rs.on('data', data =&gt; &#123; res.write(data); &#125;) rs.on('end', () =&gt; &#123; res.end() &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log(\"服务启动在 3000 端口 ... ...\");&#125;) Duplex Stream 与 Transform StreamDuplex，即双工的意思，它既可以接收数据，也可以输出数据，它的输入和输出之间可以没有任何的关系，就像是一个部件内部有两个独立的系统。Duplex 继承了 可读流(Readable)，并且拥有可写流(Writable)的所有方法。 Transform Stream 继承了 Duplex Stream，它同样具有可读流与可写流的能力，并且它的输出与输入之间是有关系的，中间做了一次转换。常见的转换流有 zlib，crypto。 出于文章结构的考虑，在这里不详细讲解这两个流，在后文中会实现这两个流，以加深对这两个流的理解。 pipe我们可以混合使用可读流与可写流来进行文件的复制 const fs = require('fs');function copy(source, target) &#123; const rs = fs.createReadStream(source); const ws = fs.createWriteStream(target); rs.on('data', data =&gt; &#123; ws.write(data); &#125;); rs.on('end', () =&gt; &#123; ws.end(); &#125;);&#125;copy('a.txt', 'b.txt'); 但是上面的写法却不被建议使用，因为没有考虑到可读流与可写流速度之间的差异，如果可读流输出数据的速度大于可写流写入数据的速度，这个时候就会有数据一直堆压在缓存区，导致占用过高的内存，专业术语叫做积压。 我们需要改善上面的程序，具体做大就是当 write() 方法返回 false，我们切换可读流的模式为暂停模式，当可写流触发了 drain 事件时，我们便将可读流的状态切换为流动模式 const fs = require('fs');function copy(source, target) &#123; const rs = fs.createReadStream(source); const ws = fs.createWriteStream(target); rs.on('data', data =&gt; &#123; if (!ws.write(data)) &#123; rs.pause(); &#125; &#125;); rs.on('end', () =&gt; &#123; ws.end(); &#125;); ws.on('drain', () =&gt; &#123; rs.resume(); &#125;)&#125; 那是不是每次我们使用流都需要写这么多的代码，当然不是。官方为可读流提供了一个 pipe(ws) 方法，pipe 方法接收一个可写流，它的作用就是将可读流中数据写入到可写流中去，并且它内部有做速度差异的处理。所以上面的写法可以改为下面的版本 const fs = require('fs');function copy(source, target) &#123; const rs = fs.createReadStream(source); const ws = fs.createWriteStream(target); rs.pipe(ws);&#125; 当我们调用 pipe 方法时，会触发可写流的 pipe 事件。pipe 的实现参考如下 Readable.prototype.pipe = function(ws) &#123; this.on('data', data =&gt; &#123; if (!ws.write(data)) &#123; this.pause(); &#125; &#125;); ws.on('drain', () =&gt; &#123; this.resume(); &#125;); // 触发 pipe 事件 ws.emit('pipe', this); // 返回可写流，以支持链式调用 return ws;&#125; 这里给出官网画的一个有关 pipe 的流程图 +===================+ x--&gt; Piping functions +--&gt; src.pipe(dest) | x are set up during |===================| x the .pipe method. | Event callbacks | +===============+ x |-------------------| | Your Data | x They exist outside | .on('close', cb) | +=======+=======+ x the data flow, but | .on('data', cb) | | x importantly attach | .on('drain', cb) | | x events, and their | .on('unpipe', cb) |+---------v---------+ x respective callbacks. | .on('error', cb) || Readable Stream +----+ | .on('finish', cb) |+-^-------^-------^-+ | | .on('end', cb) | ^ | ^ | +-------------------+ | | | | | ^ | | ^ ^ ^ | +-------------------+ +=================+ ^ | ^ +----&gt; Writable Stream +---------&gt; .write(chunk) | | | | +-------------------+ +=======+=========+ | | | | | ^ | +------------------v---------+ ^ | +-&gt; if (!chunk) | Is this chunk too big? | ^ | | emit .end(); | Is the queue busy? | | | +-&gt; else +-------+----------------+---+ | ^ | emit .write(); | | | ^ ^ +--v---+ +---v---+ | | ^-----------------------------------&lt; No | | Yes | ^ | +------+ +---v---+ ^ | | | ^ emit .pause(); +=================+ | | ^---------------^-----------------------+ return false; &lt;-----+---+ | +=================+ | | | ^ when queue is empty +============+ | ^------------^-----------------------&lt; Buffering | | | |============| | +&gt; emit .drain(); | ^Buffer^ | | +&gt; emit .resume(); +------------+ | | ^Buffer^ | | +------------+ add chunk to queue | | &lt;---^---------------------&lt; +============+ 实现流在本节中我们实现具体来流，通过实现流可以进一步加深对 Stream 内部工作细节的理解。 实现可读流上面我们都是通过 fs.createReadableStream() 方法来得到一个可读流的，在这里我们自己实现一个可读流。实现可读流只需要继承 Readable 类，然后实现 _read() 方法即可 const &#123;Readable&#125; = require('stream');class IeteratorReadableStream extends Readable &#123; constructor(iterator) &#123; super(); this.iterator = iterator; &#125; _read() &#123; let data = this.iterator.next(); // console.log(data); if(data.done) &#123; this.push(null); &#125; else &#123; // 必须 push 字符串或者 Buffer this.push(data.value+''); &#125; &#125;&#125;module.exports = IeteratorReadableStream; 上述我们实现了一个可读流，可读流接收一个迭代器作为参数，这个迭代器作为这个可读流的数据源。可读流会自动的调用 _read 获取数据，在 _read 方法中我们从迭代器中获取数据，并且调用了 push 方法，该方法的作用就是将数据放入到缓存区中，只能向其中 push 字符串或者 Buffer，当我们向其中 push null 时就表示数据已经被全部读取完毕。 所以可读流的执行逻辑为，每次调用 _read 方法从数据源读取数据，并将数据存入缓存区，然后触发 data 事件，将缓存区中的数据作为参数传递给 data 事件绑定的回调函数，循环上述过程直到向缓存区 push null 时，就表示数据源中的数据已经被读取完毕，此时会触发 end 事件。 我们创建一个迭代器作为数据源传入 const IeteratorReadableStream = require('./IteratorReadableStream');function *getData() &#123; for(let i = 0; i &lt; 5; i++) &#123; yield i; &#125;&#125;let rs = new IeteratorReadableStream(getData());rs.on('data', data =&gt; &#123; console.log(data.toString());&#125;);rs.on('end', () =&gt; &#123; console.log(\"迭代结束\");&#125;); 输出为 01234迭代结束 实现可写流实现可写流的过程同实现可读流的过程类似，首先需要继承 Writable 类，接着实现 _write 方法即可 const fs = require('fs');const &#123;Writable&#125; = require('stream');class FileWritableStream extends Writable &#123; constructor(filepath) &#123; super(); this.filepath = filepath; &#125; _write(chunk, encoding, callback) &#123; fs.appendFile(this.filepath, chunk, &#123; encoding &#125;, callback) &#125;&#125; 上面我们实现了一个可写流，这个可写流接收一个文件路径作为参数，它的作用就是向这个文件中追加数据，每次当我们调用可写流的 write() 方法时，它会向缓冲区写入数据，当达到阈值时，便会调用 _write() 方法将数据新增到文件中。 process.stdin.pipe(new FileWritableStream('c.txt')); 上面这行代码的作用就是将从标准输入的字符输出到 c.txt 中。 实现双工流Duplex Stream 既可以作为可读流，也可以作为可写流，并且它的输入与输出之间可以没有关系。Duplex Stream 继承了 Readable，并且拥有 Writable 的所有，我们只要分别实现 _read() 和 _write() 方法即可 const &#123; Duplex &#125; = require('stream');class CustomDuplexStream extends Duplex &#123; constructor() &#123; super(); this.currentCharCode = 65; &#125; _read() &#123; if(this.currentCharCode &lt;= 90) &#123; this.push(String.fromCharCode(this.currentCharCode++)) &#125; else &#123; this.push(null); &#125; &#125; _write(chunk, encoding, callback) &#123; console.log(chunk.toString()); callback(); &#125;&#125; 上面双工流的可读流部分就是将大写的 26 个字母添加进了缓存区，而可写流部分就是直接将数据输出到控制台。可见双工流可读流与可写流之间并没有任何的关系 const dp = new CustomDuplexStream();dp.write(\"1\");dp.write(\"2\");dp.end();dp.pipe(process.stdout); 输出为 12ABCDEFGHIJKLMNOPQRSTUVWXYZ 实现转换流Tranform Stream 是 Duplex 的特例，它也是一个双工流，不过它的输入和输出之间有关联，它的内部通过 _transform() 方法将可写流接收到的数据经过转换后传入到可读流中，所以我们要实现转换流，只需要实现 _transform() 方法即可 const &#123; Transform &#125; = require('stream');class UpperTransformStream extends Transform &#123; _transform(chunk, encoding, callback) &#123; this.push(chunk.toString().toUpperCase()); callback(); &#125;&#125; 上面我们实现了一个转换流，它可以将输入的小写字符转化为大写字符然后输出 const ts = new UpperTransformStream();const rs = fs.createReadStream('a.txt');rs.pipe(ts).pipe(process.stdout); 上面程序会读取 a.txt 中的所有字符，将字符转换为大写然后输出在控制台。 转换流在实际应用中还是比较多的，这里介绍一个 Node.js 内置的转换流 zlib，它的作用对文件进行解压缩，将文件压缩为压缩文件，或者将压缩文件解压为正常文件，这不就是一个典型的转换流嘛！ const zlib = require('zlib');const fs = require('fs');const args = process.argv.slice(2);const source = fs.createReadStream(args[0]);const target = fs.createWriteStream(args[1]);const gzip = zlib.createGzip();source.pipe(gzip).pipe(target); 我们可以通过 node gzip.js Graph.md Graph.md.gz 来运行上面的程序，它可以将 Graph.md 使用 gzip 压缩为 Graph.md.gz。 文件大小从 201KB 压缩到了 51KB。 同样的我们也可以通过 zlib.createGunzip() 来创建一个解压缩的转换流，具体细节同压缩文件相同，不做介绍。 本篇文章到此结束，想必到这里已经对 Stream 的使用已经有所了解了，但是本篇文章并没有列举所有有关 Stream 的 API，如果想更加详细的了解 Stream 的 API，那么接下去就可以阅读官方文档了。 参考文献 Node’s Stream 数据流中的积压问题 深入理解 Node.js Stream 内部机制 Node.js Stream - 基础篇","tags":[{"name":"Stream","slug":"Stream","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Stream/"},{"name":"zlib","slug":"zlib","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/zlib/"}]},{"title":"ES6：JavaScript中的类","date":"2021-03-02T16:00:00.000Z","path":"/ES6：JavaScript中的类/","text":"JavaScript 不同于 Java、C++ 等典型的面向对象语言，JavaScript 在过去并没有类的概念，所以一些从 Java 或 C++ 等其他面向语言转过来的开发者会感到困惑，所以在 ES6 中引入了类的概念。 基本使用定义类使用关键字 class 声明一个类 class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(`Hello $&#123;this.name&#125;`) &#125;&#125;let amy = new Person(\"Amy\");amy.sayHello(); // Hello Amy 需要注意的是 class 只是一种语法糖，即一个 class 其实本质上就是一个函数 class Person &#123; // ...&#125;console.log(typeof Person); // function 类与构造函数有如下不同： 类的声明不会提升到作用域的顶部 在类内部的代码自动运行在严格模式 (strict mode) 之下 类中的方法都是不可枚举的 类中的方法都没有内置的 [[Construct]] 方法，所以当你 new 一个类内部的方法时，会抛出错误 不使用 new 调用类会发生错误 在类中的方法中不能修改类名 class Person &#123; contructor() &#123; // 不能在方法中修改类名 Person = \"foo\"; &#125;&#125; 所以上面类的声明与下面的代码等价 // 1. 类的声明不会提升到作用域的顶部let Person = (function (o, properties) &#123; // 2. 在类内部的代码自动运行在严格模式 (strict mode) 之下 \"use strict\"; // 6. 在类中的方法中不能修改类名 (使用 const 定义) const Person = function (name) &#123; // 5. 不使用 new 调用类会发生错误 if (typeof new.target === 'undefined') &#123; throw new Error(\"Must be called by new\"); &#125; this.name = name; &#125;; Object.defineProperty(Person.prototype, \"sayHello\", &#123; value: function () &#123; // 4. 类中的方法都没有内置的 [[Construct]] 方法，所以当你 new 一个类内部的方法时，会抛出错误 if (typeof new.target !== 'undefined') &#123; throw new Error(\"Method in class can't be called by new!\"); &#125; console.log(`Hello $&#123;this.name&#125;`); &#125;, // 3. 类中的方法都是不可枚举的 enumerable: false, writable: false, configurable: false &#125;); return Person;&#125;)(); 类表达式类表达式的概念与函数表达式相对应 let Person = class &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(`Hello $&#123;this.name&#125;`) &#125;&#125;; 或者 let Person = class Person2&#123; // ...&#125;;console.log(typeof Person); // functionconsole.log(typeof Person2); // undefined 类与函数一样，都是一等公民，即可以作为参数传入函数，也可以作为返回值返回。 访问器属性我们可以在类中定义访问器属性 class Person &#123; constructor(name) &#123; this._name = name; &#125; set name(value) &#123; if (typeof value === 'string') &#123; this._name = value; &#125; &#125; get name() &#123; return this._name; &#125;&#125;let amy = new Person(\"Amy\");console.log(amy.name); // Amyamy.name = 10;console.log(amy.name); // Amyamy.name = \"Big\";console.log(amy.name); // Big 计算属性名与对象一样，我们可以为类中的方法名设置计算属性名 let methodName = \"sayHello\";class Person &#123; constructor(name) &#123; this.name = name; &#125; // 计算属性名 [methodName]() &#123; console.log(`Hello $&#123;this.name&#125;`); &#125;&#125;let amy = new Person(\"Amy\");amy.sayHello(); // Hello Amy 生成器方法类中的方法还可以是一个生成器 class Person &#123; *generateNames() &#123; yield \"Amy\"; yield \"Bob\"; yield \"Candy\"; &#125;&#125;let person = new Person();let iterator = person.generateNames();for (let name of iterator) &#123; console.log(name); // Amy // Bob // Candy&#125; 还可以为类编写一个默认的迭代器，即 [Symbol.iterator] class Stack &#123; constructor(...items) &#123; this.items= [...items]; &#125; push(value) &#123; this.items.push(value); &#125; pop() &#123; return this.items.pop(); &#125; *[Symbol.iterator]() &#123; yield *this.items.values(); &#125;&#125; 上面我们编写一个栈的数据结构，并提供一个迭代器来遍历该栈。 静态方法静态方法是类的方法，不是实例的方法，如 function Person(name) &#123; this.name = name;&#125;Person.print = console.log; 上面我们在 Person 上定义了一个 print 方法，因为 Person 的实例继承的是 Person.prototype，所以 Person 的实例访问不了 print 方法，这种只可以通过类名访问的方法我们称为静态方法，在 class 定义的类中，通过在方法名前加 static 关键字表示该方法是静态方法 class Person &#123; constructor(name) &#123; this.name = name; &#125; static print(value) &#123; console.log(value); &#125;&#125;const person = new Person(\"小明\");// TypeError: person.print is not a functionperson.print(); // 错误，实例无法访问静态方法 继承在 ES5 中实现类的继承，需要费一番额外的功夫 function Person(name) &#123; this.name = name;&#125;Person.prototype.sayHello = function () &#123; console.log(\"Hello World!\");&#125;function Student(name) &#123; Person.call(this, name);&#125;Student.prototype = Object.create(Person.prototype, &#123; constructor: Student, writable: true, enumerable: true, configurable: true&#125;);let stu = new Student(\"Alice\");stu.sayHello(); // Hello Worldconsole.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // true 在 ES6 中，我们只需要通过关键字 extends 即可来继承一个类，如 class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(\"Hello World\"); &#125;&#125;class Student **extends** Person&#123; constructor(name) &#123; super(name); &#125;&#125;let stu = new Student(\"Alice\");stu.sayHello(); // Hello Worldconsole.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // true 继承自其它类的类称为子类，或者派生类。在子类的构造方法 constructor 中，必须首先通过调用 super 方法来调用父类的构造函数，它会在这里初始化 this，如果没有调用 super 方法的话，会抛出错误，并且 super 方法只能被调用一次，且必须在访问 this 变量之前。 唯一不用在子类中调用 super 方法的情况就是在构造函数中返回一个对象。 方法重写我们可以在子类中重写父类中的方法 class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(\"Hello World\"); &#125;&#125;class Student extends Person&#123; constructor(name) &#123; super(name); &#125; // 重写父类的方法 **sayHello() &#123; console.log(\"Hi\"); &#125;**&#125;let stu = new Student(\"Alice\");stu.sayHello(); // Hi 上面在 Student 中重写了 Person sayHello 方法，所以最后打印出的结果是 “Hi”，如果我们需要在子类中调用父类中被重写方法，我们可以通过 super 调用，super 指向的就是父类的方法 class Student extends Person&#123; // ... sayHello() &#123; **super.sayHello();** console.log(\"Hi\"); &#125;&#125;let stu = new Student(\"Alice\");stu.sayHello(); // Hello World // Hi 静态方法继承类中的静态方法也可以被继承 class Person &#123; static print(...value) &#123; console.log(...value); &#125;&#125;class Student extends Person&#123;&#125;Student.print(\"Hello\", \"World\"); 上面 Student 继承了 Person，所以可以通过 Student 调用它继承的 Person 的静态方法 print。 继承自表达式extends 后面不仅仅可以是类名，还可以是一个函数，只要函数有 [[Contructor]] 方法即可，也可以是一个表达式，只要表达式的结果是具有 [[Contructor]] 方法的函数即可 function Person(name) &#123; this.name = name;&#125;Person.print = console.log;// 继承自一个函数class Student extends Person&#123;&#125;Student.print(\"Hello\", \"World\"); // Hello World 继承内置类我们可以继承内置 (build-in) 类 class MyArray extends Array&#123;&#125;let arr = new MyArray();arr[0] = \"red\";console.log(arr); // MyArray(1) [ 'red' ]console.log(arr.length); // 1arr.length = 0;console.log(arr); // MyArray(0) [] 上面我们自定类继承了 Array 即数组，因此它的工作方式通数组类似。 Symbol.species 属性首先介绍一下数组的 slice 方法，slice 方法是对数组内的元素进行拷贝，然后返回一个新的数组，该方法接收两个参数，begin 和 end，表示拷贝的起始位置和终止位置，这两个参数都是可选的，如果默认没有传入参数的话，begin 的默认值是 0，end 默认表示拷贝到数组的最后一个元素 let arr = [\"red\", \"green\", \"blue\"];let newArr = arr.slice(0, 2);console.log(newArr); // [ 'red', 'green' ]console.log(newArr instanceof Array); // true 我们知道 slice 返回的是一个数组，它是 Array 类型的实例，现在如果我们自定义类 MyArray 继承 Array 类，调用 slice 方法 class MyArray extends Array &#123;&#125;let arr = new MyArray();arr.push(...[\"red\", \"green\", \"blue\"]);let newArr = arr.slice();console.log(newArr instanceof MyArray); // trueconsole.log(newArr instanceof Array); // true 我们发现返回的是 MyArray 的实例，而不是 Array 实例，这是因为 Symbol.species 属性，它控制着 slice 方法返回的数组是谁的实例 class MyArray extends Array &#123; **static get [Symbol.species]() &#123; return Array; &#125;**&#125;let arr = new MyArray();arr.push(...[\"red\", \"green\", \"blue\"]);let newArr = arr.slice();console.log(newArr instanceof MyArray); // **false**console.log(newArr instanceof Array); // true 上面我们在 MyArray 中添加了一个静态方法 [Symbol.species]，它返回的值时 Array，表示调用 slice 方法后返回的实例是 Array 的实例。 new.target我们可以在类的 contructor 方法中访问 new.target，通过 new.target 我们可以构造一个抽象类，所谓的抽象类，指的就是不能被 new 出实例的类，它只能被继承 class Shape &#123; constructor(name) &#123; if (new.target === Shape) &#123; throw new Error(\"Can't be called by new!\"); &#125; &#125;&#125;class Rectangle extends Shape&#123; constructor(name, width, height) &#123; super(name); this.width = width; this.height = height; &#125;&#125;let rec = new Shape(\"长方形\"); Shape 类是一个抽象类，它不能通过 new 来实例化，上面当我们 new Shape 时，会抛出一个错误 我们可以实例化它的子类 let rec = new Rectangle(\"长方形\", 10, 5);","tags":[{"name":"class","slug":"class","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/class/"}]},{"title":"Node.js之Buffer","date":"2021-03-01T16:00:00.000Z","path":"/Node.js之Buffer/","text":"Buffer 是 Node.js 的内置类型，它是用来表示内存中一块区域的，它保存的是二进制数据，可以将它看做为一个二进制数组。 Buffer 可以用来表示图片、视频这样的二进制数据，另外我们从文件中读取到的也是 Buffer 类型的数据，从网络中接收的数据也是 Buffer 类型的数据，所以学习 Buffer 还是很有必要的。 Buffer 位于全局作用域中，所以不需要通过 require(&#39;buffer&#39;) 来引入 Buffer。 创建 Buffer 对象alloc我们可以通过 Buffer.alloc(size, [fill], [encoding]) 来分配一个 size 字节大小的内存，还可以接收两个可选参数 fill：使用 fill 来填充 Buffer 中的每一个字节 encoding：如果 fill 为字符串，那么使用 encoding 来对字符串进行编码为二进制 当不指定 fill 参数，默认为填充 0。 const buf1 = Buffer.alloc(5);console.log(buf1); // &lt;Buffer 00 00 00 00 00&gt;const buf2 = Buffer.alloc(10, 1);console.log(buf2); // &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;const buf3 = Buffer.alloc(12, \"hello world!\", \"utf-8\");console.log(buf3); // &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64 21&gt; 我们还可以使用 allocUnsafe(size) 来分配指定大小的内存，不过不会默认填充 0，其中的内容不确定 const buf = Buffer.allocUnsafe(5);console.log(buf); // &lt;Buffer c0 84 7c 2a 7b&gt; 我们可以通过 fill(fill, encoding) 方法为 Buffer 对象填充指定值 const buf = Buffer.allocUnsafe(5);buf.fill(0);console.log(buf); // &lt;Buffer 00 00 00 00 00&gt; from我们也可以通过 Buffer.from() 方法来创建一个 Buffer 对象，from 方法可以接收的参数包括数组，字符串，Buffer 对象，对象等类型。 接收一个整形数组，数组中的整数应该在 0~255 之间，超出此范围的数字将会被截断 const buf = Buffer.from([1, 2, 3, 4, 5]);console.log(buf); // &lt;Buffer 01 02 03 04 05&gt; 我们还可以像其中传入一个字符串，并指定编码，它会使用指定编码将字符串编码为二进制，如果不指定编码的话，默认为编码为 utf-8 const buf = Buffer.from(\"hello\", \"utf-8\");console.log(buf); // &lt;Buffer 68 65 6c 6c 6f&gt; from 方法还可以接收一个 Buffer 对象，它会拷贝传入的 Buffer 对象中的数据到新的 Buffer 对象中 const buf1 = Buffer.from(\"hello\", \"utf-8\");const buf2 = Buffer.from(buf1);console.log(buf1 === buf2); // falseconsole.log(buf2.toString()); // hello from 方法还可以接收一个对象，当传入对象，首先会将对象转化为原始值，然后根据原始值转化为对应的二进制数组 let obj = &#123; [Symbol.toPrimitive](hint) &#123; return \"a\"; &#125;,&#125;;const buf = Buffer.from(obj);console.log(buf.toString()); // a Buffer 对象的属性length通过 length 属性可以知道 Buffer 数组的长度 const buf = Buffer.from(\"Hello World!\");console.log(buf.length); // 12 bufferBuffer 对象内部实际存储数据的是一个 ArrayBuffer 的对象，通过 buffer 属性可以得到这个对象 const buf = Buffer.alloc(5);console.log(buf.buffer); // ArrayBuffer &#123; [Uint8Contents]: &lt;00 00 00 00 00&gt;, byteLength: 5 &#125; 读 Buffer 对象本节介绍如何访问 Buffer 对象中的内容。 下标在文章的开头提过，我们可以将 Buffer 对象看做是一个二进制数组，既然是数组，那么就可以通过下标的形式来访问数组中的内容。 const buf = Buffer.from([1, 2, 3, 4, 5]);console.log(buf[0]); // 1console.log(buf[5]); // undefined 它们会以补码的形式解析字节，返回对应的数字。 readXxx我们还可以通过 buf.readInt8() buf.readInt16() buf.readUint8() buf.readUint16() 等方法来访问 Buffer 对象中的内容。 const buf = Buffer.from([1, 2, 3, 4, 5]);console.log(buf.readInt8(2)); // 3// 访问超出范围的内容，会抛出 RangeErrorconsole.log(buf.readInt8(5)); // RangeError [ERR_OUT_OF_RANGE]: The value of \"offset\" is out of range. 迭代器Buffer 对象的迭代器同数组的迭代器相同，也有三个迭代器，分别是 entries keys values 我们通过遍历迭代器来访问 Buffer 对象中的内容。 const buf = Buffer.from([3, 4, 2]);for (let entry of buf.entries()) &#123; // 数组的一个元素为下标，第二个元素为下标对应的元素 console.log(entry); // [ 0, 3 ] // [ 1, 4 ] // [ 2, 2 ]&#125; for (let key of buf.keys()) &#123; console.log(key); // 0 // 1 // 2&#125; for (let value of buf.values()) &#123; console.log(value); // 3 // 4 // 2&#125; 写 Buffer 对象本小节讲解如何向 Buffer 对象中写入内容。 下标我们可以直接通过下标来改变 Buffer 对象中的内容 const buf = Buffer.from([1, 2, 3]);// 通过下标设置值buf[0] = 4;console.log(buf); // &lt;Buffer 04 02 03&gt; write我们可以通过 write(string, [offset], [length], [encoding]) 方法向 Buffer 中写入字符串： string：表示要写入的字符串 offset：偏移量，即跳过 offset 个字节开始写入，默认为 0 length：要写入的最大字节数，不超过 buf.length - offset，默认值为 buf.length - offset encoding：指定编码，默认为 utf-8 该方法返回已写入的字节数。 const buf = Buffer.from([1, 2, 3, 4]);// 跳过 1 个字节开始写入，1hi4buf.write(\"hi\", 1);console.log(buf); // &lt;Buffer 01 68 69 04&gt; writeXxx同 readXxx，我们可以通过 writeInt8() 方法向 buf 中写入数据，方法接收两个参数： value：要写入的值 offset：偏移量，默认为 0 const buf = Buffer.alloc(5);buf.writeInt8(1, 0);buf.writeInt8(3, 1);console.log(buf); // &lt;Buffer 01 03 00 00 00&gt; 踩坑：没有 writeInt16()，不过有 writeInt16BE() 与 writeInt16LE()，分别代表以大端序、小端序写入 其他方法isBuffer该方法接收一个对象，用来判断该对象是不是一个 Buffer 对象 let obj1 = &#123;&#125;;let obj2 = Buffer.alloc(3);console.log(Buffer.isBuffer(obj1)); // falseconsole.log(Buffer.isBuffer(obj2)); // true isEncoding该方法接收一个代表编码的字符串，返回 Buffer 是否支持该种编码，如果支持则返回 true，否则返回 false console.log(Buffer.isEncoding(\"utf-8\")); // trueconsole.log(Buffer.isEncoding(\"utf8\")); // trueconsole.log(Buffer.isEncoding(\"hex\")); // trueconsole.log(Buffer.isEncoding(\"latin\")); // falseconsole.log(Buffer.isEncoding(\"gbk\")); // false sliceslice(start, end) 可以裁切原有的 Buffer 对象，返回一个新的 Buffer 对象，其中 start 和 end 代表裁切的起始位置和结束位置，左闭右开 [start, end)，这两个参数是可选的，start 默认为 0，end 默认为 buf.length。返回的 Buffer 对象与原先对象引用的是同一块内存，即它们的 buffer 属性是一样的。 const buffer = Buffer.from(\"hello world!\");const newBuffer = buffer.slice(6); // 裁切 6 以后的内容到新数组console.log(newBuffer.toString()); // world!console.log(buffer.buffer === newBuffer.buffer); // true subarraysubarray(start, end) 几乎可以看做等同于 slice 方法了，二者的语义不同，不过行为确实一致的，subarray 的语义表示返回原数组的某个范围的子数组，而 slice 的语义表示的裁切。同样 subarray 返回新的 Buffer 对象，并且返回的 Buffer 对象的 buffer 与原 Buffer 对象的 buffer 属性是相同的。 const buffer = Buffer.from(\"hello world!\");const newBuffer = buffer.subarray(6);console.log(newBuffer.toString()); // world!console.log(buffer.buffer === newBuffer.buffer); // true copycopy(target, [targetStart], [sourceStart], [sourceEnd]) 方法是将 source 从 sourceStart 到 sourceEnd 的内容复制到 target 从 targetStart 的位置，见下动图 除了 target 以外，其他三个参数都是可选参数，targetStart 与 sourceStart 的默认值为 0，sourceEnd 的默认值为 buf.length. const buf1 = Buffer.from(\"HelloWorld\");const buf2 = Buffer.alloc(8);buf1.copy(buf2, 0, 1, 9);console.log(buf2.toString()); // elloWorl includesbuf.includes(value, [offset], [encoding]) 方法的作用是判断 value 是否在 buf 中。 value 可以是一个字符串，也可以是一个 Buffer 对象，也可以是一个整数；offset 用来规定查找范围，表示从 offset 处开始查找，默认为 0；enconding 表示编码，默认为 utf-8。 const buf = Buffer.from(\"HelloWorld\");// 默认从 0 开始搜索console.log(buf.includes(\"H\")); // true// 从 1 开始搜索，后面不包含 Hconsole.log(buf.includes(\"H\", 1)); // falseconsole.log(buf.includes(Buffer.from(\"Hello\"))); // true// H 对应的 utf-8 编码为 72console.log(buf.includes(72)); // true indexOfbuf.indexOf(value, [offset], [encoding]) 是用来查找 value 在 buf 中的下标的，参数的含义同 includes 方法相同，如果在 buf 找不到 value，那么会返回 -1，所以 includes(value) 方法其实就相当于 indexOf(value) !== -1 const buf = Buffer.from(\"HelloWorld\");console.log(buf.indexOf(\"H\")); // 0console.log(buf.indexOf(\"H\", 1)); // -1console.log(buf.indexOf(Buffer.from(\"World\"))); // 5console.log(buf.indexOf(72)); // 0 equalsbuf.equals(otherBuffer) 是比较两个 Buffer 对象的字节是否完全相同，如果相同，则返回 true，否则返回 false const buf1 = Buffer.alloc(5);const buf2 = Buffer.alloc(5);const buf3 = Buffer.allocUnsafe(5);console.log(buf1.equals(buf2)); // trueconsole.log(buf1.equals(buf3)); // false 参考文献 Buffer|Node.js 文档","tags":[{"name":"Buffer","slug":"Buffer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Buffer/"}]},{"title":"ES6：迭代器与生成器","date":"2021-03-01T16:00:00.000Z","path":"/ES6：迭代器和生成器/","text":"迭代器我们经常使用 for 循环来遍历数组 let arr = [\"red\", \"green\", \"blue\"]for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; 上述代码是使用变量 i 作为下标来访问数组，但是对于一些无序的集合，例如 Map 我们便不能通过下标的形式进行访问，所以有必要提供统一的方式来访问集合，这就是迭代器。 所谓的迭代器那当然是用来迭代用的，迭代的对象可以是数组，集合以及对象。迭代器含有一个方法 next()，该方法的作用就是从数组 (集合、对象) 取出一个值，它返回一个对象，对象中有两个属性： done：为布尔值，false 表示集合中还有元素可遍历，true 表示集合中没有元素可遍历 value： 如果 done 为 false，value 的值为集合中的一个元素值，如果 done 为 true，value 的值为 undefined function getIterator() &#123; let i = 0; return &#123; next() &#123; return &#123; done: i &gt; 3, value: i &gt; 3 ? undefined : i++ &#125; &#125; &#125;&#125;let iterator = getIterator();console.log(iterator.next()); // &#123; done: false, value: 0 &#125;console.log(iterator.next()); // &#123; done: false, value: 1 &#125;console.log(iterator.next()); // &#123; done: false, value: 2 &#125;console.log(iterator.next()); // &#123; done: false, value: 3 &#125;console.log(iterator.next()); // &#123; done: true, value: undefined &#125; getIterator 返回一个具有 next 方法的对象，next 方法返回一个具有 done 和 value 属性的对象，每次调用 next 方法，都会对 i 进行 ++ ，当 i &gt; 3 时，done 的值就为 true，且返回的 value 值为 undefined。 生成器生成器的作用是来生成一个迭代器的，上面我们自定义的迭代器需要自己维护 done 和 value 属性，使用起来还是比较麻烦的。生成器的语法就是在 function 关键字后加一个 * 号，通过 yield 返回被迭代的元素 function *getIterator() &#123; let i = 0 while (i &lt;=3) &#123; yield i++ &#125;&#125;let iterator = getIterator()console.log(iterator.next()); // &#123; done: false, value: 0 &#125;console.log(iterator.next()); // &#123; done: false, value: 1 &#125;console.log(iterator.next()); // &#123; done: false, value: 2 &#125;console.log(iterator.next()); // &#123; done: false, value: 3 &#125;console.log(iterator.next()); // &#123; done: true, value: undefined &#125; 当我们调用 getIterator 方法时，并不会执行该方法，而是会返回一个迭代器。每当该迭代器调用 next 方法时，就会开始执行函数，直至遇到 yield 语句，它会把 yield 后的表达式作为 value 属性的值返回，例如遇到yield 1 时，返回对象 {done: false, value: 1} 。 当返回对象后，不会继续执行函数，而是会挂起该函数，直到迭代器再次调用 next 方法时，就会从上次挂起的地方开始执行，直到遇到 yield 语句或者执行完函数。 当执行完函数时会返回 {done: true, value: undefined} ，如果是通过 return 语句结束函数的，例如 return 10 ，那么这时会返回 {done: true, value: 10} 。 因为生成器只是一个函数，所以可以有函数表达式的形式，它的函数表达式形式如下 let getIterator = function *() &#123; // do something&#125; 同样生成器也可以是对象的方法 let o = &#123; *getIterator() &#123; &#125;&#125;let iterator = o.getIterator() 当生成器作为对象的方法时，* 要放在方法名前，如 *getIterator 。 可迭代与 for…of 循环可迭代的概念是针对对象提出，如果对象含有 Symbol.iterator 属性，那么就说它是可迭代的。Symbol.iterator 是一个函数，它返回一个迭代器，因此我们可以通过下面的方式去迭代一个对象 let obj = &#123; [Symbol.iterator]() &#123; let i = 1; return &#123; next() &#123; return &#123; done: i &gt; 3, value: i &gt; 3 ? undefined : i++ &#125; &#125; &#125; &#125;&#125;let iterator = obj[Symbol.iterator]()let result = iterator.next();while(!result.done) &#123; console.log(result.value); // 1 // 2 // 3 result = iterator.next();&#125; 上面遍历对象还是比较麻烦，对于任意一个对象都需要写一些模板代码，如 let iterator = obj[Symbol.iterator]()let result = iterator.next();while(!result.done) &#123; // 拿到 result.value，然后做一些事情 result = iterator.next();&#125; 所以为了简化代码的编写，ES6 提出一个新的 for … of 语法糖来帮我们遍历可迭代的对象，上面遍历对象的代码可以写为如下 for(value of obj) &#123; console.log(value); // 1 // 2 // 3&#125; 代码简洁了很多，但是我们要明白 for … of 不是黑魔法，for … of 所做的事情同上面写的模板代码做的事情是一样的。 所有由生成器生成的迭代器都是可迭代的，因为生成器会默认为迭代器的 Symbol.iterator 属性赋值。 let getIterator = function *() &#123; yield 1 yield 2&#125;let iterator = getIterator()for (let value of iterator) &#123; console.log(value); // 1 // 2&#125; 我们可以通过判断对象的 Symbol.iteraor 是否为 function 来判断该对象是否可迭代 function isIterable(obj) &#123; return typeof obj[Symbol.iterator] === 'function';&#125;let array = [1, 2, 3]let map = new Map()let set = new Set()let weakMap = new WeakMap()let weakSet = new WeakSet()console.log(isIterable(array)); // trueconsole.log(isIterable(map)); // trueconsole.log(isIterable(set)); // trueconsole.log(isIterable(weakMap)); // falseconsole.log(isIterable(weakSet)); // false 内置的迭代器集合迭代器通过上面的代码我们知道数组、Map 以及 Set 这三个几个都是可迭代的，下面我们就将学习它们内置的迭代器。每一个集合都有如下三个方法： entries keys values 这三个方法都会返回一个迭代器，entries 迭代器中的元素为键值对组成数组，keys 中的元素为集合中的键，values 中的元素为集合的值。 其实对于数组和 Set 来说没有键的概念，但是为了接口的统一，我们在这里定义一下数组与 Set 的键：数组的键就是下标 (0, 1, …)，Set 的键与它的值相同。 定义如下集合 let arr = [\"red\", \"green\", \"blue\"]let set = new Set([\"Alice\", \"Bob\"]);let map = new Map();map.set(\"Chinese\", 88);map.set(\"Math\", 98);map.set(\"English\",59); entries for(let entry of arr.entries()) &#123; console.log(entry); // [ 0, 'red' ] // [ 1, 'green' ] // [ 2, 'blue' ]&#125;for(let entry of set.entries()) &#123; console.log(entry); // [ 'Alice', 'Alice' ] // [ 'Bob', 'Bob' ]&#125;for(let entry of map.entries()) &#123; console.log(entry); // [ 'Chinese', 88 ] // [ 'Math', 98 ] // [ 'English', 59 ]&#125; keys for(let key of arr.keys()) &#123; console.log(key); // 0 // 1 // 2&#125;for(let key of set.keys()) &#123; console.log(key); // Alice // Bob&#125;for(let key of map.keys()) &#123; console.log(key); // Chinese // Math // English&#125; values for(let value of arr.values()) &#123; console.log(value); // red // green // blue&#125;for(let value of set.values()) &#123; console.log(value); // Alice // Bob&#125;for(let value of map.values()) &#123; console.log(value); // 88 // 98 // 59 现在还有一个问题就是集合它们的 Symbol.iterator 是什么，对于数组和 Set 来说，它们的 Symbol.iterator 与 values 相同，对于 Map 来讲，它们的 Symbol.iterator 与 entries 相同 for(let item of arr)&#123; console.log(item); // red // green // blue&#125;for(let item of set)&#123; console.log(item); // Alice // Bob&#125;for(let item of map)&#123; console.log(item); // [ 'Chinese', 88 ] // [ 'Math', 98 ] // [ 'English', 59 ]&#125; 字符串迭代器字符串越来越像数组了，例如我们可以通过下标去访问字符串中的字符，所以我们可以通过下面的方式遍历字符串 const str = \"Hi 𠮷\"for(let i = 0; i &lt; str.length; i++) &#123; console.log(str[i]);&#125; 但是因为 JavaScript 不识别 4 个字节表示的字符，所以打印如下 Hi�� 所幸 ES6 对 Unicode 提供全套支持，所以 ES6 提供的字符串迭代器解决了这个问题 for(let c of str) &#123; console.log(c);&#125; Hi 𠮷 展开运算符看下面一个例子 function removeDuplicate(array) &#123; let set = new Set(array) return [...set]&#125; 上面这个函数是对去除数组中的重复元素，在其中我们使用了 […set] 展开运算符，将 Set 集合展开为一个数组返回，那么 JavaScript 内部是怎么做的，其实内部默认调用了 Set 集合迭代器，然后将 Set 集合中的元素添加到数组中的 let arr = [...set]// 等价于let arr = []for(let value of set) &#123; arr.push(value)&#125; 迭代器高级用法为迭代器传入参数我们在调用迭代器的 next 方法时，还可以向其中传入一个参数 function *getIterator() &#123; let first = yield 1; yield first + 2;&#125; let iterator = getIterator();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next(2)); // &#123; value: 4, done: false &#125; 上面的动图说明了代码的执行过程：当我们调用第一个 next 时，方法开始执行，当执行到 yield 1 后停止执行，挂起函数并将值返回，当我们第二次调用 next 时，这时我们传递一个参数，这个参数会被传递给 first，接着继续执行，当执行到 yield first + 2 挂起函数，并返回值。 抛出错误迭代器还有一个 throw 方法，它可以抛出一个错误，具体的应用场景我还不清楚 function *getIterator() &#123; let first = yield 1; try &#123; let second = yield first + 2 &#125; catch (e) &#123; second = 6; &#125; yield second&#125;const iterator = getIterator();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next(2)); // &#123; value: 4, done: false &#125;console.log(iterator.throw(new Error(\"error...\"))); // &#123; value: 6, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 委托生成器有的时候希望能够组合两个迭代器，我们可以通过 yield* 的语句来组合两个迭代器 function *generator01() &#123; yield 1; yield 2;&#125;function *generator02() &#123; yield 3; yield 4;&#125;function *generatorCombine() &#123; yield *generator01(); yield *generator02();&#125;for (value of generatorCombine()) &#123; console.log(value); // 1 // 2 // 3 // 4&#125; yield *gengerator01() 表示委托 generator01 这个生成器来做事情，当执行到这条语句时，接下来会进入 generator01 内部去执行，直到遇到 yield 语句，则会将函数挂起，然后将值返回，当下次调用 next 方法时则从上次挂起的地方重新开始执行。","tags":[{"name":"迭代器","slug":"迭代器","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%94%9F%E6%88%90%E5%99%A8/"}]},{"title":"Node.js之MongoDB","date":"2021-02-27T16:00:00.000Z","path":"/Node.js之MongoDB/","text":"本章讲解如何使用 Node.js 操作 MongoDB 数据库。分为两部分 MongoDB 的安装与使用 Node.js 第三方模块 mongoose 的使用 MongoDB 简介MongoDB 是一个 NoSQL 数据库，它的数据组织结构为 数据库 集合 文档 一个数据库 (database) 包含多个集合 (collections)，一个集合包含多个文档 (document)，在 MongoDB 中，文档是 JSON 格式的对象 &#123; \"_id\": ObjectId(\"6008027ec026735cc4aab553\"), \"username\": \"Alice\", \"todo\": \"学习\"&#125; 进入 MongoDB 官网 进行安装 然后一直下一步进行安装即可。安装好之后，运行 net start MongoDB 就可以启动 MongoDB 服务，然后在命令行输入 mongo 即可连接到 MongoDB 服务器，然后进入 MongoDB shell，我们可以在这里输入命令操作数据库 操作数据库查看数据库使用 show dbs 查看所有的数据库 &gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBnote 0.000GBtodo 0.000GB 创建数据库使用 use 数据库 来创建一个新的数据库， &gt; use ipartmentswitched to db ipartment&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBnote 0.000GBtodo 0.000GB 我们发现并没有发现新建的数据库，我们必须向数据库中插入内容，才会显示新创建的数据库 &gt; db.coll.insert(&#123;name: 'Alice'&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; show dbsadmin 0.000GBconfig 0.000GBipartment 0.000GBlocal 0.000GBnote 0.000GBtodo 0.000GB 我们向 ipartment 数据库的 coll 集合中添加了一条文档 {name: &#39;Alice&#39;}。 同样我们也可以使用 use 数据库 的方式来切换数据库，通过向命令行输入 db 可以知道目前在使用哪个数据库 &gt; use noteswitched to db note&gt; dbnote 删除数据库删除数据库，使用 db.dropDatabase() 删除数据库 # 删除之前，有 ipartment 数据库&gt; show dbsadmin 0.000GBconfig 0.000GBipartment 0.000GBlocal 0.000GBnote 0.000GBtodo 0.000GB&gt; use ipartmentswitched to db ipartment&gt; db.dropDatabase()&#123; \"dropped\" : \"ipartment\", \"ok\" : 1 &#125;# 删除之后，ipartment 数据库被删除&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBnote 0.000GBtodo 0.000GB 操作集合查看集合使用 show collections 或 show tables 查看某数据库下所有的集合 &gt; use adminswitched to db admin&gt; show collectionssystem.version&gt; show tablessystem.version 添加集合使用 db.createCollection(name, options) 来创建一个集合，接收两个参数 name：集合的名字 options：可选选项 capped：为一个布尔值，当值为 true 时表示创建一个固定大小的集合，此时必须要指定 size 选项指定集合的大小。当达到最大值时，它会自动覆盖最早的文档。 size：为固定集合指定最大值，单位为字节，指定该选项时，需要设置 capped 选项为 true max：指定集合能够包含的文档的最大数量 # 添加集合之前&gt; show collectionsnotemodels# 添加集合&gt; db.createCollection('test')&#123; \"ok\" : 1 &#125;# 添加集合之后&gt; show collectionsnotemodelstest 或者我们可以通过 db.集合名.insert() 直接向集合中插入一条文档的方式来新建一个集合 # 添加集合之前，只有两个集合&gt; show collectionsnotemodelstest# 向数据库的 coll 集合中添加一条文档&gt; db.coll.insert(&#123;name: 'Bob'&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)# 插入数据之后有三个集合&gt; show collectionscollnotemodelstest 删除集合通过 db.集合.drop() 方法来删除一个集合 # 删除之前有 3 个集合&gt; show collectionscollnotemodelstest# 删除 coll 集合&gt; db.coll.drop()true# 删除之后有两个集合&gt; show collectionsnotemodelstest 重命名集合使用 db.集合.renameCollection(name) 来为集合重命名 &gt; show collectionsnotemodelstest# 将 test 集合命名为 rename&gt; db.test.renameCollection('rename')&#123; \"ok\" : 1 &#125;&gt; show collectionsnotemodelsrename 操作文档添加文档使用 db.集合.insert() 向文档中添加文档 &gt; use testswitched to db test# 向 test 数据库的 data 集合中添加一条文档&gt; db.data.insert(&#123;name: 'Alice', age: 18&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;) 每次插入一个文档时，文档中会默认添加一个 _id 属性 (当然如果你手动指定了 _id 属性，就不会添加了)，这个 _id 属性就是这个文档的主键。 当我们使用 insert 方法插入文档时，如果主键冲突了(_id 属性的值相同)，那么此时插入会失败。 MongoDB 还提供 insertOne() 与 insertMany() 两个方法来插入数据，顾名思义，insertOne() 是用来插入一条数据的，而 insertMany() 是用来添加多条数据的。 # 插入一条数据&gt; db.data.insertOne(&#123;name: \"Bob\", age: 20&#125;)&#123; \"acknowledged\" : true, \"insertedId\" : ObjectId(\"603a33bc6999db0166256f73\")&#125;# 插入多条数据&gt; db.data.insertMany([&#123;name: 'Candy', age: 30&#125;,&#123;name: \"David\"&#125;])&#123; \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"603a33fc6999db0166256f74\"), ObjectId(\"603a33fc6999db0166256f75\") ]&#125; 查询文档使用 db.集合.find(query) 方法来查询集合中符合条件的文档，query 就是查询条件。当我们不传入 query 时或者 query 为 {} 时，表示的是查询集合中的所有文档 # 查询集合中的所有文档&gt; db.data.find()&#123; \"_id\" : ObjectId(\"603a30186999db0166256f72\"), \"name\" : \"Alice\", \"age\" : 18 &#125;&#123; \"_id\" : ObjectId(\"603a33bc6999db0166256f73\"), \"name\" : \"Bob\", \"age\" : 20 &#125;&#123; \"_id\" : ObjectId(\"603a33fc6999db0166256f74\"), \"name\" : \"Candy\", \"age\" : 30 &#125;&#123; \"_id\" : ObjectId(\"603a33fc6999db0166256f75\"), \"name\" : \"David\" &#125; # 查询文档中 name 属性值为 Alice 的所有文档&gt; db.data.find(&#123;name: 'Alice'&#125;)&#123; \"_id\" : ObjectId(\"603a30186999db0166256f72\"), \"name\" : \"Alice\", \"age\" : 18 &#125; 如果我们只是希望返回一个符合条件的文档，我们可以使用 findOne()。 更新文档使用 db.集合.update(conditions, doc) 根据条件 conditions 方法来更新文档，doc 为更新后的文档 # 更新前&gt; db.students.find()&#123; \"_id\" : ObjectId(\"603b4a6282fe3db58b69cc6d\"), \"name\" : \"Alice\", \"age\" : 20 &#125;# 将 age &gt; 18 的一条文档更新为 &#123;name: \"Alice\", age: 18&#125;&gt; db.students.update(&#123;age: &#123;$gt: 18&#125;&#125;, &#123;name: \"Alice\", age: 18&#125;)WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)# 更新后&gt; db.students.find()&#123; \"_id\" : ObjectId(\"603b4a6282fe3db58b69cc6d\"), \"name\" : \"Alice\", \"age\" : 18 &#125; 上面我们引入一个新的符号 $gt，它表示大于，而 {age: {$gt: 18}} 就表示 age &gt; 18。相关符号还有 $gte：大于等于 $lt：小于 $lte：小于等于 $neq：不等于 $eq：等于 另外如果我们只是想更新某个字段，我们可以使用 $set 符号 # 更新前&gt; db.students.find()&#123; \"_id\" : ObjectId(\"603b4a6282fe3db58b69cc6d\"), \"name\" : \"Alice\", \"age\" : 18 &#125;# 只更新 age 字段&gt; db.students.update(&#123;age: 18&#125;, &#123;$set: &#123;age: 19&#125;&#125;)WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)# 更新后&gt; db.students.find()&#123; \"_id\" : ObjectId(\"603b4a6282fe3db58b69cc6d\"), \"name\" : \"Alice\", \"age\" : 19 &#125; 删除文档使用 db.集合.remove(query) 来删除符合条件的所有文档，query 即为查询条件，当 query 为 {} 或者不传入 query 参数时，意思为删除所有文档 # 查询所有文档&gt; db.data.find()&#123; \"_id\" : ObjectId(\"603a30186999db0166256f72\"), \"name\" : \"Alice\", \"age\" : 18 &#125;&#123; \"_id\" : ObjectId(\"603a33bc6999db0166256f73\"), \"name\" : \"Bob\", \"age\" : 20 &#125;&#123; \"_id\" : ObjectId(\"603a33fc6999db0166256f74\"), \"name\" : \"Candy\", \"age\" : 30 &#125;&#123; \"_id\" : ObjectId(\"603a33fc6999db0166256f75\"), \"name\" : \"David\" &#125;# 删除 name 为 Alice 的文档&gt; db.data.remove(&#123;name: 'Alice'&#125;)WriteResult(&#123; \"nRemoved\" : 1 &#125;)# 查询所有文档，发现少了一条文档&gt; db.data.find()&#123; \"_id\" : ObjectId(\"603a33bc6999db0166256f73\"), \"name\" : \"Bob\", \"age\" : 20 &#125;&#123; \"_id\" : ObjectId(\"603a33fc6999db0166256f74\"), \"name\" : \"Candy\", \"age\" : 30 &#125;&#123; \"_id\" : ObjectId(\"603a33fc6999db0166256f75\"), \"name\" : \"David\" &#125; 另外 remove(query, options) 方法还接受一个可选参数 options，options 有一个选项 justOne，当 justOne 为 true 或者为 1 时，表示只删除一条文档。 mongoose下面我们介绍如何使用 Node.js 操作 MongonDB。官方提供 mongodb 模块比较难用，这里选择大家常用的模块 mongoose。 安装 mongoose npm install mongoose --save 来看一个简单的 demo，向数据库中添加了一条文档 const mongoose = require(\"mongoose\");// 连接上 test 数据库mongoose.connect(\"mongodb://localhost:27017/test\", &#123; useNewUrlParser: true, useUnifiedTopology: true,&#125;);// 获得数据库对象const db = mongoose.connection;db.on(\"error\", () =&gt; &#123; console.error(\"数据库连接失败!\");&#125;);db.once(\"open\", () =&gt; &#123; console.log(\"数据库连接成功!\");&#125;);// 定义模式，文档的字段的名称以及对应的类型const StudentSchema = new mongoose.Schema(&#123; name: String, age: Number,&#125;);// 根据模式创建模型对象const StudentModel = mongoose.model(\"students\", StudentSchema);// 根据模型创建文档const alice = new StudentModel(&#123; name: \"Alice\", age: 18,&#125;);// 向集合中添加一条文档alice.save(); 首先我们连接了 test 数据库，接着我们创建一个模式 (Schema)，它规定了集合中文档每个字段的名称以及值的类型，接下来我们根据这个模式创建一个模型 (Model)，并且创建了一个名为 students 的集合。 集合的名称与模型的名称(即 model() 方法的第一个参数)有关，集合名称是模型名称的小写版。并且如果模型名称的最后一个字符为字母，那么集合名称就会变为对应的复数形式；如果最后一个字符为数字，则不变 模型名称 集合名称 Student students Student1 student1 STUDENT students 下面我们根据创建的模型创建了一条文档，接着调用 save() 方法，将这条文档添加到集合中去。 为了下面演示的方便，我们创建一个 Model，并将其导出 // StudentModel.jsconst mongoose = require(\"mongoose\");mongoose.connect(\"mongodb://localhost:27017/test\", &#123; useNewUrlParser: true, useUnifiedTopology: true,&#125;);const db = mongoose.connection;db.on(\"error\", () =&gt; &#123; console.error(\"数据库连接失败!\");&#125;);db.once(\"open\", () =&gt; &#123; console.log(\"数据库连接成功!\");&#125;);const StudentScheme = new mongoose.Schema(&#123; name: String, age: Number,&#125;);const StudentModel = mongoose.model(\"students\", StudentScheme);module.exports = StudentModel; 添加文档通过向集合添加文档有三种方法： save create insertMany 其中 save 方法是 Model 实例的方法，而 create 与 insertMany 方法是 Model 的方法。下面给出一个 demo const StudentModel = require(\"./StudentModel\");// save 方法const bob = new StudentModel(&#123; name: \"Bob\", age: 18 &#125;);bob.save();// Model.create 方法StudentModel.create(&#123; name: \"Candy\", age: 20,&#125;);// Model.insertMany 方法let docs = [ &#123; name: \"David\", age: 40, &#125;, &#123; name: \"Eva\", age: 19, &#125;,];StudentModel.insertMany(docs); 查看数据库 &gt; db.students.find()&#123; \"_id\" : ObjectId(\"603a5b85606f6555b0151f65\"), \"name\" : \"David\", \"age\" : 40, \"__v\" : 0 &#125;&#123; \"_id\" : ObjectId(\"603a5b85606f6555b0151f66\"), \"name\" : \"Eva\", \"age\" : 19, \"__v\" : 0 &#125;&#123; \"_id\" : ObjectId(\"603a5b85606f6555b0151f63\"), \"name\" : \"Bob\", \"age\" : 18, \"__v\" : 0 &#125;&#123; \"_id\" : ObjectId(\"603a5b85606f6555b0151f64\"), \"name\" : \"Candy\", \"age\" : 20, \"__v\" : 0 &#125; 查询文档查询数据主要有如下三个方法： find findOne findById 上面的三个方法都返回一个 Promise，它们的用法见下面的 demo const StudentModel = require(\"./StudentModel\");// 查询所有文档const results = StudentModel.find();results.then((docs) =&gt; &#123; docs.forEach((doc) =&gt; &#123; console.log(doc.name); // David // Eva // Bob // Candy &#125;);&#125;);// 查询 name 为 Bob 的一条文档let doc = StudentModel.findOne(&#123; name: \"Bob\" &#125;);doc.then((bob) =&gt; &#123; console.log(bob.name); // Bob&#125;);// 根据 _id 属性来查询文档doc = StudentModel.findById(\"603a5b85606f6555b0151f64\");doc.then((candy) =&gt; &#123; console.log(candy.name); // Candy&#125;); 更新文档有关更新文档的方法有如下几种： update updateOne updateMany findOneAndUpdate findByIdAndUpdate update 方法接收参数如下 conditions doc options callback 我们根据条件 conditions 找到需要更新的文档，然后根据 doc 更新文档，options 包含如下选项 upsert(boolean)：如果不存在则创建新的文档 multi(boolean)：是否更新多条查询 setDefaultsOnInsert(boolean)：如果 upsert 为 true，那么插入文档时使用默认值 updateOne 表示只更新一条文档，即使设置了 multi 为 true；updateMany 可以更新多条文档，即使设置了 multi 为 false。 const StudentModel = require(\"./StudentModel\");StudentModel.update(&#123; name: \"Bob\" &#125;, &#123; $set: &#123; age: 30 &#125; &#125;); findByIdAndUpdate() 与 findOneAndUpdate() 也可以用来更新一条文档。 删除文档有关删除文档的方法有如下三种： deleteOne deleteMany findByIdAndDelete findOneAndDelete 踩坑：一直使用上述方法删除失败失败，后来发现需要在调用方法后需要加上 exec() 见下方 demo 演示方法的使用 const StudentModel = require(\"./StudentModel\");// 删除 age 为 19 的一条文档StudentModel.deleteOne(&#123; age: 19 &#125;).exec();// 删除 age &gt; 15 的所有文档StudentModel.deleteMany(&#123; age: &#123; $gt: 15 &#125; &#125;);// 删除 name 为 Alice 的文档StudentModel.findOneAndDelete(&#123; name: \"Alice\" &#125;).exec();// 根据 id 删除文档StudentModel.findByIdAndDelete(\"603a5b85606f6555b0151f65\").exec(); 参考文章 MongoDB 数据集合操作－集合的查看、创建、重命名、删除 MongoDB 教程 Express 教程 3：使用数据库 (Mongoose) 一篇文章带你入门 Mongoose","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/MongoDB/"},{"name":"mongoose","slug":"mongoose","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/mongoose/"}]},{"title":"Node.js之Express入门","date":"2021-02-24T16:00:00.000Z","path":"/Node.js之Express入门/","text":"Express 是基于 Node.js 的 Web 框架，通过 Express 可以快速的搭建一个 Web 应用。 基本使用安装 express mkdir express-democd express-demonpm init -ynpm i express --save 使用 Express 写一个简单的 Web 应用 // index.jsconst express = require('express');const app = express();app.get(\"/\", (req, res) =&gt; &#123; res.send(\"Hello World!\");&#125;);app.listen(3000); 在上面我们创建了一个简单的 Web 服务器，服务启动在 3000 端口，当我们以 get 方法访问 / 路径时，会返回 Hello World!。 node index.js 路由路由定义了服务器如何对客户端的请求作出相应，它由一个特定的 URI 以及一个 HTTP 方法确定，每一个路由都至少对应一个处理函数。 在 Express 中，路由由如下形式定义 app.method(path, handler) 其中： app：express 实例 method：HTTP 请求方法，如 get, post, delete … … path：请求路径，如 /、/add handler：该路由对应的请求 下面看几个例子 // 当客户端以 POST 访问 / 路径时，返回 POSTapp.post(\"/\", (req, res) =&gt; &#123; res.send(`POST`) &#125;); const fs = require('fs').promises;// 当客户端以 GET 方法访问 /hello 路径时，返回 hello.txt 中的内容app.get(\"/hello\", (req, res) =&gt; &#123; (async () =&gt; &#123; try &#123; const data = await fsreadFile('./hello.txt','utf-8'); res.send(data); &#125; catch(e) &#123; res.send(\"文件读取失败\"); &#125; &#125;)()&#125;); 暴露静态资源文件当我们在 html 通过 script src 去请求 javascript css 图片资源文件，我们希望不要通过路由处理，而是直接将文件返回，这时我们需要将资源文件夹暴露出来。 app.use(express.static('public')) 通过上面一行代码，将根目录下的 public 文件夹中的静态资源暴露出来了。public 文件夹的内容如下 public script index.js css index.css 当我们将 public 文件夹暴露之后，我们便可以通过 http://localhost:3000/script/index.jshttp://localhost:3000/css/index.css 访问静态资源。我们还可以为资源文件夹规定虚拟目录，例如 app.use('/static', express.static('public')) 上面我们资源文件所在的虚拟目录为 /static，即我们现在要以下面的方式访问资源文件 http://localhost:3000/static/script/index.jshttp://localhost:3000/static/css/index.css 中间件所谓的中间件就是一个函数，它可以在请求到达实际的路由之前对请求对象以及响应对象做任何的处理。例如上述暴露静态资源文件目录就是一个中间件，它可以将资源文件夹下的文件直接返回。 为什么叫做中间件，我猜是因为它位于请求与路由响应中间，所以称它为中间件 我们说中间件是一个函数，它接收三个参数 function(req, res, next) &#123; // 做一些事情&#125; 其中： req：请求对象 res：响应对象 next：下一个中间件 其中 next 是一个函数，表示下一个中间件，一般如果不在这个中间件中终止响应的话，一般都会在函数的最后调用 next() 方法，表示应用下一个中间件。 为 Express 应用中间件也很简单，就直接使用 app.use(中间件函数) 即可，例如 app.use((req, res, next) =&gt; &#123; req.requestTime = Date.now(); next();&#125;) 上面我们写了一个中间件，该中间件的函数就是为请求对象添加了一个 requestTime 的属性，用来表示请求到来的时间。这样在后面的路由处理函数中可以直接使用 req.requestTime 这个属性 app.get(\"/\", (req, res) =&gt; &#123; console.log(req.requestTime); res.send(`请求时间是：$&#123;req.requestTime&#125;`)&#125;) 在这里介绍一个常用的中间件，body-parser，它可以解析 HTTP 请求体即 body 中的内容，我们一般通过它拿到 POST 请求的请求参数。 首先安装 body-aprser npm i body-parser --save 使用 const bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(bodyParser.json()); body-parser 会将解析的结果添加到 req.body 上面，在路由处理函数中我们可以直接使用 req.body 拿到 POST 的请求参数 // 将请求参数直接返回app.post(\"/\",(req, res) =&gt; &#123; res.send(req.body);&#125;) 参考文献 Express官网 body-parser 使用详解","tags":[{"name":"Express","slug":"Express","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Express/"},{"name":"中间件","slug":"中间件","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Node.js之事件循环","date":"2021-02-23T03:46:00.000Z","path":"/Node.js之事件循环/","text":"Node.js 是单线程的，但是它却可以应用在高并发场景，原因就是它的事件循环机制。所以本篇文章来介绍 Node.js 的事件循环机制。 同步与异步因为 Node.js 是单线程的，代码的执行不能使用同步机制，因为同步执行会阻塞代码，在单线程中阻塞代码意味着整个程序都被阻塞到了，从而无法处理其他任务。其他后端语言会使用多个线程去执行代码，即使一个线程被阻塞到了，其他的线程也不会有影响。 所以 Node.js 使用异步的方式去执行代码，为了更好的理解异步的概念，我打个比方，假设你请我做一件事情，同步的方式就是你会一直等我将事情做完，在我把事情做完之前，你不能干别的事情；异步的方式就是你请我做一件事情，在我做事情的时候你可以干别的事，等到我将事情做完的时候我会去通知你。 以读取文件为例，我们来看同步的写法 const fs = require(\"fs\");// 程序会被阻塞在这里，知道文件读取完毕const data = fs.readFileSync(\"./hello.txt\", \"utf-8\");console.log(data);console.log(\"同步读取\"); 输出结果为 Hello World!同步读取 因为是同步读取文件，所以会程序会阻塞在这里，直到读取完文件才会继续执行代码，所以先输出读取的文件内容，然后输出 同步读取。 接着看异步的写法 const fs = require(\"fs\");// 程序不会被阻塞在这里fs.readFile(\"./hello.txt\", \"utf-8\", (err, data) =&gt; &#123; if (!err) &#123; console.log(data); &#125;&#125;);console.log(\"异步读取\"); 输出结果为 异步读取Hello World! 因为是异步读取文件，此时不会阻塞程序的执行，会继续执行代码，所以会先打印出 异步读取，等到文件读取完毕时，则会执行回调函数，打印出读取到的文件内容。 事件队列下面我们就来剖析 Node.js 异步执行的背后过程，我们知道 Node.js 是一门基于事件驱动的语言，我们监听某类事件，例如网络请求事件，并为它绑定一个回调函数，当事件发生时，则会调用这个回调函数。 事实上当事件发生时，回调函数并不会立即得到执行，而是会添加到一个队列中，而执行引擎则会不断的从队列中取出事件执行，取出事件执行的这个过程是同步的，就是说先添加进队列中的函数会被先执行，并且先执行完前面的函数才能执行后面的函数。 我们来看一个例子 setTimeout(() =&gt; &#123; // 该回调函数会花费 100 ms let end = Date.now(); while (end - start &lt; 100) &#123; end = Date.now(); &#125;&#125;, 5);setTimeout(() =&gt; &#123; let end = Date.now(); console.log(`延时了 $&#123;end - start&#125; ms 执行`); // 延时了 100 ms 执行&#125;, 10); 上面我们设置了两个定时器，一个延时 5ms 后执行，一个延时 10ms 后执行，但是我们发现第二个定时器是在延时 100ms 后执行的，并不是我们预期的那样。 首先我们需要明确一点，我们设置的 5ms 与 10ms 这些时间并不是指延时 5ms 或 10ms 后执行回调函数，而是指延时指定时间后将这些回调函数添加进事件队列。 我们来看一个时间线 0ms 时，事件队列为空 5ms 时，第一个定时器时间到达，将回调函数添加进事件队列 执行引擎检查事件队列，发现队列中有事件未执行，取出执行 10ms 时，第二个定时器时间到达，将回调函数添加进事件队列，但是因为前面一个回调函数还在执行中，该回调函数不会执行 100ms 时，第一个回调函数执行完毕 执行引擎接着检查事件队列，发现队列不为空，取出第二个回调函数执行函数执行 所以经过了 100ms，第二个定时器的回调函数才会被执行。 事件循环解决实际的问题，上面的模型想必已经够用了，但是如果要应对面试题，却还是需要更加深入的了解。首先看一个例子 console.log(\"start\");const start = Date.now();setImmediate(() =&gt; &#123; console.log(\"setImmediate\");&#125;);setTimeout(() =&gt; &#123; console.log(\"setTimeout\");&#125;, 5);process.nextTick(() =&gt; &#123; console.log(\"nexTick\");&#125;);new Promise((resolve) =&gt; &#123; console.log(\"resolve\"); resolve();&#125;).then(() =&gt; &#123; console.log(\"then\");&#125;);let end = Date.now();while (end - start &lt; 5) &#123; end = Date.now();&#125;console.log(\"end\"); 请问上面程序的输出结果是什么? 我先卖个关子，希望你看完下面的内容之后能够回答出来。 在上面我们使用一个队列来建模了程序的执行过程，事实上这个队列需要被拆分好几个队列 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 上面我们将队列拆分为了 6 个阶段，每一个阶段都有一个队列 timers：setTimeout 以及 setInterval 中的回调函数会放入这个队列 pending callbacks：由于某些原因需要推迟到下一轮循环的 I/O 回调函数放在这个队列(目前我还没有遇到过此类事件) idle, prepare：这个队列是 Node.js 内部使用的，我们不需要关心 poll：I/O 事件，网络请求等事件会放在这个队列 check：setImmediate 中的回调函数会放在这个队列 close：与 close 相关方法会放在这个队列，例如 socket.on(&#39;close&#39;, callback) Node 会依次经历这 6 个阶段，只有将某个阶段中队列的所有函数都执行完毕，才会进入到下一个阶段。但是关于 poll 阶段有一点不同之处，当进入 poll 阶段以后，它会计算 timers 定时器中下一个定时器到达的时间，然后检查 poll 队列是否有任务，如果有就执行，直到队列为空。当队列为空时 是否已经到达了下一个定时器到达的时间，即 timers 队列中是否有任务，如果有则继续事件循环，来到下一个阶段 如果 timers 队列中没有任务，那么检查 check 队列是否有任务，如果有继续进行事件循环 如果 timers 队列和 check 队列都没有任务，那么就会一个停留在 poll 阶段，等待新的任务到来，然后执行该任务 所以会有很长一段时间都会处于 poll 阶段。 我们把一次循环称为一个 tick。 不知道你有没有发现，我们并没有提及 process.nextTick 与 promise.then 中的回调函数放在哪个队列。其实还有两个队列，nextTickQueue 和 microTaskQueue，process.nextTick 中的回调函数会被放置在 nextTickQueue 中，而 promise.then 中的回调函数被被放置在 microTaskQueue 中。 那么这两个队列在图中处于何种位置，其实在进入每个阶段之前，都会检查一遍这两个队列，如果有任务的话就会执行，直至将队列中的任务执行完毕。并且 nextTickQueue 队列中的函数比 microTaskQueue 队列中的函数先被执行。 明白上面的内容之后我们来看那道题目 console.log(\"start\");const start = Date.now();setImmediate(() =&gt; &#123; console.log(\"setImmediate\");&#125;);setTimeout(() =&gt; &#123; console.log(\"setTimeout\");&#125;, 5);process.nextTick(() =&gt; &#123; console.log(\"nexTick\");&#125;);new Promise((resolve) =&gt; &#123; console.log(\"resolve\"); resolve();&#125;).then(() =&gt; &#123; console.log(\"then\");&#125;);let end = Date.now();while (end - start &lt; 5) &#123; end = Date.now();&#125;console.log(\"end\"); 首先当我们开始运行程序的时候，并不会立即进入事件循环，而是首先将同步代码执行完毕，所以首先会依次打印出 startresolveend 接着在进入事件循环，因为在进入每个阶段之前都会先检查 nextTickQueue 和 microTaskQueue 这两个队列，并且 nextTickQueue 在 microTaskQueue 之前执行，所以接着打印出 nextTickthen 接着进入 timers 阶段，因为我们在主程序中有这么一段代码 let end = Date.now();while (end - start &lt; 5) &#123; end = Date.now();&#125; 目的就是确保 setTimeout 中的回调函数已进入 timers 队列，所以此时 timers 队列是有函数的，所以此时会打印出 setTimeout 接着进入pending 阶段，该队列中没有函数；进入poll 阶段(忽略 idle, prepare 阶段)，也没有函数，此时因为 check 队列中有函数，所以会从 poll 阶段进入到 check 阶段，所以接着会打印 setImmediate 然后进入 close 阶段，没有函数，回到 timers 阶段，以此往复。 所以上面程序最终的打印结果为 startresolveendnexTickthensetTimeoutsetImmediate setTimeout vs setImmediatesetTimeout 位于 timers 阶段，而 setImmediate 放置于 check 阶段 setTimeout(() =&gt; &#123; console.log(\"setTimeout\");&#125;);setImmediate(() =&gt; &#123; console.log(\"setImmediate\");&#125;); 所以上面代码的执行结果应该是 setTimeoutsetImmediate 但是有时会打印出 setImmediatesetTimeout 这是因为 setTimeout 不传入时间时，默认是 0，而 Node.js 做不到 0ms 的定时，最少也是 1ms。如果执行主程序需要花费 1ms，那么 timers 队列中就会有函数，就会先打印 setTimeout，如果执行主程序不需要 1ms，那么来到 timers 阶段时，其中还没有函数，但是 check 队列中已经有函数了，就会先打印 setImmediate。 但是如果在 I/O 回调函数中同时调用 setImmediate 和 setTimeout，那么会先执行 setImmediate，因为执行 I/O 回调函数时已经处于 poll 阶段，下一个阶段就是 check 阶段，所以会先执行 setImmediate const fs = require(\"fs\");fs.readFile(\"./hello.txt\", (err, data) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"setTimeout\"); &#125;); setImmediate(() =&gt; &#123; console.log(\"setImmediate\"); &#125;);&#125;); 输出始终为 setImmediatesetTimeout process.nextTick这个函数的名字很有误导性，我们知道 process.nextTick 中的函数是在进入每个阶段之前执行的，所以它应该是 currentTick 而不是 nextTick。而 setImmediate 只有在 check 阶段才会执行，并没有那么的 Immediate。 所以有人提议将二者的名称调换。但是由于有太多的库依赖于这两个 API，如果改动 API 的话，会引起很多的改动。 另外需要注意的一点是，如果我们递归调用 process.nextTick，那么 nextTickQueue 就永远不会空，即此时就会阻塞事件循环的运行 setTimeout(() =&gt; &#123; console.log(\"setTimeout\");&#125;);const recursive = () =&gt; &#123; process.nextTick(recursive);&#125;;process.nextTick(recursive); 上面 setTimeout 中的回调函数永远都不会得到执行。 参考文献 The Node.js Event Loop, Timers, and process.nextTick() Node 定时器详解","tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Event-Loop/"}]},{"title":"Node.js之核心模块","date":"2021-02-20T14:13:00.000Z","path":"/Node.js之核心模块/","text":"Node.js 的模块分为三种： 核心模块 第三方模块 本地模块 本篇重点介绍 Node.js 中的核心模块，包括 核心模块 作用 path 路径相关 fs 操作文件 os 提供相关操作系统信息 http 搭建 http 服务器 querystring 解析请求参数 pathpath 是我们介绍的第一个核心模块，所以有必要介绍如何引入核心模块。引入核心模块很简单，直接 require(&#39;xxx&#39;) 即可，例如我们引入 path 模块 const path = require(\"path\"); path 是与路径有关的模块，再介绍 path 之前，介绍两个与路径有关的变量， __dirname 与 __filename： __dirname：表示当前模块所在的目录，是一个表示绝对路径的字符串 __filename：表示当前模块(文件)所在的路径，也是一个表示绝对路径的字符串 这两个变量都是全局变量 global 的属性，所以可以直接在模块中访问 &#x2F;&#x2F; D:\\Desktop\\Node\\2 核心模块\\1. path.jsconsole.log(__dirname); &#x2F;&#x2F; D:\\Desktop\\Node\\2 核心模块console.log(__filename); &#x2F;&#x2F; D:\\Desktop\\Node\\2 核心模块\\1. path.js 将讲解 path 模块提供的 API 之前，首先我们明确一下路径的组成 ┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │&quot; C:\\ 目录1\\目录2 \\ 文件 .txt &quot;└──────┴──────────────┴──────┴─────┘（&quot;&quot; 行中的所有空格均可忽略。它们纯粹是用于格式化。） 可见路径可以被划分为两部分： dir：文件所在目录 base：文件名称(包含扩展名) 而 base 也可以被划分为两部分： name：文件名称 ext：扩展名 dirnamepath.dirname(path) 返回的是给定路径的目录 const path = require(\"path\");let filepath = \"C:\\\\Users\\\\index.html\";console.log(path.dirname(filepath)); // C:\\Users basenamepath.basename(path, [ext]) 返回路径的最后一个部分，它会忽略最后的目录分隔符(如果有的话) const path = require(\"path\");let filepath = \"C:\\\\Users\\\\index.html\";console.log(path.basename(filepath)); // index.htmlfilepath = \"C:\\\\Users\\\\index.html\\\\\";console.log(path.basename(filepath)); // index.html basename() 还接收一个可选参数，表示文件的扩展名，如果传入的扩展名与路径最后一部分的扩展名相同，则返回没有扩展名的文件名称 const path = require(\"path\");let filepath = \"C:\\\\Users\\\\index.html\";console.log(path.basename(filepath, \".html\")); // index 需要注意的是，扩展名是区分大小写的 const path = require(\"path\");let filepath = \"C:\\\\Users\\\\index.HTML\";console.log(path.basename(filepath, \".html\")); // index.HTML 如果传入的 path 与 ext 都不是字符串，则会抛出 TypeError。 extnamepath.extname(path) 返回路径的扩展名，即路径中最后一个 . 之后的字符串(包括 .)，如果路径中没有 .，那么返回一个空字符串 const path = require(\"path\");let filepath = \"C:\\\\Users\\\\index.html\";console.log(path.extname(filepath)); // \".html\"filepath = \"C:\\\\Users\\\\index.\";console.log(path.extname(filepath)); // \".\"filepath = \"C:\\\\Users\\\\index.html.md\";console.log(path.extname(filepath)); // \".md\"filepath = \"C:\\\\Users\\\\index\";console.log(path.extname(filepath)); // \"\" formatpath.format(pathOject) 方法根据一个 pathObject 得到一个绝对路径，pathObject 对象包含下面几个属性： dir root base name ext 可见这些属性都是上面介绍的路径组成部分，它会根据这些属性构建出一个绝对路径。 因为 dir 包括 root，base 包括 name 和 ext，所以当规定了 dir 属性时，则忽略 root 属性，当规定了 base 属性时，则忽略 name 和 ext 属性。 const path = require(\"path\");const filepath = path.format(&#123; dir: \"C:\\\\Users\", // root 被忽略 root: \"D:\\\\\", base: \"index.html\", // 下面两个属性被忽略 name: \"a\", ext: \".md\",&#125;);console.log(filepath); // C:\\Users\\index.html const path = require(\"path\");const filepath = path.format(&#123; root: \"D:\\\\\", name: \"a\", ext: \".md\",&#125;);console.log(filepath); // D:\\a.md parsepath.parse(path) 接收一个表示绝对路径的字符串，返回一个对象，它的作用与 path.format 正好相反，将一个绝对路径拆分为各个组成部分 const path = require(\"path\");const filepath = \"C:\\\\Users\\\\index.html\";console.log(path.parse(filepath)); 打印一个对象如下 &#123; root: 'C:\\\\', dir: 'C:\\\\Users', base: 'index.html', ext: '.html', name: 'index'&#125; normalizepath.normalize(path) 是用来规范路径的，主要有下面几个作用： 将目录分隔符(/, \\\\) 转化为特定平台上的分隔符 解析 ..，. 路径 将多个连续的目录分隔符合并为一个目录分隔符 const path = require(\"path\");// 使用了两种目录分割符，并且一处连续使用了目录分割符const filepath = \"C:/Users\\\\\\\\\\\\index.html\";console.log(path.normalize(filepath)); // C:\\Users\\index.html const path = require(\"path\");// 路径中包含 \"..\" 和 \".\" 表示的相对路径const filepath = \"C:/Users/a/b/../.././index.html\";console.log(path.normalize(filepath)); // C:\\Users\\index.html resolvepath.resove(...paths) 接收多个路径，从右向左对路径进行拼接，直至拼接出绝对路径 const path = require(\"path\");const filepath = path.resolve(\"D:\\\\\", \"C:\\\\Users\", \"index.html\");console.log(filepath); // C:\\Users\\index.html 上面我们对 D:\\\\, C:\\\\Users, index.html 从右向左进行拼接，C:\\\\Users 与 index.html 拼接得到 C:\\\\Users\\\\index.html，这已经是一个绝对路径了，所以就不在进行拼接了。 如果传入的路径不能拼接出一个绝对路径，那么就会使用当前文件所在的路径拼接一个绝对路径，就相当于 resolve 第一个参数默认为 __dirname const path = require(\"path\");const filepath = path.resolve(\"index.html\");console.log(filepath); // D:\\Desktop\\Node\\2 核心模块\\index.html resolve 方法返回的路径是已经规范化(normalize)了的，并且尾部的分隔符会被删除(除非是根路径)。如果没有为 resolve 传入参数，那么会返回当前文件所在的路径 const path = require(\"path\");console.log(path.resolve()); // D:\\Desktop\\Node\\2 核心模块 joinpath.join(...paths) 方法接收一些路径，然后使用所在平台的分隔符(Windows 平台就是 \\， Linux/Unix 平台就是 /)进行拼接，最后进行规范化然后返回。 与 path.resolve 方法不同的是，path.resolve 方法一旦拼接出绝对路径后就不在进行拼接，path.resolve 方法返回的是一定是一个绝对路径，但是 path.join 方法只是将多个路径使用分割符进行拼接而已 const path = require(\"path\");const resolvePath = path.resolve(\"/a\", \"/b\", \"c\");const joinPath = path.join(\"/a\", \"/b\", \"c\");console.log(resolvePath); // D:\\b\\cconsole.log(joinPath); // \\a\\b\\c 如果不为 path.join 传入任何参数的话，那么会返回 .。 sep 与 delimeterpath.sep 与 path.delimeter 是 path 模块的两个属性 path.sep：所在平台的目录分隔符 Windows：\\ Linux/Unix：/ path.delimeter：所在平台的目录界定符 Windows：; Linux/Unix：: const path = require(\"path\");console.log(path.sep); // \\console.log(path.delimiter); // ; fsfs 模块是与文件系统有关的模块，可以使用它来进行文件相关的操作。 readFile我们可以使用 fs.readFile(path, [options], callback) 读取一个文件的内容，该方法接收一个路径(相对路径与绝对路径均可)，当读取完文件内容之后，会将读取到的数据作为参数传递给传入的回调函数(callback)，该方法还接受一个 options 参数，它可以是一个包含如下属性的对象： encoding：指定读取内容的编码，默认为 null flag：指定读写模式，默认为 r，表示只读 当没有指定 encoding 时，返回一个 Buffer。options 还可以是一个字符串，当 options 为一个字符串时，表示编码 const fs = require(\"fs\");fs.readFile(\"./file/hello.txt\", \"utf-8\", (err, data) =&gt; &#123; if (err) &#123; throw new Error(err.toString()); &#125; console.log(data); // Hello World!&#125;); 上述代码读取了当前目录下的 file 文件夹下的 hello.txt 文件，读取完文件后会将内容使用 utf-8 进行解码为字符串，然后将该字符串传递给回调函数。向回调函数传递参数时，第一个参数为错误对象，第二个参数才为实际的内容，之所以将第一个参数设置为错误对象，是为了提醒用户记得处理错误。 如果是第一次接触 Node.js 的话，可能不适合上面回调函数的写法，这种写法是异步写法，之所以这么写是因为 Node.js 是单线程的，为了提高程序执行的效率，所以使用异步的写法(如果无法领会上面这段话，就先放一放，我第一次接触回调函数的写法也是没有反应过来)。 readFile 还有一个对应的同步方法 readFileSync(path, [options])，参数的意义同上，不过这时不需要一个回调函数了，它会将读取到的内容返回 const fs = require(\"fs\");const data = fs.readFileSync(\"./file/hello.txt\", \"utf-8\");console.log(data); // Hello World! 这时你可能会问怎么处理错误，那就是将代码放在 try ... catch 代码块中 const fs = require(\"fs\");try &#123; const data = fs.readFileSync(\"./file/hello.txt\", \"utf-8\"); console.log(data); // Hello World!&#125; catch (e) &#123; console.log(e);&#125; 同步的方式虽然比较好理解，但是以同步的方式读取文件，会阻塞程序的执行，降低代码的执行效率，所以推荐使用 readFile 读取文件。 这种回调函数式的写法有一个问题就是会产生回调地狱，使得代码难以阅读。有下面三个文件在 file 文件夹下 // a.json&#123; \"next\": \"b.json\", \"content\": \"this is a.json\"&#125;// b.json&#123; \"next\": \"c.json\", \"content\": \"this is b.json\"&#125;// c.json&#123; \"next\": null, \"content\": \"this is c.json\"&#125; 下面这段代码是依次读取 a.json, b.json, c.json 的内容，并打印出来 const fs = require(\"fs\");const path = require(\"path\");fs.readFile(\"./file/a.json\", \"utf-8\", (err, data) =&gt; &#123; const a = JSON.parse(data); console.log(a.content); fs.readFile(path.resolve(\"file\", a.next), \"utf-8\", (err, data) =&gt; &#123; const b = JSON.parse(data); console.log(b.content); fs.readFile(path.resolve(\"file\", b.next), \"utf-8\", (err, data) =&gt; &#123; const c = JSON.parse(data); console.log(c.content); &#125;); &#125;);&#125;); 为了代码的简洁，已经省略了对错误的处理，可见上面嵌套的代码真的很难阅读，需要花费一番功夫去理解上面的代码做了什么事情。并且如果有更多的嵌套的话，代码的逻辑 正是为了解决这样的问题，在 ES6 中提出了 Promise，写出同样目的的代码，但是嵌套最多只有两三层，代码简单易读。同样，Node.js 也提出了 Promise 的文件系统 API，在 fs/promises 模块下 const fs = require(\"fs\").promises;const path = require(\"path\");fs.readFile(path.resolve(\"file\", \"a.json\"), \"utf-8\") .then((data) =&gt; &#123; data = JSON.parse(data); console.log(data.content); return fs.readFile(path.resolve(\"file\", data.next), \"utf-8\"); &#125;) .then((data) =&gt; &#123; data = JSON.parse(data); console.log(data.content); return fs.readFile(path.resolve(\"file\", data.next), \"utf-8\"); &#125;) .then((data) =&gt; &#123; data = JSON.parse(data); console.log(data.content); &#125;); 使用回调函数的写法无论有多少层嵌套，改为使用 Promise 的写法，代码的嵌套就只有两层。 writeFilefs.writeFile(path, data, [options], callback) 的作用是向文件写入内容，path 表示文件路径，data 表示向文件写入的内容，options 是一个可选参数，是一个包含如下属性的对象： encoding：将 data 表示的字符串使用该编码写入文件，默认为 utf-8，当 data 为 Buffer 类型的对象时，将忽略该属性 flag：默认为 w，表示只写 mode：默认为 0o666 当写入文件完毕时，会执行 callback 函数，callback 函数接收一个错误对象，根据错误对象我们可以判断是否写入文件成功 const fs = require(\"fs\");fs.writeFile(\"./file/world.txt\", \"World\", (err) =&gt; &#123; if (!err) &#123; console.log(\"写入成功！\"); &#125;&#125;); 上面我们向 ./file/world.txt 写入了一个 World 字符串，当写入成功后，打印出写入成功！。 appendFile上面 writeFile 表示的是向文件写入内容，之前文件的内容全部清除，如果我们希望只是想文件中添加内容，那就要使用 appendFile(path, data, [options], callback)，这些参数的意义同 writeFile 相同 const fs = require(\"fs\");// world.txt 中没有任何内容for (let i = 0; i &lt; 3; i++) &#123; fs.appendFile(\"./file/world.txt\", \"Hello World\\n\", (err) =&gt; &#123; if (err) &#123; throw new Error(err); &#125; &#125;);&#125; 执行完上述代码后，world.txt 中的内容为 Hello WorldHello WorldHello World open我们可以使用 fs.open(path, [flags], [mode], callback) 打开一个文件，打开文件后便可对文件进行多项操作，例如读取文件，向文件写入内容等等。 操作系统维护着一个打开的文件和资源的表格，每个打开的文件都分配了一个文件描述符，操作系统根据文件描述符去描述和追踪特定的文件。 使用 fs.open 打开一个文件之后，会得到一个文件描述符(file descriptor)，一旦分配一个文件描述符，我们便可以使用该文件描述符对文件进行读写。 fs.open 方法接收四个参数： path：文件路径 flags：默认为 r，表示只读 mode，默认为 0o666，表示拥有可读写的权限 callback：打开文件成功后会调用该函数，该回调函数接收两个参数 err：错误对象 fd：文件描述符 flags 可取如下值 flag 意义 r 只读，如果文件不存在，抛出异常 r+ 可读可写，如果文件不存在，抛出异常 rs+ 可读可写，以同步的方式打开文件 w 只写，如果文件不存在，则创建文件 wx 同 w，不过文件不存在时则失败 w+ 可读可写，文件不存在时创建文件 wx+ 同 w+，不过文件不存在时失败 a 向文件追加内容，文件不存在则创建文件 a+ 可向文件追加内容，也可以读取文件内容，文件不存在时则创建文件 ax 向文件追加内容，如果文件不存在则失败 ax+ 同 a+，不过文件不存在时则失败 fs.open(\"./file/hello.txt\", \"w\", (err, fd) =&gt; &#123; fs.writeFile(fd, \"Hello World!\", (err) =&gt; &#123; if (!err) &#123; console.log(\"写入成功\"); // 文件资源有限，需及时关闭资源 fs.close(fd, (err) =&gt; &#123; if (!err) &#123; console.log(\"关闭成功\"); &#125; &#125;); &#125; &#125;);&#125;); renamefs.rename(oldPath, newPath, callback) 作用就是重命名，将 oldPath 重命名为 newPath，重命名完成以后会调用 callback 函数，会为该函数传入错误对象 const fs = require(\"fs\");fs.rename(\"./file/hello.txt\", \"./file/world.txt\", (err) =&gt; &#123; if (!err) &#123; console.log(\"重命名成功\"); &#125;&#125;); readdirfs.readdir(dir, callback) 方法是读取一个目录，返回一个字符串数组，数组中的元素是该目录下的文件名和目录名 const fs = require(\"fs\");fs.readdir(\"./file/\", (err, files) =&gt; &#123; if (err) &#123; throw new Error(err); &#125; console.log(files);&#125;); 输出为 [\"a.json\", \"b.json\", \"c.json\", \"hello.html\", \"index.html\", \"world.txt\"]; 如果传入的路径不是一个目录，那么会抛出错误。 rmpath.rm(path, [options], callback)方法是用来删除文件或目录 path：路径 options：可选参数，包含如下属性： force：如果 force 为 true 的话，如果文件不存在不会抛出错误 recursive：如果传入的路径为目录，如果 recursive 为 false，那么会报错，如果为 true，则会删除该目录 maxRetries：当读取文件出现错误时，会进行尝试，该属性设置最大尝试次数，如果 recursive 为 false 的话，会忽略该选项，默认为 0 retryDelay：重试之间的间隔，单位为毫秒 callback：回调函数，删除完文件或目录后会调用该回调函数，该回调函数接收一个错误对象 const fs = require(\"fs\");// 删除 demo 文件夹下面的所有东西fs.rm( \"./demo/\", &#123; force: true, recursive: true, &#125;, (err) =&gt; &#123; if (!err) &#123; console.log(\"删除成功\"); &#125; &#125;); 该方法与 14.14.0 版本新增，所以如果要使用该方法需要升级 Node.js 到 14.14.0 版本以上。 statfs.stat(path, callback) 方法可以获知文件或目录的相关信息，path 代表文件或目录的路径，callback 是回调函数，接收两个参数 err：错误对象 stats：fs.Stats 对象，该对象包含很多与文件信息相关的方法 isDirectory()：是否是一个目录 isFile()：是否是一个文件 size：文件的大小(单位为 Byte) atime：最后访问 (access) 时间 mtime：文件最后更改 (modified) 时间，是指文件内容的修改 ctime：文件最后改变 (changed) 时间，是指文件元信息的更改，例如权限 birthtime：文件的创建时间 const fs = require(\"fs\");fs.stat(\"./file/world.txt\", (err, stats) =&gt; &#123; if (err) &#123; throw new Error(err.message); &#125; console.log(stats.isDirectory()); // false console.log(stats.isFile()); // true console.log(stats.size); // 12 console.log(stats.atime); // 2021-02-19T10:31:40.744Z console.log(stats.mtime); // 2021-02-19T10:15:58.439Z console.log(stats.ctime); // 2021-02-19T10:31:39.845Z console.log(stats.birthtime); // 2021-02-16T10:44:33.194Z&#125;); osos 模块包含有关操作系统有关的信息，例如操作系统架构，CPU 的相关信息 archos.arch() 返回的是操作系统的架构，常见的架构包括 arm arm64 x32 x64 mips … … const os = require(\"os\");console.log(os.arch()); // x64 cpusos.cpus() 是与 CPU 信息有关的方法，它返回一个数组，数组中的是一个个的对象，对象的格式如下 model: CPU 的 model 信息 speed: CPU 的速度(MHz) times: 包含如下属性的对象 user: CPU 在用户 user 状态下花费的时间 nice: CPU 在用户 nice 状态下花费的时间，在 Windows 操作系统中该属性始终为 0 sys: CPU 在用户 sys 状态下花费的时间 idle: CPU 在用户 idle 状态下花费的时间 irq: CPU 在用户 irq 状态下花费的时间 const os = require(\"os\");console.log(os.cpus()); 输出 [ &#123; model: 'Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz', speed: 2112, times: &#123; user: 4533328, nice: 0, sys: 5867843, idle: 85751843, irq: 1135437 &#125; &#125;, ... ...] totalmem、freememos.totlemen() 获得系统的总内存，os.freemen 获得系统的目前可用内存，二者单位皆为 Byte const os = require(\"os\");console.log(os.totalmem()); // 17001648128console.log(os.freemem()); // 7865696256 hostnameos.hostname() 返回主机名 const os = require(\"os\");console.log(os.hostname()); platformos.platform() 返回操作系统平台，常见有 win32 linux freebsd darwin openbsd const os = require(\"os\");console.log(os.platform()); // win32 http我们可以使用 http 模块搭建 HTTP 服务器，处理前端页面发起的请求，首先我们搭建一个简单的 HTTP 服务器 const http = require(\"http\");// 创建一个 HTTP 服务器const server = http.createServer();// 监听请求，当有请求到达时触发回调函数server.on(\"request\", (req, res) =&gt; &#123; res.setHeader(\"Content-Type\", \"text/plain\"); res.write(\"Hello World!\"); res.end();&#125;);// 监听 3000 端口server.listen(3000, (err) =&gt; &#123; if (!err) &#123; console.log(\"服务启动在3000端口...\"); &#125;&#125;); 上述我们搭建了一个 HTTP 服务器，它监听了 3000 端口，当有请求到来时，我们返回一个字符串 Hello World！，我们使用 Postman 发送一个请求测试 请求对象server.on(\"request\", (req, res) =&gt; &#123; // ... ...&#125;); 上面的代码我们向回调函数传递了两个参数 req：请求对象，包含了请求相关的信息，例如请求头，请求参数，请求地址 res：响应对象，用以设置响应信息，例如响应头，响应内容 在本节介绍请求对象。 req.url通过 req.url 我们可以过得请求地址 const http = require(\"http\");// 创建一个 HTTP 服务器const server = http.createServer();// 监听请求，当有请求到达时触发回调函数server.on(\"request\", (req, res) =&gt; &#123; // 解决中文乱码 res.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\"); // 根据不同的 url 返回不同的内容 if (req.url === \"/\") &#123; res.write(\"您访问的是主页\"); &#125; else if (req.url === \"/add\") &#123; res.write(\"添加一条记录\"); &#125; else &#123; res.write(\"您访问的资源不存在\"); &#125; res.end();&#125;);// 监听 3000 端口server.listen(3000, (err) =&gt; &#123; if (!err) &#123; console.log(\"服务在启动3000端口...\"); &#125;&#125;); 我们可以利用核心模块 querystring 来解析 url，获得请求参数 const http = require(\"http\");const querystring = require(\"querystring\");const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; // 解析请求参数为键值对的形式 const url = req.url; const query = url.split(\"?\")[1]; const params = querystring.parse(query); res.setHeader(\"Content-Type\", \"application/json\"); // 将请求参数返回 res.write(JSON.stringify(params)); res.end();&#125;);server.listen(3000);console.log(\"服务启动在3000端口......\"); req.method通过 req.method 属性，可以知道请求方法，常见请求方法包括 GET POST PUT DELETE OPTIONS const http = require(\"http\");const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; res.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\"); if (req.method === \"GET\") &#123; res.write(\"GET 请求\"); &#125; if (req.method === \"POST\") &#123; res.write(\"POST 请求\"); &#125; res.end();&#125;);server.listen(3000, (err) =&gt; &#123; if (!err) &#123; console.log(\"服务在启动3000端口...\"); &#125;&#125;); req.headersreq.headers 保存着所有的请求头的信息 const http = require(\"http\");const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; res.setHeader(\"Content-Type\", \"application/json\"); // 将请求头原样返回 res.write(JSON.stringify(req.headers)); res.end();&#125;);server.listen(3000, (err) =&gt; &#123; if (!err) &#123; console.log(\"服务在启动3000端口...\"); &#125;&#125;); 响应对象响应对象就是用来发送响应信息，包括 响应头 状态码 响应内容 setHeader我们可以通过 setHeader(name, value) 来设置响应头，例如设置 Content-Type 响应头 const http = require(\"http\");const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; // 设置响应头 Content-Type res.setHeader(\"Content-Type\", \"text/plain\"); res.write(\"Hello World!\"); res.end();&#125;);server.listen(4000); writeHead我们可以通过 writeHead 来设置响应状态码 const http = require(\"http\");const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; res.setHeader(\"Content-Type\", \"text/plain\"); res.writeHead(404); res.write(\"Resource Not Found\"); res.end();&#125;);server.listen(4000); 除此之外，writeHead 还可以接收一个可选的对象来设置请求头，它的优先级比 setHeader 方法的优先级高 const http = require(\"http\");const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; res.setHeader(\"Content-Type\", \"text/plain\"); // 重新设置 Content-Type 请求头 res.writeHead(404, &#123; \"Content-Type\": \"text/html\", &#125;); res.write(\"Resource Not Found\"); res.end();&#125;);server.listen(4000); write、end我们使用 res.write 方法来返回响应内容，res.write 方法可以多次调用，在调用多次 write 之后，应该使用 res.end 方法表示响应的结束。 const http = require(\"http\");const fs = require(\"fs\").promises;const server = http.createServer();server.on(\"request\", (req, res) =&gt; &#123; res.setHeader(\"Content-Type\", \"text/html\"); (async () =&gt; &#123; const data = await fs.readFile(\"./page/index.html\", \"utf-8\"); res.write(data); res.end(); &#125;)();&#125;);server.listen(4000); end 方法也可以接收一个 data 参数 res.end(data);// 相当于res.write(data);res.end(); 参考文章 Node.js File System Module Node.js | fs.open() Method Linux File Timestamps Explained: atime, mtime, and ctime Node.js v15.9.0 Documentation nodejs 中服务器返回响应信息中的中文乱码","tags":[{"name":"fs","slug":"fs","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/fs/"},{"name":"path","slug":"path","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/path/"},{"name":"os","slug":"os","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/os/"},{"name":"http","slug":"http","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/http/"},{"name":"querystring","slug":"querystring","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/querystring/"}]},{"title":"ES6：Set集合与Map集合","date":"2021-02-15T10:49:00.000Z","path":"/ES6：Set集合与Map集合/","text":"在 ES6 以前，JavaScript 只有数组这一种集合来存储数据(当然有的人会使用对象来存储数据)，在 ES6 中引入了两种新的集合来存储数据，它们是 Set 和 Map： Set：Set 集合中的数据都不相同 Map：数据格式为键值对，与对象类似 ES5 中的 Set 和 Map模拟 Set 和 Map在 ES5 中，开发者使用对象来模拟 Set 和 Map let set = Object.create(null);set.foo = trueif (set.foo) &#123; // do something&#125; 上面在 Set 集合中存储了一个名为 foo 的数据，通过将它的值设置为 true 来指明集合中有这个数据。 let map = Object.create(null);map.foo = \"bar\"console.log(map.foo); // bar 上述代码创建了一个 map 集合，并且在其中存储 foo-bar 这个键值对。 存在的问题问题是由于对象的特点引起的，在 JavaScript 中，对象的键值都是字符串 let map = Object.create(null);map[5] = \"hello\";console.log(map[\"5\"]); // hello 虽然上面是以数字 5 为键值存储的数据，但是在内部会被转化为字符串 “5”，所以数字 5 和字符串 “5” 为键值是一样的。因为对象会将键强转为字符串，所以无法以对象作为键值 let map = Object.create(null);let key1 = &#123;&#125;, key2 = &#123;&#125;;map[key1] = \"hello\"console.log(map[key2]); // hello 上述当我们以 key1 和 key2 为键值存储和访问数据时，都会先将对象转化为字符串，然后以该字符串为键值作为对象的键。key1 和 key2 转化为字符串得到的都是 [object Object]，所以以它们作为集合的键是同一个键，无法区分，即以对象模拟 Set 和 Map 无法以对象作为键。 另外对于 map 集合，判断一个键是否存在也存在问题，通常的判断方法如下 let map = Object.create(null);map.count = 1;if (map.count) &#123; // do something&#125; 上面通过 map.count 来判断 count 键是否存在，但是当 count 的值为 0 时得到的结果也是 false，所以这是一个判断非 0 的逻辑，还是判断键不存在的逻辑，无从得知。 SetES6 提供了原生 Set 集合，Set 集合是一个有序的、没有重复元素的集合。 使用 Set通过 new Set() 得到一个 Set 对象，Set 集合提供如下 API add(item)：向集合中添加元素 item has(item)：判断集合中是否有 item 元素 delete(item)：删除集合中的 item 元素 clear()：清空集合中的所有元素 let set = new Set();set.add(5);set.add(\"5\");console.log(set.size); // 2 Set 集合是通过 Object.is 方法来判断两个元素是否相同的，所以 5 和 “5” 是两个不同的元素。如果向 Set 集合中添加相同的元素，那么 Set 集合会忽略重复添加的语句 set.add(6);set.add(6); // 这条语句会被忽略console.log(set.size); // 3 此外，我们还可以像 Set 集合中添加对象 let key1 = &#123;&#125;, key2 = &#123;&#125;;set.add(key1);set.add(key2);console.log(set.size); // 5 上面 key1 和 key2 是不同的对象，所以二者都可以被添加进集合中。 console.log(set.has(key1)); // trueconsole.log(set.delete(key1)); // trueconsole.log(set.has(key1)); // false has 方法是判断集合中是否有该元素，而 delete 方法是删除集合中的元素，如果删除成功返回 true，否则返回 false。 set.clear();console.log(set.size); // 0 clear 方法的作用是清空 Set 集合。 遍历 SetSet 集合提供 forEach 的 API 让我们来遍历 Set 集合，forEach 接收一个回调函数，该回调函数接收三个参数 集合中的元素 同第一个参数 set 集合本身 这里比较奇怪的是第二个参数与第一个参数相同，之所以这么做是为了与数组以及 map 集合的 forEach API 保持一致，方便记忆 let set = new Set();set.add(1);set.add(3);set.add(4);set.forEach((value, _, ownerSet) =&gt; &#123; console.log(value); // 1 // 3 // 4 console.assert(ownerSet === set);&#125;); 如果需要在回调函数中使用 this 的话，可以通过 forEach 的第二个参数将 this 传入 let set = new Set([1, 2]);let processor = &#123; output(value) &#123; console.log(value); &#125;, process(dataSet) &#123; dataSet.forEach(value =&gt; &#123; this.output(value); &#125;, this); &#125;&#125;processor.process(set); Set 与数组Set 的构造方法可以接收一个数组作为参数，它会将数组中的元素添加进 Set 集合中，但是不会添加重复的元素 let set = new Set([1, 3, 2, 3, 4]);set.forEach((value, _, ownerSet) =&gt; &#123; // 1 3 2 4 console.log(value);&#125;) 可以通过 ... 运算符将 Set 转化为数组 let set = new Set([1, 3, 2, 3, 4]);let arr = [...set];console.log(Array.isArray(arr)); // trueconsole.log(arr); // [ 1, 3, 2, 4 ] 利用 Set 集合的特点，可以方便的数组进行去重 function elimateDuplicates(items) &#123; let set = new Set(items); return [...set];&#125;let arr = [1, 2, 1, 1, 3, 2];arr = elimateDuplicates(arr);console.log(arr); // [ 1, 2, 3 ] WeakSet上面的介绍的 Set 可以看做是 Strong Set，所谓的 Strong 指的是集合中的元素保持对对象的引用，例如 let set = new Set();let key = &#123; name: 'Alice'&#125;set.add(key);key = null; 上面我们为 Set 集合中添加了一个对象 key，随后将对象 key 设置为了 null，但是集合仍然保持着对对象的引用，这就意味着无法回收此对象(这个对象以及无法访问，按道理应该被回收掉)，可能会造成内存泄漏的问题。 所以相应的提出了 WeakSet，所谓的 WeakSet 指的是其中的元素没有保持的对对象的引用，如果对象被设置为 null，那么该对象就可以被回收 let weakSet = new WeakSet();let key = &#123; name: \"Alice\"&#125;;weakSet.add(key);// 设置为 null 了，对象可以被作为垃圾回收了key = null; WeakSet 提供与 Set 相似的 API add has delete 下面列举 Set 与 WeakSet 的不同： WeakSet 集合只能存储对象 WeakSet 不可遍历，没有 forEach 方法，没有 size 属性 没有 clear 方法 Map使用 MapMap 是用来存储键值对结构的数据的，我们可以通过 new Map() 创建一个 Map 集合 let map= new Map();map.set(5, \"alice\");map.set(10, \"bob\");console.log(map); // Map &#123; 5 =&gt; 'alice', 10 =&gt; 'bob' &#125; Map 提供如下 API set(key, value)：根据 key 设置 value，如集合中没有该 key，那么添加这一键值对 get(key)：根据 key 查找 value并返回，如果集合中没有该 key，返回 undefined has(key)：判断集合中有没有 key，有返回 true，否则返回 false delete(key)：根据 key 删除集合中的键值对，删除成功返回 true，失败返回 false clear()：清空集合中的所有元素 let map= new Map();map.set(\"name\", \"Alice\");map.set(\"age\", 20);console.log(map.has(\"name\")); // trueconsole.log(map.get(\"name\")); // Alicemap.delete(\"name\");console.log(map.size); // 1console.log(map.get(\"name\")); // undefinedmap.clear();console.log(map.size); // 0 Map 集合还可以通过数组进行初始化，它的构造函数接收一个二维数组，形式为 [[key1, value1], [key2, value2]] 的形式 let map= new Map([[5, \"Alice\"], [10, \"Bob\"]]);console.log(map); // Map &#123; 5 =&gt; 'Alice', 10 =&gt; 'Bob' &#125; 遍历 MapMap 集合也提供了一个 forEach 方法用来遍历 Map 集合，该方法也接受一个回调函数，回调函数接受三个参数 value key map 集合本身 let map = new Map([[\"name\", \"Alice\"], [\"age\", 18], [\"gender\", \"female\"]]);map.forEach((value, key, ownerMap) =&gt; &#123; // key: name, value: Alice // key: age, value: 18 // key: gender, value: female console.log(`key: $&#123;key&#125;, value: $&#123;value&#125;`); console.assert(map === ownerMap);&#125;) 如果回调函数中需要用到 this 的话，可以通过 forEach 的第二个参数将 this 传入。 WeakMapWeakMap 的提出与 WeakSet 相似，都是为了解决垃圾回收问题 let map = new WeakMap();let key1 = &#123;&#125;, key2 = &#123;&#125;;map.set(key1, \"Alice\");map.set(key2, \"Bob\");// key1 的值为 null，表示可以被垃圾回收了key1 = null; WeakMap 提供以下 API set get has delete let map = new WeakMap();let key1 = &#123;&#125;, key2 = &#123;&#125;;map.set(key1, \"Alice\");map.set(key2, \"Bob\");console.log(map.get(key1)); // Aliceconsole.log(map.delete(key1)); // trueconsole.log(map.has(key1)); // false WeakMap 具有如下限制： 键必须为对象，否则抛出错误 没有 size 属性，无 clear 方法 无法使用 forEach 循环，不可迭代","tags":[{"name":"Set","slug":"Set","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Set/"},{"name":"Map","slug":"Map","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Map/"}]},{"title":"Node.js 之模块系统","date":"2021-02-08T10:17:00.000Z","path":"/Node.js 之模块系统/","text":"Node.js 提出的背景背景Node.js 于 2009 年由 Ryan Dahl 提出，它提出 Node.js 是为了解决当时的并发连接问题。以往的编程语言对于请求的处理方式是，来一个请求就新建一个线程来处理这个请求，假设一个线程需要消耗 2MB 的内存资源，那么对于一个 8GB 的内存系统，它最多同时处理 4000 个请求。如果需要处理更多的请求的话，就需要增加更多的服务器，另外由于用户的每个请求可能访问不同的服务器，所以所有的资源都需要在服务器之间共享。这种 Web 架构下瓶颈就在于服务器能够处理的并发连接的最大数量。 Node.js 提出另一种方法来解决这种问题，那就是事件绑定。每次来到一个请求，并不是为该请求新建一个线程，而是为该请求绑定一个事件，并且添加到事件队列，而最终达到的效果是，使用 Node.js 的服务器能够同时处理数万个并发连接。 如果将服务器比作是一个饭店，而一个请求就是一个客人。对于使用多线程的方式的服务器，来一个客人就派一个服务生去服务客人，直至客人离开。而 Node.js 则是只有一位服务员，这位服务员不会从头到尾都服务客人，每来一个客人，在了解完客人的需求后，并记录下来，就请客人去座位上等待，会有专门的人员去处理记录的需求。 所以 Node.js 也有其适应的场景，它适合于 IO 密集型的任务，而不适合 CPU 密集型的任务。所谓的 IO 密集型任务指的就是像上面所提及的大量的并发请求，而 CPU 密集型任务指的是需要做复杂耗时长的计算的任务。 应用Node.js 自 2009 年提出发展至今已有十余年的时间，虽然 Node.js 当初的想法是为了解决大并发的问题，但是随着十几年的发展，Node.js 也催生出了其他的应用： Web 服务器：自 Node.js 诞生，提出了很多得 Web 框架，我们可以使用它方便的写出 Web 程序 Express Koa2 Egg 前端工程化：Node.js 的提出，使得前端也产生一次质的飞跃，使用 Node.js 编写的前端工具使得开发前端项目变得简单 Babel Webpack Eslint Jest 桌面项目：Node.js 提供了具有访问操作系统 API 的能力，使得使用 Node.js 也可以开发出桌面项目 Electron 脚手架工具：使用 Node.js 编写的脚手架工具，让我们可以很快的开始一个前端项目 creat-react-app vue-cli 服务端渲染： next.js nuxt.js Serverless … 模块概念现在的程序越来越复杂，已经不可能将所有的程序写在一个文件里面了，一个是难以阅读，二个是不利于多人协作，所以有必要将代码分割在不同的部分，这些部分就叫做模块。 将代码分割为不同的模块以后，可以有如下好处： 不同的模块负责不同的功能，使得代码阅读起来更加清晰，并且维护起来也会比较简单 不同的模块有各自的作用域，可以避免全局变量发生冲突 利于多人协作，每个人开发属于自己的模块，最后组合为一个大的程序 代码复用，可以将一些与业务无关的工具函数抽离出来，在别的项目中进行复用 将代码进行分割以后，还需要将代码组合起来，让它们协作得以工作。 要使得模块能够互相协作，就需要模块能够暴露给其他模块访问该模块内部的一些变量，将这些变量暴露给其他函数的行为就是导出；而导入与导出相对，将其他模块暴露出的变量引入到本模块，使得本模块能够访问其他模块暴露出的变量，这个行为就是导入。 导出在 Node.js 中，一个 .js 文件就是一个模块，在每个模块中，都有一个 module 对象，module 对象有一个 exports 属性，该属性会被作为该模块的导出内容 // alice.jsmodule.exports = &#123; name: \"Alice\", age: 18, gender: \"female\"&#125; 例如在上面，我们设置 module.exports 为一个对象，这个对象就是对外暴露的内容，可以在其他模块中导入这个对象并使用。 在每一个模块中，还有一个名为 exports 的变量，它是 module.exports 的引用，你可以看做在每个模块的开头都有这么一行代码 let exports = module.exports; 它的提出是为了简写方便 // bob.jsconst name = \"Bob\";const age = 20;const gender = \"male\";module.exports.name = name;module.exports.age = age;module.exports.gender = gender; 上面我们通过为 module.exports 的属性赋值，从而将本模块内的几个变量暴露出来给其他模块访问，上面的 module.exports 通通可以替换为 exports // bob.jsconst name = \"Bob\";const age = 20;const gender = \"male\";exports.name = name;exports.age = age;exports.gender = gender; 但是经常有新手有如下错误的写法 // bob.jsconst name = \"Bob\";const age = 20;const gender = \"male\";exports = &#123; name: name, age: age, gender: gender&#125; 上面通过给 exports 变量赋值为一个对象，希望将本模块的一些变量导出，但是在其他模块中导入该模块时，发现导入的只是一个空对象，这往往让新手百思不得其解，其实稍加分析就可以知道为什么。 要明白上面的写法为什么是错误的，我先再次强调，模块导出的是 module.exports 这个变量，而 exports 只是一个引用，指向 module.exports。所以当我们通过 exports.xxx 的方式添加属性时，也就是相当于为 module.exports 这个对象添加属性，所以被添加的属性可以被导出；但是当我们为 exports 赋予一个新的值的时候，exports 不在是 module.exports 的引用，并且 module.exports 并不会发生任何的改变，导出的内容也不会如预期那般。 如果想直接导出一个对象，请直接使用 module.exports，或者通过 exports.xxx 的方式一个个的添加属性。 如果实在搞不懂 exports，那么请忘了它，影响不大。 导入我们使用 require 这个函数来导入其他模块暴露出来的变量 // index.jsconst alice = require('./alice.js');console.log(alice.name); // Alice 上面我们通过 require 导入了 alice.js 这个模块，其实导入的内容就是 alice.js 中的 module.exports，我们使用变量 alice 进行接收。如果我们并不需要导入模块的所有内容，只是需要其中的某个属性，例如上面我们只是需要 name 这个属性，我们可以使使用 ES6 的解构语法获得需要的属性 // index.jsconst &#123; name &#125; = require('./alice.js');console.log(name); // Alice 当我们导入一个模块的时候，首先会先执行这个模块 // a.jsconsole.log(\"a.js\");//b.jsrequire('./a');console.log(\"b.js\"); 输出为 a.jsb.js 注意到，我们可以省略后缀名，当我们省略后缀名时，它将根据下面的顺序查找文件 是否有 a.js 文件，是否有 a.json 文件，是否有 a.node 文件 是否有一个名字为 a 的文件夹，下面有一个 package.json 文件并且有 main 字段，如果有则根据 main 字段指明的路径去加载文件 是否有一个名字为 a 的文件夹，下面有一个 index.js 如果按照以上顺序都没有找到文件，那么会抛出一个错误。 npm我们在手机上下载软件时，一般都是从应用商店下载软件，不会去某个软件的官网去下载，大家都把软件放在应用商店中，大家只要去商店里面下载即可了。同样，当我们需要用到其他人编写的第三方模块时，我们也希望有一个商店让我们去下载，我们不要去每个官网一个个的下载。 并且程序比软件下载更加的复杂，体现在包的依赖关系。本着不造轮子的原则，很多的程序都是直接使用别人已经写好的代码，所以代码之间可以说有非常复杂的依赖关系。我们可能需要一个 a 包帮我们做事情，但是 a 包又依赖于 b 这个包，b 包又依赖于 c 包，等等。所以为了使得我们的 a 包能够工作，我们还需要下载好 b 包、c 包等等这些被依赖的包。这就会带来问题，例如我们不知道 a 包依赖于什么包，以及即使我们知道 a 包依赖于这些包，一个个的下载这些包是否是一件极其无聊的工作。 基于以上几点，我们迫切需要一个包管理工具帮助我们。在 Node 中，Node Package Manager (npm) 正是用来做到这一点的，我们不仅可以通过它下载需要的包，并且它还会根据包的依赖关系，自动的帮我们下载好其他被依赖的包。 那么包是什么? 比较正式的定义：包是一个由 package.json 定义的文件或目录。假设有一天，你写了一个有用的工具，希望分享给大家，这个程序肯定不只是一个文件的代码，是多个模块的组合，即你分享的不是一个文件，而是一个文件夹，其中包括了这些模块。 那么 package.json 又是什么呢? 你可以把它看做是一个配置文件，其中记录了该工具的信息，例如版本，名称，作者等等内容，最重要的是，它记录了你写的工具依赖了哪些其他的第三方模块，这样当别人下载你的包时会根据 package.json 标注的依赖下载所依赖的包。 那么在 Node.js 中可以直接引入一个文件夹吗? 答案是可以的，Node.js 中的模块可以是如下三种： 一个文件(.js, .json, .node) 一个包含 package.json 文件并且定义了 main 字段的文件夹 一个包含 index.js 的文件夹 所以，我们可以直接使用 require 导入一个包，它会根据 main 字段指明的地址去加载 .js 文件。 npm init下载介绍 npm 在命令行中的使用，当我们下载好了 Node.js，一般都是会自动安装好 npm 的，我们可以在命令行通过 npm --version 查看 npm 的版本号 λ npm --version6.14.8 我们写一个项目，就肯定需要准备一个 package.json 文件，你可以手动创建该文件，或者通过 npm init 命令创建一个模板，一般情况下我们都会使用 npm init 来创建一个 package.json 文件 在我们输入 npm init 后，它会引导我们创建一个 package.json 文件，填写一些常见的信息，例如包名、版本、作者等等，当这些都执行完毕后，在目录下回出现一个 package.json 文件，其内容如下 &#123; \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"Node Demo\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"XT\", \"license\": \"MIT\"&#125; 这些内容都是我们在命令行中填写的内容。如果希望快速创建一个 package.json 文件，所以配置项采用默认配置，我们可以使用 npm init -y，传入 -y 表示所有的配置项采用默认配置。 npm install使用 npm install 可以下载包，下载的包分为三种： 全局安装 本地安装 本地依赖 开发依赖 不同依赖的包在下载时需要传入不同的参数。 全局安装全局安装的包可以在命令行直接执行，对于需要全局依赖的包，我们要传入 --global 参数或者 -g 参数，例如我们下载一个 nrm 的包，这个包是用来设置镜像源的，因为 npm 的服务器在国外，下载速度很慢，所以我们需要设置 npm 下载的镜像源 npm install -g nrm 它会将这个包下载到 C:\\Users\\username\\AppData\\Roaming\\npm\\node_modules 这个文件夹下面，并且会在 C:\\Users\\username\\AppData\\Roaming\\npm\\ 生成对应的 .cmd 文件，例如当我们全局安装 nrm 之后就会在 npm 文件夹下生成 nrm.cmd 文件 因为 C:\\Users\\username\\AppData\\Roaming\\npm\\ 这个文件夹在安装 npm 的时候就会被自动的添加到环境变量中，当我们在命令行输入 nrm 的时候，它就会在这个路径搜索 nrm 命令，然后执行，这就是全局安装的包能够在命令行直接执行的原因。 我们在命令行输入 nrm ls 它会显示出有哪些可用的镜像源 我们一般选择 taobao 或者 cnpm 镜像源，通过 nrm use 镜像源的方式选择镜像源 nrm use taobao 这里讲述我遇到的一个坑，我之前是下载好 nrm 的，为了演示我把之前下载好的 nrm 卸载掉，然后重新装了一遍，装了一遍之后发现 nrm 不好使了，开始报错 咱也不知道为啥，错误提示也看不懂，就去上网搜，说要改变 cli.js(C:\\Users\\username\\AppData\\Roaming\\npm\\node_modules\\nrm\\cli.js) 的第 17 行 上面的一行是原来第 17 行的内容，后面一行是修改后的内容，贴在下面 const NRMRC = path.join(process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'], '.nrmrc'); 如果你也遇到了这个问题，按照上面的方法改吧，亲测有效。 本地安装通过上面的分类我们可以看到，本地安装也分为两类，一种是开发依赖，意思就是仅仅在开发的时候才依赖的包，上线之后这个包就不需要了。例如压缩文件，这个包在编译的时候需要，但是在生产环境下，我们就使用这个压缩好的文件，就不需要压缩文件了，所以这个压缩文件的包只在开发(编译)时需要。另一种本地依赖的包是只在本地开发时以及上线后都需要依赖的包，比如在程序中依赖的一些库。 当我们下载开发时依赖的包时，需要传入 --save-dev 或者 -D 参数，当我们下载本地依赖的包时，传入 --save 或者 -S 参数，也可以不传，不传的情况下默认是本地依赖。 我们随便下载两个包 我们再查看 package.json 文件 &#123; \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"Node Demo\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"XT\", \"license\": \"MIT\", \"dependencies\": &#123; \"webpack\": \"^5.21.1\" &#125;, \"devDependencies\": &#123; \"ora\": \"^5.3.0\" &#125;&#125; 发现多了 dependencies 以及 devDependencies 两个属性，dependencies 中的属性是本地依赖的包，以及对于的版本号，而 devDependencies 中的属性是开发时依赖的包，以及对应的版本号。 细心的话，还会发现多了一个 package-lock.json 文件，里面不仅给定了当前项目的依赖，例如上面安装的 webpack 以及 ora，还给定了依赖的依赖以及它们的版本号，就是 webpack 以及 ora 它们所依赖的包。 所以为什么需要 package-lock.json 文件? 要明白为什么需要这个文件，就需要明白它的作用是什么。它的作用是为了锁定版本号的，例如上面我们安装 webpack 对于的版本号为 ^5.21.1，其中 ^ 表示向后兼容，所以如果没有 package-lock.json，实际安装的版本号可能是最新的版本，比 5.21.1 的版本要高，这就可能会因为版本的不一致导致各种问题(我遇到过很多次)，所以需要一个 package-lock.json 来记录具体的版本号。 这时我们甚至可以将 node_modules 这个文件夹给删掉，然后运行 npm install 即可将所依赖的包给安装回来，所以很多时候我们从 Github 上下载项目时，会发现没有 node_modules 文件夹，它要你在本地先运行 npm install 命令，将 package.json 中描述所依赖的包下载下来，然后在启动项目。 npm install 是根据 package.json 文件还是 package-lock.json 文件进行安装包的呢? 这个问题你在网上搜可能会得到不同的结论，这是因为安装策略有过三次调整： npm 5.0.x 版本，npm install 根据 package-lock.json 文件下载 然后被控诉为什么改了 package.json 文件，为啥不给我升级包 npm 5.1.0 版本后，忽略 package-lock.json 文件，只根据 package.json 文件下载 那 package-lock.json 文件有什么用 npm 5.4.2 版本后 如果 package-lock.json 与 package.json 描述的版本号不同(为什么会不同，因为手动改了 package.json 文件)，那么根据 package.json 版本进行下载，并且更新 package-lock.json 文件 如果相同，那么根据 package-lock.json 进行下载，不必理会 package.json 中依赖的包是否有更新 与 npm install 相对的是 npm uninstall 命令，是用来卸载包的，例如 npm uninstall webpack --save npm scripts在 package.json 中有一个 scripts 字段，它是一个对象，它的每一个属性都对应一个脚本 &#123; // ... \"scripts\": &#123; \"build\": \"node build.js\" &#125;&#125; 当我们在当前项目的下输入 npm run build 就相当于运行了 node build.js 这些定义在 package.json 里面的脚本，我们称之为 npm scripts。 使用 npm scripts 有如下优点： 项目中的脚本集中放置在一处 不同的项目可能有不同的构建命令，但是可以通过 npm scripts 向外提供统一的接口，如 npm run build 深入模块导入路径当我们导入其他模块时，可以指定模块的具体路径，例如 ./a.js，通过相对路径或者绝对路径均可，但是如果我们没有指定路径，如 require(&#39;a&#39;)，会以何种方式去搜寻该包。 我们可以通过 module.paths 这个属性查看搜索的路径 // D:\\Desktop\\node-demo\\a.jsconsole.log(module.paths); 输出为 [ 'd:\\\\Desktop\\\\node-demo\\\\node_modules', 'd:\\\\Desktop\\\\node_modules', 'd:\\\\node_modules'] 可见它会先搜索文件所在目录下的 node_modules 文件夹，如果搜索不到则搜索上级目录的 node_modules 文件夹，直至根目录的 node_modules 文件夹，如果在这些路径都没有找到指定的包，那么就会抛出一个错误。 缓存在导入部分我们说过，当我们导入一个模块时，首先会执行这个模块，在实际的项目中肯定会有多个模块依赖于一个模块的情形，这是不是说每次导入这个模块时，这个模块都会被执行一次? 明显这样不对，所以其实这个模块只会执行一次，然后它的 module.exports 属性就会被缓存，如果第二次、第三次导入这个模块时，直接将缓存的 module.exports 属性返回即可，不必再次执行一次这个模块。 通过 require.cache 这个属性可以知道有哪些 module 对象被缓存起来了，require.cache 是一个对象，其键值是模块的绝对地址，值为 module 对象，在我们 require 模块的时候，如果在 require.cache 对象发现这个模块已经被加载过，那么直接返回这个模块即可，而不必再次执行这个模块。 主程序一个模块被执行有两种情况： 通过 node 命令直接执行该模块 被其他模块导入 通过 node 命令执行的模块我们称之为主模块，有时候我们希望根据模块是否是主模块来表现不同的行为，所以我们需要一种方法来分辨该模块是不是主模块，我们可以通过 require.main 属性来判断一个模块是不是主模块，如果 require.main 的值与当前模块的 module 对象相同，就说明当前模块时主模块 if (require.main === module) &#123; console.log(\"主模块\");&#125; else &#123; console.log(\"非主模块\");&#125; 循环引用最后我们要探讨一下，Node.js 对模块的循环引用如何解决，所谓的循环引用就是指二者互相引用 // a.jsrequire('./b.js')//b.jsrequire(\"./a.js\") 如上 a.js 与 b.js 互相引用，我们称之为循环引用，那这样会不会形成死循环，程序如何能执行下去。 解释这个问题很简单，只需要牢牢的抓住缓存即可，因为有缓存的存在，并不会无限的去执行文件导入，而是直接去缓存中的值。假设有如下的程序 // a.jsexports.done = false;const b = require('./b.js');console.log(\"b.done: \", b.done); // trueexports.done = true;// b.jsexports.done = false;const a = require(\"./a.js\");console.log(\"a.done: \", a.done); // falseexports.done = true;// index.jsconst a = require(\"./a.js\");const b = require(\"./b.js\");console.log(\"a.done: \", a.done); // trueconsole.log(\"b.done: \", b.done); // true 我们执行 index.js，执行过程如下： 执行 index.js，导入 a.js 执行 a.js，并缓存 a.js 的 module.exports 设置 exports.done 为 false 导入 b.js 执行 b.js，并缓存 b.js 模块 在 b.js 中导入 a.js，此时因为 a.js 这个模块已经被缓存，所以取缓存即可 因为 a.js 模块此时的 done 属性为 fasle，所以打印的结果为 false 回到 a.js，取到 b.js 模块导出的module.exports，这个对象的 done 属性为 true，因此打印结果为 true 回到 index.js，导入 b.js 模块，该模块已经被缓存，直接取缓存结果 此时 a.js 与 b.js 中的 exports.done 属性均为 true，打印结果均为true 参考链接 Node.js 究竟是什么 Node.js 的模块系统 Node.js 中的包和模块 npm install 到底做了什么 通过 npm 制作命令行工具的原理 nrm 报错 [ERR_INVALID_ARG_TYPE] 解决方法 npm install 生成的 package-lock.json 是什么文件? 有什么用? npm scripts 使用指南","tags":[{"name":"模块","slug":"模块","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%A8%A1%E5%9D%97/"},{"name":"npm","slug":"npm","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/npm/"},{"name":"循环引用","slug":"循环引用","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"}]},{"title":"ES6：Symbol 和 Symbol 属性","date":"2021-02-02T09:58:00.000Z","path":"/ES6：Symbol 和 Symbol 属性/","text":"在 ES6 中引入一种新的原始类型，那就是 Symbol 。Symbol 类型的值唯一的，每个被创建出来的 Symbol 变量都是不同的，这是 Symbol 这种数据类型最大的特点。 创建Symbol 不能通过字面量来进行创建，创建 Symbol 变量需要通过 Symbol() 来创建 let x = Symbol();console.log(typeof x); // symbol let x = Symbol();let y = Symbol();console.log(x == y); // false Symbol 类型的变量可以作为对象的属性，因为每一个 Symbol 变量是唯一的，所以不会出现属性被别人覆盖的问题，以及可以设置为私有属性，别人无法访问 let x = Symbol()let person=&#123; [x]: 'Alice'&#125;console.log(person[x]); // Alice Symbol 还可以接收一个字符串作为该 Symbol 变量的描述，该字符串纯粹是为了调试方便而设置的，没有特殊的功能，两个 Symbol 类型的变量的描述符相同不代表它们是相同，每一个由 Symbol() 创建的变量都是不同的。 let name = Symbol(\"Alice\");let alice = Symbol(\"Alice\");console.log(name == alice); // false 使用Symbol 类型的变量可以作为对象的属性，不仅可以在对象的字面量中通过计算属性进行设置属性，还可以通过 Object.defineProperty 和 Object.defineProperties 对对象进行定义 let first = Symbol(\"first\");let alice = &#123; [first]: 'Alice'&#125;Object.defineProperty(alice, first, &#123; writable: false&#125;)let last = Symbol(\"last\")Object.defineProperties(alice, &#123; [last]: &#123; value: 'Lee', writable: false &#125;&#125;)console.log(alice[first]);console.log(alice[last]); 共享有的时候代码中需要共享一个 Symbol，ES6 提供了一个全局的 Symbol 管理机构，我们可以在任何时候访问它。我们是通过 Symbol.for 方法来访问这个全局机构的，Symbol.for 接收一个字符串参数，根据这个字符串参数在全局机构中查找对应的 Symbol，如果找到了就返回，如果没有找到，则在全局机构中新建一个 Symbol 并返回。 // 此时根据字符串 \"id\" 查不到 Symbol// 会新建一个 Symbol 并返回let id = Symbol.for(\"id\");console.log(typeof id); // symbol// 此时可根据 \"id\" 查找到 Symbol，返回// 返回的 Symbol 与上次根据 \"id\" 创建的 Symbol 是同一个 Symbollet id2 = Symbol.for(\"id\");console.log(id2 == id); // true 与 Symbol.for 方法向对应的是 Object.keyfor，它是根据接收的 Symbol 来获得在全局机构中对应的字符串，如果全局机构中没有该 Symbol，则返回 undefined let uid = Symbol.for(\"uid\");console.log(Symbol.keyFor(uid)); // \"uid\"let uid2 = Symbol.for(\"uid\");console.log(Symbol.keyFor(uid2)); // \"uid\"// 不是通过 Symbol.for 从全局获得的 Symbollet uid3 = Symbol(\"uid\");console.log(Symbol.keyFor(uid3)); // undefined Symbol 类型不能转为其他原始类型，其他原始类型也不能转为 Symbol 类型，强行转换会抛出错误。 获取 Symbol 属性Symbol 变量可以作为对象的属性，但是当我们通过 for…in 以及 getOwnPropertyNames 都不能获得 Symbol 属性 let age = Symbol(\"age\");let person = &#123; name: \"Alice\", [age]: 28,&#125;for(let key in person) &#123; console.log(key); // name&#125;console.log(Object.getOwnPropertyNames(person)); // [ 'name' ] 要获得 Symbol 类的属性，要通过 Object.getOwnPropertySymbols 方法 console.log(Object.getOwnPropertySymbols(person)); // [ Symbol(age) ] 通过 Symbol 暴露内部操作在以往一些内部操作我们是更改不了的，例如对于 instanceof 运算符，我们无法改变它的行为(虽然大多数的时候不需要更改，但是有的时候有这个需求)，现在ES6 将会暴露这些内部操作给我们，使得我们有机会改变一些默认的内部操作。 我们改变内部操作是通过改变对象的一些 Symbol 属性来决定的，例如改变对象 Symbol.hasInstance 属性可以改变 instanceof 行为，一些常见的Symbol 如下： Symbol.hasInstance Symbol.isConcatSpreadable Symbol.iterator Symbol.match Symbol.replace Symbol.search Symbol.species Symbol.split Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables Symbol.hasInsatnceinstanceof 是用来判断某个对象是否是某个函数的实例，如果该函数在这个对象的原型链上，那么这个对象就是这个函数的实例。在 ES6 中，我们可以 Symbol.hasInstance 来改变这一默认行为 obj instanceof Array// 相当于Array[Symbol.hasInstance](obj) 通过改变构造函数的 Symbol.hasInstance 属性，即可改变这一行为。 必须通过 Object.defineProperty 来重写 Symbol.hasInstance function Person(name) &#123; this.name = name;&#125;let alice = new Person(\"alice\");// 默认行为console.log(alice instanceof Person); // true// 更改 instanceof 行为Object.defineProperty(Person, Symbol.hasInstance, &#123; value: function(instance) &#123; return false; &#125;&#125;)console.log(alice instanceof Person); // false Symbol.hasInstance 方法接收一个参数，这个参数就是 instanceof 前面的那个对象 Symbol.isConcatSpreadable要明白这个属性的作用，得要了解数组的 concat 方法，concat 方法的作用是将两个数组拼接起来，然后返回一个新的数组 let colors1 = [\"red\", \"green\"];let colors2 = colors1.concat([\"white\", \"blue\"]);console.log(colors2); // [ 'red', 'green', 'white', 'blue' ] concat 除了可以接受数组作为参数，还可以接受非数组参数 let colors1 = [\"red\", \"green\"];let colors2 = colors1.concat([\"white\", \"blue\"], \"pink\");console.log(colors2); // [ 'red', 'green', 'white', 'blue', 'pink' ] “pink” 作为非数组参数传入，成为了 colors2 数组的第五个元素。为什么数组参数被区别对待(数组参数为什么不是整体拼接到数组中)，因为 JavaScript 规定了数组会被自动的被分割为独立的元素，而其他元素不会。 当我们向 concat 传递一个对象，根据的对象的 Symbol.isConcatSpreadable 来决定是作为整体拼接，还是将对象分割然后添加到数组中。能被自动分割的对象满足两个条件： 有 length 属性(根据 length 属性决定分割为多少个元素) Symbol.isConcatSpreadable 的值为 true 那么就会将对象中的数字属性分割为一项项添加进数组 let colors1 = [\"red\", \"green\"];let obj = &#123; 0: \"blue\", 1: \"white\", length: 2, name: \"obj\", **[Symbol.isConcatSpreadable]: true**&#125;let colors2 = colors1.concat(obj);console.log(colors2); // [ 'red', 'green', 'blue', 'white' ] Symbol.match, Symbol.replace, Symbol.search, Symbol.splitstring 类型有几个接受正则表达式的方法： match(regex) replace(regex, replacement) search(regex) split(regex) 现在 ES6 允许使用对象来代替上面的正则表达式(regex)，从而可以自定义匹配行为，以此达到自己不可告人的目的。以 match 为例，当字符串调用 match 方法传入一个对象时，会调用对象的 Symbol.match 方法，并将自己作为参数传入，Symbol.match 的返回结果作为字符串 match 方法的返回结果 let obj = &#123; [Symbol.match]: function(str) &#123; return str.length === 10 ? [\"Hello Alice!\"] : null &#125;&#125;let str = \"HelloWorld\".match(obj);console.log(str); // [ 'Hello Alice!' ] 其他的三个方法 replace, search, split 分别对应于 Symbol.replace, Symbol.search, Symbol.split，其使用方法与 match 类似。 Symbol.toPrimitive在实际中我们经常需要将对象转化为原始类型，例如对一个对象做加法，那么就会触发将对象转化为原始类型的步骤。根据对象需要转化为数字还是字符串，有两种不同的行为。如果需要转化为数字，遵循以下步骤： 调用对象的 valueOf 方法，如果返回的是原始类型，则返回 否则，调用对象的 toString 方法，如果返回的是原始类型，则返回 否则，抛出错误 如果需要转化为字符串的话，遵循以下步骤 调用对象的 toString 方法，如果返回的是原始类型，则返回 否则，调用对象的 valueOf 方法，如果返回的是原始类型，则返回 否则，抛出错误 大多数情况下都是默认转化为数字，少数对象如 Date 对象默认转化为字符串。 我们发现转化为数字和字符串时 valueOf 和 toString 方法的调用顺序不同，为了统一将对象转化为对象的行为，可以通过 Symbol.toPrimitive 覆盖默认的转化顺序，以统一转化行为。 Symbol.toPrimitive 方法接收一个 hint 作为参数，hint 是一个字符串，它只有三种取值 string number default 根据对象需要被转化为什么类型的原始字符串，hint 的取值不同，例如当对象处在需要转化为数字的上下文中，hint 的值就是 number，需要转化为字符串时，hint 就是 string，当不确定需要转化为什么时(例如加法运算，既可以用于字符串连接，也可以用于数字相加)，hint 的值就是 default let obj = &#123; [Symbol.toPrimitive]: function(hint) &#123; switch(hint) &#123; case 'number': return 10; case 'string': return \"hello\"; case 'default': return 'default'; default: throw new Error(); &#125; &#125;&#125;const print = console.log;print(1 * obj); // 10print(`$&#123;obj&#125;`); // helloprint(obj + \"\"); // default Symbol.toStringTag当我们调用自己创建的对象的 toString 方法时，得到的是 [object Object] let Person = &#123; name: 'Alice'&#125;console.log(Person.toString()); // [object Object] 如果我们希望打印出 [object Person]，那么可以借助于 Symbol.toStringTag let Person = &#123; name: 'Alice'&#125;Person[Symbol.toStringTag] = \"Person\"console.log(Person.toString()); // [object Person]","tags":[{"name":"Symbol","slug":"Symbol","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Symbol/"}]},{"title":"图","date":"2021-01-29T18:37:00.000Z","path":"/图/","text":"图的表示首先我们来看看图的数据结构长什么样子 一个图它由顶点 Vertex 和边 Edge 组成，上图蓝色的节点表示顶点，而节点与节点之间的有条线连着，这就是顶点之间的边。为了在计算机中表示图，我们给图的顶点编了号，从 $0$ 开始。在实际的模型中，顶点可能表示的是一个地铁站点，社交网络中的一个人，我们可以通过哈希表将编号与顶点实际的意义映射起来，进而把顶点的具体意义抽象为编号或者下标，当图的顶点以编号表示时，它就不具有具体的意义，从而我们可以研究图的一般理论，而当我们需要结论的具体意义时，可以通过哈希表将编号映射为具体的意义。 图的分类根据边是否有方向可以分为有向图和无向图，根据边上有否有权值可以分为有权图和无权图 有向 无向 有权 有向有权图 无向有权图 无权 有向无权图 无向无权图 图的基本概念在进入正题之前，简单的介绍一下在后面会遇到的关于图的基本概念。 自环边：图中有一个顶点有条边指向自己 平行边：两个顶点之间有两条边 如果一幅图既没有自环边，也没有平行边，我们就称该图为简单图。我们只处理简单图，如果图中有自环边或者平行边，我们会忽略这种边，或者抛出异常。 在一个图中，并不是所有的顶点都是联通的，如下 例如顶点 6-7 和顶点 0-5 之间是不联通的，像上面这样的图，我们认为它有两个联通分量，顶点 0-5 和顶点 6-7 分别代表一个联通分量。 另外，根据图中是否有环，我们可以将图分为有环图和无环图 最后介绍一个有关图的概念，那就是度(degree)，对于无向图和有向图，度的定义是不同的，这里我们介绍无向图关于度的定义，度指的是某个顶点有多少个邻边，度是顶点的属性。比如对于下图 顶点 $0$ 的度为 $2$，因为顶点 $0$ 有两个邻边，同理，顶点 $2$ 的度为 $3$，因为它有三个邻边。 图的表示所谓图的表示，就是指如何在计算机中保存一个图的数据结构 如上图，怎么将它保存在计算机中。如果学习过其他数据结构的话，如栈，队列，树，它们是怎么表示的呢? 对于栈和队列这种线性的数据结构，我们一般使用数组或者链表来进行存储，而对于树这种数据结构，我们一般使用链表进行表示，每个节点都有两个指针分别指向它的左孩子和右孩子，当然对于某些树结构，如堆、线段树，我们也可以使用数组来进行表示，因为这两种数据结构都是满二叉树，它们的孩子节点与父节点之间含有某种关系，可以十分方便的使用数组进行表示。 邻接矩阵首先我们介绍使用一个矩阵来存储图，如果整个图有 $V$ 个节点，那么我们就用 $V \\times V$ 大小的矩阵来存储图，假设这个矩阵记做 $A$，如果 $A[i][j] = 1$，则说明顶点 $i$ 与顶点 $j$ 之间存在一条边，反之如果 $A[i][j] = 0$，则说明顶点 $i$ 与顶点 $j$ 之间不存在一条边 因为不存在自环边，所以 $A[i][i]$ 的值一定为 $0$，即矩阵对角线上的值一定是 $0$。 在构建一张图时，我们会读取一个 txt 的文件，根据这个文件我们使用矩阵来存储一张图，例如上图所对应的 txt 内容如下 6 70 10 21 32 32 43 54 5 这个 txt 表示什么意思呢? 第一行的两个数字表示图中的顶点数和边数，如上图有 $6$ 个顶点和 $7$ 条边，后面每行的两个数字表示两个顶点，表示这两个顶点之间存在一条边，如第二行就表示顶点 $0$ 和顶点 $1$ 之间存在一条边，因为总共有 $7$ 条边，所以第一行后应该有 $7$ 行表示有 $7$ 条边。 代码如下： import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;public class AdjMatrix &#123; // 图的边数 private int E; // 图的顶点个数 private int V; // 表示图的矩阵 private int[][] matrix; public AdjMatrix(String filename) &#123; // 从文件中读取图的数据 File file = new File(filename); Scanner scanner = null; try &#123; // 第一行是顶点数和边数 scanner = new Scanner(file); this.V = scanner.nextInt(); matrix = new int[this.V][this.V]; this.E = scanner.nextInt(); for (int i = 0; i &lt; this.E; i++) &#123; // 读取两个相邻的顶点 int a = scanner.nextInt(); int b = scanner.nextInt(); // 设置为 1 表示相邻 this.matrix[a][b] = 1; this.matrix[b][a] = 1; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; // 当打印对象时，将矩阵打印出来 @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int i = 0; i &lt; this.V; i++) &#123; for (int j = 0; j &lt; this.V; j++) &#123; stringBuilder.append(String.format(\"%d \", this.matrix[i][j])); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; AdjMatrix adjMatrix = new AdjMatrix(\"g.txt\"); System.out.println(adjMatrix); &#125;&#125; 打印结果为 V: 6, E: 70 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 1 0 0 1 1 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 AdjMatrix 类有三个属性 属性 含义 V 表示顶点数 E 表示边数 matrix 表示图的矩阵 但是上面的程序还不够健壮，因为我们没有对 g.txt 中读到的数字进行校验，例如读到的顶点个数为负数，读到的顶点编号不合理，例如有 $5$ 个顶点，但是它的编号为 $10$。另外，我们只处理简单图，对于自环边以及平行边也没有进行处理，所以我们需要对上面的代码进行改进 import java.io.File;import java.io.FileNotFoundException;import java.util.ArrayList;import java.util.Scanner;public class AdjMatrix &#123; private int E; private int V; private int[][] matrix; public AdjMatrix(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); // 如果读取到的 V 和 E 小于 0，那么抛出异常 this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; matrix = new int[this.V][this.V]; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; for (int i = 0; i &lt; this.E; i++) &#123; // 对读取到的顶点编号进行验证，是否在 [0, V) 的范围中 int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); // 如果存在自环边，抛出异常 if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; // 如果存在平行边，抛出异常 if (this.matrix[a][b] == 1) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; this.matrix[a][b] = 1; this.matrix[b][a] = 1; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; // 对顶点编号进行验证，是否合法 private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; // 返回顶点数 public int V() &#123; return this.V; &#125; // 返回边数 public int E() &#123; return this.E; &#125; // 返回与顶点 v 相邻的所有顶点 public ArrayList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; this.V; i++) &#123; if (this.matrix[v][i] == 1) &#123; res.add(i); &#125; &#125; return res; &#125; // 判断顶点 v 和 w 是否相邻 public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return this.matrix[v][w] == 1; &#125; // 返回顶点 v 的度，即与顶点 v 相邻的顶点的个数 public int degree(int v) &#123; return adj(v).size(); &#125; // toString 不变，节省篇幅，省略&#125; 在上面我们对读取到的数字都进行了检查，保证了代码的健壮性。除了增强了代码的健壮性以外，我们还在类中添加了五个方法，具体作用见下表 方法 作用 int V() 返回图的顶点数 int E() 返回图的边数 ArrayList adj(int v) 返回与顶点 v 相邻的顶点 boolean hasEdge(int v, int w) 判断两顶点是否相邻 int degree(int v) 返回顶点 v 的度 在最后我们分析一下使用邻接矩阵表示的空间复杂度和时间复杂度 空间复杂度：$O(V^2)$ 时间复杂度： 建图：$O(E)$ 获得与顶点 $v$ 相邻的顶点：$O(V)$ 查看两个顶点是否相邻：$O(1)$ 对于建图来说，因为我们必须扫描所有的边才能获得必要的信息，所以建图的时间复杂度最少也是 $O(E)$，无法再优化；而查看两个顶点是否相邻，时间复杂度为 $O(1)$，无需优化，那么我们看看空间复杂度和获得与顶点 $v$ 相邻的顶点的时间复杂度能否进行优化。 因为我们平常遇到的图都是稀疏图，所谓稀疏图就是一幅图它的度平均值对于图的节点数目来说很小，这就会导致我们的邻接矩阵是一个稀疏矩阵，即大部分的元素是 $0$。例如对于一个社交网络，有一亿个节点，但是对于每个人来说，他认识的人最多几百个，也就是这幅图平均的度为几百，相对于一亿来说十分的小，所以社交网络是一个稀疏图。 建立一个图，我们只需要知道一幅图的顶点信息以及边的信息即可，也就是说我们只需要 $O(V + E)$ 的空间复杂度就可以表示一幅图，对于稀疏图来说，由于图的每个顶点度的平均值远远小于节点数，而 $E$ 的大小等于平均度的值乘以节点数，即$$E = degree * V$$从而有$$degree \\ll V \\Rightarrow E \\ll V^2$$得到$$O(V + E) \\ll O(V^2)$$所以使用邻接矩阵表示图，对于稀疏矩阵来说，其实浪费了很多的空间，下面将介绍使用另一种方法表示图，无论是对于稀疏图还是稠密图，都可以有更好的性能。 邻接表在这个小节中将讲解使用邻接表来表示矩阵，所谓的邻接表，是指对于每个顶点来说，我们使用一个链表来记录与它相邻的节点，如下图 图中表格第一列表示顶点编号，顶点编号后的一行表示与该顶点相邻的顶点，例如对于第一行，表示与顶点 $0$ 相邻的顶点有顶点 $1$ 和 $2$。 现在我们就要编码实现，因为大部分的逻辑与邻接矩阵是相同的，所以很多的代码与邻接矩阵表示的方式是一样的，不过因为底层保存图使用的是链表，有一些写法的不同，在下面的代码中我也会标出 import java.io.File;import java.io.FileNotFoundException;import java.util.LinkedList;import java.util.Scanner;public class AdjList &#123; private int E; private int V; // 对每一个顶点，使用一个链表来存储与它相邻的顶点 private LinkedList&lt;Integer&gt;[] lists; public AdjList(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; // 初始化链表 this.lists = new LinkedList[this.V]; for (int i = 0; i &lt; this.V; i++) &#123; this.lists[i] = new LinkedList&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; for (int i = 0; i &lt; this.E; i++) &#123; int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; // 平行边的判断 if (lists[a].contains(b)) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; // 将相邻顶点添加到自己的链表中 this.lists[a].add(b); this.lists[b].add(a); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public LinkedList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); // 直接返回顶点自己的链表即可 return lists[v]; &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return this.lists[v].contains(w); &#125; public int degree(int v) &#123; return adj(v).size(); &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (int w: adj(v)) &#123; stringBuilder.append(String.format(\"%d \", w)); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; AdjList adjList = new AdjList(\"g.txt\"); System.out.println(adjList); &#125;&#125; 输出为 V: 6, E: 70 : 1 2 1 : 0 3 2 : 0 3 4 3 : 1 2 5 4 : 2 5 5 : 3 4 下面分析一下使用邻接表实现图的时间复杂度和空间复杂度： 空间复杂度：$O(V + E)$ 时间复杂度： 建表：$O(VE)$ 获得与顶点 $V$ 相邻的顶点：$O(degree)$ 判断两个顶点是否相邻：$O(degree)$ 建表的时间复杂度为 $O(VE)$，是因为每次我们都要扫描一遍表判断是否有平行边，判断两个顶点是否相邻的时间复杂度为 $O(degree)$，是因为需要遍历表来判断两个顶点是否相邻。上面两个操作都比使用邻接矩阵实现图的操作更加的费时，都是因为查找的能力比较慢(在建图时需要查重判断是否有平行边，判断两个顶点是否相邻时也需要在链表中进行查找)，所以我们是否有办法可以提高查找表的速度。 说到查找速度，不得不说哈希表和红黑树，所以我们可以考虑使用 HashSet 或者 TreeSet 来替代上面的 LinkedList，以此来提高查找速度，二者查找的时间复杂度如下 数据结构 查找时间复杂度 HashSet $O(1)$ TreeSet $O(\\log v)$ 从时间复杂度上看，使用 HashSet 是更好的选择，但是 TreeSet 有一个优点那就是有序性，这会带来两个优点 复现我的代码时可以得到与我一致的结果(输出的顺序) 当我使用图片解释算法过程时，输出的结果可以与我演示的结果一致，可以更好的理解算法 所以这里我选择 TreeSet。我们新建一个 AdjSet 类，复制 AdjList 的代码，将其中所有的 LinkedList 改为 TreeSet 即可，如下 import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;import java.util.TreeSet;public class AdjSet &#123; private int E; private int V; private TreeSet&lt;Integer&gt;[] sets; public AdjSet(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; // 初始化链表 this.sets = new TreeSet[this.V]; for (int i = 0; i &lt; this.V; i++) &#123; this.sets[i] = new TreeSet&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; for (int i = 0; i &lt; this.E; i++) &#123; int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; // 平行边的判断 if (sets[a].contains(b)) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; // 将相邻顶点添加到自己的链表中 this.sets[a].add(b); this.sets[b].add(a); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public TreeSet&lt;Integer&gt; adj(int v) &#123; validateVertex(v); // 直接返回自己的链表即可 return sets[v]; &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return this.sets[v].contains(w); &#125; public int degree(int v) &#123; return adj(v).size(); &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (int w: adj(v)) &#123; stringBuilder.append(String.format(\"%d \", w)); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; AdjSet adjSet = new AdjSet(\"g.txt\"); System.out.println(adjSet); &#125;&#125; 在最后我们做一个改进，观察三个类的 adj 方法 // AdjMatrixpublic ArrayList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; this.V; i++) &#123; if (this.matrix[v][i] == 1) &#123; res.add(i); &#125; &#125; return res;&#125;// AdjListpublic LinkedList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return lists[v];&#125;// AdjSetpublic TreeSet&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return sets[v];&#125; 这三个方法的返回值都不相同，这就会给使用者带来负担，它还需要记住每个类的返回值是什么，考虑到使用者拿到与顶点 $v$ 相邻的所有顶点，一般都是用来遍历，所以我们返回一个接口 Iterable，ArrayList LinkedList TreeSet 三个类都实现了该接口，如下 // AdjSet 其它两个类做相同修改public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return sets[v];&#125; 注意：记得还有修改 degree 方法，因为这是 adj 方法返回的是 Iterable 接口，该接口没有 size 方法，修改如下 public int degree(int v) &#123; validateVertex(v); return this.sets[v].size();&#125; 其它两个类做类似的修改。 总结在文章的最后，我们比较一下三种方法的空间复杂度和时间复杂度 空间 建图时间 两顶点是否相邻 查找顶点的邻边 邻接矩阵 $O(V^2)$ $O(E)$ $O(1)$ $O(V)$ 邻接表(LinkedList) $O(V + E)$ $O(EV)$ $O(degree)$ $O(degree)$ 邻接表(TreeSet) $O(V + E)$ $O(E\\log V)$ $O(\\log degree)$ $O(degree)$ 由上可见，底层使用 TreeSet 的邻接表来表示图，从空间和时间上都非常的优秀，在后面的文章，都将使用 TreeSet 版本的邻接表来表示图。 后面为了屏蔽差异，我们定义一个 Graph 的接口，这三个类都实现 Graph 接口，Graph 接口如下 public interface Graph &#123; int V(); int E(); int degree(int v); boolean hasEdge(int v, int w); Iterable&lt;Integer&gt; adj(int v);&#125; 图的深度优先遍历所谓图的遍历就是按照某种顺序访问图中所有的节点，根据访问的顺序不同，可以分为两类： 深度优先遍历 广度优先遍历 在本节中讲解深度优先遍历。 所谓深度优先遍历(Depth First Search，简称 DFS)，是指在遍历时，尽可能深的访问图的节点。为了更好的理解图的深度优先遍历，我们先看看树的深度优先遍历，与图的深度优先遍历一样，树的深度优先遍历也是指尽可能深的访问树的节点，也就是说如果一个节点有孩子节点，那么我们下一步就应该遍历它的孩子节点(深度)，如下 从上面的动图可以看出，当我们遍历完当前节点以后，如果该节点有孩子节点，那么接下来我们去遍历孩子节点，我们的遍历策略就是尽可能深的遍历。类比于图，对于图来说，如果一个图的节点有邻接节点，那么在遍历完该节点后，我们下一步就去遍历它的邻接节点 这就是图的深度优先遍历，上图深度优先遍历访问的顺序是 $[0, 1, 3, 2, 4, 5]$，我们将在下面的编程中验证是否正确。 图的遍历与树的遍历有一处不同，那就是重复访问问题。树不会发生重复访问的问题，这是因为树的节点只能通过父节点访问到，只有一种路径到达该节点，所以我们不必担心；但是对于图来说，一个图中的节点可以与多个节点进行连接，这就意味着有多种路径到达该节点，这就会导致某节点已经通过一个相邻的节点被访问，但是它还是有可能通过别的相邻节点再次被访问。 所以我们需要通过一个标志来表示某个图的节点是否已经被访问过了，如果已经被访问过了，那么我们就不能再次访问，我们通过一个 visited 数组来表示图中的某个节点是否已经被访问过了，visited 数组是一个 boolean 类型的数组，值为 true 时就表示该节点已经被访问过了，例如 visited[0] = true 就表示节点 0 已经被访问过了。 下面我就将编程具体实现： import java.util.ArrayList;import java.util.Arrays;public class DFSGraph &#123; // 图的表示中定义的 Graph 接口 private Graph graph; // 保存深度优先遍历的顺序 private ArrayList&lt;Integer&gt; order; // 保存节点是否已经被访问过 private boolean[] visited; public DFSGraph(Graph graph) &#123; this.graph = graph; order = new ArrayList&lt;&gt;(graph.V()); // 初始化 visited 中的元素值为 false visited = new boolean[graph.V()]; Arrays.fill(visited, false); &#125; // DFS 的实现，首先从节点 0 开始遍历 public void dfs() &#123; dfs(0); &#125; private void dfs(int v) &#123; // 标记当前节点为访问过的状态 visited[v] = true; // 向 order 中添加当前节点 order.add(v); for (int w: graph.adj(v)) &#123; // 如果邻接节点没有被访问过，那么遍历该邻接节点 if (!visited[w]) &#123; dfs(w); &#125; &#125; &#125; public Iterable&lt;Integer&gt; order() &#123; return order; &#125; public static void main(String[] args) &#123; // 使用邻接表表示图 Graph graph = new AdjSet(\"g.txt\"); // 实例化一个 DFSGraph DFSGraph dfsGraph = new DFSGraph(graph); // 调用 dfs 方法进行深度优先遍历 dfsGraph.dfs(); // 打印出深度优先遍历的顺序 System.out.println(dfsGraph.order()); &#125;&#125; 其中 g.txt 的内容如下 6 50 10 21 32 42 5 这个文件表示的图与我们在上面的动图中看到的图是一样的，我们来看下打印的结果 [0, 1, 3, 2, 4, 5] 这与我们在动图中看到的遍历顺序是一致的。 但是上面我们实现的深度优先遍历有一个小 bug，那就是上面的深度优先遍历只适合只有一个联通分量的图，如果有多个联通分量，那么其他联通分量中的节点就永远不可能被访问到，如 既然图中有节点永远不会被访问到，那么还能叫图的遍历吗，图的遍历可是要求能够访问图中所有的节点的，所以我们对代码进行改进 这次我们不只是从节点 $0$ 开始遍历，在遍历完节点 $0$ 所在的联通分量以后，我们检查是否还有节点没有遍历，即是否存在别的联通分量，如果有，那么我们还有遍历该节点所在的联通分量。 在最后我们进行一个扩展，我们知道树的深度优先遍历分为三种 前序遍历 中序遍历 后序遍历 图没有中序遍历，它分为两种 深度优先前序遍历 深度优先后序遍历 刚刚我们所编程的只是图的深度优先前序遍历，现在我们不妨写一下后序遍历的代码。在写代码之前，我们先明确后序遍历的这个后指的是什么，这个后在树的遍历中指的是先访问当前节点的孩子节点，然后访问当前节点，也就是访问当前节点在访问当前节点的孩子节点之后。类比于图，这个后指的就是先访问当前节点的邻接节点，然后再访问当前节 上面后序遍历的顺序为 $[3, 1, 4, 5, 2, 0]$，我们重构一下上面的代码，我们使用 preorder 来保存前序遍历的结果，使用 postorder 来保存后序遍历的结果： import java.util.ArrayList;import java.util.Arrays;public class DFSGraph &#123; private Graph graph; private ArrayList&lt;Integer&gt; preorder; private ArrayList&lt;Integer&gt; postorder; private boolean[] visited; public DFSGraph(Graph graph) &#123; this.graph = graph; preorder = new ArrayList&lt;&gt;(graph.V()); postorder = new ArrayList&lt;&gt;(graph.V()); visited = new boolean[graph.V()]; Arrays.fill(visited, false); &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; dfs(i); &#125; &#125; &#125; private void dfs(int v) &#123; visited[v] = true; // 前序遍历：在遍历相邻节点前，遍历当前节点 preorder.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w); &#125; &#125; // 后序遍历：遍历相邻节点后，再遍历当前节点 postorder.add(v); &#125; public Iterable&lt;Integer&gt; preorder() &#123; return preorder; &#125; public Iterable&lt;Integer&gt; postorder() &#123; return postorder; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); DFSGraph dfsGraph = new DFSGraph(graph); dfsGraph.dfs(); System.out.println(dfsGraph.postorder()); &#125;&#125; 打印的结果为 [3, 1, 4, 5, 2, 0] 深度优先遍历的应用联通分量第一个问题是如何求解图中有多少个联通分量。其实这个问题非常的简单，在上面的我们修改 DFS 的小 bug 时就提到，因为有多个联通分量，我们无法遍历完所有图中的节点，所以我们修改了代码 每次当我们在 for 循环中调用一次 dfs 的时候，就说明存在一个联通分量(Connected Component)，所以我们只要在调用 dfs 时统计联通分量的个数就可以，我们使用一个成员变量 ccount 来保存联通分量的个数 import java.util.Arrays;public class CCGraph &#123; private int cccount; private Graph graph; private boolean[] visited; public CCGraph(Graph graph) &#123; this.graph = graph; this.cccount = 0; visited = new boolean[graph.V()]; Arrays.fill(visited, false); &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; // 联通分量个数增加 cccount++; dfs(i); &#125; &#125; &#125; private void dfs(int v) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w); &#125; &#125; &#125; public int getCccount() &#123; return cccount; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); CCGraph ccGraph = new CCGraph(graph); ccGraph.dfs(); int cccount = ccGraph.getCccount(); System.out.println(cccount); // 2 &#125;&#125; 上面的代码与 DFSGraph 类的代码几乎是一致的，只不过统计了联通分量的个数。g.txt 中的内容为： 7 60 10 21 32 52 44 5 对于的图的形状如下： 可见上面的图有两个联通分量。 第二个与联通分量有关的问题是，我们希望得到每个联通分量中有多少个节点，以及分别包含哪些节点，我们可以使用一个 ArrayList 数组保存每个联通分量包含的节点，修改 dfs 如下 import java.util.ArrayList;import java.util.Arrays;@SuppressWarnings(\"all\")public class CCGraph &#123; private int cccount; private Graph graph; private boolean[] visited; // 为什么不使用数组? 因为数组需要事先开辟空间，而我们事先不知道有多少个联通分量 private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists; // 构造函数对成员变量进行初始化 public CCGraph(Graph graph) &#123; this.graph = graph; this.cccount = 0; visited = new boolean[graph.V()]; Arrays.fill(visited, false); lists = new ArrayList&lt;&gt;(); &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; cccount++; // 每增加一个联通分量，新建一个 list 来保存该联通分量中包含的节点 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); lists.add(list); dfs(i, list); &#125; &#125; &#125; private void dfs(int v, ArrayList&lt;Integer&gt; list) &#123; visited[v] = true; // 将节点保存在所在联通分量对应的 list 中 list.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, list); &#125; &#125; &#125; public int getCCcount() &#123; return cccount; &#125; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; getCCList() &#123; return lists; &#125; // 判断两个节点是否在同一个联通分量中(是否连接) public boolean isConnected(int v, int w) &#123; for (int i = 0; i &lt; cccount; i++) &#123; ArrayList list = lists.get(i); // 某联通分量中是否同时包含这两个节点 if (list.contains(v) &amp;&amp; list.contains(w)) &#123; return true; &#125; &#125; // 所有的联通分量都不同时包含这两个节点，说明这两个节点不在同一个联通分量中 return false; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); CCGraph ccGraph = new CCGraph(graph); ccGraph.dfs(); int cccount = ccGraph.getCCcount(); System.out.println(cccount); // 2 // 打印出联通分量 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = ccGraph.getCCList(); for (int i = 0; i &lt; cccount; i++) &#123; // 获得每个联通分量对应的 list，里面保存了该联通分量包含的节点 ArrayList&lt;Integer&gt; list = lists.get(i); // 打印出联通分量中包含的节点 System.out.print(i + \": \"); for (int v: list) &#123; System.out.print(v + \" \"); &#125; System.out.println(); &#125; System.out.println(ccGraph.isConnected(0, 5)); // true System.out.println(ccGraph.isConnected(0, 6)); // false &#125;&#125; 上述的打印结果为 20: 0 1 3 2 4 5 1: 6 truefalse 路径问题所谓的路径问题就是求两个节点之间是否有路径，这个问题很简单，直接使用我们上面的 isConnected 方法就可以知道两个节点之间是否有路径了。不过我们更想知道的是，两个节点之间的路径是什么，即一个节点到达另一个节点会经历哪些节点。 对于下面的一幅图，我们想知道从节点 $0$ 到节点 $5$ 之间的路径 我们需要记录遍历时当前节点的前一个节点，例如遍历节点 $1$ 后会接着遍历节点 $3$，那么节点 $3$ 的前一个节点就是 $1$，通过这些信息就可以知道两个节点之间具体的路径。首先使用 DFS 图，在遍历的过程中记录信息，如下 在上面我们从节点 $0$ 开始遍历，在遍历的过程中我们记录了当前节点之前的节点，最后得到这么一个结果 现在我们想知道节点 $0$ 是如何到达节点 $5$ 的，直接逆推就可以知道路径为 $5 \\leftarrow 4 \\leftarrow 2 \\leftarrow 0$，如下 这个算法可以求得节点 $0$ 与任何一个节点之间的路径，但是不能求得任意两点之间的路径，因为我们是从节点 $0$ 开始遍历的，如果我们想求得节点 $4$ 与节点 $5$ 之间的路径，那么我们需要从节点 $4$ 开始遍历，所以我们这种算法只能求解单源路径(Single Source Path) 问题。 在编程实现方面，我们使用一个 pre 数组来保存当前节点的前一个节点，例如，pre[3] = 1 就表示节点 $3$ 的前一个节点是节点 $1$ import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class SingleSourcePath &#123; private Graph graph; private boolean[] visited; private int[] pre; // 从节点 s 开始遍历 private int s; public SingleSourcePath(Graph graph, int s) &#123; this.graph = graph; this.s = s; visited = new boolean[graph.V()]; Arrays.fill(visited, false); pre = new int[graph.V()]; Arrays.fill(pre, -1); // 默认认为源的前一个节点为自己，这个值访问不到，可以是任何值 dfs(s, s); &#125; private void dfs(int v, int parent) &#123; visited[v] = true; pre[v] = parent; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, v); &#125; &#125; &#125; public boolean isConnected(int t) &#123; // 如果 pre[t] != -1，说明遍历到了该节点，则该节点与源节点是联通的 return pre[t] != -1; &#125; public Iterable&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); // 如果不是联通的，直接返回 if (!isConnected(t)) return path; int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); SingleSourcePath singleSourcePath = new SingleSourcePath(graph, 0); System.out.println(singleSourcePath.path(5)); &#125;&#125; 其中 g.txt 为 7 60 10 21 32 52 44 5 对应的图就是上面的动图，输出为 [0, 2, 4, 5] 假设现在我们只想求源点 $s$ 到点 $t$ 之间的路径，而不是 $s$ 到任意一个点的路径，很明显我们的要求降低了，这意味着我们记录的信息更少，那我们算法可不可以加快呢? 当然可以，在上面我们求解源点 $s$ 到任意一点的路径，所以需要对源点 $s$ 所在的联通分量做 $DFS$，需要遍历联通分量中所有的节点，但是现在我们只需要求解到固定点 $t$ 的路径，我们不需要完整的做一遍 $DFS$，当我们遍历到节点 $t$ 时，就已经可以退出遍历了，提前终止遍历可以获得更快的性能。 假设我们需要求解源点 $0$ 到节点 $1$ 的路径 在编码上，在我们在设计 dfs 函数时，我们需要返回一个布尔值，代表是否已经找到节点 $t$，如果已经找到，我们就不需要做后续的遍历了，直接终止遍历 import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class Path &#123; private Graph graph; private boolean[] visited; private int[] pre; private int s; private int t; public Path(Graph graph, int s, int t) &#123; this.graph = graph; this.s = s; this.t = t; visited = new boolean[graph.V()]; Arrays.fill(visited, false); pre = new int[graph.V()]; Arrays.fill(pre, -1); dfs(s, s); &#125; private boolean dfs(int v, int parent) &#123; visited[v] = true; pre[v] = parent; // 如果已经找到，直接返回，不再继续遍历 if (v == t) &#123; return true; &#125; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; // 如果在某相邻节点的深度优先遍历中找到节点 t，不再继续遍历其他相邻节点，提前返回 if (dfs(w, v)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean isConnected() &#123; return visited[t]; &#125; public Iterable&lt;Integer&gt; path() &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); if (!isConnected()) &#123; return path; &#125; int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); Path path = new Path(graph, 0, 3); System.out.println(Arrays.toString(path.visited)); System.out.println(path.path()); &#125;&#125; 输出为 [true, true, false, true, false, false, false][0, 1, 3] 从打印结果可以看出，我们并没有遍历所有的节点，这样提前终止遍历可以提高查找的速度。 无向图的环检测我们怎么判断一幅图有没有环呢? 很简单，我们使用深度优先遍历，当访问到某节点时，如果该节点的某邻接节点已经被访问过，并且该邻接节点不是它的上一个节点，那么就说明该图中包含一个环 明白这一点以后我们就可以编写代码了 import java.util.Arrays;public class CircleDetection &#123; private Graph graph; private boolean[] visited; private boolean hasCircle; public CircleDetection(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; Arrays.fill(visited, false); hasCircle = false; &#125; public void dfs() &#123; // 任一联通分量中有环，那么图中就有环 for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; dfs(i, i); &#125; &#125; &#125; private void dfs(int v, int parent) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, v); // 进入下面的 if 判断就说明 w 已经访问过了 // 如果 w 不是它的上一个节点，说明有环 &#125; else if (w != parent)&#123; hasCircle = true; &#125; &#125; &#125; public boolean hasCircle() &#123; return this.hasCircle; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); CircleDetection circleDetection = new CircleDetection(graph); circleDetection.dfs(); System.out.println(circleDetection.hasCircle()); // true &#125;&#125; 其中 g.txt 的内容如下 7 60 10 21 32 52 44 5 所对应的图如下 如果我们将节点 $2$ 和 $5$ 之间的边断开，那么图中是没有环的，新建 g2.txt 如下 7 50 10 21 32 44 5 Graph graph2 = new AdjSet(\"g2.txt\");CircleDetection circleDetection2 = new CircleDetection(graph2);circleDetection2.dfs();System.out.println(circleDetection2.hasCircle()); // false 另外，我们可以提前返回进行优化，如果我们已经找到了环，那么我们可以提前终止，后面就不需要继续查找了，我们修改 dfs 的返回值为 boolean 类型，这时 dfs 函数的含义就是从顶点 $v$ 开始，判断图中是否有环 public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; if (dfs(i, i)) &#123; hasCircle = true; // 不用查找其他联通分量了 break; &#125; &#125; &#125;&#125;private boolean dfs(int v, int parent) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; if (dfs(w, v)) &#123; // 如果已经在某相邻节点中找到环，不用再遍历其他的相邻节点 return true; &#125; &#125; else if (w != parent)&#123; // 如果已经找到环，不用继续向后遍历 return true; &#125; &#125; return false;&#125; 二分图检测在这个小节我们来看一个二分图检测的问题，那么问题来了，什么叫二分图呢? 二分图需要满足一下两个特点： 图中的节点被划分为两部分 图中的边连接的是两个部分的节点 在上图中，节点 $0, 3, 4, 5$ 是一部分，节点 $1, 2, 6$ 是一部分，两部分的节点我使用不同的颜色进行填充；且图中所有的边都连接的是两个部分的节点。很明显上面的图满足二分图的两个特点，所以上面的图是一个二分图，那接下来的问题是如何检测一个图是否是一个二分图呢? 首先明白下面两个图是等价的 但是我们很难从右边的图中分辨出两部分的节点。 解决这个问题的关键是图中的所有边连接的是两个不同部分的节点，如果我们将对图进行深度优先遍历的过程中对节点染色，相同部分的节点染为一个颜色，因为所有的边都连接的是不同部分的节点，这意味着任意节点的邻接节点的颜色和自己都是不同的。 我们在遍历时将所有邻接节点的颜色染为和自己不一样，但是如果邻接节点已经染色，并且染的颜色和自己相同，与二分图的定义冲突，那么说明不是一个二分图，反之邻接节点染的颜色和自己不同，则继续遍历，如果遍历完整个图时都没有冲突，那么说明这个图就是一个二分图 代码如下： import java.util.Arrays;public class BinaryPartitionDetection &#123; private Graph graph; private boolean[] visited; // 以 0 1 表示不同颜色 private int[] colors; // 表示该图是否为二分图 private boolean isBipartite; public BinaryPartitionDetection(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; Arrays.fill(visited, false); // 初始化 colors 为 -1，表示未染色 colors = new int[graph.V()]; Arrays.fill(colors, -1); isBipartite = true; &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; // 如果在某联通分量中检测到不是二分图，不需要检测其他联通分量 if (!dfs(i, 0)) &#123; isBipartite = false; break; &#125; &#125; &#125; &#125; private boolean dfs(int v, int color) &#123; visited[v] = true; // 染色 colors[v] = color; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; // 0 =&gt; 1 - color = 1 // 1 =&gt; 1 - color = 0 // 如果已经在遍历某邻接节点的过程中检测到不是二分图，不需要遍历其他邻接节点 if (!dfs(w, 1 - color)) &#123; return false; &#125; // 进入 else if 表示该节点已经被访问过 // 如果该节点的颜色与它的邻接节点相同，说明不是二分图，后面节点无需遍历 &#125; else if (colors[v] == colors[w]) &#123; return false; &#125; &#125; return true; &#125; public boolean isBipartite() &#123; return isBipartite; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g3.txt\"); BinaryPartitionDetection binaryPartitionDetection = new BinaryPartitionDetection(graph); binaryPartitionDetection.dfs(); System.out.println(binaryPartitionDetection.isBipartite()); // true &#125;&#125; 其中 g3.txt 的内容如下 7 60 10 21 32 42 54 6 所表示的图如下，与动图中的图相同 在上面的实现中也使用了提前终止的技术，使用该技术可以很方便的提前终止遍历，提高程序的性能。 图的广度优先遍历树的层序遍历树的层序遍历是指一层一层的遍历树的节点，它的实现是借助于队列进行实现的： 每一次从队列的头部取出元素进行遍历，然后将该元素的左右孩子添加进队列，以此往复，直至队列为空，遍历结束。 import java.util.LinkedList;import java.util.Queue;public class BinaryTree &#123; private class Node &#123; private Node left; private Node right; private int value; public Node(int value) &#123; this.value = value; &#125; &#125; private Node root; public BinaryTree(int value) &#123; root = new Node(value); &#125; public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; Node node = queue.remove(); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; System.out.println(node.value); &#125; &#125;&#125; 图的广度优先遍历图的广度优先遍历与树的层序遍历相似，所谓的广度是指尽可能的遍历所有的相邻元素 广度优先遍历的实现同树的层序遍历类似，也是借助于队列这种数据结构，每次从队列的头部取出节点进行遍历，然后将该节点的所有相邻节点添加进队列，但是需要注意的是，因为图有可能发生重复遍历，所以需要使用visited 标记已遍历的节点；另外还需要考虑到有多个联通分量的情况，与深度优先遍历的写法类似 import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class BFSGraph &#123; private Graph graph; private boolean[] visited; private ArrayList&lt;Integer&gt; order; public BFSGraph(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; order = new ArrayList&lt;&gt;(graph.V()); for (int i = 0; i &lt; graph.V(); i++) &#123; if (!visited[i]) &#123; bfs(i); &#125; &#125; &#125; private void bfs(int s) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited[s] = true; while (!queue.isEmpty()) &#123; int v = queue.remove(); order.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; queue.add(w); visited[w] = true; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g4.txt\"); BFSGraph bfsGraph = new BFSGraph(graph); System.out.println(bfsGraph.order); &#125;&#125; 单源路径问题对于路径问题的思路同DFS，使用一个 pre 数组，保存当前节点的上一个节点，当查询源节点到某个目的节点的路径时，只要从目的节点根据 pre 数组一直查找它的前一个节点，直到前一个节点为源节点就找到了路径 import java.util.*;public class SingleSourcePath &#123; private Graph graph; private int s; private boolean[] visited; private int[] pre; public SingleSourcePath(Graph graph, int s) &#123; this.graph = graph; this.s = s; visited = new boolean[graph.V()]; pre = new int[graph.V()]; Arrays.fill(visited, false); Arrays.fill(pre, -1); bfs(s); &#125; private void bfs(int s) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited[s] = true; pre[s] = s; while (!queue.isEmpty()) &#123; int v = queue.remove(); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; queue.add(w); visited[w] = true; pre[w] = v; &#125; &#125; &#125; &#125; private void validate(int v) &#123; if (v &lt; 0 || v &gt;= graph.V()) &#123; throw new IllegalArgumentException(\"v is out of index\"); &#125; &#125; public boolean isConnected(int t) &#123; validate(t); return visited[t]; &#125; public ArrayList&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (!isConnected(t)) &#123; return res; &#125; int cur = t; while (cur != s) &#123; res.add(cur); cur = pre[cur]; &#125; res.add(s); Collections.reverse(res); return res; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g4.txt\"); SingleSourcePath singleSourcePath = new SingleSourcePath(graph, 0); // 0 -&gt; 6: [0, 2, 6] System.out.println(\"0 -&gt; 6: \" + singleSourcePath.path(6)); &#125;&#125; 对于同样的图，使用深度优先遍历，结果是 0 -&gt; 6: [0, 1, 3, 2, 6] BFS 找到的路径比 DFS 找到的路径要短，这不是巧合，因为在无向无环图中，BFS 有一个重要的性质就是它寻找到的路径是最短路径，或者说经历的节点最少。为什么? 换种角度看，广度优先遍历是按照距离源的最小距离遍历的。 下面一个问题是寻找源到各点之间的距离，这个最简单的实现就是获得源到各点之间的路径，然后获得路径的长度即可推算出距离。下面提供一种更快的方法，无须先获得路径。首先我们需要声明一个 dis 数组来保存源到各点的距离，假设 w 是 v 的相邻节点，且 v 先被遍历，那么 s -&gt; w 的距离为 s -&gt; v + 1，即 dis[w] = dis[v] + 1 import java.util.*;public class SingleSourcePath &#123; private Graph graph; private int s; private boolean[] visited; private int[] pre; // dis 数组保存源到各节点的距离 private int[] dis; public SingleSourcePath(Graph graph, int s) &#123; this.graph = graph; this.s = s; visited = new boolean[graph.V()]; pre = new int[graph.V()]; // 初始化 dis = new int[graph.V()]; Arrays.fill(visited, false); Arrays.fill(pre, -1); // 初始化 Arrays.fill(dis, -1); bfs(s); &#125; private void bfs(int s) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited[s] = true; pre[s] = s; // 源到源的距离为 0 dis[s] = 0; while (!queue.isEmpty()) &#123; int v = queue.remove(); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; queue.add(w); visited[w] = true; pre[w] = v; // 更新 dis dis[w] = dis[v] + 1; &#125; &#125; &#125; &#125; // 与 path 相关代码省略 public int dis(int t) &#123; validate(t); return dis[t]; &#125;&#125; 现实中有很多的问题可以建模为图论问题，然后使用 DFS 与 BFS 算法轻松的解决，现在我们打算从 LeetCode 选择几道题，来了解如何将现实问题建模为图论问题。 图论建模二分图检测题目介绍给定一个无向图graph，当这个图为二分图时返回true。如果我们能将一个图的节点集合分割成两个独立的子集 A 和 B，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，我们就将这个图称为二分图。 graph 将会以邻接表方式给出，graph[i] 表示图中与节点 i 相连的所有节点。每个节点都是一个在 0 到graph.length-1 之间的整数。这图中没有自环和平行边： graph[i] 中不存在 i，并且 graph[i] 中没有重复的值。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果 j 在 graph[i] 里边, 那么 i 也会在 graph[j] 里边。 解题思路这道题的解法是对图中的节点染色，我们使用 DFS 遍历该图，如果当前节点的颜色为红色，那么就将它未访问过的相邻的节点染为绿色，如果当前节点颜色为绿色，就将未访问过的相邻节点染为红色，根据颜色来区分两个集合。 因为一条边连接的两个节点属于两个不同的几个集合，所以一条边连接的两个节点的颜色是不同的，如果我们在遍历的过程中发现已被访问过的相邻的节点的颜色与当前节点的颜色相同，说明它不符合二分图的定义，不是一个二分图；如果遍历图中所有的联通分量，都没有产生矛盾，说明这个图就是一个二分图。 class Solution &#123; private boolean[] visited; // true 表示红色，false 表示绿色，默认为绿色 private boolean[] colors; public boolean isBipartite(int[][] graph) &#123; visited = new boolean[graph.length]; colors = new boolean[graph.length]; // 遍历所有的联通分量 for (int i = 0; i &lt; graph.length; i++) &#123; if (!visited[i]) &#123; if (!dfs(i, graph)) &#123; return false; &#125; &#125; &#125; return true; &#125; // dfs 返回一个布尔值，用以当不为二分图时提前终止遍历 private boolean dfs(int v, int[][] graph) &#123; visited[v] = true; for (int w: graph[v]) &#123; // 如果未访问过，染为相反的颜色 if (!visited[w]) &#123; colors[w] = !colors[v]; // 继续遍历 if (!dfs(w, graph)) return false; // 如果已放访问过，且相邻节点颜色相同，不是二分图 &#125; else if (visited[w] &amp;&amp; colors[w] == colors[v]) &#123; return false; &#125; &#125; // 未发现矛盾，为二分图 return true; &#125;&#125; 岛屿的最大面积题目介绍给定一个包含了一些 0 和 1 的非空二维数组 grid 。一个岛屿是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0 (代表水) 包围着。 找到给定的二维数组中最大的岛屿面积(如果没有岛屿，则返回面积为 0 )。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路我们将这个矩阵看做是一个图，矩阵中所有的 1 就是一个个的节点，如果两个 1 是垂直或者水平相邻的，那么就可以认为它们被一条边连着，即在一个联通分量中，而我们的任务就是找出包含节点最多的联通分量，并返回节点数目。 import java.util.Arrays;import java.util.stream.Collectors;public class Solution &#123; private int rows; private int columns; private boolean[][] visited; private int[][] grid; public int maxAreaOfIsland(int[][] grid) &#123; // 因为题目没说 grid 不为空，所以下面是对 grid 的一些校验 if (grid == null) &#123; return 0; &#125; this.rows = grid.length; if (rows == 0) &#123; return 0; &#125; this.columns = grid[0].length; if (columns == 0) &#123; return 0; &#125; this.grid = grid; this.visited = new boolean[rows][columns]; // 最大岛屿数目 int max = 0; for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (!visited[row][column] &amp;&amp; grid[row][column] == 1) &#123; // dfs 返回的所在联通分量的节点数目 max = Math.max(max, dfs(row, column)); &#125; &#125; &#125; return max; &#125; // 表示以 [row, column] 为起点进行 DFS 遍历所在联通分量包含的节点数目 private int dfs(int row,int column) &#123; int count = 1; visited[row][column] = true; for (int[] w: adj(row, column)) &#123; int nextRow = w[0]; int nextColumn = w[1]; if (grid[nextRow][nextColumn] == 0) &#123; continue; &#125; if (!visited[nextRow][nextColumn]) &#123; count += dfs(nextRow, nextColumn); &#125; &#125; return count; &#125; // 获得当前节点四个方向上的相邻节点 private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125;&#125; 二进制矩阵中的最短路径题目介绍在一个 $N \\times N$ 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。现在我们的目标是从 $(0, 0)$ 到达 $(N-1, N-1)$，即从左上角到达右下角，而我们的目标是寻找一条最短路径，并且返回这条路径的长度。如果无法从左上角达到右下角，则返回 -1。 每个单元格有 8 种可能的方向 下面给出一个示例 解题思路我们将方格看做是一个图，方格中所有的 0 看做是图一个节点，如果两个 0 在各自的 8 个方向之中，就说明这两个节点之间有一条边。为了求得最短路径，我们需要从左上角这个节点进行 BFS，使用 dis[i][j] 记录 $(i, j)$ 距离 $(0, 0)$ 的距离，所以 $dis[N-1][N-1]$ 也就表示从左上角到达右下角的最短路径。 import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;import java.util.stream.Collectors;class Solution &#123; private boolean[][] visited; private int[][] dis; private int rows; private int columns; public int shortestPathBinaryMatrix(int[][] grid) &#123; this.rows = grid.length; this.columns = grid[0].length; if (grid[0][0] == 1 || grid[rows - 1][columns - 1] == 1) &#123; return -1; &#125; if (rows == 1 &amp;&amp; grid[rows][columns] == 0) &#123; return 1; &#125; dis = new int[rows][columns]; visited = new boolean[rows][columns]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;0, 0&#125;); visited[0][0] = true; dis[0][0] = 1; while (!queue.isEmpty()) &#123; int[] location = queue.remove(); int row = location[0]; int column = location[1]; for (int[] nextLocation: adj(row, column)) &#123; int nextRow = nextLocation[0]; int nextColumn = nextLocation[1]; if (!visited[nextRow][nextColumn] &amp;&amp; grid[nextRow][nextColumn] == 0) &#123; queue.add(new int[]&#123;nextRow, nextColumn&#125;); visited[nextRow][nextColumn] = true; dis[nextRow][nextColumn] = dis[row][column] + 1; if (nextRow == rows - 1 &amp;&amp; nextColumn == columns - 1) &#123; return dis[nextRow][nextColumn]; &#125; &#125; &#125; &#125; return -1; &#125; private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;-1, -1&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125;&#125; 打开转盘锁题目介绍你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 解题思路我们把密码锁的一种组合称之为一种状态，例如 0000 这个组合表示的就是一种状态，现在我们的模板是将 0000 这种状态转变到 target 表示的状态，并且要求步骤最少。 我们可以把一种状态建模为图中的顶点，如果一个状态能够转变为另一种状态，我们就说这两个状态表示的节点之间存在一条边。对于密码锁来说，每一个拨轮可以前后滚动，共有四个拨轮，这意味着一个状态最多与 8 个状态相邻(考虑到 deadends，少于 8 个)，所以我们只要从 0000 这个状态开始 BFS 遍历，即可找到最少到 target 的拨动次数。 import java.util.*;import java.util.stream.Collectors;class Solution &#123; public int openLock(String[] deadends, String target) &#123; if (\"0000\".equals(target)) &#123; return 0; &#125; HashSet&lt;String&gt; deadSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; deadends.length; i++) &#123; deadSet.add(deadends[i]); &#125; if (deadSet.contains(\"0000\"))&#123; return -1; &#125; HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); HashMap&lt;String, Integer&gt; dis = new HashMap&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList(); queue.add(\"0000\"); visited.add(\"0000\"); dis.put(\"0000\", 0); while (!queue.isEmpty()) &#123; String state = queue.remove(); for (String nextState: adj(state, deadSet)) &#123; if (!visited.contains(nextState)) &#123; queue.add(nextState); visited.add(nextState); dis.put(nextState, dis.get(state) + 1); if (target.equals(nextState)) &#123; return dis.get(nextState); &#125; &#125; &#125; &#125; return -1; &#125; private Iterable&lt;String&gt; adj(String state, HashSet&lt;String&gt; deadSet) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 4; i++) &#123; char[] chars = state.toCharArray(); char s = chars[i]; chars[i] = Character.forDigit((chars[i] - '0' + 1) % 10, 10); list.add(new String(chars)); chars[i] = s; chars[i] = Character.forDigit((chars[i] - '0' - 1 + 10) % 10, 10); list.add(new String(chars)); &#125; return list.stream().filter(s -&gt; !deadSet.contains(s)).collect(Collectors.toList()); &#125;&#125; 倒水智力题有两个桶，一个能装 5 升水，一个能装 3 升水，如何得到 4 升水? 这道题还是将状态看做是一个图的节点，如果状态之间能够互相转变，就说状态之前有一条边。我们定义状态 &lt;x,y&gt; 表示第一个桶有 x 升水，第二个桶有 y 升水。那么 &lt;x, y&gt; 与哪些状态是相连的呢，分为六种情况： 倒空第一桶水：&lt;x, y&gt; =&gt; &lt;0, y&gt; 倒空第二桶水：&lt;x, y&gt; =&gt; &lt;x, 0&gt; 加满第一桶水：&lt;x, y&gt; =&gt; &lt;5, y&gt; 加满第二桶水：&lt;x, y&gt; =&gt; &lt;x, 3&gt; 第二桶水倒入第一桶水： $x + y \\geq 5$：&lt;x, y&gt; =&gt; &lt;5, x + y - 5&gt; $x + y &lt; 5$：&lt;x, y&gt; =&gt; &lt;x + y, 0&gt; 第一桶水倒入第二桶水： $x + y \\geq 3$：&lt;x, y&gt; =&gt; &lt;x + y - 3, 3&gt; $x + y &lt; 3$：&lt;x, y&gt; =&gt; &lt;0, x + y&gt; 我们使用一个两位数表示一个状态，十位数表示第一个桶中有多少升水，个位数表示第二个桶中有多少升水，例如 23 表示第一个桶中有 2 升水，第二个桶中有 3 升水。 import java.util.*;public class WaterPuzzle &#123; public Iterable&lt;Integer&gt; waterPuzzle() &#123; HashSet&lt;Integer&gt; visited = new HashSet&lt;&gt;(); HashMap&lt;Integer, Integer&gt; pre = new HashMap&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(0); visited.add(0); pre.put(0, 0); // 保存最后找到的结果 int endState = 0; // 用以跳出 while 循环 boolean flag = false; while (!queue.isEmpty()) &#123; int state = queue.remove(); for (int nextState: adj(state)) &#123; if (!visited.contains(nextState)) &#123; visited.add(nextState); queue.add(nextState); pre.put(nextState, state); if (nextState / 10 == 4 || nextState % 10 == 4) &#123; endState = nextState; flag = true; break; &#125; &#125; &#125; if (flag) &#123; break; &#125; &#125; ArrayList&lt;Integer&gt; result = new ArrayList(); int cur = endState; result.add(cur); while (pre.get(cur) != 0) &#123; cur = pre.get(cur); result.add(cur); &#125; Collections.reverse(result); return result; &#125; private Iterable&lt;Integer&gt; adj(int state) &#123; int first = state / 10; int second = state % 10; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(second); set.add(first*10); set.add(5*10 + second); set.add(first * 10 + 3); if (first + second &gt;= 5) &#123; set.add(5 * 10 + (first + second) - 5); &#125; else &#123; set.add((first + second) * 10); &#125; if (first + second &gt;= 3) &#123; set.add((first + second - 3) * 10 + 3); &#125; else &#123; set.add(first + second); &#125; return new ArrayList&lt;&gt;(set); &#125; public static void main(String[] args) &#123; WaterPuzzle waterPuzzle = new WaterPuzzle(); for (int r: waterPuzzle.waterPuzzle()) &#123; // 在个位数前加上0 System.out.print((r &gt;= 10 ? r : \"0\" + r) + \" \"); &#125; &#125;&#125; 输出为 50 23 20 02 52 43 滑动谜题题目介绍在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示。一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换。最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。 给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。 解题思路我们将谜板上的一个组合看做是一个状态，一个状态就是图上的一个节点，如果一个状态能够转变到另一个状态，我们就说这两个状态节点之间有一条边连接。我们使用字符串来表示一个状态，例如 [[1, 4, 5], [0, 2, 3]] 这个状态表示为 &quot;145023&quot;，现在我们的目标是寻找一条从初始状态到 &quot;123450&quot; 这个状态的最短路径，使用 BFS 算法即可 import java.util.*;import java.util.stream.Collectors;public class Solution &#123; private HashMap&lt;String, Integer&gt; visited = new HashMap&lt;&gt;(); private int rows; private int columns; public int slidingPuzzle(int[][] board) &#123; this.rows = board.length; this.columns = board[0].length; String initState = boardToString(board); if (initState.equals(\"123450\")) &#123; return 0; &#125; Queue&lt;String&gt; queue = new LinkedList(); queue.add(initState); visited.put(initState, 0); while (!queue.isEmpty()) &#123; String state = queue.remove(); for (String nextState: adj(state)) &#123; if (!visited.containsKey(nextState)) &#123; queue.add(nextState); visited.put(nextState, visited.get(state) + 1); if (\"123450\".equals(nextState)) &#123; return visited.get(nextState); &#125; &#125; &#125; &#125; return -1; &#125; private String boardToString(int[][] board) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; stringBuilder.append(board[i][j]); &#125; &#125; return stringBuilder.toString(); &#125; private Iterable&lt;String&gt; adj(String state) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); char[] chars = state.toCharArray(); int index = state.indexOf(\"0\"); int row = index / columns; int column = index % columns; int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; List&lt;Integer&gt; locations = Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .map(item -&gt; item[0] * columns + item[1]) .collect(Collectors.toList()); for (int i: locations) &#123; String res = swap(chars, index, i); result.add(res); swap(chars, i, index); &#125; return result; &#125; private String swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; return new String(chars); &#125;&#125; 桥和割点桥定义我们首先看一下桥的概念 上面这幅图中，我们称节点 3-5 之间的这条边为桥，它具有什么特点呢? 一旦将这条边去掉，图的联通分量就会发生变化，所以有如下定义： 如果去掉某条边，使得图的联通分量发生变化，那么称这条边为桥。 桥可以看做是图中最脆弱的那条边，如果将交通系统建模为一个图的话，桥就是交通系统中最脆弱的部分，在军事中如果我们知道对方交通系统中的桥，那么我们就可以军事打击这个桥，使得对方的交通系统瘫痪。 寻找桥如何判断某条边是不是桥，对于下图来说， 0-1 这条边是桥吗? 答案不是，因为去掉 0-1 这条边联通分量的个数没有增加，原因是节点 1 可以通过另一条路径 1-&gt;3-&gt;2-&gt;0 到达 0，所以我们判断某条边是不是桥，就是判断边的两个节点是否有另外一条路径。考虑边 v-w，如果存在另外一条路径，使得节点 v 可以到达节点 w 或者是节点 w 之前的节点，我们就认为 v-w 不是桥，否则没有另外的路径使得节点 v 到达节点 w，我们就认为 v-w 是桥。 为了完成这个判断，我们需要定义两个变量来帮助我们保存信息，一个是 order[] 数组，它保存的是以 DFS 遍历图的顺序，例如 order[0] = 0，表示节点 0 是第 0 个遍历的，order[3] = 2 表示节点 3 是第 2 个遍历的 另一个需要记录的信息是当前节点通过另外一条路径(即不是父节点那条路径)能够达到的顺序最前的节点，使用数组 low 表示，假设节点 2 能够达到最前的节点 0，而 order[0] = 0，所以 low[2] = order[0] = 0，初始 low[i] = order[i]，更新 low 数组有两个时机 节点 v 访问已被遍历过的邻接节点 w 时(该邻接节点不为父节点)，如果 low[w] &lt; low[v]，则更新 low[v] = low[w] 当我们访问到节点 2 时，接着访问节点 2 的邻接节点，访问到节点 0，节点 0 不是它的父亲节点(上一个节点)，而且节点 0 已经被访问过，并且 low[0] &lt; low[2]，所以这个时候更新 low[2] = low[0]，表示节点 2 能通过另一条路径访问第 low[0] 个遍历的节点，即节点 2 能够访问到第 0 个被遍历的节点，即节点 0 访问完邻接节点 w，回到当前节点 v 时，如果邻接节点的 low[w] &lt; low[v]，则更新 low[v] = low[w] 当节点访问完节点 2 回到节点 3 时，此时 low[2] &lt; low[3]，更新 low[3] = low[2] = 0，表示 low[3] 可以从另外一条路径到达第 low[2] = 0 个被遍历的节点，即节点 0 引入了 order 与 low 数组，接着我们可以根据这两个数组判断某条边是不是桥了，当我们遍历完相邻节点 w，来到当前节点 v 时，除了要更新 low[v]，我们还需要对这条边是不是桥进行判断。 我们需要判断 low[w] 与 order[v] 的大小，以此判断是否是桥。首先明确一下二者表示的意义： low[w] 表示节点 w 能够通过另一条路径能够到达的最前顺序，例如 low[w] = 3 就表示 w 节点能通过另一条路径到达第 3 个被遍历的节点， order [v] 表示节点 v 是第几个被遍历的 如果 low[w] $\\leq$ order[v]，说明 w 能通过另一条路径到达节点 v 或 v 之前被遍历的节点，说明就不是桥，否则就是桥。 import java.util.ArrayList;import java.util.HashSet;public class FindEdge &#123; private int[] order; private int[] low; private Graph graph; private boolean[] visited; private int count = 0; // 存储桥 private ArrayList&lt;int[]&gt; result; public FindEdge(Graph graph) &#123; this.graph = graph; order = new int[graph.V()]; low = new int[graph.V()]; result = new ArrayList&lt;&gt;(); visited = new boolean[graph.V()]; for (int i = 0; i &lt; graph.V(); i++) &#123; if (!visited[i]) &#123; dfs(i, i); &#125; &#125; &#125; private void dfs(int v, int parent) &#123; visited[v] = true; low[v] = count; order[v] = count; count++; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, v); // 更新 low[v] 时机 1 low[v] = Math.min(low[v], low[w]); // 判断是否是桥 if (low[w] &gt; order[v]) &#123; result.add(new int[]&#123;v, w&#125;); &#125; &#125; else if (w != parent)&#123; // 更细 low[v] 时机 2 low[v] = Math.min(low[w], low[v]); &#125; &#125; &#125; public ArrayList&lt;int[]&gt; getResult() &#123; return result; &#125;&#125; 割点定义割点的定义与桥的定义类似，割点指的是一个节点，如果一旦移除这个节点，会导致图中的联通分量发生变化，那么就称这个节点为割点。 上图中节点 3 与节点 5 为割点，一旦去掉这两个节点之一，图的联通分量的个数就会发生变化。 寻找割点寻找割点的过程同寻找桥是一样的，也需要维护 order 与 low 两个数组，这两数组的含义也是同上一致的。low 数组的更新时机以及更新过程也是同上一致的。 现在的问题是我们在什么时候判断某节点是不是割点，以及条件是什么。我们在遍历完相邻节点 w，返回到当前节点 v 时，如果 low[w] $\\geq$ order[v] 时，就说明它是一个割点。这里的判断条件与桥的判断不同，桥的判断条件是如果 low[w] &gt; order[v] 时，就说明 v-w 这条边是桥，注意多了一个等于号。 low[w] $\\geq$ order[v] 表示节点 w 与 节点 v 之前被遍历的节点产生连接只能通过节点 v 例如节点 4 通过另外一条路径它最多到达节点 5，无法与节点 5 之前被遍历的节点产生连接。一旦节点 5 被删除，4 就无法访问到节点 0, 1, 2, 3，所以 5 就是割点。 但是添加了等于号之后，这个时候因为任何节点 low[v] $\\geq$ order[0]，所以根节点 0 会被认为是割点，但根节点不一定是割点，这个时候我们就需要对根节点分别讨论，判断根节点是不是割点很简单，如果通过 DFS 遍历，根节点有两个相邻节点就说明它是割点 import java.util.ArrayList;import java.util.HashSet;public class FindCutPoints &#123; private Graph graph; private boolean[] visited; private int[] order; private int[] low; private int count = 0; private HashSet&lt;Integer&gt; result = new HashSet&lt;&gt;(); public FindCutPoints(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; order = new int[graph.V()]; low = new int[graph.V()]; for (int i = 0; i &lt; graph.V(); i++) &#123; if (!visited[i]) &#123; dfs(i, i); &#125; &#125; &#125; private void dfs(int v, int parent) &#123; visited[v] = true; order[v] = count; low[v] = count; count++; int child = 0; for (int w: graph.adj(v)) &#123; child++; if (!visited[w]) &#123; dfs(w, v); low[v] = Math.min(low[v], low[w]); if (v != parent &amp;&amp; low[w] &gt;= order[v]) &#123; result.add(v); &#125; if (v == parent &amp;&amp; child &gt; 1) &#123; result.add(v); &#125; &#125; else if (w != parent) &#123; low[v] = Math.min(low[v], low[w]); &#125; &#125; &#125; public HashSet&lt;Integer&gt; getResult() &#123; return result; &#125;&#125; 哈密尔顿回路与哈密尔顿路径哈密尔顿回路1859年，爱尔兰数学家哈密尔顿（Hamilton）提出下列周游世界的游戏：在正十二面体的二十个顶点上依次标记伦敦、巴黎、莫斯科等世界著名大城市，正十二面体的棱表示连接这些城市的路线。试问能否在图中做一次旅行，从顶点到顶点，沿着边行走，经过每个城市恰好一次之后再回到出发点。 将上面的问题抽象为一个图论问题：如果我们能从图的某点出发，经过所有的节点有且仅有一次，并且回到原点，那么我们就说图中存在哈密尔顿回路。 哈密尔顿回路在数学上并没有找到充分必要条件，所谓充分必要条件指的是，如果图满足什么性质它就有哈密尔顿回路以及一旦图有哈密尔顿回路这个图就满足什么性质。所以我们判断判断某个图是否是哈密尔顿图，办法就是暴力搜索，使用回溯法去搜索图。 import java.util.ArrayList;import java.util.Collections;public class HamiltonCycle &#123; private Graph graph; private boolean[] visited; // 还有多少个节点未访问，当 left == 0 时表示所有节点都被访问过 private int left; // 当前节点的前一个节点，已获得路径 private int[] pre; // 最后一个被访问的节点 private int end; public HamiltonCycle(Graph graph) &#123; this.graph = graph; this.visited = new boolean[graph.V()]; this.left = graph.V(); this.pre = new int[graph.V()]; this.end = -1; pre[0] = 0; dfs(0); &#125; // dfs 设有返回值，当找到哈密尔顿回路时，提前终止 private boolean dfs(int v) &#123; visited[v] = true; left--; if (left == 0 &amp;&amp; graph.hasEdge(v, 0)) &#123; end = v; return true; &#125; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; pre[w] = v; if (dfs(w)) return true; &#125; &#125; visited[v] = false; left++; return false; &#125; public Iterable&lt;Integer&gt; result() &#123; ArrayList result = new ArrayList(); if (end == -1) &#123; return result; &#125; int cur = end; while (cur != 0) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(0); Collections.reverse(result); return result; &#125;&#125; 状态压缩对图进行暴力搜索的时间复杂度是 $O(n!)$，所以暴力搜索图只适合图的规模不大的情况，当图的规模不大时，我们可以对 visited 数组进行压缩，使用一个整数来表示图中个节点的访问状态，具体就是根据这个数字的二进制位为 0 还是为 1 来表示是否被访问过。 举个例子，我们使用 int 类型来保存 visited 变量，int 类型占据 4 个字节，即 32 位，第一位是符号位，故可以认为可以表示 31 个节点访问状态，如果 visited = 1，二进制就是 00000000 00000000 00000000 00000001，从右往左数第 0 个数是 1，就表示节点 0 被访问过了，其他数字都是 0，表示其他节点没有被访问过。 观察上面的程序，我们对 visited 有三种操作： 判断某个节点有没有被访问过，例如判断节点 i 有没有被访问过，只要 $2^i$ 和 visited 相与即可知道，如果结果为 1，说明第 i 位为 1，即节点 i 被访问过，否则就是未被访问过 将节点 i 设置为被访问过(visited[i] = true)，也就是将第 i 个位置由 0 变为 1，就是将 $2^i$ 与 visited 异或即可 将节点 i 设置为未被访问过(visited[i] = false)，也就是将第 i 个位置由 1 变为 0，还是将 $2^i$ 与 visited 异或即可 注意 $2^i$ 可以表示为 i &lt;&lt; 1 所以我们修改上面的程序，将 visited 数组变为一个数字 public class HamiltonCircleCompress &#123; private Graph graph; private int visited; private int left; private int[] pre; private int end; // 不变 public HamiltonCircleCompress(Graph graph) &#123; this.graph = graph; this.visited = 0; this.left = graph.V(); this.pre = new int[graph.V()]; this.end = -1; pre[0] = 0; dfs(0); &#125; private boolean dfs(int v) &#123; // 设置 visited[v] 为 true visited = visited ^ (1 &lt;&lt; v); left--; if (left == 0 &amp;&amp; graph.hasEdge(v, 0)) &#123; end = v; return true; &#125; for (int w: graph.adj(v)) &#123; // 判断 visited[w] 是否访问过 if ((visited &amp; (1 &lt;&lt; w)) == 0) &#123; pre[w] = v; if (dfs(w)) return true; &#125; &#125; // 设置 visited[v] 为 false visited = visited ^ (1 &lt;&lt; v); left++; return false; &#125; // 不变 public Iterable&lt;Integer&gt; result() &#123; ArrayList result = new ArrayList(); if (end == -1) &#123; return result; &#125; int cur = end; while (cur != 0) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(0); Collections.reverse(result); return result; &#125;&#125; 哈密尔顿路径哈密尔顿路径的定义同哈密尔顿回路相似，如果从图中的某一点出发，能够经过图中所有的节点有且仅有一次，那么这条路径就是哈密尔顿路径。需要注意的是，图中是否存在哈密尔顿回路与起始点无关，但是哈密尔顿路径与起始点有关，可能从某点出发，并不能走过每一节点，但是从另一个节点出发，却能够走过所有节点，且只经过一次。 哈密尔顿路径的代码同哈密尔顿回路的代码相似，只有两处不同： 需要传入起始点 当 left 为 0 时，不用判断最后节点是否与起始点相邻，因为哈密尔顿路径不要求回到起始点 代码如下 import java.util.ArrayList;import java.util.Collections;public class HamiltonPath &#123; private Graph graph; private boolean[] visited; private int left; private int[] pre; private int end; // 起始点 private int s; public HamiltonPath(Graph graph, int s) &#123; this.graph = graph; this.s = s; this.visited = new boolean[graph.V()]; this.left = graph.V(); this.pre = new int[graph.V()]; this.end = -1; pre[0] = 0; dfs(s); &#125; private boolean dfs(int v) &#123; visited[v] = true; left--; // 不用判断 v 是否与起始点相邻 if (left == 0) &#123; end = v; return true; &#125; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; pre[w] = v; if (dfs(w)) return true; &#125; &#125; visited[v] = false; left++; return false; &#125; public Iterable&lt;Integer&gt; result() &#123; ArrayList result = new ArrayList(); if (end == -1) &#123; return result; &#125; int cur = end; while (cur != 0) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(0); Collections.reverse(result); return result; &#125;&#125; 不同路径 III这是一道 LeetCode 上的题目，它的本质就是在求哈密尔顿路径。 题目简介在二维网格 grid 上，有 4 种类型的方格： 1 表示起始方格。且只有一个起始方格 2 表示结束方格，且只有一个结束方格 0 表示我们可以走过的空方格 -1 表示我们无法跨越的障碍 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。 提示：1 &lt;= grid.length * grid[0].length &lt;= 20。 解题思路我们可以将整个二维网格建模为一幅图，0 表示一个节点(起始点 1 和终止点 2 也是节点)，如果两个 0 上下左右相邻，就表示它们之间有一条边。现在题目要求从起始点到达终止点，必须经过每一个节点，并且有且只能经过一次，这不就是哈密尔顿路径吗? 那么题目就是在要求这个图有多少条哈密尔顿路径。 import java.util.Arrays;import java.util.stream.Collectors;public class Solution &#123; // 状态压缩，题目给出节点数目小于等于 20 private int visited; // 起始点和终止点下标 private int[] start; private int[] end; // 网格的行数和列数 private int rows; private int columns; // 剩余未访问节点 private int left; // 网格 private int[][] grid; public int uniquePathsIII(int[][] grid) &#123; this.grid = grid; this.rows = grid.length; this.columns = grid[0].length; this.visited = 0; this.start = new int[2]; this.end = new int[2]; this.left = rows * columns; // 下面这个循环是为了找到起始点和终止点，并且更新 left for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (grid[row][column] == 1) &#123; start[0] = row; start[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == 2) &#123; end[0] = row; end[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == -1) &#123; // -1 不是节点，需要减掉 left--; &#125; &#125; &#125; return dfs(start); &#125; private int dfs(int[] v) &#123; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left--; if (left == 0 &amp;&amp; (v[0] == end[0] &amp;&amp; v[1] == end[1])) &#123; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left++; return 1; &#125; int res = 0; for (int[] w: adj(v[0], v[1])) &#123; if ((visited &amp; (1 &lt;&lt; (w[0] * columns + w[1]))) == 0 &amp;&amp; grid[w[0]][w[1]] != -1) &#123; res += dfs(w); &#125; &#125; // 回溯 left++; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); return res; &#125; private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125; public static void main(String[] args) &#123; int[][] grid = &#123;&#123;1,0,0,0&#125;,&#123;0,0,0,0&#125;,&#123;0,0,2,-1&#125;&#125;; Solution solution = new Solution(); int res = solution.uniquePathsIII(grid); System.out.println(res); &#125;&#125; 记忆化搜索考虑这么一幅图 我们将它分为两部分 我们称左边为第一部分，右边为第二部分。现在从节点 0 开始遍历，寻找有多少条哈密尔顿回路，我们发现不论是以何种方式遍历完第一部分来到第二部分，有多少条哈密尔顿路径只与第二部分有关，即这几种路径搜索多少条哈密尔顿路径的结果是一样的，无需重复遍历。 例如，我们以 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$ 的方式遍历完第一部分来到第二部分 它有多少条哈密尔顿路径只与第二部分有关，如果我们以 $0 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$ 的方式遍历完第一部分来到第二部分 它有多少条哈密尔顿路径的结果应该与以 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$ 顺序遍历的结果相同，如果我们可以缓存这个结果，就可以避免不必要的遍历，从而提高性能。 当遍历到节点 v 时，如果此时它们的 visited 是一样的，我们就可以认为它们会有一样的结果，例如对于上图，当遍历到节点 3 时，两条路径的遍历 visited 状态是一样的，我们可以认为它们的结果是一样的。 这种搜索策略叫做记忆化搜索，基于记忆化搜索的想法，我们改造上面的程序 import java.util.Arrays;import java.util.HashMap;import java.util.stream.Collectors;public class Solution &#123; private int visited; private int[] start; private int[] end; private int rows; private int columns; private int left; private int[][] grid; private HashMap&lt;String, Integer&gt; memo= new HashMap&lt;&gt;(); public int uniquePathsIII(int[][] grid) &#123; this.grid = grid; this.rows = grid.length; this.columns = grid[0].length; this.visited = 0; this.start = new int[2]; this.end = new int[2]; this.left = rows * columns; for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (grid[row][column] == 1) &#123; start[0] = row; start[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == 2) &#123; end[0] = row; end[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == -1) &#123; left--; &#125; &#125; &#125; return dfs(start); &#125; private int dfs(int[] v) &#123; String strV = format(v); if (memo.containsKey(visited + strV)) &#123; return memo.get(visited + strV); &#125; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left--; if (left == 0 &amp;&amp; (v[0] == end[0] &amp;&amp; v[1] == end[1])) &#123; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left++; memo.put(visited + strV, 1); return 1; &#125; int res = 0; for (int[] w: adj(v[0], v[1])) &#123; if ((visited &amp; (1 &lt;&lt; (w[0] * columns + w[1]))) == 0 &amp;&amp; grid[w[0]][w[1]] != -1) &#123; res += dfs(w); &#125; &#125; left++; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); memo.put(visited+strV, res); return res; &#125; private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125; private String format(int[] v) &#123; int location = v[0] * columns + v[1]; int first = location / 10; int second = location % 10; return \"\" + first + second; &#125;&#125; 欧拉回路与欧拉路径欧拉回路七桥问题18世纪初普鲁士的哥尼斯堡，有一条河穿过，河上有两个小岛，有七座桥把两个岛与河岸联系起来，如下图(黄色线条代表桥，绿色区域代表小岛和河岸) 有个人提出一个问题：一个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。 数学家欧拉将河岸与小岛建模为节点，而七座桥建模为边，所以七桥问题建模为上图最右边的图论问题，找到图中经过所有边一次且回到原点的回路，这种回路我们后来称为欧拉回路。 欧拉回路的数学性质上述的七桥问题很长时间都没有解决，即人们没有找到一条回路，能够只经过每座桥一次，然后回到原点。所以欧拉就猜想是不是根本不存在这种回路，经过他的证明，上述七桥问题的确不存在欧拉回路。 欧拉证明十分的简单，因为要从起点出发回到原点，那么对于每个节点都要一进一出，而每次进出需要消耗两条边，所以每个节点必须具有偶数条边，它才能保证有进有出，才有可能回到原点。所以就得到了欧拉回路一个充分必要条件： 每个节点的度都是偶数 $\\Leftrightarrow$ 图中存在欧拉回路 每个节点的度都是偶数是图中存在欧拉回路是充分必要条件，二者可以互推，所以我们只要判断图中每个节点的度是不是偶数即可得到图中是否有欧拉回路这个结论。 回到七桥问题，观察图中的每一个节点，发现它们的度都不是偶数，所以绝对不可能从某点出发，经过所以的边一次然后回到原点，至此欧拉完美的解决了七桥问题，图论领域也是从此开始发展。 下面是判断欧拉回路是否存在的代码： public class EulerCycle &#123; private Graph graph; public EulerCycle(Graph graph) &#123; this.graph = graph; &#125; public boolean hasEulerCycle() &#123; // 如果图中不只一个联通分量的话，说明肯定没有欧拉回路 CCGraph ccGraph = new CCGraph(graph); if (ccGraph.getCCcount() != 1) &#123; return false; &#125; for (int i = 0; i &lt; graph.V(); i++) &#123; if (graph.degree(i) % 2 != 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 求解欧拉回路上面我们只是判断图中欧拉回路是否存在，但是我们没有得到一个具体的欧拉回路，所以在本节中介绍三种方法得到欧拉回路。 回溯法回溯法就是暴力搜索法，搜索从起点出发的所有路径，直到找到一条欧拉回路 Fleury 算法考虑下图，当我们从节点 0 来到节点 2 时 对于回溯法，可以选择遍历节点 1，也可以选择遍历节点 3，而 Fleury 算法却会选择接下来遍历节点 3 而不是节点 1，因为边 2-1 它是一个桥，如果选择遍历节点 1，就不可能再次回到节点 2，即节点 2 右边的边 2-3 2-4 不可能被访问到，所以 Fleury 算法的策略就是在遍历边前判断这条边是不是桥，如果是桥的话，就不遍历这条边，选择其他的边。 Hierholzer 算法 上图每个节点的度都是偶数，所以该图一定有欧拉回路。Hierholzer 算法首先在图中随便找到一个环 这个环如果是欧拉回路，那就找到了；如果不是欧拉回路，例如上面找到环 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 0$，它不是欧拉回路，中间缺失了一环，因为节点 2 还与别的节点相连，上述链中的 $2$ 应该变为 $2 \\rightarrow … \\rightarrow 2 $，所以我们需要回退到节点 2 开始寻找这个环。 比如我们继续找到了 $2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2$ 这个环 但是因为 $5$ 还与别的节点相连，所以 $5$ 应该被扩展为 $5 \\rightarrow … \\rightarrow 5$，所以又需要回退到节点 5 开始寻找新的环 最终我们找到了环 $5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 5$，将这个结果替换 $2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2$ 其中的 $5$，得到 $2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 5 \\rightarrow 2$，最后将这个结果环替换 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 0$ 其中的 $2$，结果变为 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 5 \\rightarrow 2 \\rightarrow 3 \\rightarrow 0$。 我们可以使用栈来模拟上面的回退动作，当我们遍历环时，将节点添加进栈 result中，当我们发现来到某个节点不能继续遍历并且还有边未被遍历时，我们便进行回退，从栈中弹出元素，直到栈顶节点还与其他节点相连，从该节点开始寻找新的环。我们会将从栈中弹出的节点添加到另一个栈 back 中，当我们遍历完所有的边时在将 back 这个栈中的节点依次弹入到 result 这个栈中 因为上面有删边的动作，所以我们在 Graph 接口添加了一个 removeEdge(int v, int w)，作用就是将 v-w 这条边删除，具体实现如下 @Overridepublic void removeEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); sets[v].remove(w); sets[w].remove(v);&#125; Hierholzer 算法的实现如下 import java.util.ArrayList;import java.util.Collections;import java.util.Stack;public class EulerCycle &#123; private Graph graph; public EulerCycle(Graph graph) &#123; this.graph = graph; &#125; public boolean hasEulerCycle() &#123; CCGraph ccGraph = new CCGraph(graph); if (ccGraph.getCCcount() != 1) &#123; return false; &#125; for (int i = 0; i &lt; graph.V(); i++) &#123; if (graph.degree(i) % 2 != 0) &#123; return false; &#125; &#125; return true; &#125; public Iterable&lt;Integer&gt; result() &#123; ArrayList res = new ArrayList(); if (!hasEulerCycle()) return res; // 剩余未被遍历的边数 int left = graph.E(); Stack&lt;Integer&gt; result = new Stack&lt;&gt;(); Stack&lt;Integer&gt; back = new Stack&lt;&gt;(); int curV = 0; result.push(curV); // 还有边未被遍历就继续遍历 while (left != 0) &#123; // 每次更新 curV 为栈顶节点 curV = result.peek(); // 如果栈顶元素有相邻节点，从此寻找新的环 if (graph.degree(curV) != 0) &#123; // 获得一个相邻节点 int w = graph.adj(curV).iterator().next(); result.push(w); graph.removeEdge(curV, w); left--; &#125; else &#123; // 没有相邻节点，进行回溯 back.push(result.pop()); &#125; &#125; // 将 back 栈中的数据依次弹出到 result while (!back.isEmpty()) &#123; result.push(back.pop()); &#125; // 将栈中元素弹出到 list 中 while (!result.isEmpty()) &#123; res.add(result.pop()); &#125; Collections.reverse(res); return res; &#125;&#125; 验证算法是否正确，新建 g11.txt，内容如下 9 110 10 31 22 32 42 54 55 65 86 77 8 所表示的图就是示例中的图 测试如下 public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g11.txt\"); EulerCycle eulerCycle = new EulerCycle(graph); for (int w: eulerCycle.result()) &#123; System.out.print(w + \" \"); &#125;&#125; 输出为 0 1 2 4 5 6 7 8 5 2 3 0 与我们讨论的结果一致。 最小生成树带权图在之前的文章中，介绍的都是无向无权图，那本篇开始介绍无向带权图 如果将上述的图看做是一个交通系统的话，那么边的权重就可以代表为距离。为了表示带有权重的图，我们建立一个 WeightedGraph 类来表示带权图。 同无权图 AdjSet 一样，我们从如下格式的文件读取内容生成图 7 120 1 20 3 70 5 21 2 11 3 41 4 31 5 52 4 42 5 43 4 13 6 54 6 7 第一行 7 表示总共有 7 个节点，12 表示有 12 条件，下面表示两两相邻的节点，以及之间的权重，例如 0 1 2 表示节点 0 与节点 1 相邻，之间的权重为 2。 WeightedGraph 类如下，代码大部分同 AdjSet 类： import java.io.File;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class WeightedGraph&#123; private int V; private int E; // adj[i] 是一个 HashMap，键为相邻的节点，值为边上的权重 private HashMap&lt;Integer, Integer&gt;[] adj; public WeightedGraph(String path) &#123; File file = new File(path); Scanner scanner = null; // 从 txt 文件读取建立图，大部分同 AdjSet 类 try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (V &lt; 0) &#123; throw new IllegalArgumentException(\"V can't be negative\"); &#125; adj = new HashMap[V]; for (int i = 0; i &lt; V; i++) &#123; adj[i] = new HashMap&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (E &lt; 0) &#123; throw new IllegalArgumentException(\"E can't be negative\"); &#125; for (int i = 0; i &lt; E; i++) &#123; int v = scanner.nextInt(); int w = scanner.nextInt(); int weight = scanner.nextInt(); if (v == w) &#123; throw new IllegalArgumentException(\"存在自环边\"); &#125; if (adj[v].containsKey(w)) &#123; throw new IllegalArgumentException(\"存在平行边\"); &#125; adj[v].put(w, weight); adj[w].put(v, weight); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; scanner.close(); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public int getWeight(int v, int w) &#123; validateVertex(v); validateVertex(w); return adj[v].get(w); &#125; public int degree(int v) &#123; validateVertex(v); return adj[v].size(); &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return adj[v].containsKey(w); &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return adj[v].keySet(); &#125; public void validateVertex(int v) &#123; if (v &lt; 0 &amp;&amp; v &gt;= V) &#123; throw new IllegalArgumentException(\"节点超过 [0, V) 的范围\"); &#125; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (Map.Entry w: adj[v].entrySet()) &#123; stringBuilder.append(String.format(\"(%d: %d) \", w.getKey(), w.getValue())); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 最小生成树首先介绍生成树的概念，假设图中有 $V$ 个顶点，如果能找到图中 $V - 1$ 条边这 $V$ 个节点连接起来，那么就说这 V 个节点与 V - 1 条边形成的图叫做这个图的生成树。 例如图的 DFS 遍历以及 BFS 遍历就会形成一个生成树 只要图中的 $V - 1$ 条边将图中的 $V$ 个顶点联通起来，那么就是图的一个生成树，所以一个图有很多的生成树，所谓的最小生成树，就是生成树边上的权值加起来最小 那么最小生成树有什么应用呢? 如果将这个图看做是交通系统，找出最小生成树就是找到一种耗费最低的方式将所有站点连通起来的布局方案。 切分定理下面介绍切分定理，这个定理被用来寻找最小生成树。首先什么叫切分，所谓切分就是把节点分为两部分 上图中节点 $0, 5, 4$ 被划分一部分，其余节点为另一部分。切分的方式有很多种，随意你进行切分，只要将图中的节点划分为两部分即可。 引入了切分的概念，下面继续引入横切边的概念。所谓的横切边指的是将两个不同部分节点连接起来的边，例如对于上面的划分，有如下横切边 上面被标记为绿色的边就是横切边，可以看到横切边的两端是两个不同部分的节点。 介绍完必须的概念之后，引入切分定理： 切分定理：对于任意一个切分，这种切分形成的横切边中，权值最小的横切边一定在最小生成树中 这个定理很好证明，我们根据切分将图分为两部分 这两部分之间的边就是横切边，可以观察到横切边将这两个部分连接在了一起，为了使得生成树连通，一定要在横切边中选择一条边，而为了得到最小生成树，那当然选择的是权值最小的横切边，所以说权值最小的横切边一定在最小生成树中。 Kruskal 算法Kruskal 算法是求的最小生成树的一种算法，他的思想很简单，就是每次取图中最小的边，只要这条边没有已经选取的边形成环。例如对于下图 首先选择图中最短的两条边，即权值为 1 的两条边 1-2 与 3-4 下面继续选择权值最小的边，选择 0-5、0-1，这两条边的权值为 2 继续选择权值最小的边，此时选择 1-4，权值为 3 继续选择，此时应该选择 5-2 与 1-3 两条边，它们的权值为 4，但是我们发现选择 5-2 就会形成一个环，选择 1-3 也会形成环，所以这两条边不能选，生成树中可不能有环的。除开这两条边继续选择，发现 5-1、3-6 这两条边的权值为 5，权值最小，但是选择 5-1 就会形成环，所以不选 5-1，只选择 3-6 这个时候我们已经找到了 6 条边将这 7 个顶点连接起来，即找到了一个最小生成树 Kruskal 的算法思想很简单，就是贪心，每次选择权重最小的边，但是怎么证明这种贪心策略是对的。这就需要用到切分定理。 每次我们选择最小的边，我们只需要让这条边是一个切分的横切边就行，这种切分很好做，让这条边两个节点属于不同的部分即可，根据切分定理这条横切边一定是最小生成树中的一条边。如果这条边与选择的边形成了一个环，这说明找不到一个切分，使得这条边的所有横切边中最短的边，所以不能选择它。 在代码的实现方向，每次我们找到一个最短的边时，需要判断是否构成一个环，例如我们找到边 5-1，需要判断添加这条边是否构成一个环，其实就是在检测在添加这条边之前节点 5 和节点 1 是否连通，如果是连通，添加这条边后就会形成环。 每次都需要判断两个节点需要连通，可以使用 DFS 来做，但是这样做复杂度太高，借助并查集这种数据结构可以很方便的判断两个节点是否连通，只需要判断它们是否在一个集合中即可，如果对于并查集不熟，可以参考这篇文章。 并查集的实现如下： public class UnionFind &#123; private int[] parent; private int[] rank; public UnionFind(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; index = parent[index]; &#125; return index; &#125; public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; 我们需要一个类来保存边的信息，这里我们新建一个 WeightedEdge 类： public class WeightedEdge &#123; private int v; private int w; private int weight; public WeightedEdge(int v, int w, int weight) &#123; this.v = v; this.w = w; this.weight = weight; &#125; public int getV() &#123; return v; &#125; public int getW() &#123; return w; &#125; public int getWeight() &#123; return weight; &#125; @Override public String toString() &#123; return String.format(\"(%d-%d: %d)\", v, w, weight); &#125;&#125; Kruskal 算法实现如下： import java.util.ArrayList;import java.util.Collections;public class Kruskal &#123; private WeightedGraph graph; public ArrayList&lt;WeightedEdge&gt; result = new ArrayList&lt;&gt;(); public Kruskal(WeightedGraph graph) &#123; this.graph = graph; int V = graph.V(); // 将所有的边添加进集合中 ArrayList&lt;WeightedEdge&gt; edges = new ArrayList&lt;&gt;(); for (int v = 0; v &lt; V; v++) &#123; for (int w: graph.adj(v)) &#123; if (v &lt; w) &#123; edges.add(new WeightedEdge(v, w, graph.getWeight(v, w))); &#125; &#125; &#125; // 根据边的权值大小，从小到大排序 Collections.sort(edges, (w1, w2) -&gt; w1.getWeight() - w2.getWeight()); UnionFind unionFind = new UnionFind(V); for (WeightedEdge edge: edges) &#123; int v = edge.getV(); int w = edge.getW(); // 如果之前不连通 if (!unionFind.isConnected(v, w)) &#123; result.add(edge); unionFind.unionElements(v, w); &#125; &#125; &#125; public Iterable&lt;WeightedEdge&gt; result() &#123; return result; &#125;&#125; Prim 算法Prim 算法也是有关最小生成树的算法，它的思想同切分定理密切相关。因为对于每一个切分，权值最小的横切边一定在最小生成树中。Prim 算法就在遍历节点的过程中，将遍历到的节点与未遍历的节点作为两部分形成一个切分，然后遍历此时所有的横切边，在此边作为最小生成树的一条边。 每次遍历到一个节点即可找到一条横切边，当遍历到最后一个节点时，就能找到 $V-1$ 条边，即可形成一个生成树，并且根据切分定理，这个生成树一定是最小生成树。 Prim 算法最后的结果是同 Kruskal 算法相同的。 在代码的实现方面，因为每次产生一次新的切分，都要找到所有的横切边进行遍历然后找到最小的横切边，这个过程我们可以使用优先队列进行实现。 当遍历到一个节点时，新的横切边的产生都与这个遍历到的节点相连，我们只要将新的横切边添加到队列中即可，不用遍历节点寻找所以的横切边，另外这是一个优先队列，即队首元素它的权重是最小的，我们也不用查找最小边的炒作，直接取出队首元素即可。 另外，可能你会注意到，当遍历到一个新的节点，产生一个新的切分时，之前的横切边可能不是横切边了，即优先队列中的边不是所有的边都是横切边。仔细想想，这个并没有影响，因为虽然不是所有的边都是横切边，但是所有的横切边都在队列里，我们从队列中取出边时进行判断，不是横切边直接忽略即可，完全不影响我寻找最小的横切边。 import java.util.ArrayList;import java.util.PriorityQueue;public class Prim &#123; private WeightedGraph graph; private boolean[] visited; private ArrayList&lt;WeightedEdge&gt; result = new ArrayList&lt;&gt;(); public Prim(WeightedGraph graph) &#123; this.graph = graph; PriorityQueue&lt;WeightedEdge&gt; priorityQueue = new PriorityQueue&lt;&gt;((w1, w2) -&gt; w1.getWeight() - w2.getWeight()); this.visited = new boolean[graph.V()]; visited[0] = true; for (int w: graph.adj(0)) &#123; priorityQueue.add(new WeightedEdge(0, w, graph.getWeight(0, w))); &#125; while (!priorityQueue.isEmpty()) &#123; WeightedEdge edge = priorityQueue.remove(); int v = edge.getV(); int w = edge.getW(); // 不是横切边直接忽略 if (visited[v] &amp;&amp; visited[w]) &#123; continue; &#125; result.add(edge); visited[w] = true; // 添加新的横切边 for (int next: graph.adj(w)) &#123; priorityQueue.add(new WeightedEdge(w, next, graph.getWeight(w, next))); &#125; &#125; &#125; public Iterable&lt;WeightedEdge&gt; result() &#123; return result; &#125;&#125; 如果在实际中需要手写最小生成树算法，推荐使用 Prim 算法，因为在大多数的语言标准库中都有优先队列的实现，但是都没有并查集的实现，所以如果使用 Kruskal 算法需要手写并查集。 最短路径算法本文讲解图中点与点之间的最短路径问题，主要讲解三个算法： Dijkstra 算法 Bellman-Ford 算法 Floyed 算法 其中 Dijkstra 与 Bellman-Ford 是解决单源最短路径问题，即它只能求解某节点到其他节点的最短路径，而 Floyed 算法能够求解所有节点之间的最短路径。 Dijkstra 算法Dijkstra 算法它能够求解单源最短路径问题，并且使用该算法有一个前提，图中不能存在负权边，即图中的每条边的权值都必须是大于等于 0 的。 Dijkstra 算法使用一个 dis 数组来表示从源 s 到其他节点的最短距离，例如 dis[v] 表示的就是源 s 到达节点 v 的最短距离，在初始时，除了 dis[s] 为 0，其余的 dis[v] 均为无穷大。 Dijkstra 算法的思想是，每次从未遍历的节点，寻找在 dis 数组中值最小的节点，然后根据这个节点更新其未被遍历过的相邻节点在 dis 数组中的值。例如遍历到节点 v，其相邻节点为 w，并且节点 w 未被遍历过，如果 dis[v] + weight(v,w) &lt; dis[w]​，那么就更新 dis[w]，其中 weight(v, w) 是边 v-w 的权值。 举个例子，假设源为节点 0，我们求解节点 0 到各个节点的最短路径 初始节点 0 到节点 0 的距离为 0，其余节点距离节点 0 的距离为 $\\infin$。根据 Dijkstra 算法，每次从未遍历的节点，寻找在 dis 数组中值最小的节点，所以此时我们找到了节点 0，dis[0] 为 0，比其他元素小。我们来到节点 0，根据公式 dis[0] + weight(0, w) &lt; dis[w]更新与 0 相邻的节点 w 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，是节点 2，它的值为 1，并且此时我们可以断定节点 0 离节点 2 的最短距离就是 1。 为什么呢? 假设存在一条更短的路径从 0 到 2，例如是 0-1-2，但是因为此时 0-2 是最小的，而图中又不存在负权边，所以 0-1-2 比 0-1 还大，也就是比 0-2 大，所以 0-2 就是从 0 到 2 的最短路径。来到节点 2 之后，根据条件 dis[2] + weight(2, w) &lt; dis[w] 是否成立更新其相邻节点。 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，此时 dis[1] 与 dis[6] 的值都是 2，随便选一个就可以，这里我选择节点 1，并且此时可以判定节点 0 到节点 1 的最短路径就是 dis[1] 为 2。为什么? 假设存在一条路径经过未遍历的节点从 0 到达节点 1，比如是节点 4 好了，因为 dis[1] 此时是未遍历的节点中最小的，所以 dis[1] &lt; dis[4]，更别说还要加上节点 4 到节点 1 的距离，矛盾，所以找不到一条经过未遍历节点来到节点 1。 那么是否存在一条路径只经过已经遍历过的节点到达节点 1，并且路径比 dis[1] 小，不妨假设存在这么一条路径 0 -&gt; ... -&gt; s -&gt; 1，它的值比 dis[1] 小，即 dis[s] + weight(s, 1) &lt; dis[1]，那么当我们之前遍历到节点 s 对相邻节点更新的时候就会更新 dis[1] 为更小的值，也产生了矛盾，因此也不存在一条路径只经过已经遍历过的节点到达节点 1。所以我们可以说此时的 dis[1] 就是从 0 到 1 的最短路径。 来到节点 1 之后，更新其未被遍历过的相邻节点的值，当然图中节点 1 此时不存在未被遍历过的相邻节点，所以不进行任何的更新 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，找到节点 6，此时 dis[6] 的值为 2，并且此时我们可以判定从节点 0 到节点 6 的最短距离就是 2。 分析方法同上，先假设存在一条从未被遍历过的节点到达节点 6 得到的更短路径，但是因为 dis[6] 已经是从 0 到未被遍历的节点最小的，图中又不存在负权边，所以矛盾，再做假设存在只经过已被遍历过的节点到达节点 6，那么在之前 dis[6] 的值就会被更新为更小的值，也会产生矛盾，从而得到结论，不存在另外一条路径从 0 到 6 更短，此时 dis[6] 就是从 0 到 6 的最短距离。 来到节点 6 之后根据条件更新其未被遍历的相邻节点，图中节点 6 不存在未被遍历过的相邻节点，因此不作更新 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，发现 dis[3] 和 dis[4] 都是 3，我们就随便选择一个，这里选择节点 3，并且此时可以判定 dis[3] 是从节点 0 到节点 3 的最短距离，已经分析过多次，不再分析。 来到节点 3 之后，根据条件更新其未被遍历过的相邻节点，与节点 3 相邻未被遍历过的节点就是节点 4，但是并不满足 dis[3] + 3 &lt; dis[4] 的条件，所以不更新 dis[4] 重复上面的过程，我们可以得到下面这张表 0 1 2 3 4 5 6 dis 0 2 1 3 3 4 2 第二行的值表示原点到各点的最短路径。 所以 Dijkstra 算法就始终在重复两步： 寻找未被遍历节点中在 dis 数组中最小的那个节点 根据条件更新未被遍历过的相邻节点 寻找最小节点的操作我们使用一个优先队列来完成，直接从队首取出的值就是最小的，无需寻找 import java.util.*;public class Dijkstra &#123; private WeightedGraph graph; private int s; private int[] dis; private boolean[] visited; // 求具体的路径用 private int[] pre; public Dijkstra(WeightedGraph graph, int s) &#123; this.graph = graph; graph.validateVertex(s); this.s = s; this.dis = new int[graph.V()]; this.visited = new boolean[graph.V()]; this.pre = new int[graph.V()]; // 初始化操作 Arrays.fill(pre, -1); Arrays.fill(dis, Integer.MAX_VALUE); pre[s] = s; dis[s] = 0; // 建立一个优先队列，Node 保存的是节点 dis[v] 的值 PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;&gt;((node1, node2) -&gt; node1.getDis() - node2.getDis()); queue.add(new Node(s, 0)); while (!queue.isEmpty()) &#123; // 选出最小节点 int v = queue.remove().getV(); // 可能存在重复添加的情况，忽略 if (visited[v]) &#123; continue; &#125; visited[v] = true; // 更新未被遍历的相邻节点 for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dis[w] = Math.min(dis[w], dis[v] + graph.getWeight(v, w)); // 将 dis[w] 添加进队列，可能会重复添加 // 不过我们只对最小的那个感兴趣，重复添加取出后会被忽略 queue.add(new Node(w, dis[w])); pre[w] = v; &#125; &#125; &#125; &#125; public int[] result() &#123; return dis; &#125; // 获得源到节点 t 的具体路径 public Iterable&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); if (!visited[t]) &#123; return path; &#125; int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125;&#125; Bellman-Ford 算法Bellman-Ford 算法也是求解单源最短路径的算法，与 Dijkstra 算法不同的是，它能够处理负权边，即使允许图中存在权值为负数的边。 在讲解 Bellman-Ford 算法之前，我们来看一组操作 dis[w] = Math.min(dis[w], dis[v] + graph.getWeight(v, w)); 这个操作叫做松弛操作。 为什么叫松弛，因为本来可以直接到达点 w，现在经过上面的操作之后，偏要经过点 v 然后到达 w (不一定会经过，只有当 dis[v] + graph.getWeight(v, w) &lt; dis[w] 才会经过点 v)，如果把边看做橡皮筋的话，不就相当于松弛了吗? 而 Bellman-Ford 算法就是，对所有的边进行 $V - 1$ 轮松弛操作，这个 $V$ 指的是图中的节点数目，经过 $V - 1$ 轮松弛操作后，此时 dis 数组中保存的就是源点到各个节点的最短路径。 为了理解 Bellman-Ford 算法为什么这么神奇，每个节点经过 $V-1$ 轮松弛操作之后就可以得到最短路径，我们还是要研究一下松弛操作 dis[w] = Math.min(dis[w], dis[v] + graph.getWeight(v, w)); 如果进行了松弛操作，意味源多经过了一条边到 w，所以如果我们设定 dis[w] 为源点最多经过 $k$ 条边到达点 w的最短路径，那么经过一次松弛操作之后 dis[w] 语义变为源点最多经过 $k + 1$ 条边到达点 w 的最短路径，因为一个节点到达另一个节点最多经过 $V-1$ 条边，因此经过 $V - 1$ 轮的松弛操作之后，dis[w] 语义变为了源点最多经过 $V - 1$ 条边到达点 w 的最短路径，考虑到了源点到达节点 w 能经过的边数的所有情况，所以最终的 dis[w] 就是源点到点 w 的最短路径。 我们来看一个例子，假设源点为 0 图中有 4 个节点，因此要进行 3 轮松弛操作。第一次对所有边进行松弛操作 第二次对所有边进行松弛操作 第三次对所有边进行松弛操作 最后得到的结果为 0 1 2 3 dis 0 4 1 2 Bellman-Ford 虽然能够处理负权边，但是如果图中有负权环的话，那么就无法求解了，所谓的负权环是指环中所以边的路径和为负值，这样的只要我每次经过一次环，每个节点的 dis 值都在减少，如果图中存在负权环的话，那么根本就不存在最小路径。 大家在考虑一个问题，对于无向图来说，如果图中出现了负权边意味着什么? 假设 0-1 是一个负权边，因为是无向图，可以从 0 到 1，也可以从 1-0，那么我们可以从 0 来到 1，然后从 1 来到 0，这就形成一个负权环。所以 Bellman-Ford 算法其实是一个有向图算法。 另外我们可以通 Bellman-Ford 算法检测图中是否存在负权环，我们知道如果如果不存在负权环的话，经过 $V-1$ 次松弛操作后，dis 数组中的元素的值是不会再改变的，所以我们可以经过 $V-1$ 次松弛操作后再次进行一次松弛操作，如果在这次的松弛操作中，dis 中有元素的值发生改变，那么就说明存在负权环。 import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class BellmanFord &#123; private int[] dis; private WeightedGraph graph; private int s; private boolean hasNegativeCycle = false; private int[] pre; public BellmanFord(WeightedGraph graph, int s) &#123; this.graph = graph; graph.validateVertex(s); this.s = s; this.dis = new int[graph.V()]; this.pre = new int[graph.V()]; Arrays.fill(dis, Integer.MAX_VALUE); Arrays.fill(pre, -1); dis[s] = 0; pre[s] = s; // k 代表轮数 for (int k = 1; k &lt; graph.V(); k++) &#123; // 对所有边进行松弛操作，v-w 与 w-v 是两条边 for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; if (dis[v] != Integer.MAX_VALUE &amp;&amp; dis[v] + graph.getWeight(v, w) &lt; dis[w]) &#123; dis[w] = dis[v] + graph.getWeight(v, w); pre[w] = v; &#125; &#125; &#125; &#125; // 再次进行一次松弛操作，检测负权环 for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; if (dis[v] != Integer.MAX_VALUE &amp;&amp; (dis[v] + graph.getWeight(v, w) &lt; dis[w])) &#123; hasNegativeCycle = true; &#125; &#125; &#125; &#125; public int[] result() &#123; return dis; &#125; public Iterable&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125; public boolean isHasNegativeCycle() &#123; return hasNegativeCycle; &#125;&#125; Floyed 算法上面的两个算法解决的都是单源最短路径问题，而 Floyed 算法解决的所有点对之间的最短问题。我们其实可以通过使用 $V$ 次 Dijkstra 算法就可以求解所有点对之间的最短路径，不过 Dijkstra 算法不能处理负权边的问题，而 Floyed 算法可以处理负权边的问题。 但是同 Bellman-Ford 算法一样，如果图中存在负权环的话，就根本不存在最短路径，而我们知道如果无向图中有负权边的话，就相当于存在负权环，所以 Floyed 算法其实也是一个有向图算法。 Floyed 算法的思想也很简单，对于 v-w，假设它们之间的最短路径表示为 dis[v][w]，每一次都要尝试一下绕道点 t 会不会得到更短的路径(t 从节点 $0$ 取值到节点 $V-1$)，相当于 for(int t = 0; t &lt; V; t++) &#123; dis[v][w] = Math.min(dis[v][t] + dis[t][w], dis[v][w])&#125; 当经历过 $V$ 次的绕道尝试后，最终 dis[v][w] 就表示节点 v 与节点 w 之间的最短路径。 另外我们也可以通过 Floyed 算法对负权环进行检测，我们知道如果没有负权环的话 dis[v][v] 的值始终是 0，如果存在负权环的话，那么 dis[v][v] 的值就会更新为小于 0 的值，在经过 $V$ 次绕道之后检查所有的 dis[v][v] 是否等于 0 即可知道图中是否有负权环。 import java.util.Arrays;public class Floyed &#123; private WeightedGraph graph; private int[][] dis; private boolean hasNegativeCycle = false; public Floyed(WeightedGraph graph) &#123; this.graph = graph; this.dis = new int[graph.V()][graph.V()]; for (int i = 0; i &lt; dis.length; i++) &#123; Arrays.fill(dis[i], Integer.MAX_VALUE); &#125; // 初始化 dis[][] for (int v = 0; v &lt; graph.V(); v++) &#123; dis[v][v] = 0; for (int w: graph.adj(v)) &#123; dis[v][w] = graph.getWeight(v, w); &#125; &#125; // 绕道尝试 for (int t = 0; t &lt; graph.V(); t++) &#123; for(int v = 0; v &lt; graph.V(); v++) &#123; for (int w = 0; w &lt; graph.V(); w++) &#123; if (!(dis[v][t] == Integer.MAX_VALUE || dis[t][w] == Integer.MAX_VALUE)) &#123; dis[v][w] = Math.min(dis[v][w], dis[v][t] + dis[t][w]); &#125; &#125; &#125; &#125; // 检测负权环 for (int v = 0; v &lt; graph.V(); v++) &#123; if (dis[v][v] &lt; 0) &#123; hasNegativeCycle = true; &#125; &#125; &#125; public int dis(int v, int w) &#123; return dis[v][w]; &#125; public boolean isHasNegativeCycle() &#123; return hasNegativeCycle; &#125;&#125; Floyed 算法也有时称为 3-for 算法，因为它的算法核心就是三个嵌套的 for 循环，Floyed 算法的实现是这三个算法中最简单的。 之前接触过的图都是无向图，在这个小节中讲解有向图 实际生活中的很多问题都可以建模为一个有向图的模型： 社交网络：图中的节点看做是一个个的人，如果一个节点指向一个节点，表示这个人关注了这个人，这种关注关系是有方向的 学习课程：将图中的节点看做是一门门的课程，一门课程被其他课程所指向，表示学习这门课程之前需要学习其他的课程，这种学习顺序也是有指向关系的 模块引用：将图中的节点看做是一个个的程序模块，一个模块被其他模块指向，表示该模块依赖于其他模块，这种模块之间的依赖也是有方向的 有向图算法有向图的表示我们之前介绍的无向图可以看做是一种特殊的有向图，所谓的特殊在于每个节点都互相指向。我们之前在 g.txt 值规定规定了节点之间的连接关系，所以我们当我们读取到下面的形式的时候 0 1 表示的是节点 0 指向节点 1 以及节点 1 指向节点 0，所以我们在无向图中实现如下 adj[0].add(1);adj[1].add(0); 如果我们只是想表示节点 0 指向节点 1，我们就不需要添加下面那一行语句就好了。所以有向图对比于无向图的实现只需要更改这一个部分 &#123;48&#125;import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;import java.util.TreeSet;public class DirectedGraph &#123; private int E; private int V; private TreeSet&lt;Integer&gt;[] adj; public DirectedGraph(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; this.adj = new TreeSet[this.V]; for (int i = 0; i &lt; this.V; i++) &#123; this.adj[i] = new TreeSet&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; this.inDegree = new int[V]; this.outDegree = new int[V]; for (int i = 0; i &lt; this.E; i++) &#123; int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; if (adj[a].contains(b)) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; // 只是删掉了 adj[b].add(a) adj[a].add(b); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return adj[v]; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (int w: adj(v)) &#123; stringBuilder.append(String.format(\"%d \", w)); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 需要注意的是有一个概念同无向图有所不同，那就是度的概念，在有向图中度分为两类： 入度：有多少条边指向该节点 出度：有多少条件从该节点指向别的节点 例如对于下图，节点 2 的入度为 2，因为有两条边指向节点 2，出度为 1，因为有一条边从它指向节点 4。 所以我们再次修改一下类 DirectedGraph 如下 import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;import java.util.TreeSet;public class DirectedGraph &#123; private int E; private int V; private TreeSet&lt;Integer&gt;[] adj; // 增加入度和出度的成员变量 private int[] inDegree; private int[] outDegree; public DirectedGraph(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; // 其他代码相同 this.inDegree = new int[V]; this.outDegree = new int[V]; for (int i = 0; i &lt; this.E; i++) &#123; // 其他代码相同 adj[a].add(b); // 在这里初始化入度和出度，a → b，a的出度增加，b的入度增加 inDegree[b]++; outDegree[a]++; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; public int inDegree(int v) &#123; validateVertex(v); return inDegree[v]; &#125; public int outDegree(int v) &#123; validateVertex(v); return outDegree[v]; &#125; // 其他方法&#125; DFS对于有向图来说，它的 DFS 代码和 BFS 代码同无向图的写法完全是一样的，因为在后文中需要用到 DFS 遍历，所以这里贴出有向图的 DFS 遍历代码 import java.util.ArrayList;public class DFSDirectedGraph &#123; private DirectedGraph graph; // 深度优先前序遍历结果 private ArrayList&lt;Integer&gt; pre; // 深度优先后序遍历结果 private ArrayList&lt;Integer&gt; post; private boolean[] visited; public DFSDirectedGraph(DirectedGraph graph) &#123; this.graph = graph; this.pre = new ArrayList&lt;&gt;(); this.post = new ArrayList&lt;&gt;(); this.visited = new boolean[graph.V()]; for (int v = 0; v &lt; graph.V(); v++) &#123; if (!visited[v]) &#123; dfs(v); &#125; &#125; &#125; private void dfs(int v) &#123; visited[v] = true; pre.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w); &#125; &#125; post.add(v); &#125; public ArrayList&lt;Integer&gt; pre() &#123; return pre; &#125; public ArrayList&lt;Integer&gt; post() &#123; return post; &#125;&#125; 可见上面的代码与无向图的 DFS 并无不同。 有向图的环检测检测有向图中是否存在环是一件很有必要的事情 如果将上面的图看做是一个课程之间的依赖关系，如果图中存在环，说明课程之间相互依赖，学习课程 A 之前需要先学习课程 B，而学习课程 B 之前又需要先学习课程 A，这样的学习顺序肯定是有问题的。 我们想一想我们在无向图中是怎么做环检测的，我们使用 DFS 遍历，当遍历到一个节点时，如果某个邻接节点已经被访问了，并且不是它的父亲节点，我们就可以认为图中存在一个环。但是对于有向图就不一样了 上面的动图是优先遍历的顺序，最后我们来到了节点 3 此时我们发现节点 3 的相邻节点 2 已经被访问过了，并且节点 2 不是 3 的上一个节点，但是我们能说图中存在一个环吗? 不能，因为节点 2 无法到达节点 3，所以形成不了一个环。 此时我们需要另外一个变量来表示节点是否在路径上，如果一个节点访问邻接节点时发现该节点已经被访问过且在路径上，我们就可以说构成了一个环。 什么叫在路径上，如果这个节点还没有回溯到上一个节点，我们就说这个节点在路径上。 如果我们在访问到节点 w 时，节点 v 还在路径上，说明节点 v 可以到达节点 w，如果此时节点 w 可以到达节点 v 不就说明存在一个环吗。 public class DirectedCycleDetect &#123; private DirectedGraph graph; private boolean[] visited; // onPath[w] 表示节点 w 是否在路径上 private boolean[] onPath; private boolean hasCycle; public DirectedCycleDetect(DirectedGraph graph) &#123; this.graph = graph; this.visited = new boolean[graph.V()]; this.onPath = new boolean[graph.V()]; this.hasCycle = false; for (int v = 0; v &lt; graph.V(); v++) &#123; if (!visited[v]) &#123; if (dfs(v)) &#123; hasCycle = true; break; &#125; &#125; &#125; &#125; private boolean dfs(int v) &#123; visited[v] = true; onPath[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; if (dfs(w)) &#123; return true; &#125; // 通无向图不同，2 -&gt; 1 -&gt; 2 也是一个环 &#125; else if (onPath[w]) &#123; return true; &#125; &#125; // 回溯到上一个节点时就不在路径上了 onPath[v] = false; return false; &#125; public boolean isHasCycle() &#123; return hasCycle; &#125;&#125; 拓扑排序还是对于下面的这么一副图 假设上面的节点代表一门课程的话，我们想知道应该以什么样的顺序学习所有的课程，这其实就是在寻找图的拓扑排序。 那么我们寻找图的拓扑排序呢? 还是以学习课程举例，要学习一门课，那么这门就不能依赖于任何一门其他的课，或者这门课已经被学过了，就比如上面我们应该先学习课程 0，因为没有任何课程指向它，它不依赖于任何课程，以图论的语言来说，因为节点 0 的入度为 0，所以先学习课程 0。 学习完课程 0 之后，为了表示这门课程已经学过，我们将依赖于节点 0 的节点的入度减一 接下来我们应该学习哪门课呢? 当然是入度为 0 的课，表示不需要前置课程或者前置课程已经学过了，所以我们接下来学习课程 1，并且将依赖课程 1 的其他课程的入度减一 接下来还是学习入度为 0 的课程，即课程 3，并且更新依赖课程 3 的其他课程的入度 接着学习课程 2，因为它的入度为 0，然后更新依赖课程 2 的其他课程的入度 最后学习课程 4 所以最终课程的学习顺序为 0 → 1 → 3 → 2 → 4，也就是拓扑排序的结果。 所以我们对图做拓扑排序，就重复做两步： 选择入度为 0 的节点 更新相邻节点的入度 另外一个需要注意的问题就是，拓扑排序只对有向无环图(DAG) 有效，如果图中有环，二者相互依赖，就不知道先学习哪一门课程了。 在代码的实现方面，我们使用队列来存储入度为 0 的节点，在更新相邻节点入度的时候，如果入度为 0 则添加进队列中，每次从队列取出一个值时，我们添加到一个 List 中，表示拓扑排序的顺序。另外如果图中存在环的话，那么这个 List 中保存的节点数目肯定小于整个图的节点数目，此时可以使用拓扑排序来做环检测。 import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class TopoSort &#123; private DirectedGraph graph; private int[] inDegree; private ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); private boolean hasCycle = false; public TopoSort(DirectedGraph graph) &#123; this.graph = graph; this.inDegree = new int[graph.V()]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int v = 0; v &lt; graph.V(); v++) &#123; inDegree[v] = graph.inDegree(v); if (inDegree[v] == 0) &#123; queue.add(v); &#125; &#125; while (!queue.isEmpty()) &#123; int v = queue.remove(); result.add(v); for (int w: graph.adj(v)) &#123; inDegree[w]--; if (inDegree[w] == 0) &#123; queue.add(w); &#125; &#125; &#125; if (result.size() != graph.V()) &#123; hasCycle = true; result.clear(); &#125; &#125; public boolean isHasCycle() &#123; return hasCycle; &#125; public ArrayList&lt;Integer&gt; result() &#123; return result; &#125;&#125; 此时我们在介绍一种拓扑排序的算法，它需要借助于深度优先后序遍历。回顾一个后序遍历的概念，后序遍历指的是先访问完相邻节点，然后访问自己。 对于有向图意味着什么，意味着先访问依赖自己的节点，然后访问自己，说明自己是在依赖于自己的节点之后访问的，如果我们对深度优先后序遍历做一个逆序，这个顺序就表示自己在依赖于自己的节点之前被访问的，这不就是拓扑排序的结果吗。 使用深度优先后序遍历有一个缺点就是它不能做环检测，虽然图中有环，但是还是能够深度优先后序遍历，只不过此时结果便没有意义了。所以在使用这个方法做拓扑排序之前，我们需要使用我们之前讲解的有向图的环检测算法进行环检测 import java.util.ArrayList;import java.util.Collections;public class TopoSort2 &#123; private DirectedGraph graph; private boolean hasCycle; private ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public TopoSort2(DirectedGraph graph) &#123; this.graph = graph; // 使用之前的讲解的环检测类进行环检测 DirectedCycleDetect directedCycleDetect = new DirectedCycleDetect(graph); this.hasCycle = directedCycleDetect.isHasCycle(); if (hasCycle) &#123; return; &#125; // 对图做深度优先后序遍历 DFSDirectedGraph dfsDirectedGraph = new DFSDirectedGraph(graph); for (int v: dfsDirectedGraph.post()) &#123; result.add(v); &#125; // 对后序遍历取逆序 Collections.reverse(result); &#125; public boolean isHasCycle() &#123; return hasCycle; &#125; public ArrayList&lt;Integer&gt; result() &#123; return result; &#125;&#125; 强连通分量现在还有一个问题就是我们怎么检测图中有多少个强联通分量，以及每一个强联通分量中包含哪些节点。所谓的强联通分量指如果某些节点互相可达，那么这些节点就组成了一个强联通分量。 如上图就三个强联通分量，每个联通分量内部的节点都是互相可达的。 在求解有向图的联通分量之前，我们回顾一下无向图的联通分量是如何求解的，我们从任意一个节点开始做 DFS，每次做一次 DFS 就表示有一个联通分量 for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; cccount++; // 联通分量个数增加 dfs(i); &#125;&#125; 但是对于有向图我们能从任意一个节点开始吗? 答案是不行，而是要以特定的顺序遍历。如果我们将一个个的联通分量看做是一个图中的节点 如果我们分别遍历联通分量 $E \\rightarrow C \\rightarrow A \\rightarrow D \\rightarrow B$ 中的节点，那么每做一次 DFS 就就可以统计联通分量数目，那么为什么会是上面的顺序呢? 为什么从 $E$ 开始遍历，因为 $E$ 只依赖其他联通分量的节点，没有其他联通分量依赖于它，所以从 $E$ 中的某个节点做 DFS，只能遍历到联通分量 $E$ 中的节点。同理遍历完了 $E$，此时 $C$ 也只依赖于其他联通分量，虽然 $E$ 依赖于 $C$，但是 $E$ 已经遍历完毕了，所以此时从 $C$ 中的节点开始做 DFS 只能遍历到 $C$ 中所有的节点，剩余的也是同理。 也就是说依赖于自己的联通分量要被先遍历到，也就是相邻节点要在自己之前被访问到，其实就是深度优先后序遍历的顺序，所以 $E \\rightarrow C \\rightarrow A \\rightarrow D \\rightarrow B$ 这个顺序其实是深度优先后序遍历的顺序。 但是这个深度优先后序遍历指的是以联通分量作为节点进行的遍历，如果我们从任意一个节点做深度优先后序遍历是得不到这个顺序的。例如我们从联通分量中的节点 $D$ 开始遍历，接着来到了联通分量 $C$，虽然遍历完联通分量 $C$ 中所有节点之前肯定需要遍历完联通分量 $E$，但是不能保证所有 $E$ 中的节点都在 $C$ 之前被遍历，即可能有这样的顺序 $C_1 \\rightarrow E \\rightarrow C_2 \\rightarrow \\cdots$，这样的顺序是我们不想要的，因为我们必须从联通分量 $E$ 中的节点开始遍历。 虽然上面的深度优先遍历不能严格按照 $E \\rightarrow C \\rightarrow A \\rightarrow D \\rightarrow B$ 的顺序遍历，但是我们发现一定有分量 $C$ 中的节点在分量 $E$ 遍历完之后遍历的 $C_1 \\rightarrow E \\rightarrow C_2 \\rightarrow \\cdots$，例如 $C_2$ 在遍历完 $E$ 之后被遍历了，这给了我们灵感，如果我们取个逆，就可以得到一定有 $C$ 中的节点在 $E$ 分量节点被遍历之前遍历。 而我们想要的是一定要 $E$ 中的节点在 $C$ 中的节点被遍历之前遍历，怎么办，我们将整个图的方向改变一下，原来是 $a \\rightarrow b$，现在变为 $b \\rightarrow a$ 然后进行深度优先后序遍历，然后取个逆就可以保证一定有在 $E$ 中的节点在 $C$ 中的节点遍历之前被遍历到，同理可以得到一定有 $C$ 中的节点在 $D$ 中的节点被遍历之前被遍历到，这就达到我们的目的，我们再根据这个顺序做 DFS 就可以统计出联通分量的个数了。 上面这个算法就是 Kosaraju 算法，总结上面的步骤如下： 图翻转得到反图 对反图做深度优先后序遍历，然后对遍历结果取逆 根据取逆后的结果依次做 DFS，统计联通分量个数 import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.TreeSet;public class StrongCC &#123; private DirectedGraph graph; private int[] visited; private int scccount; public StrongCC(DirectedGraph graph) &#123; this.graph = graph; this.visited = new int[graph.V()]; Arrays.fill(visited, -1); this.scccount = 0; // 翻转图 TreeSet&lt;Integer&gt;[] reverse = new TreeSet[graph.V()]; for (int i = 0; i &lt; graph.V(); i++) &#123; reverse[i] = new TreeSet&lt;&gt;(); &#125; for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; reverse[w].add(v); &#125; &#125; // 对翻转图做 DFS DFSDirectedGraph dfsDirectedGraph = new DFSDirectedGraph(new DirectedGraph(reverse)); // 对深度优先后序遍历取逆 ArrayList&lt;Integer&gt; res = dfsDirectedGraph.post(); Collections.reverse(res); // 依次做 DFS，每做一次 DFS，联通分量个数增加 for(int v: res) &#123; if (visited[v] == -1) &#123; dfs(v, scccount); scccount++; &#125; &#125; &#125; private void dfs(int v, int id) &#123; visited[v] = id; for (int w: graph.adj(v)) &#123; if (visited[w] == -1) &#123; dfs(w, id); &#125; &#125; &#125; public ArrayList&lt;Integer&gt;[] components() &#123; ArrayList&lt;Integer&gt;[] results = new ArrayList[scccount]; for (int i = 0; i&lt; scccount; i++) &#123; results[i] = new ArrayList&lt;&gt;(); &#125; for (int v = 0; v &lt; graph.V(); v++) &#123; results[visited[v]].add(v); &#125; return results; &#125;&#125; 网络流网络流与最大流考虑一幅有向带权图 如果图中有一个源点，即入度为 0 的节点，上图的节点 0，有一个汇点，它的出度为 0，上图的节点 3，并且图中所有边的权值都是非负的，那么我们可以说这是一个网络流。 同一般的带权图不同，网络流中边的权值不是指从一个节点到达一个节点的距离是多少，耗费是多少，它指的是从一个节点到达另一个节点能够容忍的最大流量，例如从节点 0 到节点 1 它最多能够容忍 3 的流量。除了流量限制以外，还需要满足平衡限制，即流入某个节点的流量必须等于流出该节点的流量，即节点不允许存储流量，也不能产生流量(除了源点和汇点)。 真实世界中很多的问题可以建模为网络流的模型，例如供水系统，图中的边可以看做是水管，其中的权值表示的是水管能够通过的最大流量；又比如通信系统，每条边看做是一个信道，而权值可以看做是信道容量。 源点不断的发出流量，汇点不断接收流量，因为剩余的节点既不生产流量，也不存储流量，所以从源点发出的流量会全部进入到汇点。现在我们比较关心的是，从源点最多能发出多少流量，最终到达汇点，这就是最大流问题。 有向带权图在讲解如何获得网络的最大流之前，我们先看看怎么表示网络流模型。其实网络流就是一个有向的带权图，我们只需要根据之前的无向带权图进行改造就可以得到有向带权图，改造的过程可以参考之前的无向无权图到有向无权图的改造，其实就是将 adj[v].put(w, weight);adj[w].put(v, weight); 修改为了 adj[v].put(w, weight); 以此表明是一个有方向的图。另外为了实现后续的算法，我们为带权图增加了 2 个 API setWeight(v, w, weight) addEdge(v, w, weight) 另外我们还添加了一个新的构造方法，该方法只接收一个参数，即图中有多少个节点，得到一个没有边的图，在后续通过 addEdge 方法来图添加边。 DirectedWeightedGraph 类如下 import java.io.File;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class DirectedWeightedGraph&#123; private int V; private int E; private HashMap&lt;Integer, Integer&gt;[] adj; public DirectedWeightedGraph(String path) &#123; File file = new File(path); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (V &lt; 0) &#123; throw new IllegalArgumentException(\"V can't be negative\"); &#125; adj = new HashMap[V]; for (int i = 0; i &lt; V; i++) &#123; adj[i] = new HashMap&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (E &lt; 0) &#123; throw new IllegalArgumentException(\"E can't be negative\"); &#125; for (int i = 0; i &lt; E; i++) &#123; int v = scanner.nextInt(); int w = scanner.nextInt(); int weight = scanner.nextInt(); if (v == w) &#123; throw new IllegalArgumentException(\"存在自环边\"); &#125; if (adj[v].containsKey(w)) &#123; throw new IllegalArgumentException(\"存在平行边\"); &#125; // 表示有向 adj[v].put(w, weight); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; scanner.close(); &#125; &#125; // 另一构造方法 public DirectedWeightedGraph(int V) &#123; this.V = V; this.E = 0; this.adj = new HashMap[V]; for (int v = 0; v &lt; V; v++) &#123; adj[v] = new HashMap&lt;&gt;(); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public int getWeight(int v, int w) &#123; validateVertex(v); validateVertex(w); if (!hasEdge(v, w)) &#123; throw new IllegalArgumentException(String.format(\"%d-%d 不存在\", v, w)); &#125; return adj[v].get(w); &#125; public void setWeight(int v, int w, int weight) &#123; validateVertex(v); validateVertex(w); if (!hasEdge(v, w)) &#123; throw new IllegalArgumentException(String.format(\"%d-%d 不存在\", v, w)); &#125; adj[v].put(w, weight); &#125; public void addEdge(int v, int w, int weight) &#123; validateVertex(v); validateVertex(w); if (v == w) &#123; throw new IllegalArgumentException(\"存在自环边\"); &#125; if (adj[v].containsKey(w)) &#123; throw new IllegalArgumentException(\"存在平行边\"); &#125; adj[v].put(w, weight); E++; &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return adj[v].containsKey(w); &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return adj[v].keySet(); &#125; public void validateVertex(int v) &#123; if (v &lt; 0 &amp;&amp; v &gt;= V) &#123; throw new IllegalArgumentException(\"节点超过 [0, V) 的范围\"); &#125; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (Map.Entry w: adj[v].entrySet()) &#123; stringBuilder.append(String.format(\"(%d: %d) \", w.getKey(), w.getValue())); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 该类的大部分实现细节与无向的版本相似，如果不熟悉可以查看无向图的相关章节。 Ford-Fulkerson 思想现在我们开始看一看如何找到图中的最大流，还是以下图为例 我们先从源点随便选择一条路径到达汇点 如上图我们就选择 $0 → 1 → 3$ 这条路径，这条路径能够允许的最大容量为 2，所以这条路径的流量为 2，为了表示已经通过了多少流量，我们以下面形式表示图 左边的数字表示已经通过了多少流量，右边的数字表示允许通过最大容量。接下来我们在选择一条路径 上面我们选择了 $0 → 1 → 2 → 3$ 这条路径，因为 $0 → 1$ 只允许 1 个流量通过了，所以这条路径的流量为 1，我们更新一下图 然后在选择一条路径 这次我们选择了 $0 → 2 → 3$，这条路径的流量为 $2$，更新图如下 接下来我们我们找不到一条路径从源点到汇点了，所以此时我们可以说该网络流的最大流为 $2 + 1 + 2 = 5$。 所以上面的算法就是重复下面两步： 随便找一条路径从源点到汇点，找到路径的最小值，就是这条路径的流量 更新每条边允许通过的流量 但是真的随便找一条路径就可以吗? 显然不行，例如我们一开始就找到了这么一个路径 这条路径的流量为 3，我们更新图 但是接下来我们发现找不到路径从源点到汇点了，所以我们得出这个网络流的最大路径为 $3$，明显这个答案是不对的，所以我们不能随便选择路径走，因为可能得不到正确的答案。 但是，如果我们允许反向流动呢? 例如还是以上图为例 这次我们选择路径如下 更新后的图为 本来从 $2 → 1$ 是不可达的，但是我们赋予它一个语义，表示将原来通过 $1 → 2$ 的流量引导到别的路径去了，例如本来 $1 → 2$ 有流量为 3，现在我们反向流动 2 个流量，表示将原来这 3 个流量中的 2 个流量引导到别的路径中去了。 赋予这么一个语义的话，那么上面图的所有箭头都可以变为双向的，反向的箭头表示允许被引导到别的路径上，我们给它一个权值，表示能够被允许引导到别的路径上去的流量的最大值，这个值应该是已经通过该路径的流量，例如如果 $1 → 2$ 是用 $3/5$ 表示的话，表示已经有 $3$ 个流量通过 $1 → 2$，那么$2 → 1$ 最多允许 $3$ 个流量被引导。 为了表示方便，不用 $3/5$ 这样的形式来标记边了，而是以剩余允许通过的流量表示边，例如 $3/5$ 表示最大容量为 $5$，已经通过流量为 $3$，所以剩余能够通过的流量为 $2$，我们以 $2$ 来标记这条边，同理我们也以这样的方式标记反向的边，得到下面的这么一个图 黑色表示正向边，红色表示反向边，上面的数值表示能够允许通过的最大流量，可见在最开始反向边是不能允许通过流量的，它们的权值都是 0，这个图我们称之为残差图。 接下下我们就可以使用上面提到的两步了： 随便找一条路径从源点到汇点，找到路径的最小值，就是这条路径的流量 更新每条边允许通过的流量 这个方法就是 Ford-Fulkerson 思想。 Edmonds-Karp 算法上面的 Ford-Fulkerson 只是提供了一种思想，得到一个网络流的残差图，然后随便找一条路径从源点到汇点，但是没有说怎么找这条路径，所以它只是一种思想。 接下来我们就介绍 Edmonds-Karp 算法，它就是为 Ford-Fulkerson 提供了一种具体的实现，怎么找一条路径，很简单，那就是从源点进行 BFS 来找到一条路径，当我们通过 BFS 无法达到汇点时，说明网络不能够承受更大的流量了。 所以上面的方法是不是非常的简单，下面就给出具体的实现 import java.util.*;public class MaxFlow &#123; private DirectedWeightedGraph graph; private int s; private int t; private DirectedWeightedGraph rcGraph; private int maxFlow = 0; public MaxFlow(DirectedWeightedGraph graph, int s, int t) &#123; this.graph = graph; // 一些校验工作 if (graph.V() &lt; 2) &#123; throw new IllegalArgumentException(\"网络流中节点个数必须大于1\"); &#125; graph.validateVertex(s); graph.validateVertex(t); this.s = s; this.t = t; // 根据传入的网络流，构造残差图 DirectedWeightedGraph rcGraph = new DirectedWeightedGraph(graph.V()); for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; rcGraph.addEdge(v, w, graph.getWeight(v, w)); // 一开始反向边能够允许通过的最大流量为 0 rcGraph.addEdge(w, v, 0); &#125; &#125; this.rcGraph = rcGraph; while (true) &#123; // 开始从源点做 BFS ArrayList&lt;Integer&gt; path = getAugmentPath(); // 如果从 BFS 得到的路径为空，说明不能到达汇点了，此时退出循环 if (path.size() == 0) &#123; break; &#125; // 获得路径的最小值，即这条路径允许通过的最大流量 int min = Integer.MAX_VALUE; for (int i = 1; i &lt; path.size(); i++) &#123; int v = path.get(i - 1); int w = path.get(i); min = Math.min(min, rcGraph.getWeight(v, w)); &#125; maxFlow += min; // 更新残差图 for (int i = 1; i &lt; path.size(); i++) &#123; int v = path.get(i - 1); int w = path.get(i); rcGraph.setWeight(v, w, rcGraph.getWeight(v, w) - min); rcGraph.setWeight(w, v, rcGraph.getWeight(w, v) + min); &#125; &#125; &#125; // 做 BFS private ArrayList&lt;Integer&gt; getAugmentPath() &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int[] pre = new int[graph.V()]; queue.add(s); Arrays.fill(pre, -1); pre[s] = s; while (!queue.isEmpty()) &#123; int v = queue.remove(); for (int w: rcGraph.adj(v)) &#123; if (pre[w] == -1 &amp;&amp; rcGraph.getWeight(v, w) &gt; 0) &#123; pre[w] = v; queue.add(w); &#125; &#125; &#125; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (pre[t] == -1) &#123; return result; &#125; int cur = t; while (cur != s) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(s); Collections.reverse(result); return result; &#125; // 返回网络的最大流 public int result() &#123; return maxFlow; &#125; // 返回最终 v-w 允许通过的流量 public int flow(int v, int w) &#123; if (!graph.hasEdge(v, w)) &#123; throw new IllegalArgumentException(\"存在这条边\"); &#125; graph.validateVertex(v); graph.validateVertex(w); return rcGraph.getWeight(w, v); &#125;&#125; 棒球比赛最后我们看一个使用最大流解决实际问题的例子，那就是棒球比赛。 全美每年都会举行一次棒球比赛，每个队都要进行 162 场比赛，最终所胜的场次最多的队伍获胜，如果平局就进行加赛。 但是如果在比赛的过程中，某一队已经没有获得冠军的希望了，那么该队就会被直接淘汰。例如 $A$ 队已经赢了 $10$ 场了，而 $B$ 队只赢了 $1$ 场，并且还有 $8$ 场比赛没有打，此时 $B$ 队如何也不能赢的场次比 $A$ 队多，所以 $B$ 队应该被淘汰。 现在我们拿到了 1996 年 8 月 30 日真实的比赛数据，此时只剩下 5 个队 Teams Wins Loss Left Against NY Bal Bos Tor Det New York 75 59 28 0 3 8 7 3 Baltimore 71 63 28 3 0 2 7 4 Boston 69 66 27 8 2 0 0 0 Toronto 63 72 27 7 7 0 0 0 Detroit 49 86 27 3 4 0 0 0 Wins 代表赢了多少场，Loss 表示输了多少场，Left 表示剩余多少场没有打，Against 后面的 5 列表示与其他队要打多少场。 当时媒体争议的是最后一个队，即 Detroit 队还有没有获胜的希望。从数据上看，如果 Detroit 剩下的 27 场全赢，那么它的赢的总场次是 $49 + 27 = 76$，比最强的 New York 还多一场，所以它还有赢的机会，但是这样想的话就忽略了一个事实，即使 Detroit 与其他四队的比赛都打赢了，但是这四个队之间还有比赛，也就说说这四个队它们的总胜场是会增加的。 所以现在又变为了这么一个问题，如果前四个队之间比赛，如果最终它们的胜场最多是 76 的话，说明 Detroit 队还有赢的希望，否则 Detroit 队没有赢的可能。现在我们如下建模 这个图分为三部分，第一部分 其中权值表示比赛场次，比如 s → NY-Bal 这条边的权值为 $5$，表示 NY 与 Bal 之间有五场比赛要打，可见这四个队伍总共要打 $5 + 8 + 7 + 2 + 7 = 27$ 场比赛。第二部分 这次的权值表示的是胜场的分配。第三部分 这时其中的权值表示每个队最多赢多少次，例如 NY 队目前 $75$ 分，它最多只能赢一场。如果上述网络流的最大流大于等于比赛的总场次，所以存在一种方案能够分配所有胜场使得所有队的得分最多只有 $76$ 分。 上面网络流我们建模为如下图 11 190 1 30 2 80 3 70 4 20 5 71 6 31 7 32 6 82 8 83 6 73 9 74 7 24 8 25 7 77 9 76 10 17 10 58 10 79 10 13 现在我们用之前写的 MaxFlow 类来查看最大流是多少 public class BaseBallSolution &#123; public static void main(String[] args) &#123; DirectedWeightedGraph baseball = new DirectedWeightedGraph(\"g17.txt\"); MaxFlow maxflow = new MaxFlow(baseball, 0, 10); System.out.println(maxflow.result()); &#125;&#125; 结果是 26 说明最大流为 26，小于 27，说明无法分配 27 场比赛使得所有队最多只能赢 76 场，这就意味着 Detroit 没有赢的可能了。 匹配问题最大匹配与完全匹配下面我们讲解的算法都是有关于二分图的算法 例如对于上图就是一个二分图，每条边都连接了两个不同部分的节点，生活中很多问题都可以建模为二分图的问题，例如相亲。左边表示男生群体，右边表示女生群体，如果两个节点之间有一条边，说明这一对男女可以匹配为一对；另外又比如求职，左边的节点表示求职者，右边的节点表示公司，如果节点之间有一条边，表明求职者与公司互相都比较满意，可以匹配。 现在我们关心的问题是，向这样的二分图最多有多少个匹配，这样的问题称为最大匹配问题，如果最大匹配的个数与左右两边的节点数目都相同，那么就称为是完全匹配，对于相亲来说，意味着每一个人都可以找到另一半，对于求职来说，每个求职者都可以找到一家公司。 最大流解决匹配问题解决最大匹配问题的一个方案就是将上面的图建模为一个网络流 图中的每一条边的权值都为 1，即每条边的允许通过的最大流量为 1，表示每一个节点都只能被匹配一次，此时这个网络流的最大流就等于最大匹配数，我们将求二分图的最大匹配问题转化为了求网络流的最大流问题，而求最大流的问题我们在以前已经接触过。 我们唯一需要的工作量就是根据上面的二分图得到一个网络流的模型，具体见代码 public class BipartiteMatching &#123; private Graph graph; private int maxMatching; public BipartiteMatching(Graph graph) &#123; this.graph = graph; // 首先对是否是二分图进行检测 BinaryPartitionDetection bpd = new BinaryPartitionDetection(graph); if (!bpd.isBipartite()) &#123; throw new IllegalArgumentException(\"该图不为一个二分图\"); &#125; int[] colors = bpd.colors(); // 根据二分图建模为网络流，多添加的两个节点为源点和汇点，源点编号为 V，汇点为 V + 1 DirectedWeightedGraph directedWeightedGraph = new DirectedWeightedGraph(graph.V() + 2); for (int v = 0; v &lt; graph.V(); v++) &#123; // colors[v] == 0 表明是左边的节点，被源点指向 if (colors[v] == 0) &#123; directedWeightedGraph.addEdge(graph.V(), v, 1); &#125; else &#123; // colors[v] == 1 表示是右边的节点，执行汇点 directedWeightedGraph.addEdge(v, graph.V() + 1, 1); &#125; for (int w: graph.adj(v)) &#123; if (v &lt; w) &#123; // 左边的节点指向右边的节点 if (colors[v] == 0) &#123; directedWeightedGraph.addEdge(v, w, 1); &#125; else &#123; directedWeightedGraph.addEdge(w, v, 1); &#125; &#125; &#125; &#125; // 建立网络流，获得最大流 MaxFlow maxFlow = new MaxFlow(directedWeightedGraph, graph.V(), graph.V() +1); maxMatching = maxFlow.result(); &#125; public int result() &#123; return maxMatching; &#125; // 如果最大匹配的两倍等于图中的节点数，说明是完全匹配 public boolean isPerfectMatching() &#123; return maxMatching * 2 == graph.V(); &#125;&#125; 上面对二分图检测以及最大流的类在之前文章讲解过，不多加介绍。 LCP04 覆盖LCP04 覆盖是一道 LeetCode 上的题目，我们可以将这道题建模为二分图的最大匹配问题。 题目介绍你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为 $1 * 2$ 的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌? 这些骨牌可以横着或者竖着放。 输入：n, m代表棋盘的大小；broken是一个 $b * 2$ 的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。 输出：一个整数，代表最多能在棋盘上放的骨牌数。 解题思路对于棋盘问题，如果玩过国际象棋的话，就知道棋盘是被染为黑白两色的，如 同理我们也可以将上面的棋盘根据上面的染色分为两个区域，如果将网格上的一个个网格看做是图中的节点的话，这不就是一个二分图吗? 而对一个 $1 * 2$ 的多米诺骨牌，它总是一边在黑色区域，一边在白色区域，题目问能够放置多少块多米诺骨牌不就是在问该二分图的最大匹配图吗? 因为我们成功的将上面的问题建模为了二分图的最大匹配，可以利用我们上面的算法进行解决，现在唯一的难点可能就是将上面的网格建模为一个图了，代码如下 import java.util.*;public class Solution &#123; public int domino(int n, int m, int[][] broken) &#123; int[][] board = new int[n][m]; // 1 表示格子坏掉了，0 表示格子是好的 for (int[] p: broken) &#123; board[p[0]][p[1]] = 1; &#125; // 将网格建模为一个图 AdjSet graph = new AdjSet(n * m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; // 我们只添加右边和下面的节点，因为左边的节点的右边就是自己，不用重复添加，同理对于上面也是 if (j + 1 &lt; m &amp;&amp; board[i][j] == 0 &amp;&amp; board[i][j + 1] == 0) &#123; graph.addEdge(i * m + j, i * m + j + 1); &#125; if (i + 1 &lt; n &amp;&amp; board[i][j] == 0 &amp;&amp; board[i + 1][j] == 0) &#123; graph.addEdge(i * m + j, (i + 1) * m + j); &#125; &#125; &#125; BipartiteMatching bm = new BipartiteMatching(graph); return bm.result(); &#125;&#125; 匈牙利算法解决匹配问题的另一个算法就是匈牙利算法，还是以下图为例 匈牙利算法的思想就是每次从左边未匹配的点出发进行遍历，如果右边的点没有匹配，则将它们匹配为一对 上面我们从节点 0 出发，来到节点 4，发现节点 4 没有被匹配，因此将它们设置为匹配，我们使用一个数组来进行记录 matching[0] = 4;matching[4] = 0; 如果右边的节点已经被遍历了，则从右边节点匹配的节点继续遍历，例如对于下图，我们从 1 出发，来到节点 4，发现节点 4 已经被遍历了，于是来与节点 4 匹配的节点 0，然后从 0 开始向右遍历，直到向右找到一个未匹配的节点 上面我们遍历的路径是 $1 → 4 → 0 → 6$，本来 0-4 是匹配的，现在我们让它断开，让 1-4、0-6 匹配。 重复上面的过程，每次如果在右边找到一个未匹配的节点，匹配数加一，当我们遍历完左边所有的未匹配的节点时，最终的匹配数就是最大匹配数，这就是匈牙利算法。 这里总结一下匈牙利算法的流程： 从左边未匹配的节点遍历，如果右边的节点未匹配，那么让二者匹配，匹配数加一 否则右边的节点已匹配，那么从右边节点匹配的节点继续遍历 重复上面的过程，直到找到一个右边未匹配的节点，那么匹配数加一，并且更新匹配关系 根据遍历的顺序不同，匈牙利算法有两种实现，一种是使用 BFS 进行遍历，该种方法速度较快，但是代码复杂 import java.util.*;public class HungarianBFS &#123; private Graph graph; private int[] matching; private int maxMatching; public HungarianBFS(Graph graph) &#123; this.graph = graph; // 先检测是否是二分图 BinaryPartitionDetection bpm = new BinaryPartitionDetection(graph); if (!bpm.isBipartite()) &#123; throw new IllegalArgumentException(\"该图不是二分图\"); &#125; this.matching = new int[graph.V()]; Arrays.fill(matching, -1); int[] colors = bpm.colors(); for (int v = 0; v &lt; graph.V(); v++) &#123; // colors[v] == 0 说明是左边节点 // matching[v] == -1 说明未匹配，从这种节点开始遍历 if (colors[v] == 0 &amp;&amp; matching[v] == -1) &#123; // bfs 的返回值表示是否找到一个右边未匹配的节点 if (bfs(v)) &#123; // 找到匹配数就加一 maxMatching++; &#125; &#125; &#125; &#125; // 进行 bfs 遍历 private boolean bfs(int v) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(v); int[] pre = new int[graph.V()]; Arrays.fill(pre, -1); pre[v] = v; while (!queue.isEmpty()) &#123; int cur = queue.remove(); for (int next: graph.adj(cur)) &#123; if (pre[next] == -1) &#123; // 如果右边的节点已经匹配了 if (matching[next] != -1) &#123; // 从右边节点的匹配节点开始继续遍历 queue.add(matching[next]); pre[next] = cur; pre[matching[next]] = next; &#125; else &#123; // 右边的节点未匹配，找到了，更新匹配关系 pre[next] = cur; ArrayList&lt;Integer&gt; path = getPath(pre, v, next); for (int i = 0; i &lt; path.size(); i += 2) &#123; matching[path.get(i)] = path.get(i + 1); matching[path.get(i + 1)] = path.get(i); &#125; return true; &#125; &#125; &#125; &#125; return false; &#125; private ArrayList&lt;Integer&gt; getPath(int[] pre, int start, int end) &#123; int cur = end; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (cur != start) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(start); Collections.reverse(result); return result; &#125; public int result() &#123; return maxMatching; &#125;&#125; 还有一种实现是使用 DFS 进行遍历，虽然比 BFS 慢一丢丢，但还是实现简单 import java.util.Arrays;public class HungarianDFS &#123; private Graph graph; private int maxMatching; private boolean[] visited; private int[] matching; public HungarianDFS(Graph graph) &#123; // 下面的初始化逻辑同 BFS this.graph = graph; BinaryPartitionDetection bmp = new BinaryPartitionDetection(graph); if (!bmp.isBipartite()) &#123; throw new IllegalArgumentException(\"该图不是二分图\"); &#125; int[] colors = bmp.colors(); this.maxMatching = 0; this.visited = new boolean[graph.V()]; this.matching = new int[graph.V()]; Arrays.fill(matching, -1); for (int v = 0; v &lt; graph.V(); v++) &#123; // 左边未匹配节点开始遍历 if (colors[v] == 0 &amp;&amp; matching[v] == -1) &#123; Arrays.fill(visited, false); // dfs 返回值的含义同 bfs if (dfs(v)) &#123; maxMatching++; &#125; &#125; &#125; &#125; private boolean dfs(int v) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; visited[w] = true; // 如果右边未匹配，更新匹配关系 // 或者右边已匹配，并且从右边已匹配的节点遍历能找到一个右边未匹配的节点，也更新匹配关系 if (matching[w] == -1 || dfs(matching[w])) &#123; matching[v] = w; matching[w] = v; return true; &#125; &#125; &#125; return false; &#125; public int result() &#123; return maxMatching; &#125;&#125; 同理我们可以使用匈牙利算法来完成上面的 LeetCode 问题 import java.util.*;public class Solution &#123; public int domino(int n, int m, int[][] broken) &#123; int[][] board = new int[n][m]; for (int[] p: broken) &#123; board[p[0]][p[1]] = 1; &#125; AdjSet graph = new AdjSet(n * m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (j + 1 &lt; m &amp;&amp; board[i][j] == 0 &amp;&amp; board[i][j + 1] == 0) &#123; graph.addEdge(i * m + j, i * m + j + 1); &#125; if (i + 1 &lt; n &amp;&amp; board[i][j] == 0 &amp;&amp; board[i + 1][j] == 0) &#123; graph.addEdge(i * m + j, (i + 1) * m + j); &#125; &#125; &#125; HungarianBFS hungarianBFS = new HungarianBFS(graph); return hungarianBFS.result(); &#125;&#125; 速度比使用网络流要快","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"匹配问题","date":"2021-01-29T18:33:00.000Z","path":"/匹配问题/","text":"最大匹配与完全匹配下面我们讲解的算法都是有关于二分图的算法 例如对于上图就是一个二分图，每条边都连接了两个不同部分的节点，生活中很多问题都可以建模为二分图的问题，例如相亲。左边表示男生群体，右边表示女生群体，如果两个节点之间有一条边，说明这一对男女可以匹配为一对；另外又比如求职，左边的节点表示求职者，右边的节点表示公司，如果节点之间有一条边，表明求职者与公司互相都比较满意，可以匹配。 现在我们关心的问题是，向这样的二分图最多有多少个匹配，这样的问题称为最大匹配问题，如果最大匹配的个数与左右两边的节点数目都相同，那么就称为是完全匹配，对于相亲来说，意味着每一个人都可以找到另一半，对于求职来说，每个求职者都可以找到一家公司。 最大流解决匹配问题解决最大匹配问题的一个方案就是将上面的图建模为一个网络流 图中的每一条边的权值都为 1，即每条边的允许通过的最大流量为 1，表示每一个节点都只能被匹配一次，此时这个网络流的最大流就等于最大匹配数，我们将求二分图的最大匹配问题转化为了求网络流的最大流问题，而求最大流的问题我们在以前已经接触过。 我们唯一需要的工作量就是根据上面的二分图得到一个网络流的模型，具体见代码 public class BipartiteMatching &#123; private Graph graph; private int maxMatching; public BipartiteMatching(Graph graph) &#123; this.graph = graph; // 首先对是否是二分图进行检测 BinaryPartitionDetection bpd = new BinaryPartitionDetection(graph); if (!bpd.isBipartite()) &#123; throw new IllegalArgumentException(\"该图不为一个二分图\"); &#125; int[] colors = bpd.colors(); // 根据二分图建模为网络流，多添加的两个节点为源点和汇点，源点编号为 V，汇点为 V + 1 DirectedWeightedGraph directedWeightedGraph = new DirectedWeightedGraph(graph.V() + 2); for (int v = 0; v &lt; graph.V(); v++) &#123; // colors[v] == 0 表明是左边的节点，被源点指向 if (colors[v] == 0) &#123; directedWeightedGraph.addEdge(graph.V(), v, 1); &#125; else &#123; // colors[v] == 1 表示是右边的节点，执行汇点 directedWeightedGraph.addEdge(v, graph.V() + 1, 1); &#125; for (int w: graph.adj(v)) &#123; if (v &lt; w) &#123; // 左边的节点指向右边的节点 if (colors[v] == 0) &#123; directedWeightedGraph.addEdge(v, w, 1); &#125; else &#123; directedWeightedGraph.addEdge(w, v, 1); &#125; &#125; &#125; &#125; // 建立网络流，获得最大流 MaxFlow maxFlow = new MaxFlow(directedWeightedGraph, graph.V(), graph.V() +1); maxMatching = maxFlow.result(); &#125; public int result() &#123; return maxMatching; &#125; // 如果最大匹配的两倍等于图中的节点数，说明是完全匹配 public boolean isPerfectMatching() &#123; return maxMatching * 2 == graph.V(); &#125;&#125; 上面对二分图检测以及最大流的类在之前文章讲解过，不多加介绍。 LCP04 覆盖LCP04 覆盖是一道 LeetCode 上的题目，我们可以将这道题建模为二分图的最大匹配问题。 题目介绍你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为 $1 * 2$ 的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌? 这些骨牌可以横着或者竖着放。 输入：n, m代表棋盘的大小；broken是一个 $b * 2$ 的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。 输出：一个整数，代表最多能在棋盘上放的骨牌数。 解题思路对于棋盘问题，如果玩过国际象棋的话，就知道棋盘是被染为黑白两色的，如 同理我们也可以将上面的棋盘根据上面的染色分为两个区域，如果将网格上的一个个网格看做是图中的节点的话，这不就是一个二分图吗? 而对一个 $1 * 2$ 的多米诺骨牌，它总是一边在黑色区域，一边在白色区域，题目问能够放置多少块多米诺骨牌不就是在问该二分图的最大匹配图吗? 因为我们成功的将上面的问题建模为了二分图的最大匹配，可以利用我们上面的算法进行解决，现在唯一的难点可能就是将上面的网格建模为一个图了，代码如下 import java.util.*;public class Solution &#123; public int domino(int n, int m, int[][] broken) &#123; int[][] board = new int[n][m]; // 1 表示格子坏掉了，0 表示格子是好的 for (int[] p: broken) &#123; board[p[0]][p[1]] = 1; &#125; // 将网格建模为一个图 AdjSet graph = new AdjSet(n * m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; // 我们只添加右边和下面的节点，因为左边的节点的右边就是自己，不用重复添加，同理对于上面也是 if (j + 1 &lt; m &amp;&amp; board[i][j] == 0 &amp;&amp; board[i][j + 1] == 0) &#123; graph.addEdge(i * m + j, i * m + j + 1); &#125; if (i + 1 &lt; n &amp;&amp; board[i][j] == 0 &amp;&amp; board[i + 1][j] == 0) &#123; graph.addEdge(i * m + j, (i + 1) * m + j); &#125; &#125; &#125; BipartiteMatching bm = new BipartiteMatching(graph); return bm.result(); &#125;&#125; 匈牙利算法解决匹配问题的另一个算法就是匈牙利算法，还是以下图为例 匈牙利算法的思想就是每次从左边未匹配的点出发进行遍历，如果右边的点没有匹配，则将它们匹配为一对 上面我们从节点 0 出发，来到节点 4，发现节点 4 没有被匹配，因此将它们设置为匹配，我们使用一个数组来进行记录 matching[0] = 4;matching[4] = 0; 如果右边的节点已经被遍历了，则从右边节点匹配的节点继续遍历，例如对于下图，我们从 1 出发，来到节点 4，发现节点 4 已经被遍历了，于是来与节点 4 匹配的节点 0，然后从 0 开始向右遍历，直到向右找到一个未匹配的节点 上面我们遍历的路径是 $1 → 4 → 0 → 6$，本来 0-4 是匹配的，现在我们让它断开，让 1-4、0-6 匹配。 重复上面的过程，每次如果在右边找到一个未匹配的节点，匹配数加一，当我们遍历完左边所有的未匹配的节点时，最终的匹配数就是最大匹配数，这就是匈牙利算法。 这里总结一下匈牙利算法的流程： 从左边未匹配的节点遍历，如果右边的节点未匹配，那么让二者匹配，匹配数加一 否则右边的节点已匹配，那么从右边节点匹配的节点继续遍历 重复上面的过程，直到找到一个右边未匹配的节点，那么匹配数加一，并且更新匹配关系 根据遍历的顺序不同，匈牙利算法有两种实现，一种是使用 BFS 进行遍历，该种方法速度较快，但是代码复杂 import java.util.*;public class HungarianBFS &#123; private Graph graph; private int[] matching; private int maxMatching; public HungarianBFS(Graph graph) &#123; this.graph = graph; // 先检测是否是二分图 BinaryPartitionDetection bpm = new BinaryPartitionDetection(graph); if (!bpm.isBipartite()) &#123; throw new IllegalArgumentException(\"该图不是二分图\"); &#125; this.matching = new int[graph.V()]; Arrays.fill(matching, -1); int[] colors = bpm.colors(); for (int v = 0; v &lt; graph.V(); v++) &#123; // colors[v] == 0 说明是左边节点 // matching[v] == -1 说明未匹配，从这种节点开始遍历 if (colors[v] == 0 &amp;&amp; matching[v] == -1) &#123; // bfs 的返回值表示是否找到一个右边未匹配的节点 if (bfs(v)) &#123; // 找到匹配数就加一 maxMatching++; &#125; &#125; &#125; &#125; // 进行 bfs 遍历 private boolean bfs(int v) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(v); int[] pre = new int[graph.V()]; Arrays.fill(pre, -1); pre[v] = v; while (!queue.isEmpty()) &#123; int cur = queue.remove(); for (int next: graph.adj(cur)) &#123; if (pre[next] == -1) &#123; // 如果右边的节点已经匹配了 if (matching[next] != -1) &#123; // 从右边节点的匹配节点开始继续遍历 queue.add(matching[next]); pre[next] = cur; pre[matching[next]] = next; &#125; else &#123; // 右边的节点未匹配，找到了，更新匹配关系 pre[next] = cur; ArrayList&lt;Integer&gt; path = getPath(pre, v, next); for (int i = 0; i &lt; path.size(); i += 2) &#123; matching[path.get(i)] = path.get(i + 1); matching[path.get(i + 1)] = path.get(i); &#125; return true; &#125; &#125; &#125; &#125; return false; &#125; private ArrayList&lt;Integer&gt; getPath(int[] pre, int start, int end) &#123; int cur = end; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (cur != start) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(start); Collections.reverse(result); return result; &#125; public int result() &#123; return maxMatching; &#125;&#125; 还有一种实现是使用 DFS 进行遍历，虽然比 BFS 慢一丢丢，但还是实现简单 import java.util.Arrays;public class HungarianDFS &#123; private Graph graph; private int maxMatching; private boolean[] visited; private int[] matching; public HungarianDFS(Graph graph) &#123; // 下面的初始化逻辑同 BFS this.graph = graph; BinaryPartitionDetection bmp = new BinaryPartitionDetection(graph); if (!bmp.isBipartite()) &#123; throw new IllegalArgumentException(\"该图不是二分图\"); &#125; int[] colors = bmp.colors(); this.maxMatching = 0; this.visited = new boolean[graph.V()]; this.matching = new int[graph.V()]; Arrays.fill(matching, -1); for (int v = 0; v &lt; graph.V(); v++) &#123; // 左边未匹配节点开始遍历 if (colors[v] == 0 &amp;&amp; matching[v] == -1) &#123; Arrays.fill(visited, false); // dfs 返回值的含义同 bfs if (dfs(v)) &#123; maxMatching++; &#125; &#125; &#125; &#125; private boolean dfs(int v) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; visited[w] = true; // 如果右边未匹配，更新匹配关系 // 或者右边已匹配，并且从右边已匹配的节点遍历能找到一个右边未匹配的节点，也更新匹配关系 if (matching[w] == -1 || dfs(matching[w])) &#123; matching[v] = w; matching[w] = v; return true; &#125; &#125; &#125; return false; &#125; public int result() &#123; return maxMatching; &#125;&#125; 同理我们可以使用匈牙利算法来完成上面的 LeetCode 问题 import java.util.*;public class Solution &#123; public int domino(int n, int m, int[][] broken) &#123; int[][] board = new int[n][m]; for (int[] p: broken) &#123; board[p[0]][p[1]] = 1; &#125; AdjSet graph = new AdjSet(n * m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (j + 1 &lt; m &amp;&amp; board[i][j] == 0 &amp;&amp; board[i][j + 1] == 0) &#123; graph.addEdge(i * m + j, i * m + j + 1); &#125; if (i + 1 &lt; n &amp;&amp; board[i][j] == 0 &amp;&amp; board[i + 1][j] == 0) &#123; graph.addEdge(i * m + j, (i + 1) * m + j); &#125; &#125; &#125; HungarianBFS hungarianBFS = new HungarianBFS(graph); return hungarianBFS.result(); &#125;&#125; 速度比使用网络流要快","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"网络流与最大流","date":"2021-01-29T11:31:00.000Z","path":"/网络流与最大流/","text":"网络流与最大流考虑一幅有向带权图 如果图中有一个源点，即入度为 0 的节点，上图的节点 0，有一个汇点，它的出度为 0，上图的节点 3，并且图中所有边的权值都是非负的，那么我们可以说这是一个网络流。 同一般的带权图不同，网络流中边的权值不是指从一个节点到达一个节点的距离是多少，耗费是多少，它指的是从一个节点到达另一个节点能够容忍的最大流量，例如从节点 0 到节点 1 它最多能够容忍 3 的流量。除了流量限制以外，还需要满足平衡限制，即流入某个节点的流量必须等于流出该节点的流量，即节点不允许存储流量，也不能产生流量(除了源点和汇点)。 真实世界中很多的问题可以建模为网络流的模型，例如供水系统，图中的边可以看做是水管，其中的权值表示的是水管能够通过的最大流量；又比如通信系统，每条边看做是一个信道，而权值可以看做是信道容量。 源点不断的发出流量，汇点不断接收流量，因为剩余的节点既不生产流量，也不存储流量，所以从源点发出的流量会全部进入到汇点。现在我们比较关心的是，从源点最多能发出多少流量，最终到达汇点，这就是最大流问题。 有向带权图在讲解如何获得网络的最大流之前，我们先看看怎么表示网络流模型。其实网络流就是一个有向的带权图，我们只需要根据之前的无向带权图进行改造就可以得到有向带权图，改造的过程可以参考之前的无向无权图到有向无权图的改造，其实就是将 adj[v].put(w, weight);adj[w].put(v, weight); 修改为了 adj[v].put(w, weight); 以此表明是一个有方向的图。另外为了实现后续的算法，我们为带权图增加了 2 个 API setWeight(v, w, weight) addEdge(v, w, weight) 另外我们还添加了一个新的构造方法，该方法只接收一个参数，即图中有多少个节点，得到一个没有边的图，在后续通过 addEdge 方法来图添加边。 DirectedWeightedGraph 类如下 import java.io.File;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class DirectedWeightedGraph&#123; private int V; private int E; private HashMap&lt;Integer, Integer&gt;[] adj; public DirectedWeightedGraph(String path) &#123; File file = new File(path); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (V &lt; 0) &#123; throw new IllegalArgumentException(\"V can't be negative\"); &#125; adj = new HashMap[V]; for (int i = 0; i &lt; V; i++) &#123; adj[i] = new HashMap&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (E &lt; 0) &#123; throw new IllegalArgumentException(\"E can't be negative\"); &#125; for (int i = 0; i &lt; E; i++) &#123; int v = scanner.nextInt(); int w = scanner.nextInt(); int weight = scanner.nextInt(); if (v == w) &#123; throw new IllegalArgumentException(\"存在自环边\"); &#125; if (adj[v].containsKey(w)) &#123; throw new IllegalArgumentException(\"存在平行边\"); &#125; // 表示有向 adj[v].put(w, weight); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; scanner.close(); &#125; &#125; // 另一构造方法 public DirectedWeightedGraph(int V) &#123; this.V = V; this.E = 0; this.adj = new HashMap[V]; for (int v = 0; v &lt; V; v++) &#123; adj[v] = new HashMap&lt;&gt;(); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public int getWeight(int v, int w) &#123; validateVertex(v); validateVertex(w); if (!hasEdge(v, w)) &#123; throw new IllegalArgumentException(String.format(\"%d-%d 不存在\", v, w)); &#125; return adj[v].get(w); &#125; public void setWeight(int v, int w, int weight) &#123; validateVertex(v); validateVertex(w); if (!hasEdge(v, w)) &#123; throw new IllegalArgumentException(String.format(\"%d-%d 不存在\", v, w)); &#125; adj[v].put(w, weight); &#125; public void addEdge(int v, int w, int weight) &#123; validateVertex(v); validateVertex(w); if (v == w) &#123; throw new IllegalArgumentException(\"存在自环边\"); &#125; if (adj[v].containsKey(w)) &#123; throw new IllegalArgumentException(\"存在平行边\"); &#125; adj[v].put(w, weight); E++; &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return adj[v].containsKey(w); &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return adj[v].keySet(); &#125; public void validateVertex(int v) &#123; if (v &lt; 0 &amp;&amp; v &gt;= V) &#123; throw new IllegalArgumentException(\"节点超过 [0, V) 的范围\"); &#125; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (Map.Entry w: adj[v].entrySet()) &#123; stringBuilder.append(String.format(\"(%d: %d) \", w.getKey(), w.getValue())); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 该类的大部分实现细节与无向的版本相似，如果不熟悉可以查看无向图的相关章节。 Ford-Fulkerson 思想现在我们开始看一看如何找到图中的最大流，还是以下图为例 我们先从源点随便选择一条路径到达汇点 如上图我们就选择 $0 → 1 → 3$ 这条路径，这条路径能够允许的最大容量为 2，所以这条路径的流量为 2，为了表示已经通过了多少流量，我们以下面形式表示图 左边的数字表示已经通过了多少流量，右边的数字表示允许通过最大容量。接下来我们在选择一条路径 上面我们选择了 $0 → 1 → 2 → 3$ 这条路径，因为 $0 → 1$ 只允许 1 个流量通过了，所以这条路径的流量为 1，我们更新一下图 然后在选择一条路径 这次我们选择了 $0 → 2 → 3$，这条路径的流量为 $2$，更新图如下 接下来我们我们找不到一条路径从源点到汇点了，所以此时我们可以说该网络流的最大流为 $2 + 1 + 2 = 5$。 所以上面的算法就是重复下面两步： 随便找一条路径从源点到汇点，找到路径的最小值，就是这条路径的流量 更新每条边允许通过的流量 但是真的随便找一条路径就可以吗? 显然不行，例如我们一开始就找到了这么一个路径 这条路径的流量为 3，我们更新图 但是接下来我们发现找不到路径从源点到汇点了，所以我们得出这个网络流的最大路径为 $3$，明显这个答案是不对的，所以我们不能随便选择路径走，因为可能得不到正确的答案。 但是，如果我们允许反向流动呢? 例如还是以上图为例 这次我们选择路径如下 更新后的图为 本来从 $2 → 1$ 是不可达的，但是我们赋予它一个语义，表示将原来通过 $1 → 2$ 的流量引导到别的路径去了，例如本来 $1 → 2$ 有流量为 3，现在我们反向流动 2 个流量，表示将原来这 3 个流量中的 2 个流量引导到别的路径中去了。 赋予这么一个语义的话，那么上面图的所有箭头都可以变为双向的，反向的箭头表示允许被引导到别的路径上，我们给它一个权值，表示能够被允许引导到别的路径上去的流量的最大值，这个值应该是已经通过该路径的流量，例如如果 $1 → 2$ 是用 $3/5$ 表示的话，表示已经有 $3$ 个流量通过 $1 → 2$，那么$2 → 1$ 最多允许 $3$ 个流量被引导。 为了表示方便，不用 $3/5$ 这样的形式来标记边了，而是以剩余允许通过的流量表示边，例如 $3/5$ 表示最大容量为 $5$，已经通过流量为 $3$，所以剩余能够通过的流量为 $2$，我们以 $2$ 来标记这条边，同理我们也以这样的方式标记反向的边，得到下面的这么一个图 黑色表示正向边，红色表示反向边，上面的数值表示能够允许通过的最大流量，可见在最开始反向边是不能允许通过流量的，它们的权值都是 0，这个图我们称之为残差图。 接下下我们就可以使用上面提到的两步了： 随便找一条路径从源点到汇点，找到路径的最小值，就是这条路径的流量 更新每条边允许通过的流量 这个方法就是 Ford-Fulkerson 思想。 Edmonds-Karp 算法上面的 Ford-Fulkerson 只是提供了一种思想，得到一个网络流的残差图，然后随便找一条路径从源点到汇点，但是没有说怎么找这条路径，所以它只是一种思想。 接下来我们就介绍 Edmonds-Karp 算法，它就是为 Ford-Fulkerson 提供了一种具体的实现，怎么找一条路径，很简单，那就是从源点进行 BFS 来找到一条路径，当我们通过 BFS 无法达到汇点时，说明网络不能够承受更大的流量了。 所以上面的方法是不是非常的简单，下面就给出具体的实现 import java.util.*;public class MaxFlow &#123; private DirectedWeightedGraph graph; private int s; private int t; private DirectedWeightedGraph rcGraph; private int maxFlow = 0; public MaxFlow(DirectedWeightedGraph graph, int s, int t) &#123; this.graph = graph; // 一些校验工作 if (graph.V() &lt; 2) &#123; throw new IllegalArgumentException(\"网络流中节点个数必须大于1\"); &#125; graph.validateVertex(s); graph.validateVertex(t); this.s = s; this.t = t; // 根据传入的网络流，构造残差图 DirectedWeightedGraph rcGraph = new DirectedWeightedGraph(graph.V()); for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; rcGraph.addEdge(v, w, graph.getWeight(v, w)); // 一开始反向边能够允许通过的最大流量为 0 rcGraph.addEdge(w, v, 0); &#125; &#125; this.rcGraph = rcGraph; while (true) &#123; // 开始从源点做 BFS ArrayList&lt;Integer&gt; path = getAugmentPath(); // 如果从 BFS 得到的路径为空，说明不能到达汇点了，此时退出循环 if (path.size() == 0) &#123; break; &#125; // 获得路径的最小值，即这条路径允许通过的最大流量 int min = Integer.MAX_VALUE; for (int i = 1; i &lt; path.size(); i++) &#123; int v = path.get(i - 1); int w = path.get(i); min = Math.min(min, rcGraph.getWeight(v, w)); &#125; maxFlow += min; // 更新残差图 for (int i = 1; i &lt; path.size(); i++) &#123; int v = path.get(i - 1); int w = path.get(i); rcGraph.setWeight(v, w, rcGraph.getWeight(v, w) - min); rcGraph.setWeight(w, v, rcGraph.getWeight(w, v) + min); &#125; &#125; &#125; // 做 BFS private ArrayList&lt;Integer&gt; getAugmentPath() &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int[] pre = new int[graph.V()]; queue.add(s); Arrays.fill(pre, -1); pre[s] = s; while (!queue.isEmpty()) &#123; int v = queue.remove(); for (int w: rcGraph.adj(v)) &#123; if (pre[w] == -1 &amp;&amp; rcGraph.getWeight(v, w) &gt; 0) &#123; pre[w] = v; queue.add(w); &#125; &#125; &#125; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (pre[t] == -1) &#123; return result; &#125; int cur = t; while (cur != s) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(s); Collections.reverse(result); return result; &#125; // 返回网络的最大流 public int result() &#123; return maxFlow; &#125; // 返回最终 v-w 允许通过的流量 public int flow(int v, int w) &#123; if (!graph.hasEdge(v, w)) &#123; throw new IllegalArgumentException(\"存在这条边\"); &#125; graph.validateVertex(v); graph.validateVertex(w); return rcGraph.getWeight(w, v); &#125;&#125; 棒球比赛最后我们看一个使用最大流解决实际问题的例子，那就是棒球比赛。 全美每年都会举行一次棒球比赛，每个队都要进行 162 场比赛，最终所胜的场次最多的队伍获胜，如果平局就进行加赛。 但是如果在比赛的过程中，某一队已经没有获得冠军的希望了，那么该队就会被直接淘汰。例如 $A$ 队已经赢了 $10$ 场了，而 $B$ 队只赢了 $1$ 场，并且还有 $8$ 场比赛没有打，此时 $B$ 队如何也不能赢的场次比 $A$ 队多，所以 $B$ 队应该被淘汰。 现在我们拿到了 1996 年 8 月 30 日真实的比赛数据，此时只剩下 5 个队 Teams Wins Loss Left Against NY Bal Bos Tor Det New York 75 59 28 0 3 8 7 3 Baltimore 71 63 28 3 0 2 7 4 Boston 69 66 27 8 2 0 0 0 Toronto 63 72 27 7 7 0 0 0 Detroit 49 86 27 3 4 0 0 0 Wins 代表赢了多少场，Loss 表示输了多少场，Left 表示剩余多少场没有打，Against 后面的 5 列表示与其他队要打多少场。 当时媒体争议的是最后一个队，即 Detroit 队还有没有获胜的希望。从数据上看，如果 Detroit 剩下的 27 场全赢，那么它的赢的总场次是 $49 + 27 = 76$，比最强的 New York 还多一场，所以它还有赢的机会，但是这样想的话就忽略了一个事实，即使 Detroit 与其他四队的比赛都打赢了，但是这四个队之间还有比赛，也就说说这四个队它们的总胜场是会增加的。 所以现在又变为了这么一个问题，如果前四个队之间比赛，如果最终它们的胜场最多是 76 的话，说明 Detroit 队还有赢的希望，否则 Detroit 队没有赢的可能。现在我们如下建模 这个图分为三部分，第一部分 其中权值表示比赛场次，比如 s → NY-Bal 这条边的权值为 $5$，表示 NY 与 Bal 之间有五场比赛要打，可见这四个队伍总共要打 $5 + 8 + 7 + 2 + 7 = 27$ 场比赛。第二部分 这次的权值表示的是胜场的分配。第三部分 这时其中的权值表示每个队最多赢多少次，例如 NY 队目前 $75$ 分，它最多只能赢一场。如果上述网络流的最大流大于等于比赛的总场次，所以存在一种方案能够分配所有胜场使得所有队的得分最多只有 $76$ 分。 上面网络流我们建模为如下图 11 190 1 30 2 80 3 70 4 20 5 71 6 31 7 32 6 82 8 83 6 73 9 74 7 24 8 25 7 77 9 76 10 17 10 58 10 79 10 13 现在我们用之前写的 MaxFlow 类来查看最大流是多少 public class BaseBallSolution &#123; public static void main(String[] args) &#123; DirectedWeightedGraph baseball = new DirectedWeightedGraph(\"g17.txt\"); MaxFlow maxflow = new MaxFlow(baseball, 0, 10); System.out.println(maxflow.result()); &#125;&#125; 结果是 26 说明最大流为 26，小于 27，说明无法分配 27 场比赛使得所有队最多只能赢 76 场，这就意味着 Detroit 没有赢的可能了。","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"有向图算法","date":"2021-01-28T13:07:00.000Z","path":"/有向图算法/","text":"之前接触过的图都是无向图，在这个小节中讲解有向图 实际生活中的很多问题都可以建模为一个有向图的模型： 社交网络：图中的节点看做是一个个的人，如果一个节点指向一个节点，表示这个人关注了这个人，这种关注关系是有方向的 学习课程：将图中的节点看做是一门门的课程，一门课程被其他课程所指向，表示学习这门课程之前需要学习其他的课程，这种学习顺序也是有指向关系的 模块引用：将图中的节点看做是一个个的程序模块，一个模块被其他模块指向，表示该模块依赖于其他模块，这种模块之间的依赖也是有方向的 有向图的表示我们之前介绍的无向图可以看做是一种特殊的有向图，所谓的特殊在于每个节点都互相指向。我们之前在 g.txt 值规定规定了节点之间的连接关系，所以我们当我们读取到下面的形式的时候 0 1 表示的是节点 0 指向节点 1 以及节点 1 指向节点 0，所以我们在无向图中实现如下 adj[0].add(1);adj[1].add(0); 如果我们只是想表示节点 0 指向节点 1，我们就不需要添加下面那一行语句就好了。所以有向图对比于无向图的实现只需要更改这一个部分 &#123;48&#125;import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;import java.util.TreeSet;public class DirectedGraph &#123; private int E; private int V; private TreeSet&lt;Integer&gt;[] adj; public DirectedGraph(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; this.adj = new TreeSet[this.V]; for (int i = 0; i &lt; this.V; i++) &#123; this.adj[i] = new TreeSet&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; this.inDegree = new int[V]; this.outDegree = new int[V]; for (int i = 0; i &lt; this.E; i++) &#123; int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; if (adj[a].contains(b)) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; // 只是删掉了 adj[b].add(a) adj[a].add(b); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return adj[v]; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (int w: adj(v)) &#123; stringBuilder.append(String.format(\"%d \", w)); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 需要注意的是有一个概念同无向图有所不同，那就是度的概念，在有向图中度分为两类： 入度：有多少条边指向该节点 出度：有多少条件从该节点指向别的节点 例如对于下图，节点 2 的入度为 2，因为有两条边指向节点 2，出度为 1，因为有一条边从它指向节点 4。 所以我们再次修改一下类 DirectedGraph 如下 import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;import java.util.TreeSet;public class DirectedGraph &#123; private int E; private int V; private TreeSet&lt;Integer&gt;[] adj; // 增加入度和出度的成员变量 private int[] inDegree; private int[] outDegree; public DirectedGraph(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; // 其他代码相同 this.inDegree = new int[V]; this.outDegree = new int[V]; for (int i = 0; i &lt; this.E; i++) &#123; // 其他代码相同 adj[a].add(b); // 在这里初始化入度和出度，a → b，a的出度增加，b的入度增加 inDegree[b]++; outDegree[a]++; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; public int inDegree(int v) &#123; validateVertex(v); return inDegree[v]; &#125; public int outDegree(int v) &#123; validateVertex(v); return outDegree[v]; &#125; // 其他方法&#125; DFS对于有向图来说，它的 DFS 代码和 BFS 代码同无向图的写法完全是一样的，因为在后文中需要用到 DFS 遍历，所以这里贴出有向图的 DFS 遍历代码 import java.util.ArrayList;public class DFSDirectedGraph &#123; private DirectedGraph graph; // 深度优先前序遍历结果 private ArrayList&lt;Integer&gt; pre; // 深度优先后序遍历结果 private ArrayList&lt;Integer&gt; post; private boolean[] visited; public DFSDirectedGraph(DirectedGraph graph) &#123; this.graph = graph; this.pre = new ArrayList&lt;&gt;(); this.post = new ArrayList&lt;&gt;(); this.visited = new boolean[graph.V()]; for (int v = 0; v &lt; graph.V(); v++) &#123; if (!visited[v]) &#123; dfs(v); &#125; &#125; &#125; private void dfs(int v) &#123; visited[v] = true; pre.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w); &#125; &#125; post.add(v); &#125; public ArrayList&lt;Integer&gt; pre() &#123; return pre; &#125; public ArrayList&lt;Integer&gt; post() &#123; return post; &#125;&#125; 可见上面的代码与无向图的 DFS 并无不同。 有向图的环检测检测有向图中是否存在环是一件很有必要的事情 如果将上面的图看做是一个课程之间的依赖关系，如果图中存在环，说明课程之间相互依赖，学习课程 A 之前需要先学习课程 B，而学习课程 B 之前又需要先学习课程 A，这样的学习顺序肯定是有问题的。 我们想一想我们在无向图中是怎么做环检测的，我们使用 DFS 遍历，当遍历到一个节点时，如果某个邻接节点已经被访问了，并且不是它的父亲节点，我们就可以认为图中存在一个环。但是对于有向图就不一样了 上面的动图是优先遍历的顺序，最后我们来到了节点 3 此时我们发现节点 3 的相邻节点 2 已经被访问过了，并且节点 2 不是 3 的上一个节点，但是我们能说图中存在一个环吗? 不能，因为节点 2 无法到达节点 3，所以形成不了一个环。 此时我们需要另外一个变量来表示节点是否在路径上，如果一个节点访问邻接节点时发现该节点已经被访问过且在路径上，我们就可以说构成了一个环。 什么叫在路径上，如果这个节点还没有回溯到上一个节点，我们就说这个节点在路径上。 如果我们在访问到节点 w 时，节点 v 还在路径上，说明节点 v 可以到达节点 w，如果此时节点 w 可以到达节点 v 不就说明存在一个环吗。 public class DirectedCycleDetect &#123; private DirectedGraph graph; private boolean[] visited; // onPath[w] 表示节点 w 是否在路径上 private boolean[] onPath; private boolean hasCycle; public DirectedCycleDetect(DirectedGraph graph) &#123; this.graph = graph; this.visited = new boolean[graph.V()]; this.onPath = new boolean[graph.V()]; this.hasCycle = false; for (int v = 0; v &lt; graph.V(); v++) &#123; if (!visited[v]) &#123; if (dfs(v)) &#123; hasCycle = true; break; &#125; &#125; &#125; &#125; private boolean dfs(int v) &#123; visited[v] = true; onPath[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; if (dfs(w)) &#123; return true; &#125; // 通无向图不同，2 -&gt; 1 -&gt; 2 也是一个环 &#125; else if (onPath[w]) &#123; return true; &#125; &#125; // 回溯到上一个节点时就不在路径上了 onPath[v] = false; return false; &#125; public boolean isHasCycle() &#123; return hasCycle; &#125;&#125; 拓扑排序还是对于下面的这么一副图 假设上面的节点代表一门课程的话，我们想知道应该以什么样的顺序学习所有的课程，这其实就是在寻找图的拓扑排序。 那么我们寻找图的拓扑排序呢? 还是以学习课程举例，要学习一门课，那么这门就不能依赖于任何一门其他的课，或者这门课已经被学过了，就比如上面我们应该先学习课程 0，因为没有任何课程指向它，它不依赖于任何课程，以图论的语言来说，因为节点 0 的入度为 0，所以先学习课程 0。 学习完课程 0 之后，为了表示这门课程已经学过，我们将依赖于节点 0 的节点的入度减一 接下来我们应该学习哪门课呢? 当然是入度为 0 的课，表示不需要前置课程或者前置课程已经学过了，所以我们接下来学习课程 1，并且将依赖课程 1 的其他课程的入度减一 接下来还是学习入度为 0 的课程，即课程 3，并且更新依赖课程 3 的其他课程的入度 接着学习课程 2，因为它的入度为 0，然后更新依赖课程 2 的其他课程的入度 最后学习课程 4 所以最终课程的学习顺序为 0 → 1 → 3 → 2 → 4，也就是拓扑排序的结果。 所以我们对图做拓扑排序，就重复做两步： 选择入度为 0 的节点 更新相邻节点的入度 另外一个需要注意的问题就是，拓扑排序只对有向无环图(DAG) 有效，如果图中有环，二者相互依赖，就不知道先学习哪一门课程了。 在代码的实现方面，我们使用队列来存储入度为 0 的节点，在更新相邻节点入度的时候，如果入度为 0 则添加进队列中，每次从队列取出一个值时，我们添加到一个 List 中，表示拓扑排序的顺序。另外如果图中存在环的话，那么这个 List 中保存的节点数目肯定小于整个图的节点数目，此时可以使用拓扑排序来做环检测。 import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class TopoSort &#123; private DirectedGraph graph; private int[] inDegree; private ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); private boolean hasCycle = false; public TopoSort(DirectedGraph graph) &#123; this.graph = graph; this.inDegree = new int[graph.V()]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int v = 0; v &lt; graph.V(); v++) &#123; inDegree[v] = graph.inDegree(v); if (inDegree[v] == 0) &#123; queue.add(v); &#125; &#125; while (!queue.isEmpty()) &#123; int v = queue.remove(); result.add(v); for (int w: graph.adj(v)) &#123; inDegree[w]--; if (inDegree[w] == 0) &#123; queue.add(w); &#125; &#125; &#125; if (result.size() != graph.V()) &#123; hasCycle = true; result.clear(); &#125; &#125; public boolean isHasCycle() &#123; return hasCycle; &#125; public ArrayList&lt;Integer&gt; result() &#123; return result; &#125;&#125; 此时我们在介绍一种拓扑排序的算法，它需要借助于深度优先后序遍历。回顾一个后序遍历的概念，后序遍历指的是先访问完相邻节点，然后访问自己。 对于有向图意味着什么，意味着先访问依赖自己的节点，然后访问自己，说明自己是在依赖于自己的节点之后访问的，如果我们对深度优先后序遍历做一个逆序，这个顺序就表示自己在依赖于自己的节点之前被访问的，这不就是拓扑排序的结果吗。 使用深度优先后序遍历有一个缺点就是它不能做环检测，虽然图中有环，但是还是能够深度优先后序遍历，只不过此时结果便没有意义了。所以在使用这个方法做拓扑排序之前，我们需要使用我们之前讲解的有向图的环检测算法进行环检测 import java.util.ArrayList;import java.util.Collections;public class TopoSort2 &#123; private DirectedGraph graph; private boolean hasCycle; private ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public TopoSort2(DirectedGraph graph) &#123; this.graph = graph; // 使用之前的讲解的环检测类进行环检测 DirectedCycleDetect directedCycleDetect = new DirectedCycleDetect(graph); this.hasCycle = directedCycleDetect.isHasCycle(); if (hasCycle) &#123; return; &#125; // 对图做深度优先后序遍历 DFSDirectedGraph dfsDirectedGraph = new DFSDirectedGraph(graph); for (int v: dfsDirectedGraph.post()) &#123; result.add(v); &#125; // 对后序遍历取逆序 Collections.reverse(result); &#125; public boolean isHasCycle() &#123; return hasCycle; &#125; public ArrayList&lt;Integer&gt; result() &#123; return result; &#125;&#125; 强连通分量现在还有一个问题就是我们怎么检测图中有多少个强联通分量，以及每一个强联通分量中包含哪些节点。所谓的强联通分量指如果某些节点互相可达，那么这些节点就组成了一个强联通分量。 如上图就三个强联通分量，每个联通分量内部的节点都是互相可达的。 在求解有向图的联通分量之前，我们回顾一下无向图的联通分量是如何求解的，我们从任意一个节点开始做 DFS，每次做一次 DFS 就表示有一个联通分量 for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; cccount++; // 联通分量个数增加 dfs(i); &#125;&#125; 但是对于有向图我们能从任意一个节点开始吗? 答案是不行，而是要以特定的顺序遍历。如果我们将一个个的联通分量看做是一个图中的节点 如果我们分别遍历联通分量 $E \\rightarrow C \\rightarrow A \\rightarrow D \\rightarrow B$ 中的节点，那么每做一次 DFS 就就可以统计联通分量数目，那么为什么会是上面的顺序呢? 为什么从 $E$ 开始遍历，因为 $E$ 只依赖其他联通分量的节点，没有其他联通分量依赖于它，所以从 $E$ 中的某个节点做 DFS，只能遍历到联通分量 $E$ 中的节点。同理遍历完了 $E$，此时 $C$ 也只依赖于其他联通分量，虽然 $E$ 依赖于 $C$，但是 $E$ 已经遍历完毕了，所以此时从 $C$ 中的节点开始做 DFS 只能遍历到 $C$ 中所有的节点，剩余的也是同理。 也就是说依赖于自己的联通分量要被先遍历到，也就是相邻节点要在自己之前被访问到，其实就是深度优先后序遍历的顺序，所以 $E \\rightarrow C \\rightarrow A \\rightarrow D \\rightarrow B$ 这个顺序其实是深度优先后序遍历的顺序。 但是这个深度优先后序遍历指的是以联通分量作为节点进行的遍历，如果我们从任意一个节点做深度优先后序遍历是得不到这个顺序的。例如我们从联通分量中的节点 $D$ 开始遍历，接着来到了联通分量 $C$，虽然遍历完联通分量 $C$ 中所有节点之前肯定需要遍历完联通分量 $E$，但是不能保证所有 $E$ 中的节点都在 $C$ 之前被遍历，即可能有这样的顺序 $C_1 \\rightarrow E \\rightarrow C_2 \\rightarrow \\cdots$，这样的顺序是我们不想要的，因为我们必须从联通分量 $E$ 中的节点开始遍历。 虽然上面的深度优先遍历不能严格按照 $E \\rightarrow C \\rightarrow A \\rightarrow D \\rightarrow B$ 的顺序遍历，但是我们发现一定有分量 $C$ 中的节点在分量 $E$ 遍历完之后遍历的 $C_1 \\rightarrow E \\rightarrow C_2 \\rightarrow \\cdots$，例如 $C_2$ 在遍历完 $E$ 之后被遍历了，这给了我们灵感，如果我们取个逆，就可以得到一定有 $C$ 中的节点在 $E$ 分量节点被遍历之前遍历。 而我们想要的是一定要 $E$ 中的节点在 $C$ 中的节点被遍历之前遍历，怎么办，我们将整个图的方向改变一下，原来是 $a \\rightarrow b$，现在变为 $b \\rightarrow a$ 然后进行深度优先后序遍历，然后取个逆就可以保证一定有在 $E$ 中的节点在 $C$ 中的节点遍历之前被遍历到，同理可以得到一定有 $C$ 中的节点在 $D$ 中的节点被遍历之前被遍历到，这就达到我们的目的，我们再根据这个顺序做 DFS 就可以统计出联通分量的个数了。 上面这个算法就是 Kosaraju 算法，总结上面的步骤如下： 图翻转得到反图 对反图做深度优先后序遍历，然后对遍历结果取逆 根据取逆后的结果依次做 DFS，统计联通分量个数 import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.TreeSet;public class StrongCC &#123; private DirectedGraph graph; private int[] visited; private int scccount; public StrongCC(DirectedGraph graph) &#123; this.graph = graph; this.visited = new int[graph.V()]; Arrays.fill(visited, -1); this.scccount = 0; // 翻转图 TreeSet&lt;Integer&gt;[] reverse = new TreeSet[graph.V()]; for (int i = 0; i &lt; graph.V(); i++) &#123; reverse[i] = new TreeSet&lt;&gt;(); &#125; for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; reverse[w].add(v); &#125; &#125; // 对翻转图做 DFS DFSDirectedGraph dfsDirectedGraph = new DFSDirectedGraph(new DirectedGraph(reverse)); // 对深度优先后序遍历取逆 ArrayList&lt;Integer&gt; res = dfsDirectedGraph.post(); Collections.reverse(res); // 依次做 DFS，每做一次 DFS，联通分量个数增加 for(int v: res) &#123; if (visited[v] == -1) &#123; dfs(v, scccount); scccount++; &#125; &#125; &#125; private void dfs(int v, int id) &#123; visited[v] = id; for (int w: graph.adj(v)) &#123; if (visited[w] == -1) &#123; dfs(w, id); &#125; &#125; &#125; public ArrayList&lt;Integer&gt;[] components() &#123; ArrayList&lt;Integer&gt;[] results = new ArrayList[scccount]; for (int i = 0; i&lt; scccount; i++) &#123; results[i] = new ArrayList&lt;&gt;(); &#125; for (int v = 0; v &lt; graph.V(); v++) &#123; results[visited[v]].add(v); &#125; return results; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最短路径算法","date":"2021-01-27T15:16:00.000Z","path":"/最短路径算法/","text":"本文讲解图中点与点之间的最短路径问题，主要讲解三个算法： Dijkstra 算法 Bellman-Ford 算法 Floyed 算法 其中 Dijkstra 与 Bellman-Ford 是解决单源最短路径问题，即它只能求解某节点到其他节点的最短路径，而 Floyed 算法能够求解所有节点之间的最短路径。 Dijkstra 算法Dijkstra 算法它能够求解单源最短路径问题，并且使用该算法有一个前提，图中不能存在负权边，即图中的每条边的权值都必须是大于等于 0 的。 Dijkstra 算法使用一个 dis 数组来表示从源 s 到其他节点的最短距离，例如 dis[v] 表示的就是源 s 到达节点 v 的最短距离，在初始时，除了 dis[s] 为 0，其余的 dis[v] 均为无穷大。 Dijkstra 算法的思想是，每次从未遍历的节点，寻找在 dis 数组中值最小的节点，然后根据这个节点更新其未被遍历过的相邻节点在 dis 数组中的值。例如遍历到节点 v，其相邻节点为 w，并且节点 w 未被遍历过，如果 dis[v] + weight(v,w) &lt; dis[w]​，那么就更新 dis[w]，其中 weight(v, w) 是边 v-w 的权值。 举个例子，假设源为节点 0，我们求解节点 0 到各个节点的最短路径 初始节点 0 到节点 0 的距离为 0，其余节点距离节点 0 的距离为 $\\infin$。根据 Dijkstra 算法，每次从未遍历的节点，寻找在 dis 数组中值最小的节点，所以此时我们找到了节点 0，dis[0] 为 0，比其他元素小。我们来到节点 0，根据公式 dis[0] + weight(0, w) &lt; dis[w]更新与 0 相邻的节点 w 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，是节点 2，它的值为 1，并且此时我们可以断定节点 0 离节点 2 的最短距离就是 1。 为什么呢? 假设存在一条更短的路径从 0 到 2，例如是 0-1-2，但是因为此时 0-2 是最小的，而图中又不存在负权边，所以 0-1-2 比 0-1 还大，也就是比 0-2 大，所以 0-2 就是从 0 到 2 的最短路径。来到节点 2 之后，根据条件 dis[2] + weight(2, w) &lt; dis[w] 是否成立更新其相邻节点。 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，此时 dis[1] 与 dis[6] 的值都是 2，随便选一个就可以，这里我选择节点 1，并且此时可以判定节点 0 到节点 1 的最短路径就是 dis[1] 为 2。为什么? 假设存在一条路径经过未遍历的节点从 0 到达节点 1，比如是节点 4 好了，因为 dis[1] 此时是未遍历的节点中最小的，所以 dis[1] &lt; dis[4]，更别说还要加上节点 4 到节点 1 的距离，矛盾，所以找不到一条经过未遍历节点来到节点 1。 那么是否存在一条路径只经过已经遍历过的节点到达节点 1，并且路径比 dis[1] 小，不妨假设存在这么一条路径 0 -&gt; ... -&gt; s -&gt; 1，它的值比 dis[1] 小，即 dis[s] + weight(s, 1) &lt; dis[1]，那么当我们之前遍历到节点 s 对相邻节点更新的时候就会更新 dis[1] 为更小的值，也产生了矛盾，因此也不存在一条路径只经过已经遍历过的节点到达节点 1。所以我们可以说此时的 dis[1] 就是从 0 到 1 的最短路径。 来到节点 1 之后，更新其未被遍历过的相邻节点的值，当然图中节点 1 此时不存在未被遍历过的相邻节点，所以不进行任何的更新 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，找到节点 6，此时 dis[6] 的值为 2，并且此时我们可以判定从节点 0 到节点 6 的最短距离就是 2。 分析方法同上，先假设存在一条从未被遍历过的节点到达节点 6 得到的更短路径，但是因为 dis[6] 已经是从 0 到未被遍历的节点最小的，图中又不存在负权边，所以矛盾，再做假设存在只经过已被遍历过的节点到达节点 6，那么在之前 dis[6] 的值就会被更新为更小的值，也会产生矛盾，从而得到结论，不存在另外一条路径从 0 到 6 更短，此时 dis[6] 就是从 0 到 6 的最短距离。 来到节点 6 之后根据条件更新其未被遍历的相邻节点，图中节点 6 不存在未被遍历过的相邻节点，因此不作更新 继续从未遍历的节点，寻找在 dis 数组中值最小的节点，发现 dis[3] 和 dis[4] 都是 3，我们就随便选择一个，这里选择节点 3，并且此时可以判定 dis[3] 是从节点 0 到节点 3 的最短距离，已经分析过多次，不再分析。 来到节点 3 之后，根据条件更新其未被遍历过的相邻节点，与节点 3 相邻未被遍历过的节点就是节点 4，但是并不满足 dis[3] + 3 &lt; dis[4] 的条件，所以不更新 dis[4] 重复上面的过程，我们可以得到下面这张表 0 1 2 3 4 5 6 dis 0 2 1 3 3 4 2 第二行的值表示原点到各点的最短路径。 所以 Dijkstra 算法就始终在重复两步： 寻找未被遍历节点中在 dis 数组中最小的那个节点 根据条件更新未被遍历过的相邻节点 寻找最小节点的操作我们使用一个优先队列来完成，直接从队首取出的值就是最小的，无需寻找 import java.util.*;public class Dijkstra &#123; private WeightedGraph graph; private int s; private int[] dis; private boolean[] visited; // 求具体的路径用 private int[] pre; public Dijkstra(WeightedGraph graph, int s) &#123; this.graph = graph; graph.validateVertex(s); this.s = s; this.dis = new int[graph.V()]; this.visited = new boolean[graph.V()]; this.pre = new int[graph.V()]; // 初始化操作 Arrays.fill(pre, -1); Arrays.fill(dis, Integer.MAX_VALUE); pre[s] = s; dis[s] = 0; // 建立一个优先队列，Node 保存的是节点 dis[v] 的值 PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;&gt;((node1, node2) -&gt; node1.getDis() - node2.getDis()); queue.add(new Node(s, 0)); while (!queue.isEmpty()) &#123; // 选出最小节点 int v = queue.remove().getV(); // 可能存在重复添加的情况，忽略 if (visited[v]) &#123; continue; &#125; visited[v] = true; // 更新未被遍历的相邻节点 for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dis[w] = Math.min(dis[w], dis[v] + graph.getWeight(v, w)); // 将 dis[w] 添加进队列，可能会重复添加 // 不过我们只对最小的那个感兴趣，重复添加取出后会被忽略 queue.add(new Node(w, dis[w])); pre[w] = v; &#125; &#125; &#125; &#125; public int[] result() &#123; return dis; &#125; // 获得源到节点 t 的具体路径 public Iterable&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); if (!visited[t]) &#123; return path; &#125; int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125;&#125; Bellman-Ford 算法Bellman-Ford 算法也是求解单源最短路径的算法，与 Dijkstra 算法不同的是，它能够处理负权边，即使允许图中存在权值为负数的边。 在讲解 Bellman-Ford 算法之前，我们来看一组操作 dis[w] = Math.min(dis[w], dis[v] + graph.getWeight(v, w)); 这个操作叫做松弛操作。 为什么叫松弛，因为本来可以直接到达点 w，现在经过上面的操作之后，偏要经过点 v 然后到达 w (不一定会经过，只有当 dis[v] + graph.getWeight(v, w) &lt; dis[w] 才会经过点 v)，如果把边看做橡皮筋的话，不就相当于松弛了吗? 而 Bellman-Ford 算法就是，对所有的边进行 $V - 1$ 轮松弛操作，这个 $V$ 指的是图中的节点数目，经过 $V - 1$ 轮松弛操作后，此时 dis 数组中保存的就是源点到各个节点的最短路径。 为了理解 Bellman-Ford 算法为什么这么神奇，每个节点经过 $V-1$ 轮松弛操作之后就可以得到最短路径，我们还是要研究一下松弛操作 dis[w] = Math.min(dis[w], dis[v] + graph.getWeight(v, w)); 如果进行了松弛操作，意味源多经过了一条边到 w，所以如果我们设定 dis[w] 为源点最多经过 $k$ 条边到达点 w的最短路径，那么经过一次松弛操作之后 dis[w] 语义变为源点最多经过 $k + 1$ 条边到达点 w 的最短路径，因为一个节点到达另一个节点最多经过 $V-1$ 条边，因此经过 $V - 1$ 轮的松弛操作之后，dis[w] 语义变为了源点最多经过 $V - 1$ 条边到达点 w 的最短路径，考虑到了源点到达节点 w 能经过的边数的所有情况，所以最终的 dis[w] 就是源点到点 w 的最短路径。 我们来看一个例子，假设源点为 0 图中有 4 个节点，因此要进行 3 轮松弛操作。第一次对所有边进行松弛操作 第二次对所有边进行松弛操作 第三次对所有边进行松弛操作 最后得到的结果为 0 1 2 3 dis 0 4 1 2 Bellman-Ford 虽然能够处理负权边，但是如果图中有负权环的话，那么就无法求解了，所谓的负权环是指环中所以边的路径和为负值，这样的只要我每次经过一次环，每个节点的 dis 值都在减少，如果图中存在负权环的话，那么根本就不存在最小路径。 大家在考虑一个问题，对于无向图来说，如果图中出现了负权边意味着什么? 假设 0-1 是一个负权边，因为是无向图，可以从 0 到 1，也可以从 1-0，那么我们可以从 0 来到 1，然后从 1 来到 0，这就形成一个负权环。所以 Bellman-Ford 算法其实是一个有向图算法。 另外我们可以通 Bellman-Ford 算法检测图中是否存在负权环，我们知道如果如果不存在负权环的话，经过 $V-1$ 次松弛操作后，dis 数组中的元素的值是不会再改变的，所以我们可以经过 $V-1$ 次松弛操作后再次进行一次松弛操作，如果在这次的松弛操作中，dis 中有元素的值发生改变，那么就说明存在负权环。 import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class BellmanFord &#123; private int[] dis; private WeightedGraph graph; private int s; private boolean hasNegativeCycle = false; private int[] pre; public BellmanFord(WeightedGraph graph, int s) &#123; this.graph = graph; graph.validateVertex(s); this.s = s; this.dis = new int[graph.V()]; this.pre = new int[graph.V()]; Arrays.fill(dis, Integer.MAX_VALUE); Arrays.fill(pre, -1); dis[s] = 0; pre[s] = s; // k 代表轮数 for (int k = 1; k &lt; graph.V(); k++) &#123; // 对所有边进行松弛操作，v-w 与 w-v 是两条边 for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; if (dis[v] != Integer.MAX_VALUE &amp;&amp; dis[v] + graph.getWeight(v, w) &lt; dis[w]) &#123; dis[w] = dis[v] + graph.getWeight(v, w); pre[w] = v; &#125; &#125; &#125; &#125; // 再次进行一次松弛操作，检测负权环 for (int v = 0; v &lt; graph.V(); v++) &#123; for (int w: graph.adj(v)) &#123; if (dis[v] != Integer.MAX_VALUE &amp;&amp; (dis[v] + graph.getWeight(v, w) &lt; dis[w])) &#123; hasNegativeCycle = true; &#125; &#125; &#125; &#125; public int[] result() &#123; return dis; &#125; public Iterable&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125; public boolean isHasNegativeCycle() &#123; return hasNegativeCycle; &#125;&#125; Floyed 算法上面的两个算法解决的都是单源最短路径问题，而 Floyed 算法解决的所有点对之间的最短问题。我们其实可以通过使用 $V$ 次 Dijkstra 算法就可以求解所有点对之间的最短路径，不过 Dijkstra 算法不能处理负权边的问题，而 Floyed 算法可以处理负权边的问题。 但是同 Bellman-Ford 算法一样，如果图中存在负权环的话，就根本不存在最短路径，而我们知道如果无向图中有负权边的话，就相当于存在负权环，所以 Floyed 算法其实也是一个有向图算法。 Floyed 算法的思想也很简单，对于 v-w，假设它们之间的最短路径表示为 dis[v][w]，每一次都要尝试一下绕道点 t 会不会得到更短的路径(t 从节点 $0$ 取值到节点 $V-1$)，相当于 for(int t = 0; t &lt; V; t++) &#123; dis[v][w] = Math.min(dis[v][t] + dis[t][w], dis[v][w])&#125; 当经历过 $V$ 次的绕道尝试后，最终 dis[v][w] 就表示节点 v 与节点 w 之间的最短路径。 另外我们也可以通过 Floyed 算法对负权环进行检测，我们知道如果没有负权环的话 dis[v][v] 的值始终是 0，如果存在负权环的话，那么 dis[v][v] 的值就会更新为小于 0 的值，在经过 $V$ 次绕道之后检查所有的 dis[v][v] 是否等于 0 即可知道图中是否有负权环。 import java.util.Arrays;public class Floyed &#123; private WeightedGraph graph; private int[][] dis; private boolean hasNegativeCycle = false; public Floyed(WeightedGraph graph) &#123; this.graph = graph; this.dis = new int[graph.V()][graph.V()]; for (int i = 0; i &lt; dis.length; i++) &#123; Arrays.fill(dis[i], Integer.MAX_VALUE); &#125; // 初始化 dis[][] for (int v = 0; v &lt; graph.V(); v++) &#123; dis[v][v] = 0; for (int w: graph.adj(v)) &#123; dis[v][w] = graph.getWeight(v, w); &#125; &#125; // 绕道尝试 for (int t = 0; t &lt; graph.V(); t++) &#123; for(int v = 0; v &lt; graph.V(); v++) &#123; for (int w = 0; w &lt; graph.V(); w++) &#123; if (!(dis[v][t] == Integer.MAX_VALUE || dis[t][w] == Integer.MAX_VALUE)) &#123; dis[v][w] = Math.min(dis[v][w], dis[v][t] + dis[t][w]); &#125; &#125; &#125; &#125; // 检测负权环 for (int v = 0; v &lt; graph.V(); v++) &#123; if (dis[v][v] &lt; 0) &#123; hasNegativeCycle = true; &#125; &#125; &#125; public int dis(int v, int w) &#123; return dis[v][w]; &#125; public boolean isHasNegativeCycle() &#123; return hasNegativeCycle; &#125;&#125; Floyed 算法也有时称为 3-for 算法，因为它的算法核心就是三个嵌套的 for 循环，Floyed 算法的实现是这三个算法中最简单的。","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最小生成树","date":"2021-01-26T08:32:00.000Z","path":"/最小生成树/","text":"带权图在之前的文章中，介绍的都是无向无权图，那本篇开始介绍无向带权图 如果将上述的图看做是一个交通系统的话，那么边的权重就可以代表为距离。为了表示带有权重的图，我们建立一个 WeightedGraph 类来表示带权图。 同无权图 AdjSet 一样，我们从如下格式的文件读取内容生成图 7 120 1 20 3 70 5 21 2 11 3 41 4 31 5 52 4 42 5 43 4 13 6 54 6 7 第一行 7 表示总共有 7 个节点，12 表示有 12 条件，下面表示两两相邻的节点，以及之间的权重，例如 0 1 2 表示节点 0 与节点 1 相邻，之间的权重为 2。 WeightedGraph 类如下，代码大部分同 AdjSet 类： import java.io.File;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class WeightedGraph&#123; private int V; private int E; // adj[i] 是一个 HashMap，键为相邻的节点，值为边上的权重 private HashMap&lt;Integer, Integer&gt;[] adj; public WeightedGraph(String path) &#123; File file = new File(path); Scanner scanner = null; // 从 txt 文件读取建立图，大部分同 AdjSet 类 try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (V &lt; 0) &#123; throw new IllegalArgumentException(\"V can't be negative\"); &#125; adj = new HashMap[V]; for (int i = 0; i &lt; V; i++) &#123; adj[i] = new HashMap&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (E &lt; 0) &#123; throw new IllegalArgumentException(\"E can't be negative\"); &#125; for (int i = 0; i &lt; E; i++) &#123; int v = scanner.nextInt(); int w = scanner.nextInt(); int weight = scanner.nextInt(); if (v == w) &#123; throw new IllegalArgumentException(\"存在自环边\"); &#125; if (adj[v].containsKey(w)) &#123; throw new IllegalArgumentException(\"存在平行边\"); &#125; adj[v].put(w, weight); adj[w].put(v, weight); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; scanner.close(); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public int getWeight(int v, int w) &#123; validateVertex(v); validateVertex(w); return adj[v].get(w); &#125; public int degree(int v) &#123; validateVertex(v); return adj[v].size(); &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return adj[v].containsKey(w); &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return adj[v].keySet(); &#125; public void validateVertex(int v) &#123; if (v &lt; 0 &amp;&amp; v &gt;= V) &#123; throw new IllegalArgumentException(\"节点超过 [0, V) 的范围\"); &#125; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (Map.Entry w: adj[v].entrySet()) &#123; stringBuilder.append(String.format(\"(%d: %d) \", w.getKey(), w.getValue())); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 最小生成树首先介绍生成树的概念，假设图中有 $V$ 个顶点，如果能找到图中 $V - 1$ 条边这 $V$ 个节点连接起来，那么就说这 V 个节点与 V - 1 条边形成的图叫做这个图的生成树。 例如图的 DFS 遍历以及 BFS 遍历就会形成一个生成树 只要图中的 $V - 1$ 条边将图中的 $V$ 个顶点联通起来，那么就是图的一个生成树，所以一个图有很多的生成树，所谓的最小生成树，就是生成树边上的权值加起来最小 那么最小生成树有什么应用呢? 如果将这个图看做是交通系统，找出最小生成树就是找到一种耗费最低的方式将所有站点连通起来的布局方案。 切分定理下面介绍切分定理，这个定理被用来寻找最小生成树。首先什么叫切分，所谓切分就是把节点分为两部分 上图中节点 $0, 5, 4$ 被划分一部分，其余节点为另一部分。切分的方式有很多种，随意你进行切分，只要将图中的节点划分为两部分即可。 引入了切分的概念，下面继续引入横切边的概念。所谓的横切边指的是将两个不同部分节点连接起来的边，例如对于上面的划分，有如下横切边 上面被标记为绿色的边就是横切边，可以看到横切边的两端是两个不同部分的节点。 介绍完必须的概念之后，引入切分定理： 切分定理：对于任意一个切分，这种切分形成的横切边中，权值最小的横切边一定在最小生成树中 这个定理很好证明，我们根据切分将图分为两部分 这两部分之间的边就是横切边，可以观察到横切边将这两个部分连接在了一起，为了使得生成树连通，一定要在横切边中选择一条边，而为了得到最小生成树，那当然选择的是权值最小的横切边，所以说权值最小的横切边一定在最小生成树中。 Kruskal 算法Kruskal 算法是求的最小生成树的一种算法，他的思想很简单，就是每次取图中最小的边，只要这条边没有已经选取的边形成环。例如对于下图 首先选择图中最短的两条边，即权值为 1 的两条边 1-2 与 3-4 下面继续选择权值最小的边，选择 0-5、0-1，这两条边的权值为 2 继续选择权值最小的边，此时选择 1-4，权值为 3 继续选择，此时应该选择 5-2 与 1-3 两条边，它们的权值为 4，但是我们发现选择 5-2 就会形成一个环，选择 1-3 也会形成环，所以这两条边不能选，生成树中可不能有环的。除开这两条边继续选择，发现 5-1、3-6 这两条边的权值为 5，权值最小，但是选择 5-1 就会形成环，所以不选 5-1，只选择 3-6 这个时候我们已经找到了 6 条边将这 7 个顶点连接起来，即找到了一个最小生成树 Kruskal 的算法思想很简单，就是贪心，每次选择权重最小的边，但是怎么证明这种贪心策略是对的。这就需要用到切分定理。 每次我们选择最小的边，我们只需要让这条边是一个切分的横切边就行，这种切分很好做，让这条边两个节点属于不同的部分即可，根据切分定理这条横切边一定是最小生成树中的一条边。如果这条边与选择的边形成了一个环，这说明找不到一个切分，使得这条边的所有横切边中最短的边，所以不能选择它。 在代码的实现方向，每次我们找到一个最短的边时，需要判断是否构成一个环，例如我们找到边 5-1，需要判断添加这条边是否构成一个环，其实就是在检测在添加这条边之前节点 5 和节点 1 是否连通，如果是连通，添加这条边后就会形成环。 每次都需要判断两个节点需要连通，可以使用 DFS 来做，但是这样做复杂度太高，借助并查集这种数据结构可以很方便的判断两个节点是否连通，只需要判断它们是否在一个集合中即可，如果对于并查集不熟，可以参考这篇文章。 并查集的实现如下： public class UnionFind &#123; private int[] parent; private int[] rank; public UnionFind(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; index = parent[index]; &#125; return index; &#125; public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; 我们需要一个类来保存边的信息，这里我们新建一个 WeightedEdge 类： public class WeightedEdge &#123; private int v; private int w; private int weight; public WeightedEdge(int v, int w, int weight) &#123; this.v = v; this.w = w; this.weight = weight; &#125; public int getV() &#123; return v; &#125; public int getW() &#123; return w; &#125; public int getWeight() &#123; return weight; &#125; @Override public String toString() &#123; return String.format(\"(%d-%d: %d)\", v, w, weight); &#125;&#125; Kruskal 算法实现如下： import java.util.ArrayList;import java.util.Collections;public class Kruskal &#123; private WeightedGraph graph; public ArrayList&lt;WeightedEdge&gt; result = new ArrayList&lt;&gt;(); public Kruskal(WeightedGraph graph) &#123; this.graph = graph; int V = graph.V(); // 将所有的边添加进集合中 ArrayList&lt;WeightedEdge&gt; edges = new ArrayList&lt;&gt;(); for (int v = 0; v &lt; V; v++) &#123; for (int w: graph.adj(v)) &#123; if (v &lt; w) &#123; edges.add(new WeightedEdge(v, w, graph.getWeight(v, w))); &#125; &#125; &#125; // 根据边的权值大小，从小到大排序 Collections.sort(edges, (w1, w2) -&gt; w1.getWeight() - w2.getWeight()); UnionFind unionFind = new UnionFind(V); for (WeightedEdge edge: edges) &#123; int v = edge.getV(); int w = edge.getW(); // 如果之前不连通 if (!unionFind.isConnected(v, w)) &#123; result.add(edge); unionFind.unionElements(v, w); &#125; &#125; &#125; public Iterable&lt;WeightedEdge&gt; result() &#123; return result; &#125;&#125; Prim 算法Prim 算法也是有关最小生成树的算法，它的思想同切分定理密切相关。因为对于每一个切分，权值最小的横切边一定在最小生成树中。Prim 算法就在遍历节点的过程中，将遍历到的节点与未遍历的节点作为两部分形成一个切分，然后遍历此时所有的横切边，在此边作为最小生成树的一条边。 每次遍历到一个节点即可找到一条横切边，当遍历到最后一个节点时，就能找到 $V-1$ 条边，即可形成一个生成树，并且根据切分定理，这个生成树一定是最小生成树。 Prim 算法最后的结果是同 Kruskal 算法相同的。 在代码的实现方面，因为每次产生一次新的切分，都要找到所有的横切边进行遍历然后找到最小的横切边，这个过程我们可以使用优先队列进行实现。 当遍历到一个节点时，新的横切边的产生都与这个遍历到的节点相连，我们只要将新的横切边添加到队列中即可，不用遍历节点寻找所以的横切边，另外这是一个优先队列，即队首元素它的权重是最小的，我们也不用查找最小边的炒作，直接取出队首元素即可。 另外，可能你会注意到，当遍历到一个新的节点，产生一个新的切分时，之前的横切边可能不是横切边了，即优先队列中的边不是所有的边都是横切边。仔细想想，这个并没有影响，因为虽然不是所有的边都是横切边，但是所有的横切边都在队列里，我们从队列中取出边时进行判断，不是横切边直接忽略即可，完全不影响我寻找最小的横切边。 import java.util.ArrayList;import java.util.PriorityQueue;public class Prim &#123; private WeightedGraph graph; private boolean[] visited; private ArrayList&lt;WeightedEdge&gt; result = new ArrayList&lt;&gt;(); public Prim(WeightedGraph graph) &#123; this.graph = graph; PriorityQueue&lt;WeightedEdge&gt; priorityQueue = new PriorityQueue&lt;&gt;((w1, w2) -&gt; w1.getWeight() - w2.getWeight()); this.visited = new boolean[graph.V()]; visited[0] = true; for (int w: graph.adj(0)) &#123; priorityQueue.add(new WeightedEdge(0, w, graph.getWeight(0, w))); &#125; while (!priorityQueue.isEmpty()) &#123; WeightedEdge edge = priorityQueue.remove(); int v = edge.getV(); int w = edge.getW(); // 不是横切边直接忽略 if (visited[v] &amp;&amp; visited[w]) &#123; continue; &#125; result.add(edge); visited[w] = true; // 添加新的横切边 for (int next: graph.adj(w)) &#123; priorityQueue.add(new WeightedEdge(w, next, graph.getWeight(w, next))); &#125; &#125; &#125; public Iterable&lt;WeightedEdge&gt; result() &#123; return result; &#125;&#125; 如果在实际中需要手写最小生成树算法，推荐使用 Prim 算法，因为在大多数的语言标准库中都有优先队列的实现，但是都没有并查集的实现，所以如果使用 Kruskal 算法需要手写并查集。","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"ES6：解构","date":"2021-01-26T07:11:00.000Z","path":"/ES6：解构/","text":"当我们使用 Ajax 向服务器端获取数据时，服务器一般会返回一个对象，这个时候我们需要从对象中提取出需要的数据 const print = console.log;const data = &#123; type: 'male', name: 'Alice'&#125;// 从对象中提取出数据let type = data.type;let name = data.name;print(type); // maleprint(name); // Alice 下面的内容讲的是 ES6 提供新的语法来方便的做到这件事情。 对象解构下面的代码可以做到和上面一样的事情 const print = console.log;const data = &#123; type: 'male', name: 'Alice'&#125;let &#123;type, name&#125;= data;print(type); // maleprint(name); // Alice 上面使用了 let {name, type} = data 来进行赋值，这行代码的意思就是从 data 对象中提取出 name 和 type 属性，并且赋值到名为 name 和 type 的本地变量中。 默认值考虑下面的例子 let &#123;type, name, value&#125; = data;print(type); // maleprint(name); // Aliceprint(value); // undefined 上面增加了一个 value 变量，我们想从 data 里面提取出 value 属性给变量 value，但是 data 对象并没有 value 属性，所以 value 变量的值是 undefined，现在我们希望如果 data 里面没有 value 属性的话，给变量 value 一个默认值，那么可以这么写 let &#123;type, name, value = 0&#125; = data;print(type); // maleprint(name); // Aliceprint(value); // 0 当 data 对象没有 value 属性，或者 value 属性的值为 undefined 时，value 变量就会使用默认值 0。 赋值给非同名变量let &#123;type, name&#125;= data; 出于某种原因，我们希望将 data.type 属性的值赋值给 localType 的变量而不是 type 变量，那么我们可以这么写 let &#123;type: localType, name&#125; = data;print(localType); // maleprint(type); // ReferenceError: type is not defined 上面代码作用就是提取 data 对象的 type 属性给变量 localType，接着我们分别打印了 localType 和 type 变量的值，发现本地根本没有 type 变量。 嵌套对象解构考虑一个复杂结构的对象 const data = &#123; first: &#123; name: \"Alice\", age: 18 &#125;, second: &#123; name: \"Bob\", age: 3 &#125;&#125; 我们希望将 data.first.name 赋值为一个本地变量 name，那么可以这样写 let &#123;first: &#123;name&#125;&#125; = data;print(name); // Alice 如果希望将 data.first.name 赋值为别的变量，如 firstName，那么可以这么写 let &#123;first: &#123;name: firstName&#125;&#125; = data;print(firstName) // Aliceprint(name); // ReferenceError: name is not defined 数组解构数组解构的语法同对象解构的语法相似，不过对象解构是根据名称进行解构，而数组则是根据下标解构 const data = [\"red\", \"green\", \"blue\"];let [first, second] = data;print(first); // redprint(second); // green [first, second] = data 指的就是将 data 数组的第一个元素的值赋值给变量 first，第二个元素的值赋值给变量 second。如果希望只获得第二个元素的值，可以这么写 let [, second] = data;print(second); // green 默认值const data = [\"red\"];let [first, second] = data;print(first); // redprint(second); // undefine 因为数组中只有一个元素，所以 second 变量的值为 undefined，我们希望如果数组个数不足时，能为 second 赋值一个默认值，可以采取下面的办法 const data = [\"red\"];let [first, second = \"white\"] = data;print(first); // redprint(second); // white 当数组值的个数不足时，或者数组元素的值为 undefined 时，就使用默认值。 嵌套数组解构假设有如下嵌套数组 const data = [\"red\", [\"white\", \"black\"], \"yellow\"]; 现在希望从里面解构出 white，可以这么写 let [, [white]] = data;print(white); // white 其中第一个 , 表示我们不需要第一个元素，而第二个 [white] 表示我们要第二个元素里面的第一个元素，并将其赋值给 white 变量。 剩余项使用 ... 语法可以获得数组中的剩余项，例如 let data = [\"red\", \"green\", \"blue\"];let [first, ...rest] = data;print(first); // redprint(rest); // [ 'green', 'blue' ] 上面的 [first, ...rest] = data 表示将第一个元素赋值给 first 变量，而剩下的元素赋值给 rest 变量。使用 ... 的语法可以方便的做到数组的复制，如 const data = [\"red\", \"green\", \"blue\"];let [...copyData] = data;print(copyData); // [ 'red', 'green', 'blue' ] 解构参数下面是一个向服务端发送请求的函数 function getData(type, url, options) &#123; options = options || &#123;&#125;; let timeout = options.timeout, success = options.success; error = options.error; // dosomething&#125; 除了接收 type，url 两个必须的参数，还可以接收一些配置项由 options 参数给出，在函数中我们将 options 的属性提取出来给了特定的变量，其实上面的操作可以由下写法做到 function getData(type, url, &#123;timeout, success, error&#125; = &#123;&#125;) &#123; print(timeout); // 5000 print(success); // [Function: success] print(error); // [Function: error] // dosomething&#125;getData(\"get\", \"http://localhost:4000\", &#123; timeout: 5000, success: function(data) &#123;&#125;, error: function(error) &#123;&#125;&#125;) 我们传入的对象会被解构具体的参数。如果我们希望在没有给出配置项时，参数有默认值，例如 timeout 如果没有被给出的话，我们希望它的值是 3000，根据解构的默认值语法，不难写出如下 function getData(type, url, &#123;timeout = 2000, success, error&#125; = &#123;&#125;) &#123; print(timeout); // 2000 print(success); // [Function: success] print(error); // [Function: error] // dosomething&#125;// 没有传入 timeout 参数getData(\"get\", \"http://localhost:4000\", &#123; success: function(data) &#123;&#125;, error: function(error) &#123;&#125;&#125;)","tags":[{"name":"解构","slug":"解构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E8%A7%A3%E6%9E%84/"}]},{"title":"欧拉回路","date":"2021-01-25T07:43:00.000Z","path":"/欧拉回路/","text":"欧拉回路七桥问题18世纪初普鲁士的哥尼斯堡，有一条河穿过，河上有两个小岛，有七座桥把两个岛与河岸联系起来，如下图(黄色线条代表桥，绿色区域代表小岛和河岸) 有个人提出一个问题：一个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。 数学家欧拉将河岸与小岛建模为节点，而七座桥建模为边，所以七桥问题建模为上图最右边的图论问题，找到图中经过所有边一次且回到原点的回路，这种回路我们后来称为欧拉回路。 欧拉回路的数学性质上述的七桥问题很长时间都没有解决，即人们没有找到一条回路，能够只经过每座桥一次，然后回到原点。所以欧拉就猜想是不是根本不存在这种回路，经过他的证明，上述七桥问题的确不存在欧拉回路。 欧拉证明十分的简单，因为要从起点出发回到原点，那么对于每个节点都要一进一出，而每次进出需要消耗两条边，所以每个节点必须具有偶数条边，它才能保证有进有出，才有可能回到原点。所以就得到了欧拉回路一个充分必要条件： 每个节点的度都是偶数 $\\Leftrightarrow$ 图中存在欧拉回路 每个节点的度都是偶数是图中存在欧拉回路是充分必要条件，二者可以互推，所以我们只要判断图中每个节点的度是不是偶数即可得到图中是否有欧拉回路这个结论。 回到七桥问题，观察图中的每一个节点，发现它们的度都不是偶数，所以绝对不可能从某点出发，经过所以的边一次然后回到原点，至此欧拉完美的解决了七桥问题，图论领域也是从此开始发展。 下面是判断欧拉回路是否存在的代码： public class EulerCycle &#123; private Graph graph; public EulerCycle(Graph graph) &#123; this.graph = graph; &#125; public boolean hasEulerCycle() &#123; // 如果图中不只一个联通分量的话，说明肯定没有欧拉回路 CCGraph ccGraph = new CCGraph(graph); if (ccGraph.getCCcount() != 1) &#123; return false; &#125; for (int i = 0; i &lt; graph.V(); i++) &#123; if (graph.degree(i) % 2 != 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 求解欧拉回路上面我们只是判断图中欧拉回路是否存在，但是我们没有得到一个具体的欧拉回路，所以在本节中介绍三种方法得到欧拉回路。 回溯法回溯法就是暴力搜索法，搜索从起点出发的所有路径，直到找到一条欧拉回路 Fleury 算法考虑下图，当我们从节点 0 来到节点 2 时 对于回溯法，可以选择遍历节点 1，也可以选择遍历节点 3，而 Fleury 算法却会选择接下来遍历节点 3 而不是节点 1，因为边 2-1 它是一个桥，如果选择遍历节点 1，就不可能再次回到节点 2，即节点 2 右边的边 2-3 2-4 不可能被访问到，所以 Fleury 算法的策略就是在遍历边前判断这条边是不是桥，如果是桥的话，就不遍历这条边，选择其他的边。 Hierholzer 算法 上图每个节点的度都是偶数，所以该图一定有欧拉回路。Hierholzer 算法首先在图中随便找到一个环 这个环如果是欧拉回路，那就找到了；如果不是欧拉回路，例如上面找到环 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 0$，它不是欧拉回路，中间缺失了一环，因为节点 2 还与别的节点相连，上述链中的 $2$ 应该变为 $2 \\rightarrow … \\rightarrow 2 $，所以我们需要回退到节点 2 开始寻找这个环。 比如我们继续找到了 $2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2$ 这个环 但是因为 $5$ 还与别的节点相连，所以 $5$ 应该被扩展为 $5 \\rightarrow … \\rightarrow 5$，所以又需要回退到节点 5 开始寻找新的环 最终我们找到了环 $5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 5$，将这个结果替换 $2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2$ 其中的 $5$，得到 $2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 5 \\rightarrow 2$，最后将这个结果环替换 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 0$ 其中的 $2$，结果变为 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 5 \\rightarrow 2 \\rightarrow 3 \\rightarrow 0$。 我们可以使用栈来模拟上面的回退动作，当我们遍历环时，将节点添加进栈 result中，当我们发现来到某个节点不能继续遍历并且还有边未被遍历时，我们便进行回退，从栈中弹出元素，直到栈顶节点还与其他节点相连，从该节点开始寻找新的环。我们会将从栈中弹出的节点添加到另一个栈 back 中，当我们遍历完所有的边时在将 back 这个栈中的节点依次弹入到 result 这个栈中 因为上面有删边的动作，所以我们在 Graph 接口添加了一个 removeEdge(int v, int w)，作用就是将 v-w 这条边删除，具体实现如下 @Overridepublic void removeEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); sets[v].remove(w); sets[w].remove(v);&#125; Hierholzer 算法的实现如下 import java.util.ArrayList;import java.util.Collections;import java.util.Stack;public class EulerCycle &#123; private Graph graph; public EulerCycle(Graph graph) &#123; this.graph = graph; &#125; public boolean hasEulerCycle() &#123; CCGraph ccGraph = new CCGraph(graph); if (ccGraph.getCCcount() != 1) &#123; return false; &#125; for (int i = 0; i &lt; graph.V(); i++) &#123; if (graph.degree(i) % 2 != 0) &#123; return false; &#125; &#125; return true; &#125; public Iterable&lt;Integer&gt; result() &#123; ArrayList res = new ArrayList(); if (!hasEulerCycle()) return res; // 剩余未被遍历的边数 int left = graph.E(); Stack&lt;Integer&gt; result = new Stack&lt;&gt;(); Stack&lt;Integer&gt; back = new Stack&lt;&gt;(); int curV = 0; result.push(curV); // 还有边未被遍历就继续遍历 while (left != 0) &#123; // 每次更新 curV 为栈顶节点 curV = result.peek(); // 如果栈顶元素有相邻节点，从此寻找新的环 if (graph.degree(curV) != 0) &#123; // 获得一个相邻节点 int w = graph.adj(curV).iterator().next(); result.push(w); graph.removeEdge(curV, w); left--; &#125; else &#123; // 没有相邻节点，进行回溯 back.push(result.pop()); &#125; &#125; // 将 back 栈中的数据依次弹出到 result while (!back.isEmpty()) &#123; result.push(back.pop()); &#125; // 将栈中元素弹出到 list 中 while (!result.isEmpty()) &#123; res.add(result.pop()); &#125; Collections.reverse(res); return res; &#125;&#125; 验证算法是否正确，新建 g11.txt，内容如下 9 110 10 31 22 32 42 54 55 65 86 77 8 所表示的图就是示例中的图 测试如下 public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g11.txt\"); EulerCycle eulerCycle = new EulerCycle(graph); for (int w: eulerCycle.result()) &#123; System.out.print(w + \" \"); &#125;&#125; 输出为 0 1 2 4 5 6 7 8 5 2 3 0 与我们讨论的结果一致。","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"哈密尔顿回路与哈密尔顿路径","date":"2021-01-24T18:16:00.000Z","path":"/哈密尔顿回路/","text":"哈密尔顿回路1859年，爱尔兰数学家哈密尔顿（Hamilton）提出下列周游世界的游戏：在正十二面体的二十个顶点上依次标记伦敦、巴黎、莫斯科等世界著名大城市，正十二面体的棱表示连接这些城市的路线。试问能否在图中做一次旅行，从顶点到顶点，沿着边行走，经过每个城市恰好一次之后再回到出发点。 将上面的问题抽象为一个图论问题：如果我们能从图的某点出发，经过所有的节点有且仅有一次，并且回到原点，那么我们就说图中存在哈密尔顿回路。 哈密尔顿回路在数学上并没有找到充分必要条件，所谓充分必要条件指的是，如果图满足什么性质它就有哈密尔顿回路以及一旦图有哈密尔顿回路这个图就满足什么性质。所以我们判断判断某个图是否是哈密尔顿图，办法就是暴力搜索，使用回溯法去搜索图。 import java.util.ArrayList;import java.util.Collections;public class HamiltonCycle &#123; private Graph graph; private boolean[] visited; // 还有多少个节点未访问，当 left == 0 时表示所有节点都被访问过 private int left; // 当前节点的前一个节点，已获得路径 private int[] pre; // 最后一个被访问的节点 private int end; public HamiltonCycle(Graph graph) &#123; this.graph = graph; this.visited = new boolean[graph.V()]; this.left = graph.V(); this.pre = new int[graph.V()]; this.end = -1; pre[0] = 0; dfs(0); &#125; // dfs 设有返回值，当找到哈密尔顿回路时，提前终止 private boolean dfs(int v) &#123; visited[v] = true; left--; if (left == 0 &amp;&amp; graph.hasEdge(v, 0)) &#123; end = v; return true; &#125; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; pre[w] = v; if (dfs(w)) return true; &#125; &#125; visited[v] = false; left++; return false; &#125; public Iterable&lt;Integer&gt; result() &#123; ArrayList result = new ArrayList(); if (end == -1) &#123; return result; &#125; int cur = end; while (cur != 0) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(0); Collections.reverse(result); return result; &#125;&#125; 状态压缩对图进行暴力搜索的时间复杂度是 $O(n!)$，所以暴力搜索图只适合图的规模不大的情况，当图的规模不大时，我们可以对 visited 数组进行压缩，使用一个整数来表示图中个节点的访问状态，具体就是根据这个数字的二进制位为 0 还是为 1 来表示是否被访问过。 举个例子，我们使用 int 类型来保存 visited 变量，int 类型占据 4 个字节，即 32 位，第一位是符号位，故可以认为可以表示 31 个节点访问状态，如果 visited = 1，二进制就是 00000000 00000000 00000000 00000001，从右往左数第 0 个数是 1，就表示节点 0 被访问过了，其他数字都是 0，表示其他节点没有被访问过。 观察上面的程序，我们对 visited 有三种操作： 判断某个节点有没有被访问过，例如判断节点 i 有没有被访问过，只要 $2^i$ 和 visited 相与即可知道，如果结果为 1，说明第 i 位为 1，即节点 i 被访问过，否则就是未被访问过 将节点 i 设置为被访问过(visited[i] = true)，也就是将第 i 个位置由 0 变为 1，就是将 $2^i$ 与 visited 异或即可 将节点 i 设置为未被访问过(visited[i] = false)，也就是将第 i 个位置由 1 变为 0，还是将 $2^i$ 与 visited 异或即可 注意 $2^i$ 可以表示为 1 &lt;&lt; i 所以我们修改上面的程序，将 visited 数组变为一个数字 public class HamiltonCircleCompress &#123; private Graph graph; private int visited; private int left; private int[] pre; private int end; // 不变 public HamiltonCircleCompress(Graph graph) &#123; this.graph = graph; this.visited = 0; this.left = graph.V(); this.pre = new int[graph.V()]; this.end = -1; pre[0] = 0; dfs(0); &#125; private boolean dfs(int v) &#123; // 设置 visited[v] 为 true visited = visited ^ (1 &lt;&lt; v); left--; if (left == 0 &amp;&amp; graph.hasEdge(v, 0)) &#123; end = v; return true; &#125; for (int w: graph.adj(v)) &#123; // 判断 visited[w] 是否访问过 if ((visited &amp; (1 &lt;&lt; w)) == 0) &#123; pre[w] = v; if (dfs(w)) return true; &#125; &#125; // 设置 visited[v] 为 false visited = visited ^ (1 &lt;&lt; v); left++; return false; &#125; // 不变 public Iterable&lt;Integer&gt; result() &#123; ArrayList result = new ArrayList(); if (end == -1) &#123; return result; &#125; int cur = end; while (cur != 0) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(0); Collections.reverse(result); return result; &#125;&#125; 哈密尔顿路径哈密尔顿路径的定义同哈密尔顿回路相似，如果从图中的某一点出发，能够经过图中所有的节点有且仅有一次，那么这条路径就是哈密尔顿路径。需要注意的是，图中是否存在哈密尔顿回路与起始点无关，但是哈密尔顿路径与起始点有关，可能从某点出发，并不能走过每一节点，但是从另一个节点出发，却能够走过所有节点，且只经过一次。 哈密尔顿路径的代码同哈密尔顿回路的代码相似，只有两处不同： 需要传入起始点 当 left 为 0 时，不用判断最后节点是否与起始点相邻，因为哈密尔顿路径不要求回到起始点 代码如下 import java.util.ArrayList;import java.util.Collections;public class HamiltonPath &#123; private Graph graph; private boolean[] visited; private int left; private int[] pre; private int end; // 起始点 private int s; public HamiltonPath(Graph graph, int s) &#123; this.graph = graph; this.s = s; this.visited = new boolean[graph.V()]; this.left = graph.V(); this.pre = new int[graph.V()]; this.end = -1; pre[0] = 0; dfs(s); &#125; private boolean dfs(int v) &#123; visited[v] = true; left--; // 不用判断 v 是否与起始点相邻 if (left == 0) &#123; end = v; return true; &#125; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; pre[w] = v; if (dfs(w)) return true; &#125; &#125; visited[v] = false; left++; return false; &#125; public Iterable&lt;Integer&gt; result() &#123; ArrayList result = new ArrayList(); if (end == -1) &#123; return result; &#125; int cur = end; while (cur != 0) &#123; result.add(cur); cur = pre[cur]; &#125; result.add(0); Collections.reverse(result); return result; &#125;&#125; 不同路径 III这是一道 LeetCode 上的题目，它的本质就是在求哈密尔顿路径。 题目简介在二维网格 grid 上，有 4 种类型的方格： 1 表示起始方格。且只有一个起始方格 2 表示结束方格，且只有一个结束方格 0 表示我们可以走过的空方格 -1 表示我们无法跨越的障碍 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。 提示：1 &lt;= grid.length * grid[0].length &lt;= 20。 解题思路我们可以将整个二维网格建模为一幅图，0 表示一个节点(起始点 1 和终止点 2 也是节点)，如果两个 0 上下左右相邻，就表示它们之间有一条边。现在题目要求从起始点到达终止点，必须经过每一个节点，并且有且只能经过一次，这不就是哈密尔顿路径吗? 那么题目就是在要求这个图有多少条哈密尔顿路径。 import java.util.Arrays;import java.util.stream.Collectors;public class Solution &#123; // 状态压缩，题目给出节点数目小于等于 20 private int visited; // 起始点和终止点下标 private int[] start; private int[] end; // 网格的行数和列数 private int rows; private int columns; // 剩余未访问节点 private int left; // 网格 private int[][] grid; public int uniquePathsIII(int[][] grid) &#123; this.grid = grid; this.rows = grid.length; this.columns = grid[0].length; this.visited = 0; this.start = new int[2]; this.end = new int[2]; this.left = rows * columns; // 下面这个循环是为了找到起始点和终止点，并且更新 left for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (grid[row][column] == 1) &#123; start[0] = row; start[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == 2) &#123; end[0] = row; end[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == -1) &#123; // -1 不是节点，需要减掉 left--; &#125; &#125; &#125; return dfs(start); &#125; private int dfs(int[] v) &#123; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left--; if (left == 0 &amp;&amp; (v[0] == end[0] &amp;&amp; v[1] == end[1])) &#123; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left++; return 1; &#125; int res = 0; for (int[] w: adj(v[0], v[1])) &#123; if ((visited &amp; (1 &lt;&lt; (w[0] * columns + w[1]))) == 0 &amp;&amp; grid[w[0]][w[1]] != -1) &#123; res += dfs(w); &#125; &#125; // 回溯 left++; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); return res; &#125; private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125; public static void main(String[] args) &#123; int[][] grid = &#123;&#123;1,0,0,0&#125;,&#123;0,0,0,0&#125;,&#123;0,0,2,-1&#125;&#125;; Solution solution = new Solution(); int res = solution.uniquePathsIII(grid); System.out.println(res); &#125;&#125; 记忆化搜索考虑这么一幅图 我们将它分为两部分 我们称左边为第一部分，右边为第二部分。现在从节点 0 开始遍历，寻找有多少条哈密尔顿回路，我们发现不论是以何种方式遍历完第一部分来到第二部分，有多少条哈密尔顿路径只与第二部分有关，即这几种路径搜索多少条哈密尔顿路径的结果是一样的，无需重复遍历。 例如，我们以 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$ 的方式遍历完第一部分来到第二部分 它有多少条哈密尔顿路径只与第二部分有关，如果我们以 $0 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$ 的方式遍历完第一部分来到第二部分 它有多少条哈密尔顿路径的结果应该与以 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$ 顺序遍历的结果相同，如果我们可以缓存这个结果，就可以避免不必要的遍历，从而提高性能。 当遍历到节点 v 时，如果此时它们的 visited 是一样的，我们就可以认为它们会有一样的结果，例如对于上图，当遍历到节点 3 时，两条路径的遍历 visited 状态是一样的，我们可以认为它们的结果是一样的。 这种搜索策略叫做记忆化搜索，基于记忆化搜索的想法，我们改造上面的程序 import java.util.Arrays;import java.util.HashMap;import java.util.stream.Collectors;public class Solution &#123; private int visited; private int[] start; private int[] end; private int rows; private int columns; private int left; private int[][] grid; private HashMap&lt;String, Integer&gt; memo= new HashMap&lt;&gt;(); public int uniquePathsIII(int[][] grid) &#123; this.grid = grid; this.rows = grid.length; this.columns = grid[0].length; this.visited = 0; this.start = new int[2]; this.end = new int[2]; this.left = rows * columns; for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (grid[row][column] == 1) &#123; start[0] = row; start[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == 2) &#123; end[0] = row; end[1] = column; grid[row][column] = 0; &#125; else if (grid[row][column] == -1) &#123; left--; &#125; &#125; &#125; return dfs(start); &#125; private int dfs(int[] v) &#123; String strV = format(v); if (memo.containsKey(visited + strV)) &#123; return memo.get(visited + strV); &#125; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left--; if (left == 0 &amp;&amp; (v[0] == end[0] &amp;&amp; v[1] == end[1])) &#123; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); left++; memo.put(visited + strV, 1); return 1; &#125; int res = 0; for (int[] w: adj(v[0], v[1])) &#123; if ((visited &amp; (1 &lt;&lt; (w[0] * columns + w[1]))) == 0 &amp;&amp; grid[w[0]][w[1]] != -1) &#123; res += dfs(w); &#125; &#125; left++; visited = visited ^ (1 &lt;&lt; (v[0] * columns + v[1])); memo.put(visited+strV, res); return res; &#125; private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125; private String format(int[] v) &#123; int location = v[0] * columns + v[1]; int first = location / 10; int second = location % 10; return \"\" + first + second; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"ES6：扩展对象的功能性","date":"2021-01-24T03:28:00.000Z","path":"/ES6：扩展对象的功能性/","text":"Object 语法扩展属性简写当我们使用字面量声明一个对象时，经常会有下面的写法 let person = &#123; name: name, // 第一个 name 是键名，第二个 name 是一个变量 age: age&#125; 其中键的名字和值的名字都是相同的，name，age 写了两遍，在 ES6 中提供了简写语法，当键的名称与值对应变量名相同时，那么就可以简写，如上可以简写为 let person = &#123; name, age&#125; 方法简写在 ES5 中如下定义方法 let person = &#123; name: \"Alice\", sayHello: function() &#123; return \"Hello\"; &#125;&#125; 在 ES6 中提供了更加简洁的写法 let person = &#123; name: \"Alice\", sayHello() &#123; return \"Hello\"; &#125;&#125; 简写的方法与一般方法的不同在于，在简写方法中可以使用 super，而非简写方法不行。简写方法的 name 属性就是括号前的名称，例如上面 person.sayHello 的 name 属性是 sayHello。 计算属性名在 ES5 中是无法使用一个变量的值作为键名的，例如 let lastName = \"last name\"let person = &#123; \"first name\": \"Xiong\", lastName: \"Tao\"&#125;console.log(person[\"first name\"]); // Xiongconsole.log(person[\"last name\"]); // undefiendconsole.log(person[\"lastName\"]); // Tao 我们希望的是 person 对象有两个属性，分别是 first name last name 但是实际上的两个属性为 first name lastName 在 ES6 中可以通过方括号 [] 将变量括起来，使得变量的值成为对象的键 let lastName = \"last name\"let person = &#123; \"first name\": \"Xiong\", [lastName]: \"Tao\"&#125;console.log(person[\"first name\"]); // Xiongconsole.log(person[\"last name\"]); // Taoconsole.log(person[\"lastName\"]); // undefiend 新方法Object.is在比较两个值时，我们会使用 == 或者更加严格的 === ，更多的人乐意使用 ===，但是即使是 === 也会不准确，例如 +0 === -0 ：true NaN === Nan ：false Object.is 方法正是用来修补这一小的瑕疵的，它的作用与 == 和 === 一样也是用来比较两个值是否相同的 const print = console.log;print(5 == \"5\"); // trueprint(5 === \"5\"); // falseprint(Object.is(5, \"5\")); // false print(+0 == -0); // trueprint(+0 === -0); // trueprint(Object.is(+0, -0)); // falseprint(NaN === NaN); // falseprint(Object.is(NaN, NaN)); // true Object.is 与 === 的不同仅在于 +0，-0 以及 NaN 的比较。 Object.assign在实际的工作中，需要将其他对象的属性复制到另一个对象中，这个操作常称之为mixin function mixin(receiver, supplier) &#123; Object.keys(supplier).forEach(function(key) &#123; receiver[key] = supplier[key]; &#125;); return receiver; &#125; 在其他的库有相似的方法实现相同的功能，如 mix，extend 等等。ES6 引入了 Object.assign 方法，实现的功能与上述的相同，Object.assign 不能复制原型链上的属性以及不可枚举的属性。Object.assign 的语法如下 Object.assign(target, ...sources) 接收一个 target 对象，以及任意多个 source，将多个 source 中的属性复制到 target 当中，如果 target 中的属性与 sources 中某对象的属性相同，那么 target 中的属性的值将会被覆盖，如果多个 source 有相同的属性名，那么后面的 source 属性值会覆盖签名的属性值。 let target = &#123;&#125;let source1 = &#123; name: 'Alice', age: 2&#125;let source2 = &#123; name: 'Bob'&#125;Object.assign(target, source1, source2)print(target) // &#123; name: 'Bob', age: 2 &#125; Object.assign 进行的是浅拷贝，如果需要进行深拷贝，需要另求他法。在使用 Object.assign 进行复制的过程中，会触发 getter 和 setter 方法。 Object.assign 的更多细节，参考 MDN Object.assign() 重复字面属性在 ES6 之前，如果在定义对象时，有重复的属性名，那么会报错 let person = &#123; // 在 ES5 中会报错 name: 'Alice', name: 'Bob'&#125; 但是在 ES6 中不会，后面定义的属性值会覆盖之前定义的属性值 let person = &#123; name: 'Alice', name: 'Bob'&#125;print(person) // &#123; name: 'Bob' &#125; 自有属性遍历顺序在 ES5 中没有规定当遍历一个对象时应该以何种顺序来访问对象的属性，但是在 ES6 中规定了访问的顺序，这个影响了 Object.getOwnPropertyNames() 和 Reflect.ownKeys()，同样也影响了调用 Object.assign 进行复制时赋值的顺序。键的顺序如下： 按照升序排序的数字 按照添加顺序排序的字符串 按照添加顺序排序的 Symbol let obj = &#123; a: 1, 0: 1, 2: 1, c: 3, 1: 2, b: 4&#125;;obj.d = 1;console.log(Object.getOwnPropertyNames(obj).join(\" \")); // 0 1 2 a c b d for-in 循环没有具体的遍历顺序，因为不同的 JavaScript 引擎有不同的实现。Object.keys() 和 JSON.stringfy() 规定使用和 for-in 循环一样的遍历顺序。 Prototypes 的增强改变对象的原型在创建对象时，我们可以通过 Object.create 为对象指定一个原型 let person = &#123; sayHello() &#123; console.log(\"Hello\"); &#125;&#125;let friend = Object.create(person);friend.sayHello(); // Hello 可以通过 Object.getPrototypeOf() 获得对象的原型 console.log(Object.getPrototypeOf(friend) === person); // true 在 ES6 中新增了 Object.setPrototypeOf() 方法，可以改变一个对象的原型 let dog = &#123; sayHello() &#123; console.log(\"Woff\"); &#125;&#125;Object.setPrototypeOf(friend, dog);friend.sayHello(); // Woffconsole.log(Object.getPrototypeOf(friend) === dog); // true super如果对象重写了原型的方法，如何在对象中调用原型的同名方法，一般通过如下方式调用 let person = &#123; sayHello() &#123; return \"Hello\"; &#125;&#125;let dog = &#123; sayHello() &#123; return \"Woff\"; &#125;&#125;let friend = &#123; sayHello() &#123; return Object.getPrototypeOf(this).sayHello.call(this) + \", Man!\"; &#125;&#125;Object.setPrototypeOf(friend, person);console.log(friend.sayHello()); // Hello, Man!Object.setPrototypeOf(friend, dog);console.log(friend.sayHello()); // Woff, Man! 我们通过 Object.getPrototypeOf(this).sayHello.call(this) 来调用父类的某个方法，在 ES6 中引入了 super，super 指定原型对象，所以 friend 对象中的代码可以简化如下 let friend = &#123; sayHello() &#123; return super.sayHello.call(this) + \", Man!\"; &#125;&#125; super 只能在简写方法中使用，如下会发生语法错误 let friend = &#123; sayHello: function() &#123; // SyntaxError: 'super' keyword unexpected here return super.sayHello.call(this) + \", Man!\"; &#125;&#125;","tags":[{"name":"Object","slug":"Object","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Object/"},{"name":"对象","slug":"对象","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%AF%B9%E8%B1%A1/"}]},{"title":"桥和割点","date":"2021-01-23T16:00:00.000Z","path":"/桥和割点/","text":"桥定义我们首先看一下桥的概念 上面这幅图中，我们称节点 3-5 之间的这条边为桥，它具有什么特点呢? 一旦将这条边去掉，图的联通分量就会发生变化，所以有如下定义： 如果去掉某条边，使得图的联通分量发生变化，那么称这条边为桥。 桥可以看做是图中最脆弱的那条边，如果将交通系统建模为一个图的话，桥就是交通系统中最脆弱的部分，在军事中如果我们知道对方交通系统中的桥，那么我们就可以军事打击这个桥，使得对方的交通系统瘫痪。 寻找桥如何判断某条边是不是桥，对于下图来说， 0-1 这条边是桥吗? 答案不是，因为去掉 0-1 这条边联通分量的个数没有增加，原因是节点 1 可以通过另一条路径 1-&gt;3-&gt;2-&gt;0 到达 0，所以我们判断某条边是不是桥，就是判断边的两个节点是否有另外一条路径。考虑边 v-w，如果存在另外一条路径，使得节点 v 可以到达节点 w 或者是节点 w 之前的节点，我们就认为 v-w 不是桥，否则没有另外的路径使得节点 v 到达节点 w，我们就认为 v-w 是桥。 为了完成这个判断，我们需要定义两个变量来帮助我们保存信息，一个是 order[] 数组，它保存的是以 DFS 遍历图的顺序，例如 order[0] = 0，表示节点 0 是第 0 个遍历的，order[3] = 2 表示节点 3 是第 2 个遍历的 另一个需要记录的信息是当前节点通过另外一条路径(即不是父节点那条路径)能够达到的顺序最前的节点，使用数组 low 表示，假设节点 2 能够达到最前的节点 0，而 order[0] = 0，所以 low[2] = order[0] = 0，初始 low[i] = order[i]，更新 low 数组有两个时机 节点 v 访问已被遍历过的邻接节点 w 时(该邻接节点不为父节点)，如果 low[w] &lt; low[v]，则更新 low[v] = low[w] 当我们访问到节点 2 时，接着访问节点 2 的邻接节点，访问到节点 0，节点 0 不是它的父亲节点(上一个节点)，而且节点 0 已经被访问过，并且 low[0] &lt; low[2]，所以这个时候更新 low[2] = low[0]，表示节点 2 能通过另一条路径访问第 low[0] 个遍历的节点，即节点 2 能够访问到第 0 个被遍历的节点，即节点 0 访问完邻接节点 w，回到当前节点 v 时，如果邻接节点的 low[w] &lt; low[v]，则更新 low[v] = low[w] 当节点访问完节点 2 回到节点 3 时，此时 low[2] &lt; low[3]，更新 low[3] = low[2] = 0，表示 low[3] 可以从另外一条路径到达第 low[2] = 0 个被遍历的节点，即节点 0 引入了 order 与 low 数组，接着我们可以根据这两个数组判断某条边是不是桥了，当我们遍历完相邻节点 w，来到当前节点 v 时，除了要更新 low[v]，我们还需要对这条边是不是桥进行判断。 我们需要判断 low[w] 与 order[v] 的大小，以此判断是否是桥。首先明确一下二者表示的意义： low[w] 表示节点 w 能够通过另一条路径能够到达的最前顺序，例如 low[w] = 3 就表示 w 节点能通过另一条路径到达第 3 个被遍历的节点， order [v] 表示节点 v 是第几个被遍历的 如果 low[w] $\\leq$ order[v]，说明 w 能通过另一条路径到达节点 v 或 v 之前被遍历的节点，说明就不是桥，否则就是桥。 import java.util.ArrayList;import java.util.HashSet;public class FindEdge &#123; private int[] order; private int[] low; private Graph graph; private boolean[] visited; private int count = 0; // 存储桥 private ArrayList&lt;int[]&gt; result; public FindEdge(Graph graph) &#123; this.graph = graph; order = new int[graph.V()]; low = new int[graph.V()]; result = new ArrayList&lt;&gt;(); visited = new boolean[graph.V()]; for (int i = 0; i &lt; graph.V(); i++) &#123; if (!visited[i]) &#123; dfs(i, i); &#125; &#125; &#125; private void dfs(int v, int parent) &#123; visited[v] = true; low[v] = count; order[v] = count; count++; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, v); // 更新 low[v] 时机 1 low[v] = Math.min(low[v], low[w]); // 判断是否是桥 if (low[w] &gt; order[v]) &#123; result.add(new int[]&#123;v, w&#125;); &#125; &#125; else if (w != parent)&#123; // 更细 low[v] 时机 2 low[v] = Math.min(low[w], low[v]); &#125; &#125; &#125; public ArrayList&lt;int[]&gt; getResult() &#123; return result; &#125;&#125; 割点定义割点的定义与桥的定义类似，割点指的是一个节点，如果一旦移除这个节点，会导致图中的联通分量发生变化，那么就称这个节点为割点。 上图中节点 3 与节点 5 为割点，一旦去掉这两个节点之一，图的联通分量的个数就会发生变化。 寻找割点寻找割点的过程同寻找桥是一样的，也需要维护 order 与 low 两个数组，这两数组的含义也是同上一致的。low 数组的更新时机以及更新过程也是同上一致的。 现在的问题是我们在什么时候判断某节点是不是割点，以及条件是什么。我们在遍历完相邻节点 w，返回到当前节点 v 时，如果 low[w] $\\geq$ order[v] 时，就说明它是一个割点。这里的判断条件与桥的判断不同，桥的判断条件是如果 low[w] &gt; order[v] 时，就说明 v-w 这条边是桥，注意多了一个等于号。 low[w] $\\geq$ order[v] 表示节点 w 与 节点 v 之前被遍历的节点产生连接只能通过节点 v 例如节点 4 通过另外一条路径它最多到达节点 5，无法与节点 5 之前被遍历的节点产生连接。一旦节点 5 被删除，4 就无法访问到节点 0, 1, 2, 3，所以 5 就是割点。 但是添加了等于号之后，这个时候因为任何节点 low[v] $\\geq$ order[0]，所以根节点 0 会被认为是割点，但根节点不一定是割点，这个时候我们就需要对根节点分别讨论，判断根节点是不是割点很简单，如果通过 DFS 遍历，根节点有两个相邻节点就说明它是割点 import java.util.ArrayList;import java.util.HashSet;public class FindCutPoints &#123; private Graph graph; private boolean[] visited; private int[] order; private int[] low; private int count = 0; private HashSet&lt;Integer&gt; result = new HashSet&lt;&gt;(); public FindCutPoints(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; order = new int[graph.V()]; low = new int[graph.V()]; for (int i = 0; i &lt; graph.V(); i++) &#123; if (!visited[i]) &#123; dfs(i, i); &#125; &#125; &#125; private void dfs(int v, int parent) &#123; visited[v] = true; order[v] = count; low[v] = count; count++; int child = 0; for (int w: graph.adj(v)) &#123; child++; if (!visited[w]) &#123; dfs(w, v); low[v] = Math.min(low[v], low[w]); if (v != parent &amp;&amp; low[w] &gt;= order[v]) &#123; result.add(v); &#125; if (v == parent &amp;&amp; child &gt; 1) &#123; result.add(v); &#125; &#125; else if (w != parent) &#123; low[v] = Math.min(low[v], low[w]); &#125; &#125; &#125; public HashSet&lt;Integer&gt; getResult() &#123; return result; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"图论建模","date":"2021-01-22T16:00:00.000Z","path":"/图论建模/","text":"现实中有很多的问题可以建模为图论问题，然后使用 DFS 与 BFS 算法轻松的解决，现在我们打算从 LeetCode 选择几道题，来了解如何将现实问题建模为图论问题。 二分图检测题目介绍给定一个无向图graph，当这个图为二分图时返回true。如果我们能将一个图的节点集合分割成两个独立的子集 A 和 B，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，我们就将这个图称为二分图。 graph 将会以邻接表方式给出，graph[i] 表示图中与节点 i 相连的所有节点。每个节点都是一个在 0 到graph.length-1 之间的整数。这图中没有自环和平行边： graph[i] 中不存在 i，并且 graph[i] 中没有重复的值。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果 j 在 graph[i] 里边, 那么 i 也会在 graph[j] 里边。 解题思路这道题的解法是对图中的节点染色，我们使用 DFS 遍历该图，如果当前节点的颜色为红色，那么就将它未访问过的相邻的节点染为绿色，如果当前节点颜色为绿色，就将未访问过的相邻节点染为红色，根据颜色来区分两个集合。 因为一条边连接的两个节点属于两个不同的几个集合，所以一条边连接的两个节点的颜色是不同的，如果我们在遍历的过程中发现已被访问过的相邻的节点的颜色与当前节点的颜色相同，说明它不符合二分图的定义，不是一个二分图；如果遍历图中所有的联通分量，都没有产生矛盾，说明这个图就是一个二分图。 class Solution &#123; private boolean[] visited; // true 表示红色，false 表示绿色，默认为绿色 private boolean[] colors; public boolean isBipartite(int[][] graph) &#123; visited = new boolean[graph.length]; colors = new boolean[graph.length]; // 遍历所有的联通分量 for (int i = 0; i &lt; graph.length; i++) &#123; if (!visited[i]) &#123; if (!dfs(i, graph)) &#123; return false; &#125; &#125; &#125; return true; &#125; // dfs 返回一个布尔值，用以当不为二分图时提前终止遍历 private boolean dfs(int v, int[][] graph) &#123; visited[v] = true; for (int w: graph[v]) &#123; // 如果未访问过，染为相反的颜色 if (!visited[w]) &#123; colors[w] = !colors[v]; // 继续遍历 if (!dfs(w, graph)) return false; // 如果已放访问过，且相邻节点颜色相同，不是二分图 &#125; else if (visited[w] &amp;&amp; colors[w] == colors[v]) &#123; return false; &#125; &#125; // 未发现矛盾，为二分图 return true; &#125;&#125; 岛屿的最大面积题目介绍给定一个包含了一些 0 和 1 的非空二维数组 grid 。一个岛屿是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0 (代表水) 包围着。 找到给定的二维数组中最大的岛屿面积(如果没有岛屿，则返回面积为 0 )。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路我们将这个矩阵看做是一个图，矩阵中所有的 1 就是一个个的节点，如果两个 1 是垂直或者水平相邻的，那么就可以认为它们被一条边连着，即在一个联通分量中，而我们的任务就是找出包含节点最多的联通分量，并返回节点数目。 import java.util.Arrays;import java.util.stream.Collectors;public class Solution &#123; private int rows; private int columns; private boolean[][] visited; private int[][] grid; public int maxAreaOfIsland(int[][] grid) &#123; // 因为题目没说 grid 不为空，所以下面是对 grid 的一些校验 if (grid == null) &#123; return 0; &#125; this.rows = grid.length; if (rows == 0) &#123; return 0; &#125; this.columns = grid[0].length; if (columns == 0) &#123; return 0; &#125; this.grid = grid; this.visited = new boolean[rows][columns]; // 最大岛屿数目 int max = 0; for (int row = 0; row &lt; rows; row++) &#123; for (int column = 0; column &lt; columns; column++) &#123; if (!visited[row][column] &amp;&amp; grid[row][column] == 1) &#123; // dfs 返回的所在联通分量的节点数目 max = Math.max(max, dfs(row, column)); &#125; &#125; &#125; return max; &#125; // 表示以 [row, column] 为起点进行 DFS 遍历所在联通分量包含的节点数目 private int dfs(int row,int column) &#123; int count = 1; visited[row][column] = true; for (int[] w: adj(row, column)) &#123; int nextRow = w[0]; int nextColumn = w[1]; if (grid[nextRow][nextColumn] == 0) &#123; continue; &#125; if (!visited[nextRow][nextColumn]) &#123; count += dfs(nextRow, nextColumn); &#125; &#125; return count; &#125; // 获得当前节点四个方向上的相邻节点 private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125;&#125; 二进制矩阵中的最短路径题目介绍在一个 $N \\times N$ 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。现在我们的目标是从 $(0, 0)$ 到达 $(N-1, N-1)$，即从左上角到达右下角，而我们的目标是寻找一条最短路径，并且返回这条路径的长度。如果无法从左上角达到右下角，则返回 -1。 每个单元格有 8 种可能的方向 下面给出一个示例 解题思路我们将方格看做是一个图，方格中所有的 0 看做是图一个节点，如果两个 0 在各自的 8 个方向之中，就说明这两个节点之间有一条边。为了求得最短路径，我们需要从左上角这个节点进行 BFS，使用 dis[i][j] 记录 $(i, j)$ 距离 $(0, 0)$ 的距离，所以 $dis[N-1][N-1]$ 也就表示从左上角到达右下角的最短路径。 import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;import java.util.stream.Collectors;class Solution &#123; private boolean[][] visited; private int[][] dis; private int rows; private int columns; public int shortestPathBinaryMatrix(int[][] grid) &#123; this.rows = grid.length; this.columns = grid[0].length; if (grid[0][0] == 1 || grid[rows - 1][columns - 1] == 1) &#123; return -1; &#125; if (rows == 1 &amp;&amp; grid[rows][columns] == 0) &#123; return 1; &#125; dis = new int[rows][columns]; visited = new boolean[rows][columns]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;0, 0&#125;); visited[0][0] = true; dis[0][0] = 1; while (!queue.isEmpty()) &#123; int[] location = queue.remove(); int row = location[0]; int column = location[1]; for (int[] nextLocation: adj(row, column)) &#123; int nextRow = nextLocation[0]; int nextColumn = nextLocation[1]; if (!visited[nextRow][nextColumn] &amp;&amp; grid[nextRow][nextColumn] == 0) &#123; queue.add(new int[]&#123;nextRow, nextColumn&#125;); visited[nextRow][nextColumn] = true; dis[nextRow][nextColumn] = dis[row][column] + 1; if (nextRow == rows - 1 &amp;&amp; nextColumn == columns - 1) &#123; return dis[nextRow][nextColumn]; &#125; &#125; &#125; &#125; return -1; &#125; private Iterable&lt;int[]&gt; adj(int row, int column) &#123; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;-1, -1&#125;&#125;; return Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .collect(Collectors.toList()); &#125;&#125; 打开转盘锁题目介绍你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 解题思路我们把密码锁的一种组合称之为一种状态，例如 0000 这个组合表示的就是一种状态，现在我们的模板是将 0000 这种状态转变到 target 表示的状态，并且要求步骤最少。 我们可以把一种状态建模为图中的顶点，如果一个状态能够转变为另一种状态，我们就说这两个状态表示的节点之间存在一条边。对于密码锁来说，每一个拨轮可以前后滚动，共有四个拨轮，这意味着一个状态最多与 8 个状态相邻(考虑到 deadends，少于 8 个)，所以我们只要从 0000 这个状态开始 BFS 遍历，即可找到最少到 target 的拨动次数。 import java.util.*;import java.util.stream.Collectors;class Solution &#123; public int openLock(String[] deadends, String target) &#123; if (\"0000\".equals(target)) &#123; return 0; &#125; HashSet&lt;String&gt; deadSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; deadends.length; i++) &#123; deadSet.add(deadends[i]); &#125; if (deadSet.contains(\"0000\"))&#123; return -1; &#125; HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); HashMap&lt;String, Integer&gt; dis = new HashMap&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList(); queue.add(\"0000\"); visited.add(\"0000\"); dis.put(\"0000\", 0); while (!queue.isEmpty()) &#123; String state = queue.remove(); for (String nextState: adj(state, deadSet)) &#123; if (!visited.contains(nextState)) &#123; queue.add(nextState); visited.add(nextState); dis.put(nextState, dis.get(state) + 1); if (target.equals(nextState)) &#123; return dis.get(nextState); &#125; &#125; &#125; &#125; return -1; &#125; private Iterable&lt;String&gt; adj(String state, HashSet&lt;String&gt; deadSet) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 4; i++) &#123; char[] chars = state.toCharArray(); char s = chars[i]; chars[i] = Character.forDigit((chars[i] - '0' + 1) % 10, 10); list.add(new String(chars)); chars[i] = s; chars[i] = Character.forDigit((chars[i] - '0' - 1 + 10) % 10, 10); list.add(new String(chars)); &#125; return list.stream().filter(s -&gt; !deadSet.contains(s)).collect(Collectors.toList()); &#125;&#125; 倒水智力题有两个桶，一个能装 5 升水，一个能装 3 升水，如何得到 4 升水? 这道题还是将状态看做是一个图的节点，如果状态之间能够互相转变，就说状态之前有一条边。我们定义状态 &lt;x,y&gt; 表示第一个桶有 x 升水，第二个桶有 y 升水。那么 &lt;x, y&gt; 与哪些状态是相连的呢，分为六种情况： 倒空第一桶水：&lt;x, y&gt; =&gt; &lt;0, y&gt; 倒空第二桶水：&lt;x, y&gt; =&gt; &lt;x, 0&gt; 加满第一桶水：&lt;x, y&gt; =&gt; &lt;5, y&gt; 加满第二桶水：&lt;x, y&gt; =&gt; &lt;x, 3&gt; 第二桶水倒入第一桶水： $x + y \\geq 5$：&lt;x, y&gt; =&gt; &lt;5, x + y - 5&gt; $x + y &lt; 5$：&lt;x, y&gt; =&gt; &lt;x + y, 0&gt; 第一桶水倒入第二桶水： $x + y \\geq 3$：&lt;x, y&gt; =&gt; &lt;x + y - 3, 3&gt; $x + y &lt; 3$：&lt;x, y&gt; =&gt; &lt;0, x + y&gt; 我们使用一个两位数表示一个状态，十位数表示第一个桶中有多少升水，个位数表示第二个桶中有多少升水，例如 23 表示第一个桶中有 2 升水，第二个桶中有 3 升水。 import java.util.*;public class WaterPuzzle &#123; public Iterable&lt;Integer&gt; waterPuzzle() &#123; HashSet&lt;Integer&gt; visited = new HashSet&lt;&gt;(); HashMap&lt;Integer, Integer&gt; pre = new HashMap&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(0); visited.add(0); pre.put(0, 0); // 保存最后找到的结果 int endState = 0; // 用以跳出 while 循环 boolean flag = false; while (!queue.isEmpty()) &#123; int state = queue.remove(); for (int nextState: adj(state)) &#123; if (!visited.contains(nextState)) &#123; visited.add(nextState); queue.add(nextState); pre.put(nextState, state); if (nextState / 10 == 4 || nextState % 10 == 4) &#123; endState = nextState; flag = true; break; &#125; &#125; &#125; if (flag) &#123; break; &#125; &#125; ArrayList&lt;Integer&gt; result = new ArrayList(); int cur = endState; result.add(cur); while (pre.get(cur) != 0) &#123; cur = pre.get(cur); result.add(cur); &#125; Collections.reverse(result); return result; &#125; private Iterable&lt;Integer&gt; adj(int state) &#123; int first = state / 10; int second = state % 10; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(second); set.add(first*10); set.add(5*10 + second); set.add(first * 10 + 3); if (first + second &gt;= 5) &#123; set.add(5 * 10 + (first + second) - 5); &#125; else &#123; set.add((first + second) * 10); &#125; if (first + second &gt;= 3) &#123; set.add((first + second - 3) * 10 + 3); &#125; else &#123; set.add(first + second); &#125; return new ArrayList&lt;&gt;(set); &#125; public static void main(String[] args) &#123; WaterPuzzle waterPuzzle = new WaterPuzzle(); for (int r: waterPuzzle.waterPuzzle()) &#123; // 在个位数前加上0 System.out.print((r &gt;= 10 ? r : \"0\" + r) + \" \"); &#125; &#125;&#125; 输出为 50 23 20 02 52 43 滑动谜题题目介绍在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示。一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换。最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。 给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。 解题思路我们将谜板上的一个组合看做是一个状态，一个状态就是图上的一个节点，如果一个状态能够转变到另一个状态，我们就说这两个状态节点之间有一条边连接。我们使用字符串来表示一个状态，例如 [[1, 4, 5], [0, 2, 3]] 这个状态表示为 &quot;145023&quot;，现在我们的目标是寻找一条从初始状态到 &quot;123450&quot; 这个状态的最短路径，使用 BFS 算法即可 import java.util.*;import java.util.stream.Collectors;public class Solution &#123; private HashMap&lt;String, Integer&gt; visited = new HashMap&lt;&gt;(); private int rows; private int columns; public int slidingPuzzle(int[][] board) &#123; this.rows = board.length; this.columns = board[0].length; String initState = boardToString(board); if (initState.equals(\"123450\")) &#123; return 0; &#125; Queue&lt;String&gt; queue = new LinkedList(); queue.add(initState); visited.put(initState, 0); while (!queue.isEmpty()) &#123; String state = queue.remove(); for (String nextState: adj(state)) &#123; if (!visited.containsKey(nextState)) &#123; queue.add(nextState); visited.put(nextState, visited.get(state) + 1); if (\"123450\".equals(nextState)) &#123; return visited.get(nextState); &#125; &#125; &#125; &#125; return -1; &#125; private String boardToString(int[][] board) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; stringBuilder.append(board[i][j]); &#125; &#125; return stringBuilder.toString(); &#125; private Iterable&lt;String&gt; adj(String state) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); char[] chars = state.toCharArray(); int index = state.indexOf(\"0\"); int row = index / columns; int column = index % columns; int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; List&lt;Integer&gt; locations = Arrays.stream(dirs) .map(dir -&gt; new int[]&#123;dir[0] + row, dir[1] + column&#125;) .filter(item -&gt; item[0] &lt; rows &amp;&amp; item[0] &gt;= 0 &amp;&amp; item[1] &lt; columns &amp;&amp; item[1] &gt;= 0) .map(item -&gt; item[0] * columns + item[1]) .collect(Collectors.toList()); for (int i: locations) &#123; String res = swap(chars, index, i); result.add(res); swap(chars, i, index); &#125; return result; &#125; private String swap(char[] chars, int i, int j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; return new String(chars); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"ES6：函数","date":"2021-01-18T09:20:00.000Z","path":"/ES6：函数/","text":"默认参数如果在调用函数时没有传入参数时，我们希望使用默认值，ES5 的写法如下 function getValue(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function(data) &#123; console.log(data); &#125; // 其他处理逻辑&#125; 但是上面的代码有问题，如果 timeout 传入的是 0，那么 timeout 还是会使用默认值，因为 0 对应的 boolean 为 false，所以代码会修改如下 function getValue(url, timeout, callback) &#123; timeout = (typeof timeout !== 'undefined') ? timeout : 2000; callback = (typeof callback !== 'undefined') ? callback : function(data) &#123; console.log(data); &#125; // 其他处理逻辑&#125; 现在我们可以在 ES6 通过简单的写法实现上面的效果 function getValue(url, timeout = 2000, callback = function(data) &#123;console.log(data)&#125;) &#123; // 其他处理逻辑&#125; 上面的 timeout 和 callback 参数我们称之为默认参数，当调用函数没有传入参数，或者传入的参数为 undefiend 时，就是使用指定的默认参数。 arguments 对象每一个函数中都会有一个 arguments 对象，其中保存的是传入的参数值。arguments 对象在严格和非严格模式下的行为是不同的。 在非严格模式下，arguments 会受到命名参数的影响，即在函数内对命名参数进行修改，也会相应的对 arguments 对象产生修改 function getName(first, second) &#123; console.log(first === arguments[0]); // true console.log(second === arguments[1]); // true first = 'a'; second = 'b'; console.log(first === arguments[0]); // true console.log(second === arguments[1]); // true&#125; 在严格模式下，对命名参数的修改不会影响 arguments 对象 function getName(first, second = \"hello\") &#123; \"use strict\" console.log(first === arguments[0]); // true console.log(second === arguments[1]); // true first = 'a'; second = 'b'; console.log(first === arguments[0]); // false console.log(second === arguments[1]); // false&#125; 对于默认参数，无论是在严格模式还是在非严格模式下，对命名参数的修改都不会影响 arguments 对象 function getName(first, second = \"hello\") &#123; console.log(first === arguments[0]); // true console.log(second === arguments[1]); // false first = 'a'; second = 'b'; console.log(first === arguments[0]); // false console.log(second === arguments[1]); // false&#125;getName(\"Hello\") 因为只传入了一个参数值，所以 arguments[0] === first，而 arguments[1] === undefiend ，所以 second 的值与 arguments[1] 不相等。 表达式默认参数的取值除了原始值以外，还可以是一个表达式，例如 function getValue() &#123; return 5;&#125;function add(first, second = getValue()) &#123; return first + second;&#125;add(1, 1); // 2add(1); // 6 甚至你可以将前面的参数作为后面参数的默认值 function add(first, second = first) &#123; return first + second;&#125;add(1, 2); // 3add(2); // 4 TDZ(暂时性死区)所谓的临时死区是指在变量声明之前，不能够访问该变量 function add(first = second, second) &#123; return first + second;&#125;add(undefined, 2); // ReferenceError: Cannot access 'second' before initialization 上面我们设置 first 的默认值为 second，当我们为 first 传入 udefiend 时会使用默认值，但是此时 second 并未初始化，所以这时访问 second 会发生错误。 匿名参数当我们调用 JavaScript 的函数时，传入的参数个数可以与定义函数时要求的函数个数不同，可多可少。所以传入的参数都会保存在 arguments 对象中，无论是在函数签名中已经定义了的参数(命名参数)还是未定义的参数(匿名参数) function print(arg) &#123; for(let i = 0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125;print(\"a\", \"b\", \"c\"); // a // b // c 在 ES6 中引入了剩余参数(Rest Parameters)，剩余参数中只保留匿名参数的值 function print(arg, ...values) &#123; for(let i = 0; i &lt; values.length; i++) &#123; console.log(values[i]); &#125;&#125;print(\"a\", \"b\", \"c\"); // b // c, 在上面对函数进行了一点修改，在参数列表中添加了一项 ...values ,values 表示的就是剩余参数，如果调用函数时多传入了参数，那么多余的参数就会放入 values 这个数组中。 剩余参数与 arguments 参数的不同： 剩余参数是一个真正的数组，而 arguments 是一个类数组 剩余参数中只保存了匿名参数的值，而 arguments则保存了所有传入的值 使用剩余参数有两点限制： 一个函数中只能有一个剩余参数，且剩余参数必须放置在参数列表的最后 剩余参数不能用于对象的 setter 方法中 let obj = &#123; // SyntaxError: Setter function argument must not be a rest parameter set name(...values) &#123; // do something &#125;&#125; 这是因为 setter 方法被限制为只能有一个参数，但是剩余参数理论上表示的是可以接受无穷多的参数。 无论在函数的参数列表中是否定义了剩余参数，都对 arguments 对象没有影响，它始终保存着传入函数的所有参数。 Function 增强Function 构造函数一般是用来生成函数实例的，但是我们很少用到它来声明一个函数 let add = new Function(\"first\", \"second\", \"return first + second\");console.log(add(1, 2)); // 3 在 ES6 中对 Function 构造函数进行了增强，使它能够使用默认参数和剩余参数 let add= new Function(\"first\", \"second = first\", \"return first + second\");console.log(add(2)); // 4 let print = new Function(\"...values\", \"console.log(values[0])\");print(1, 2, 3); // 1 展开运算符与剩余参数密切相关就是展开运算符，剩余参数是将多个独立的参数合并为一个数组，而展开运算符则相反，向一个数组展开为一个个独立的参数。考虑 Math.max 方法，它接收一个个独立的参数 Math.max(3, 5); 当参数的个数比较少时可以还算容易使用，当需要比较的参数较多时，一般我们会将参数放置在一个数组中然后传入，但是Math.max 不接收数组，它只接收一个个独立的参数 Math.max([1, 3, 5, 4]); // ×Math.max(1, 3, 5, 4); // √ 这个时候我们通过会借助于 apply 方法，因为 apply 方法是将方法的参数合并为数组传入的 Math,max.apply(Math, [1, 3, 5, 4]); 在 ES6 中提供了展开运算符，可以直接将数组展开为一个个的独立参数进行传入 Math.max(...[1, 3, 5, 4]) name 属性 由于有多种方式创建函数，所以识别一个函数很难 匿名函数的盛行，使得调试十分困难，无法跟踪堆栈信息 出于如上原因，ES6 为所有的函数都添加了一个 name 属性。 function doSomething() &#123; // empty&#125;const doOtherThing = function() &#123; // empty&#125;const anotherThing = doOtherThing;console.log(doSomething.name); // doSomethingconsole.log(doOtherThing.name); // doOtherThingconsole.log(anotherThing.name); // doOtherThing 函数 doSomething 的 name 属性为 doSomething，因为它的函数签名为 doSomething；匿名函数 doOtherThing 的 name 属性为 doOtherThing，因为它被赋予的变量名为 doOtherThing。anotherThing 的 name 属性还是为 doOtherThing，说明匿名函数的 name 属性并不会更改。 下面看几个特例： let doSomething= function doSomethingElse() &#123; // empty&#125;console.log(doSomething.name); // doSomethingElse let doSomething = function() &#123; // empty&#125;console.log(doSomething.bind().name); // bound doSomething console.log((new Function()).name); // anonymous 函数的多重角色函数可以通过 new 调用，也可以不通过 new 调用。JavaScript 的函数含有两个内部可见的方法，[[Call]] 和 [[Construct]]。 当一个函数通过 new 调用时，[[Construct]] 方法就会被调用，该方法是用来创建一个新对象的，称之为实例，通过函数体内部的 this 来设置实例。拥有 [[Construct]] 方法的函数叫做构造器，并不是所有的函数都有[[Construct]] 方法，例如后面提及的箭头函数就没有。 当函数不是通过 new 调用时，就是调用函数内部的 [[Call]] 方法，它会执行函数的方法体。 那么如何分辨函数以何种方式调用呢? 在 ES5 中，常常通过 instance 来判别 function Person(name) &#123; if(this instanceof Person) &#123; this.name = name; &#125; else &#123; throw new Error(\"You must use new with Person\"); &#125;&#125;let person = new Person(\"Alice\");let notAPerson = Person(\"Bob\"); // Error: You must use new with Person 上面的方法能够有效是因为 [[Construct]] 方法会创建一个 Person 的实例，并将它赋值给 this。但是这个方法并不可靠，因为不使用 new 也可以得到 Person 的实例 function Person(name) &#123; if(this instanceof Person) &#123; this.name = name; &#125; else &#123; throw new Error(\"You must use new with Person\"); &#125;&#125;let person = new Person(\"Alice\");let notAPerson = Person.call(person, \"Bob\"); // 没有报错 在 ES6 中提出了更好的解决办法，那就是 new.target，如果一个函数的 [[Construct]] 方法被调用，new.target 的值就会被赋值为新创建的对象，如果 [[Call]] 被调用，那么 new.target 的值就是 undefiend。所以通过 new.target 可以方便的知道是通过何种方式调用的函数 function Person(name) &#123; if (new.target !== undefined)&#123; this.name = name; &#125; else &#123; throw new Error(\"You must use new with Person\"); &#125;&#125;let person = new Person(\"Alice\");let notAPerson = Person.call(person, \"Bob\"); // Error: You must use new with Person 在函数的外部不能使用 new.target， 否则会报语法错误。 Block-Level Functions在 ES3 或者更早以前，是不能在块级作用域中定义函数的，但是所有的浏览器都支持这一行为，于是在 ES5 中，为了修复这不兼容的行为，规定在严格模式下载块级作用域中声明函数将会导致错误 \"use strict\"if (condition) &#123; // 在 ES5 中会导致错误 function doSomething() &#123; // empty &#125;&#125; 但是上面的行为在 ES6 中却是可以的，在 ES6 的严格模式下，函数的作用域只在块级作用域中，在块级作用域以外不能访问该函数 \"use strict\"console.log(typeof doSomething); // undefinedif (true) &#123; console.log(typeof doSomething); // function function doSomething() &#123; // empty &#125; console.log(typeof doSomething); // function&#125;console.log(typeof doSomething); // undefiend 因为对于函数的声明会被提升到作用域的最前方，所以第二个 typeof doSomething 的结果是function。 上面的行为都是在严格模式下发生的，那么在非严格模式下，函数的声明没有块级作用域的概念，所以函数的声明是在全局作用域中，即在块级作用域之外也可以访问到函数。 箭头函数语法箭头函数是 ES6 中的新语法，正如名字所暗示的一样，是使用箭头来声明函数的，例如 let add = (x, y) =&gt; &#123; return x + y;&#125;add(1, 2); // 3 上面的函数等价于(当然不是完全等价，具体的区别后文详述) let add= function(x, y) &#123; return x + y;&#125; 箭头函数由三部分组成 参数列表：使用括号将参数括起，参数之间使用逗号分隔 (x, y) (x, y = x) 箭头：⇒ 函数体：使用花括号括起 如果参数列表只有一个参数的话，那么可以参数列表不写括号 (x) =&gt; &#123; return x;&#125;// 等价于x =&gt; &#123; return x;&#125; 如果函数体中只有一条语句的话，那么也可以省略花括号 x =&gt; return x; 进一步，如果这一条语句直接返回一个值的话，return 也可以省略，它会计算这条语句，然后将值返回 x =&gt; x; 如果是直接返回一个字面量对象的话，需要使用括号括起 () =&gt; (&#123;x: 1, y: 2&#125;);// 等价于function() &#123; return &#123; x: 1, y: 2 &#125;&#125; 无 this 绑定在 JavaScript 中，每一个函数都会默认的传入一个 this 参数，它的取值取决于调用方式，而不是所处的位置 function Person(name) &#123; this.name = name; this.getName = function() &#123; return this.name; &#125;&#125;let person = new Person(\"Alice\");console.log(person.getName()); // Aliceconsole.log(person.getName.call(global)); // undefiend 不同的调用方式，函数内部 this 的取值也不同，所以很容易就写出错误的代码。但是箭头函数内部没有 this 绑定，这意味着它会在它的作用域链中去寻找 this function Person(name) &#123; this.name = name; this.getName = () =&gt; &#123; return this.name; &#125;&#125;let person = new Person(\"Alice\");console.log(person.getName()); // Aliceconsole.log(person.getName.call(global)); // Alice 上面修改 getName 为箭头函数，因为箭头函数的内部没有 this 绑定，所以它会向它的作用域链中寻找 this，即它使用的是它父级作用域的 this，这意味着箭头函数内部的 this 与调用方式无关，与它所在的位置有关，这样可以获得预期的结果，减少出 bug 的几率。 无 arguments 绑定同 this 一样，每个函数内部都会自动传入一个 arguments 对象，但是箭头函数内部并没有 arguments 对象，所以想取得箭头函数传入的参数，就得使用剩余参数 (function() &#123; let add = (...values) =&gt; &#123; console.log(arguments); // [Arguments] &#123;&#125; console.log(values); // [ 1, 2, 3 ] let sum = 0; for (let i = 0; i &lt; values.length; i++) &#123; sum += values[i]; &#125; return sum; &#125; console.log(add(1, 2, 3)); // 6&#125;)(); 箭头函数与一般函数的不同： 函数内部没有 this，arguments，new.target 绑定 不能通过 new 的方式被调用，上文提及过，箭头函数内部没有 [[Construct]] 方法 没有 prototype 尽管箭头函数与一般函数有所不同，但是通过 typeof 以及 instanceof 方法鉴别的行为与一般函数相同 let add = (x, y) =&gt; x + y;console.log(typeof add); // functionconsole.log(add instanceof Function); // true 箭头函数也可以调用call，apply，bind 方法，但是箭头函数内部的 this 取值并不会受到影响。 尾调用优化什么叫尾调用? 尾调用指的是函数的最后一条语句是调用一个函数，例如 function doSomething() &#123; return doSomethingElse();&#125; 我们知道每次调用函数时，都会创建一个栈帧放置到函数栈中，当函数调用较多时，特别是递归调用，可能会使得栈中的栈帧越来越多，当超过栈帧允许的最大数量时，就会报错 function doSomething()&#123; doSomething();&#125;doSomething(); // RangeError: Maximum call stack size exceeded 那么所谓的尾调用优化指的是，当函数的最后一条语句是返回另一个函数的调用时，那么调用的函数会复用当前栈帧，而不会创建一个新的栈帧，这样栈中的栈帧的数量就不会增加，也就不会出现超过栈帧允许的最大数量。 要实现尾调用优化，被调用函数要满足以下特点： 尾调用没有访问当前栈帧中的变量 尾调用是最后一条语句 尾调用的返回值作为函数的返回值 function doSomething()&#123; // 无法优化，没有 return doSomething();&#125; function doSomething() &#123; // 无法优化，尾调用不是最后一条语句，先进行函数调用，然后进行加法 return 1 + doSomething();&#125; function doSomething() &#123; let num = 1, func = () =&gt; num; // 无法优化，访问了当前栈帧中的变量 return func();&#125; 下面我们看一个求阶乘的例子 function factorial(n) &#123; if (n &lt; 0) &#123; throw new Error(\"参数错误\"); &#125; if (n &lt;= 1) &#123; return 1; &#125; return n * factorial(n - 1);&#125; 上面的函数无法进行尾优化，因为最后一条语句不是尾调用。现在我们换一种思路，将上面的函数转化为可以进行尾调用优化的函数 function factorial(n, result = 1) &#123; if (n &lt; 0) &#123; throw new Error(\"参数错误\"); &#125; if (n &lt;= 1) &#123; return result; &#125; result = result * n; return factorial(n - 1, result);&#125;","tags":[{"name":"默认参数","slug":"默认参数","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"ES6：字符串和正则表达式","date":"2021-01-15T09:39:00.000Z","path":"/ES6：字符串和正则表达式/","text":"首先推荐两篇文章了解字符编码相关细节 Unicode与JavaScript详解 Javascript中的string类型使用UTF-16编码 Unicode、UTF-8 与 UTF-16在开发的过程中，经常会碰到 Unicode，UTF-8，UTF-16 等等术语，在很多的时候我一直是将它们混为一谈的，不过今天详细的了解了它们之间的不同，作为本章的前言，方便本章内容的理解。 首先 Unicode 表示的是字符集，而 UTF-8，UTF-16 表示的是字符编码。所谓的字符集指的就是字符的集合，Unicode 字符集几乎包含了世界上所有国家的字符，所以 Unicode 又被称为是万国码，如果使用 Unicode 字符集的话，那么可以表示几乎所有国家中的字符(ASCII字符集只包含了英文，而 GBK 字符集包含中日韩等几个国家的字符以及英文字符)。对于每一个字符，Unicode 都为它们对应了一个码点(Code Point)，码点从 0 开始计算，例如 \\u0000 表示的就是 null，表示空的意思。 UFT-8，UTF-16 则是将 Unicode 字符集中包含的字符编码为数字存储在计算机中，UTF-8 和 UTF-16 分别对应不同的编码规则。这里详细介绍一下 UTF-16，因为 JavaScript 的编码与之相关。 所谓的 UTF-16 指的是使用 16 位即 2 个字节去表示一个字符，不过随着 Unicode 中包含的字符越来越多，使用 2 个字节已经无法表示 Unicode 中所有的字符，所以实际上 UTF-16 使用 2 个字节或者 4 个字节来表示 Unicode 中的字符，那什么时候用 2 个字节表示，什么时候使用 4 个字节表示? 为了解决这个问题，UTF-16 将字符分为了两部分 基本平面：由前 $65536(2^{16})$ 个字符组成，即 \\u0000-\\uFFFF 辅助平面：剩余其它字符组成 对于位于基本平面中的字符使用 2 个字节表示，而对于辅助平面中的字符使用 4 个字节表示。 那 UTF-16 是怎么解码的呢? 如果在解码时发现某 2 个字节表示的数在 \\uD800-\\uDFFF 之间，则说明这是一个使用 4 个字节表示的字符，如果不在 \\uD800-\\uDFFF 之间，则说明是基本平面的字符。 但是 JavaScript 并不是使用 UTF-16 进行编码的，而是使用 UCS-2 进行编码的！！！UCS-2 由于发明的比较早，当时 Unicode 中的字符使用 2 个字节即可表示，所以 UCS-2 对于任意的字符都是使用 2 个字节进行编码的。所以在 JavaScript 中有个 bug 就是它不认 4 个字节表示的字符！！！ 上面的那段是我从网上看到，然后总结的，但是我有一个疑问，既然 UCS-2 对任意字符都使用 2 个字节进行编码，这不就意味着有的字符无法被编码，而且也不会有 4 个字节表示的字符，我觉得应该是使用 UTF-16 进行编码，但是使用的是 UCS-2 进行解码(仅仅是我的猜测)。 为什么 JavaScript 不使用 UTF-16 进行编码? 因为在 JavaScript 发明的时候，只有 UCS-2 该种编码被提出来了，UTF-16 还没有被提出来。 let text = '𠮷'console.log(text.length) // 2console.log(/^.$/.test(text)) // falseconsole.log(text.charCodeAt(0)) // 55362console.log(text.charCodeAt(1)) // 57271 上面的字符串 ‘𠮷’ 明明是一个字符，但是 length 属性却显示有两个字符，这是因为 ‘𠮷’ 是辅助平面上的字符，具有 4 个字节，而 JavaScript 并不认识 4 个字节的字符，会将其解释为两个 2 字节的字符，所以这就是 length 属性为 2 的原因。 并且在使用正则表达式时也有 bug，/^.$/ 表示任意只有一个字符的字符串，按照常理来说，/^.$/.test(text) 测试的结果应该是true，但是最后的结果显示是 false。 charCodeAt 方法可以获得 Unicode 的 Code Ponit，但是很明显它不能得到 4 字节的 Unicode 字符的 Code Point，只是将这个 4 字节的字符作为两个 2 字节的字符，得到两个 Code Point。 更好的 Uniode 支持codePointAt()上面的 charCodeAt()方法无法得到 4 字节字符的 Code Point，而 ES6 提供了 codePointAt() 方法，通过该方法可以得到 4 字节字符的 Code Point let text = '𠮷'console.log(text.codePointAt(0)); // 134071console.log(text.codePointAt(1)); // 57271 上面的 134071 是 ‘𠮷’ 的 Code Point。另外通过 codePointAt 方法可以很容易的知道字符是否为 4 字节的字符 function is32BitChar(c)&#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;console.log(is32BitChar(text)); // true String.fromCodePoint()String.fromCodePoint() 的作用与 codePointAt() 方法互补，它的作用是根据 Code Point 得到字符 let c = String.fromCodePoint(134071);console.log(c); 在我的控制台打印出的一个乱码，不知道是不是我控制台编码的问题。 normalize有的时候，有多个 Code Point 序列对应一个字符 let string1 = '\\u00F1';let string2 = '\\u006E\\u0303';console.log(string1); // ñconsole.log(string2); // ñ 虽然他们表示都是同一个字符，但是因为他们的 Code Point 序列不同，所以直接进行比较时，它们是不同的 let string1 = '\\u00F1'; // ñlet string2 = '\\u006E\\u0303'; // ñconsole.log(string1 === string2); // falseconsole.log(string1.length); // 1console.log(string2.length); // 2 而 normalize 正是来解决这个问题的，它通过将字符转化为标准化的形式，具体见下面的 MDN String.prototype.normalize() 正则表达式的 u 标签如果正则表达式使用了 u 标签，那么他会基于字符匹配而不是 Code Point 进行匹配 let text = '𠮷'console.log(/^.$/.test(text)); // falseconsole.log(/^.$/**u**.test(text)); // true 通过 length 属性，我们得到的并不是字符串的长度，我们可以通过 u 标签计算有多少个 Code Point 从而得到字符串的真实长度 function codePointLength(text) &#123; let result = text.match(/[\\s\\S]/gu); return result ? result.length : 0&#125;console.log(codePointLength(\"abc\")); // 3 console.log(codePointLength(\"𠮷bc\")); // 3 字符串识别子串在 ES5 中，我们经常使用 indexOf 方法来识别子串，在 ES6 中新引入了三个方法来帮助我们更加方便的识别子串 includes startsWith endsWith 通过方法的名称即可知道方法的作用。这些方法都接收两个参数 要识别的子串，substr 起始位置，index 对于 index 的含义，includes 和 startsWith 的含义表示以 index 开始识别，而 endsWith 表示以 length - index 结束识别。index 是可选的，如果不传入该参数，默认从字符串的首部开始搜索。 let msg = \"Hello World!\";console.log(msg.startsWith(\"Hello\")); // trueconsole.log(msg.endsWith(\"!\")); // trueconsole.log(msg.includes(\"o\")); // trueconsole.log(msg.startsWith('o', 4)); // trueconsole.log(msg.endsWith('o', 8)); // trueconsole.log(msg.includes('o', 8)); // false 如果向 startsWith、endsWith、includes 中传入正则表达式，那么会抛出一个错误。 repeatrepeat 方法接收一个数字参数 n，它的作用是将字符串复制 n 遍然后返回 console.log(\"hello \".repeat(3)); // \"hello hello hello \" 正则表达式y FlagES6 增加了一个 y 标签，该标签表示从 lastIndex 处精确匹配 // 没有使用修饰符let pattern = /hello\\d\\s?/;// 使用了 g 修饰符let globalPattern = /hello\\d\\s?/g;// 使用了 y 修饰符let stickyPattern= /hello\\d\\s?/y;let text = \"hello1 hello2 hello3\";// 进行一次匹配let result = pattern.exec(text);let globalResult = globalPattern.exec(text);let stickyResult= stickyPattern.exec(text);console.log(result[0]); // hello1console.log(globalResult[0]); // hello1console.log(stickyResult[0]); // hello1// 修改 lastIndexpattern.lastIndex = 1;globalPattern.lastIndex = 1;stickyPattern.lastIndex = 1;// 修改 lastIndex 对无修饰符的正则对象无影响result = pattern.exec(text);// 从 lastIndex 处开始进行搜索匹配globalResult = globalPattern.exec(text);// 从 lastIndex 处进行精确匹配，如果不匹配则不再进行后续匹配stickyResult= stickyPattern.exec(text);console.log(result[0]); // hello1console.log(globalResult[0]); // hello2console.log(stickyResult[0]); // TypeError: Cannot read property '0' of null 当修改包含 y flag 的正则对象的 lastIndex 为 1 后在进行匹配时，并没有匹配到任何东西，因为 index 为 1 后的字符为 ello…，无法与 /hello\\d\\s?/ 精确匹配，所以不会匹配到任何的东西。 y flag 会存储上次匹配的字符的下一个字符的下标，该值会被存储在lastIndex 中 let stickyPattern= /hello\\d\\s?/y;let text = \"hello1 hello2 hello3\";let stickyResult= stickyPattern.exec(text);console.log(stickyResult[0]); // hello1console.log(stickyPattern.lastIndex); // 7stickyResult= stickyPattern.exec(text);console.log(stickyResult[0]); // hello2console.log(stickyPattern.lastIndex); // 14stickyResult= stickyPattern.exec(text);console.log(stickyResult[0]); // hello3console.log(stickyPattern.lastIndex); // 20 通过正则对象的 sticky 属性可以知道该对象是否指定了y flag let pattern = /hello\\d/y;console.log(pattern.sticky); // true 正则表达式的复制在 ES5 中可以通过 RegExp 构造函数进行正则表达式的复制 let re1 = /a\\db/i, re2 = new RegExp(re1); 但是在构造函数的第二个参数指定了修饰符，那么在 ES5 会报错，而在 ES6 中是可以的，并且新指定的修饰符会覆盖原来的修饰符 let re1 = /a\\db/i, // 在 ES5 中会报错 re2 = new RegExp(re1, \"g\");console.log(re1.toString()); // \"/a\\db/i\"console.log(re2.toString()); // \"/a\\db/g\"console.log(re1.test(\"A2B\")); // trueconsole.log(re2.test(\"A2B\")); // false flags 属性在 ES5 中想获得正则对象包含哪些修饰符，一般通过解析 toString 得到的字符串 let getFlags = function(re) &#123; let str = re.toString(); return str.substring(str.lastIndexOf(\"/\") + 1, str.length)&#125;let re = /abc/igu;console.log(getFlags(re)); // \"giu\" 在 ES6 中为正则对象添加了一个 flags 属性，可以通过 flags 属性来获得正则对象包含的修饰符 let re = /abc/igu;console.log(re.source); // \"abc\"console.log(re.flags); // \"giu\" 模板字符串ES5 中字符串处理难点： 多行字符串 字符串格式化 HTML 转义 ES6 引入模板字符串来解决该问题。 基本语法使用 ` 号将字符串括起来 let str = `Hello World!`;console.log(str); // \"Hello World\"console.log(typeof str); // string 多行字符串ES6 之前表示多行字符串的写法 let str = \"Hello \\n\\World!\";console.log(str); // \"Hello // World!\"// 或者let message = [\"Hello\", \"World!\"].join(\"\\n\");console.log(message); // Hello // World! ES6 中更简单的写法 let str = `HelloWorld!`;console.log(str); // Hello // World! 在 `` 中所有的空白字符都会被算作是字符串的一部分。 通过上面的写法，可以写出易于阅读的 HTML 字符串 let html = `&lt;div&gt; &lt;p&gt;Hello World!&lt;/p&gt;&lt;/div&gt;`; 模板替换在 ES5 中一般如下拼接字符串 let name = \"Alice\";let message = \"Hello, My name is \" + name + \", nice to meet you!\";console.log(message); // Hello, My name is Alice, nice to meet you! 在 ES6 中我们可以使用占位符来方便实现字符串的拼接 let name = \"Alice\";let message = `Hello, My name is $&#123;name&#125;, nice to meet you!`console.log(message); // Hello, My name is Alice, nice to meet you! 其中 ${name} 会被本地变量 name 替换，最后形成的字符串就是被替换的字符串。替换的语法就是${}，其中 {} 中的内容可以是变量名，也可以是表达式 let price = 2.5, count = 3;let message = `$&#123;count&#125; items cost $$&#123;(price * count).toFixed(2)&#125;.`console.log(message); // 3 items cost $7.50. 如果 $ 后面没有 {} 的话，会被当做是正常的美元字符进行输出。 因为模板字符串本身也是表达式，这意味着可以在模板字符串中嵌入模板字符串 let name = \"Alice\";let message = `Hello, $&#123; `my name is $&#123;name&#125;.`&#125;`;console.log(message); // Hello, my name is Alice. 标签模板标签对模板字符串进行转换，并返回最终的字符串值。标签放置在模板的前方 let str = tag`Hello World!`; 其中 tag 就是标签，tag 标签会对模板字符串进行处理，返回的字符串作为最终模板字符串的值 let str = tag`Hello World!`;function tag() &#123; return \"hello\";&#125;console.log(str); // hello 一个标签其实就是一个函数，它接收两个参数 由 ${} 分割的模板字符串数组 ${} 中表达式计算后的结果形成的数组 let price = 2.5, count = 3;let message = tag`$&#123;count&#125; items cost $$&#123;(price * count).toFixed(2)&#125;.`function tag(literals, ...substitutions) &#123; console.log(literals); // [ '', ' items cost $', '.' ] console.log(substitutions); // [ 3, '7.50' ]&#125; 在 message 的模板字符串中，有两个 ${}，所以会被分为三段，这三段的内容形成的数组就是第一个参数的值，两个 ${} 中表达式计算后的值形成的数组是第二个参数的值。 下面使用自定义的标签来模拟模板字符串的默认行为 function defaultTemplate(literals, ...substitutions) &#123; let result = \"\"; for(let i = 0; i &lt; substitutions.length; i++) &#123; result += literals[i]; result += substitutions[i]; &#125; result += literals[literals.length - 1]; return result;&#125;let price = 2.5, count = 3;let message = defaultTemplate`$&#123;count&#125; items cost $$&#123;(price * count).toFixed(2)&#125;.`console.log(message); // 3 items cost $7.50. 标签还可以访问到模板字符串的原始信息，主要指能够访问字符转义。JavaScript 提供了 String.raw 标签以模板访问字符串的原始信息 let str1 = String.raw`Hello\\nWorld!`;let str2 = `Hello\\nWorld!`;console.log(str1); // Hello\\nWorld!console.log(str2); // Hello // World! 传入标签的 literals 参数有一个 raw 属性，里面保存的就是字符串的原始信息，自定义 raw 标签来模拟 String.raw function raw(literals, ...substitutions) &#123; let result = \"\"; for(let i = 0; i &lt; substitutions.length; i++) &#123; result += literals.raw[i]; result += substitutions[i]; &#125; result += literals.raw[literals.length - 1]; return result;&#125; 与 defaultTemplate 不同的就是将 literals[i] 换为了 literals.raw[i]。","tags":[{"name":"字符串","slug":"字符串","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"ES6：let 和 const","date":"2021-01-12T15:12:00.000Z","path":"/ES6：let 和 const/","text":"var 声明变量使用 var 声明变量的特点： 变量提升 console.log(value); // undefiendvar value = 'hello'; 上述代码在变量 value 声明之前就访问了 value，在其他的类 C 语言中，要使用变量必须先声明变量，如果没有声明则会报错，但是对于上述的代码，JavaScript 并没有报错，而是打印出了 undefiend，这时因为 JavaScript 对使用 var 声明的变量做了变量提升，将变量 value 的声明放置在所在作用域的最前面，所以上面的代码相当于如下 var value;console.log(value);value = 'hello'; 无块级作用域 对于其他的类 C 语言，变量的作用域一般是在一个块级作用域中的，一旦出了所在的块级作用域，就无法访问到该变量。但是 JavaScript 并没有块级作用域，只有全局作用域和函数作用域 if (true) &#123; var value = \"hello\";&#125;console.log(value); // hello 变量 value 声明在 if 的块级作用域中，但是对于 JavaScript 来说没有块级作用域，所以 value 是个全局变量，即使在 if 的块级作用域之外还是可以访问。 let 和 const块级作用域使用 let 和 const 可以声明块级作用域 if (true) &#123; let value = 'hello'&#125;console.log(value) 因为使用 let 声明的变量拥有块级作用域，所以如果在作用域外访问变量，那么就会报错，如上面的代码会报下面的错误 const 的用法和 let 是相同的，不同的是使用 const 声明的变量，它的值不能被更改，所以 const 声明的遍历在声明时就要做初始化，如果没有做初始化，则会报错 const value 同样如果对 const 定义的变量进行修改的话，也会报错 const value = 'hello'value = 'world' 但是如果 const 修饰的变量是一个对象的话，我们可以修改遍历的属性值，例如 const person = &#123; name: 'Alice', age: 18&#125;person.name = 'Bob'console.log(person.name) // Bob 使用 const 修饰 person，意味着 person 的值不能发生改变，而改变 person 的属性不会改变 person 的值，所以上面的修改是可以的，但是如果你试图对 person 进行赋值，那么就会报错 // TypeError: Assignment to constant variable.person = &#123; name: 'Bob', age: 20&#125; 暂时性死区对于使用 let 和 const 定义的变量，它们的声明不会被编译器提升到作用域的开头，该变量所在的作用域的开始到该变量声明的地方之间的区域叫做暂时性死区 在暂时性死区访问变量会发生错误，即使是 typeof 这么安全的操作符都不行 // undefinedconsole.log(typeof value); if(true) &#123; // ReferenceError: Cannot access 'value' before initialization console.log(typeof value); let value = \"hello\";&#125; 暂时性死区并未出现在 ECMAScript 规范中，但是人们经常使用这个术语来解释为什么在 let 和 const 定义变量前不能访问该变量。 重复声明变量在同一个作用域中，不能声明相同变量名的变量，例如 var value = 'hello'// SyntaxError: Identifier 'value' has already been declaredlet value = 'world' 循环中的块级作用域下面我们要看一个遍历的例子 const funcs = [];for(var i = 0; i &lt; 10; i++) &#123; funcs.push(function()&#123; console.log(i) &#125;)&#125;funcs.forEach(function(func) &#123; func()&#125;) 上面的程序也许你会以为会输出 0-9 ，但是最后的输出是 10 个 10 10101010101010101010 有点反常，但是想想还真是，funcs 数组中的函数里面的 i 指向的都是循环变量 i，当循环执行完毕时，循环变量 i 已经变为了 10，当打印 i 时，结果就当然全部都是 10 了。如果我们想打印 0-9 的话，就需要将遍历 i 的 “快照” 传入，如下 const funcs = [];for(var i = 0; i &lt; 10; i++) &#123; funcs.push((function(value)&#123; return function() &#123; console.log(value) &#125; &#125;)(i))&#125;funcs.forEach(function(func) &#123; func()&#125;) 上面的代码开始有点复杂了，如果是新手一时半会儿还看不懂。上面代码就是将变量 i 的值传入了立即执行函数，这时 funcs 数组中的函数保存的 value 值是循环遍历时 i 的 “快照”，而不是循环变量 i，所以上面的最终结果是打印出 0-9 0123456789 现在我们用 let 来实现打印出 0-9 const funcs = []for(let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;)&#125;funcs.forEach(function(func)&#123; func()&#125;) 上面打印出来的结果是 0-9，和使用 var 定义循环变量的情况不同。原因是因为每次遍历时，let 都会创建一个新的变量 i，所以每一个 func 中的 i 它们都是不同的，每一个 func 函数都有一个 i，并且是当时遍历时的值，所以最后处理的结果是 0-9。 使用 let 定义循环变量时，每次都出创建一个新的变量使用 let 定义循环变量时，每次都出创建一个新的变量使用 let 定义循环变量时，每次都出创建一个新的变量重要的事情说三遍！！！ 最佳实践：变量使用 const 定义，当遍历需要改变时，在使用 let 定义。","tags":[{"name":"let","slug":"let","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/let/"},{"name":"const","slug":"const","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/const/"}]},{"title":"图的广度优先遍历","date":"2020-12-23T16:00:00.000Z","path":"/图的广度优先遍历/","text":"树的层序遍历树的层序遍历是指一层一层的遍历树的节点，它的实现是借助于队列进行实现的： 每一次从队列的头部取出元素进行遍历，然后将该元素的左右孩子添加进队列，以此往复，直至队列为空，遍历结束。 import java.util.LinkedList;import java.util.Queue;public class BinaryTree &#123; private class Node &#123; private Node left; private Node right; private int value; public Node(int value) &#123; this.value = value; &#125; &#125; private Node root; public BinaryTree(int value) &#123; root = new Node(value); &#125; public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; Node node = queue.remove(); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; System.out.println(node.value); &#125; &#125;&#125; 图的广度遍历图的广度优先遍历与树的层序遍历相似，所谓的广度是指尽可能的遍历所有的相邻元素 广度优先遍历的实现同树的层序遍历类似，也是借助于队列这种数据结构，每次从队列的头部取出节点进行遍历，然后将该节点的所有相邻节点添加进队列，但是需要注意的是，因为图有可能发生重复遍历，所以需要使用visited 标记已遍历的节点；另外还需要考虑到有多个联通分量的情况，与深度优先遍历的写法类似 import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class BFSGraph &#123; private Graph graph; private boolean[] visited; private ArrayList&lt;Integer&gt; order; public BFSGraph(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; order = new ArrayList&lt;&gt;(graph.V()); for (int i = 0; i &lt; graph.V(); i++) &#123; if (!visited[i]) &#123; bfs(i); &#125; &#125; &#125; private void bfs(int s) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited[s] = true; while (!queue.isEmpty()) &#123; int v = queue.remove(); order.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; queue.add(w); visited[w] = true; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g4.txt\"); BFSGraph bfsGraph = new BFSGraph(graph); System.out.println(bfsGraph.order); &#125;&#125; 单源路径问题对于路径问题的思路同DFS，使用一个 pre 数组，保存当前节点的上一个节点，当查询源节点到某个目的节点的路径时，只要从目的节点根据 pre 数组一直查找它的前一个节点，直到前一个节点为源节点就找到了路径 import java.util.*;public class SingleSourcePath &#123; private Graph graph; private int s; private boolean[] visited; private int[] pre; public SingleSourcePath(Graph graph, int s) &#123; this.graph = graph; this.s = s; visited = new boolean[graph.V()]; pre = new int[graph.V()]; Arrays.fill(visited, false); Arrays.fill(pre, -1); bfs(s); &#125; private void bfs(int s) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited[s] = true; pre[s] = s; while (!queue.isEmpty()) &#123; int v = queue.remove(); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; queue.add(w); visited[w] = true; pre[w] = v; &#125; &#125; &#125; &#125; private void validate(int v) &#123; if (v &lt; 0 || v &gt;= graph.V()) &#123; throw new IllegalArgumentException(\"v is out of index\"); &#125; &#125; public boolean isConnected(int t) &#123; validate(t); return visited[t]; &#125; public ArrayList&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (!isConnected(t)) &#123; return res; &#125; int cur = t; while (cur != s) &#123; res.add(cur); cur = pre[cur]; &#125; res.add(s); Collections.reverse(res); return res; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g4.txt\"); SingleSourcePath singleSourcePath = new SingleSourcePath(graph, 0); // 0 -&gt; 6: [0, 2, 6] System.out.println(\"0 -&gt; 6: \" + singleSourcePath.path(6)); &#125;&#125; 对于同样的图，使用深度优先遍历，结果是 0 -&gt; 6: [0, 1, 3, 2, 6] BFS 找到的路径比 DFS 找到的路径要短，这不是巧合，因为在无向无环图中，BFS 有一个重要的性质就是它寻找到的路径是最短路径，或者说经历的节点最少。为什么? 换种角度看，广度优先遍历是按照距离源的最小距离遍历的。 下面一个问题是寻找源到各点之间的距离，这个最简单的实现就是获得源到各点之间的路径，然后获得路径的长度即可推算出距离。下面提供一种更快的方法，无须先获得路径。首先我们需要声明一个 dis 数组来保存源到各点的距离，假设 w 是 v 的相邻节点，且 v 先被遍历，那么 s -&gt; w 的距离为 s -&gt; v + 1，即 dis[w] = dis[v] + 1 import java.util.*;public class SingleSourcePath &#123; private Graph graph; private int s; private boolean[] visited; private int[] pre; // dis 数组保存源到各节点的距离 private int[] dis; public SingleSourcePath(Graph graph, int s) &#123; this.graph = graph; this.s = s; visited = new boolean[graph.V()]; pre = new int[graph.V()]; // 初始化 dis = new int[graph.V()]; Arrays.fill(visited, false); Arrays.fill(pre, -1); // 初始化 Arrays.fill(dis, -1); bfs(s); &#125; private void bfs(int s) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited[s] = true; pre[s] = s; // 源到源的距离为 0 dis[s] = 0; while (!queue.isEmpty()) &#123; int v = queue.remove(); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; queue.add(w); visited[w] = true; pre[w] = v; // 更新 dis dis[w] = dis[v] + 1; &#125; &#125; &#125; &#125; // 与 path 相关代码省略 public int dis(int t) &#123; validate(t); return dis[t]; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"最长回文字符串","date":"2020-11-19T15:51:00.000Z","path":"/最长回文字符串/","text":"题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\"输出: \"bb\" 暴力法扫描一遍字符串，判断 $[i, j]$ 范围内的字符串是不是回文字符串，并且在这个过程中记录最长的字符串 class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 2) &#123; return s; &#125; char[] str = s.toCharArray(); int start = 0; int maxLength = 1; for (int i = 0; i &lt; str.length - 1; i++) &#123; for (int j = i + 1; j &lt; str.length; j++) &#123; // 如果 [i,j] 范围的字符串长度小于目前已知的最长回文字符串的长度，则无需判断 if ((j - i + 1) &gt; maxLength) &#123; // 如果是回文字符串，更新最长回文字符串的长度，以及该回文字符串的起始位置 if (isPalindrome(str, i, j)) &#123; maxLength = j - i + 1; start = i; &#125; &#125; &#125; &#125; return s.substring(start, start + maxLength); &#125; // 判断 [start, end] 范围内的字符串是否为回文字符串 private boolean isPalindrome(char[] str, int start, int end) &#123; while (start &lt;= end) &#123; // 判断两端的字符串是否相同,不相同则不可能是回文字符串 if (str[start] != str[end]) &#123; return false; &#125; start++; end--; &#125; return true; &#125;&#125; 动态规划我们开辟一个数组 $dp$，$dp[i][j]$ 表示 $[i, j]$ 范围内的字符串是否为回文字符串，那我们可以知道 $$dp[i][j] =\\begin{cases}false, \\quad &amp;when \\quad str[i] \\neq str[j] \\\\dp[i+1][j-1], \\quad &amp;when \\quad str[i] = str[j]\\end{cases}$$ 当 $str[i] \\neq str[j]$ 的时候，那么不可能是回文字符串，如果 $str[i] = str[j]$ 的时候，如果 $dp[i+1][j-1]$ 是回文字符串，那么 $dp[i][j]$ 就是回文字符串。 但是如果 $i + 1 &gt; j - 1$ 的话，这时 $dp[i + 1][j - 1]$ 没有意义，其实这种情况就是 $[i,j]$ 内只有两个字符，如果 $str[i] = str[j]$ 的话，那么它就是一个回文字符串，所以这时可以直接得到 $dp[i][j] = true$。 class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 2) &#123; return s; &#125; int length = s.length(); boolean dp[][] = new boolean[length][length]; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; dp[i][j] = false; &#125; &#125; // [i,i] 表示单个字符，肯定是回文字符串 for (int i = 0; i &lt; length; i++) &#123; dp[i][i] = true; &#125; int maxLength = 1; int begin = 0; // 因为 [i, j] 要用到 [i + 1, j - 1]，所以让 i 动 // 如果让 j 动，那么 [i + 1, j -1] 的范围没都判断过，会导致错误的结果 for (int j = 1; j &lt; length; j++) &#123; for (int i = 0; i &lt; j; i++) &#123; // 如果字符两端不相等，不是回文字符串 if (s.charAt(i) != s.charAt(j)) &#123; dp[i][j] = false; &#125; else &#123; // 如果只有两个元素，可以直接判断为回文字符串 if (i + 1 &gt; j - 1) &#123; dp[i][j] = true; &#125; else &#123; // 与 dp[i + 1][j - 1] 相同 dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 更新最长长度以及起始位置 if (dp[i][j] &amp;&amp; (j - i + 1) &gt; maxLength) &#123; maxLength = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLength); &#125;&#125; 中间扩散法上面的情况都是检查某个范围内的字符串是否是回文字符串，而中心扩散法，则是以某点为中心进行向外扩散，在扩散的同时检查是否是回文字符串，过程如下 检查该点左右两边的字符串是否相等，如果相等则继续扩散，如果不相等则停止扩散 停止扩散后记录该回文字符串的长度，如果大于当前记录的最大回文字符串的长度，则进行更新，为了获得该回文字符串，还需要记录该回文字符串的起始位置 需要注意的是，既可以从某个字符开始扩散，也可以从字符间的空隙进行扩散 从某个点进行扩散的代码如下： private int centerSpread(String s, int left, int right) &#123; int length = 0; while(left &gt;=0 &amp;&amp; right &lt; s.length()) &#123; if (!(s.charAt(left) == s.charAt(right))) &#123; break; &#125; length++; left--; right++; &#125; return length;&#125; 如果从某个字符进行扩散，那么 left 和 right 都是该字符的下标，如果从某个字符空隙进行扩散，则 left 和 right 分别为该空隙左右两边字符的下标。扩散的示意图如下 完整代码如下 class Solution &#123; public String longestPalindrome(String s) &#123; int begin = 0; int maxLength = 1; for (int i = 1; i &lt; s.length(); i++) &#123; // 从字符空隙进行扩散 int length1 = centerSpread(s, i - 1, i); // 从字符进行扩散 int length2 = centerSpread(s, i, i); // 获得二者进行扩散的回文字符串的最大长度 int length = (2 * length1) &gt;= (2 * length2 - 1) ? 2 * length1 : (2 * length2 - 1); // 如果比 maxLength 大，则进行更新 if (length &gt; maxLength) &#123; maxLength = length; begin = i - length/2; &#125; &#125; return s.substring(begin, begin + maxLength); &#125; private int centerSpread(String s, int left, int right) &#123; int length = 0; while(left &gt;=0 &amp;&amp; right &lt; s.length()) &#123; if (!(s.charAt(left) == s.charAt(right))) &#123; break; &#125; length++; left--; right++; &#125; return length; &#125;&#125; Manacher算法Manacher 算法是对中间扩散法的改进，首先我们在字符间填充 # 以此充当字符空隙，得到一个新的字符串，然后用一个数组记录新字符串每个字符能够扩散多远 b # a # b # a # d 我们复用中心扩散法的代码 class Solution &#123; public String longestPalindrome(String s) &#123; int begin = 0; int maxLength = 1; // babad =&gt; b#a#b#a#d String str = String.join( \"#\", s.split(\"\")); for (int i = 1; i &lt; str.length(); i++) &#123; int length = centerSpread(str, i, i); length = 2 * length - 1; if (length &gt;= maxLength) &#123; // #a# b#b 二者长度相同，但是应选择后面的 if (length &gt; maxLength || str.charAt(i + length/2) != '#') &#123; maxLength = length; begin = i - length/2; &#125; &#125; &#125; // b#a#b =&gt; bab return String.join( \"\", str.substring(begin, begin + maxLength).split(\"#\")); &#125; private int centerSpread(String s, int left, int right) &#123; int length = 0; while (left &gt;= 0 &amp;&amp; right &lt; s.length()) &#123; if (!(s.charAt(left) == s.charAt(right))) &#123; break; &#125; length++; left--; right++; &#125; return length; &#125;&#125; 这个时候我们还没有使用上面提到的数组，接下来我们需要利用数组记录一些信息，从而加快中间扩散法的速度。 首先我们要知道如何加快中间扩散法的速度，这就需要利用回文字符串的特点，那就是回文字符串是左右对称的，当我们对回文字符串内的某个字符进行中间扩散时，我们可以先找到对称位置的字符，看看它能够扩散的多远 如果它扩散的距离小于所处回文字符串的范围，那么根据对称的特点，我们不需要对该字符进行中间扩散，它能够扩散的距离就是对称位置所能扩散的距离 但是对称位置能够扩散的距离刚好在所处回文字符串的边界，或者大于所处的回文字符串，那么此时扩散的距离就不等于对称位置能够扩散的距离，而是需要进行扩散才能确定 但是我们不需要从该字符串开始进行扩散，因为我们可以确定在回文字符串的范围内，它是对称的，所以我们只需要从回文字符串的外部进行扩散即可 扩散完毕后记录能够扩散后的距离，并决定是否更新 begin，maxLength。 现在还有一个问题，如何知道某个字符处于一个回文字符串中，我们通过记录两个变量 center 和 maxRight 来表示一个回文字符串，center 表示回文字符串的中心，maxRight 表示中心离回文字符串右边界的距离 我们认为如果字符的下标小于 $center + maxRight$，那么它就在一个回文字符串中。 那什么时候更新这两个变量呢? 那就是在某个字符扩散之后，他向右边能够扩散的范围大于当前的 $center + maxRight$，那么就更新 center 和 maxRight。 代码如下： class Solution &#123; public String longestPalindrome(String s) &#123; // 将字符串转化为 a#b#c#b 的形式 // String newStr = String.join( \"#\", s.split(\"\")); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) &#123; if (i != s.length() - 1) &#123; stringBuilder.append(s.charAt(i) + \"#\"); &#125; else &#123; stringBuilder.append(s.charAt(i)); &#125; &#125; String newStr = stringBuilder.toString(); // records[i] 表示扩散距离 int[] records = new int[newStr.length()]; records[0] = 0; // 回文字符串的起始位置和长度 int begin = 0; int maxLength = 1; // 表示回文字符串 int center = 0; int maxRight = 0; for (int i = 1; i &lt; newStr.length(); i++) &#123; // 如果 str[i] 在某个回文字符串中 if (i &lt;= center + maxRight) &#123; // 对称位置的扩散距离 int mirrorLength = records[2 * center - i]; // 超过或等于 center + maxRight 表示的边界，进行中间扩散，并进行必要的更新 if (i + mirrorLength &gt;= center + maxRight) &#123; // 扩散 int length = center + maxRight - i; while (i + length + 1 &lt; newStr.length() &amp;&amp; (i -length - 1) &gt;= 0) &#123; if (newStr.charAt(i + length + 1) != newStr.charAt(i - length - 1)) &#123; break; &#125; length++; &#125; records[i] = length; // 更新 if (2 * length + 1 &gt;= maxLength) &#123; if (2 * length + 1 &gt; maxLength || newStr.charAt(center) != '#') &#123; begin = i - length; maxLength = 2 * length + 1; &#125; &#125; if (i + length &gt; center + maxRight) &#123; center = i; maxRight = length; &#125; &#125; else &#123; // 小于 center + maxRight 形成的边界，直接使用对称位置的值 records[i] = mirrorLength; &#125; &#125; else &#123; // 不在回文字符串中，进行中心扩散，并进行必要的更新 int length = 0; while (i + length + 1 &lt; newStr.length() &amp;&amp; (i - length - 1) &gt;= 0) &#123; if (newStr.charAt(i + length + 1) != newStr.charAt(i - length - 1)) &#123; break; &#125; length++; &#125; if (2 * length + 1 &gt; maxLength) &#123; begin = i - length; maxLength = 2 * length + 1; &#125; center = i; maxRight = length; records[i] = length; &#125; &#125; // 将 a#b#b#a 形式的字符串转化为 abba // return String.join( \"\", newStr.substring(begin, begin + maxLength).split(\"#\")); String ss = newStr.substring(begin, begin + maxLength); StringBuilder stringBuilder1 = new StringBuilder(); for (int i = 0; i &lt; ss.length(); i++) &#123; if (ss.charAt(i) != '#') &#123; stringBuilder1.append(ss.charAt(i)); &#125; &#125; return stringBuilder1.toString(); &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/leetcode/"}]},{"title":"安全与算法","date":"2020-11-05T01:55:00.000Z","path":"/安全算法/","text":"我们在使用互联网交换数据时，数据需要经过各种各样的网络设备才能到达通信双方，如果数据在传输的过程中经过某些恶意用户的设备，就有可能导致信息被窃取。所以如果想安全的使用互联网，了解必须的安全技术是不可或缺的。 安全问题我们首先了解一下在通信的过程中会遇到什么样的安全问题。 窃听 $A$ 向 $B$ 发送的信息可能会在传输的过程中被 $X$ 偷看，这就是窃听。 假冒 $A$ 以为给 $B$ 发送了消息，但是 $B$ 有可能是 $X$ 冒充的；同样 $B$ 以为收到了 $A$ 的消息，但是 $A$ 也有可能是 $X$ 冒充的，这种问题叫做假冒。 篡改 $B$ 确实收到了 $A$ 发送的信息，但是内容已经被 $X$ 给改变了，这种行为叫做篡改。 事后否认 $B$ 从 $A$ 那里收到了消息，但是 $A$ 在事后宣称消息不是它发的，这会导致互联网上的商业交易或合同无法成立，这种行为叫做事后否认。 在这篇文章中就着重解决这四类问题，对于窃听，我们对消息进行加密技术；对于假冒，我们使用消息认证码或数字签名；对于篡改，我们同样可以使用消息认证码或数字签名；对于事后否认，我们可以使用数字签名。 问题 解决办法 窃听 加密 假冒 消息认证码或数字签名 篡改 消息认证码或数字签名 事后否认 数字签名 数字签名存在无法确认公开密钥制作者的问题，我们可以使用数字证书来解决，具体的过程我们在后面分析。 对称加密如果我们在互联网上直接将消息发送过去的话，有可能会被窃听，所以我们需要将消息变为密文，然后发送出去，将消息变为密文的过程叫做加密，同样在接收方需要将密文变为明文(消息)，这个过程叫做解密。 在加密和解密的过程中需要用到密钥，所谓的密钥可以类比于钥匙，钥匙的作用就是加锁与开锁，而密钥的作用是加密与解密。根据加密和解密是否使用的是相同的密钥，可以分为对称加密与非对称加密： 对称加密：加密和解密的密钥是同一个密钥 非对称加密：加密和解密的密钥不相同 在本小节中就介绍对称加密，以及对称加密存在什么问题。 对称加密的过如下： $A$ 将密钥 $key$ 发送给 $B$ $A$ 使用密钥 $key$ 对消息 $aaa$ 加密，得到密文 $xyz$ $B$ 接到密文 $xyz$，使用密钥 $key$ 对密文解密得到 $aaa$ 这时如果窃听者来窃听的话，因为窃听者没有密钥，所以无法得知明文是什么。 但是上述的加密有一个问题，如果密钥 $key$ 在 $A$ 发送给 $B$ 的时候被窃听了 这时窃听者就知道密钥，以此将密文解密，从而窃听消息。 非对称加密非对称加密指的是加密的密钥和解密的密钥不是同一个密钥，我们把加密密钥称为公开密钥，因为它是可以公开的，任何人都可以访问到，我们称解密密钥为私有密钥。 当 $A$ 给 $B$ 发送消息时，在此之前，$B$ 会生成公开密钥和私有密钥，然后 $B$ 将公开密钥发送给 $A$，接着 $A$ 使用该公开密钥加密消息，并将消息发送给 $B$，当 $B$ 接收到消息之后，使用私有密钥对消息解密 即使窃听者窃听到了密文以及公开密钥，但是它没有私有密钥，所以它不能解密出消息。 但是这种方法并不是完美的，假设在 $B$ 向 $A$ 发送公开密钥时，窃听者将 $B$ 公开密钥修改为了自己的公开密钥发送给 $A$ 因为公开密钥并不能指明来源是谁，当 $A$ 接收到密钥时误以为是 $B$ 的公开密钥，这样当 $A$ 向 $B$ 发送消息时，其实使用的是窃听者的公开密钥来加密消息，这时窃听者通过私钥解密，从而窃听到消息 并且再次使用 $B$ 的公开密钥加密消息，将消息发送给 $B$，对于 $A$ 和 $B$ 来说，它们完全没有意识到自己被窃听了 这种通过中途替换公开密钥来窃听数据的攻击方法叫做中间人攻击。 非对称加密可靠性会出现问题就是因为 $A$ 无法判断接收到的密钥是否来自于 $B$，想要解决这个问题，就要用到后面讲到的数字证书。 混合加密使用非对称加密虽然比对称加密安全，但是非对称加密方法加密和解密所需的资源以及时间比对称加密方法所需的资源和时间代价高很多，那么就有人提出一种加密方式，同时使用对称加密和非对称加密这种混合加密的方式，既能得到非对称加密的安全性，又能得到对称加密的快速性。 首先我们上面谈到对称加密时有讲到对称加密的缺点，那就是需要将加密的密钥在互联网上传输，而密钥有可能会被窃听者窃取。 如果我们使用非对称加密的方法来加密对称加密的密钥，这样对称加密的密钥就不会被窃听者窃取，因为窃听者没有私钥，然后在下面的通信过程中使用对称加密的密钥加密消息，因为我们只使用了非对称加密加密了对称加密所使用的密钥，而消息的加密都是通过对称加密的密钥加密的，所以不会存在速度慢的问题，这样既保证了安全性，又兼顾了加解密所需的资源和时间。 目前在网页中使用的 HTTPS 协议使用的就是混合加密的方式。 密钥交换算法Diffie-Hellman 密钥交换可以解决使用对称加密方法进行通信时密钥被窃听的问题。在讲解该算法的消息过程之前，我们先了解一下该算法的概念。 该算法它可以合成两个密钥 并且合成的密钥有三个特点 已知其中一个密钥，无法根据合成的密钥推断出另一个密钥 合成的密钥可以继续与其他的密钥进行合成 密钥合成的结果与合成的顺序无关 现在我们就使用这种方法在 $A$ 和 $B$ 之间传递密钥，首先由 $A$ 生成密钥 $P$，然后将该密钥发送给 $B$，在这个过程中有可能被窃听者 $X$ 窃取到密钥，所以这时的密钥不能被用来加密消息 接着 $A$ 和 $B$ 各自生成自己的私钥 $SA$ 和 $SB$，并使用上述的合成方法与密钥 $P$ 进行合成，然后发送给对方，双方接收到对方合成的密钥后，再将密钥与自己的私钥合成，如下 最后，$A$ 得到密钥 $P|SB|SA$，而 $B$ 得到密钥 $P|SA|SB$，根据算法特点 $3$，合成的密钥与合成的顺序无关，所以二者的密钥是相同的，所以接下来 $A$ 和 $B$ 可以用该密钥来加密和解密消息。 那窃听者有可能窃听该密钥吗? 通过上面的动图我们知道窃听者掌握的信息有密钥 $P$，以及两个合成密钥 $P|SA$ 和 $P|SB$，根据算法特点 $1$，窃听者是无法推断 $SA$ 和 $SB$ 的，所以窃听者就不能合成出密钥 $P|SA|SB$。 消息认证码消息认证码可以检测篡改，例如下面的场景 $A$ 向 $B$ 发送一个消息，在中途消息被恶意用户修改了，但是 $B$ 并没有意识到消息已经被修改了，以为接收到的消息就是 $A$ 发送的消息。消息认证码可以预防这种情况发生。 下面看一下使用消息认证码发消息的流程： $A$ 生成了一个生成消息认证码的密钥，并以安全的方式将密钥发送给了 $B$ $A$ 根据消息内容(已加密)，使用密钥生成一个值，这个生成的值就是消息认证码，简称 MAC(Message Authentication Code) $A$ 将消息和 MAC 发送给 $B$ $B$ 根据接收到的消息，使用 $A$ 之前发送的密钥生成一个值，如果这个值与 $A$ 发送过来的 MAC 相同，则可以认为消息是没有被篡改过的 接下来只需要对密文解密即可 如果在中途 $X$ 对 $A$ 发送的消息进行了篡改，那么 $B$ 收到的密文和 $A$ 发送的密文不同，那么 $B$ 生成的消息认证码和 $A$ 发送的消息认证码就不相同，这个时候 $B$ 就知道消息被篡改过了，这时可以要求 $A$ 重新发送消息。 数字签名消息认证码虽然解决了篡改的问题，但是因为他们使用的是相同的密钥加密和解密，所以 $B$ 也可以生成消息认证码，所以事后 $A$ 可以否认消息并不是他发的，因为不仅仅是他可以生成消息认证码(事情又不是我一个人可以干，你凭什么说是我干的)。 使用数字签名不仅可以解决篡改问题，还可以解决事后否认问题。假设 $A$ 给 $B$ 发送消息，我们首先看一下流程： $A$ 在发送前给消息加上数字签名，数字签名只能由 $A$ 生成 $B$ 收到 $A$ 的消息，验证数字签名的正确性，但是无法生成数字签名 因为数字签名只能由 $A$ 生成，所以 $A$ 无法在事后否认(这件事情就你能干，不是你干的是谁干的)。 我们看一下使用数字签名通信的详细过程： $A$ 生成一对公钥和私钥，公钥是每个人都知道的，私钥是 $A$ 独有的，$A$ 使用私钥对消息(已加密后的消息)加密，得到数字签名 $A$ 将消息以及数字签名发送给 $B$ $B$ 使用 $A$ 的公钥对消息解密，得到一个数字签名，验证该数字签名与 $A$ 发送数字签名是否相同 数字签名确认无误，说明消息没有经过篡改，并且可以确认消息是 $A$ 发的，可以对消息解密得到明文 上述过程有两次加密，第一次加密是对明文进行加密，得到密文防止被窃听，第二次加密是根据密文生成数字签名。对应的也要进行两次解密，第一次解密是为了得到数字签名，从而验证数字签名的正确性，如果数字签名确认无误，那么就需要进行第二次解密，将密文变换为明文，得到真正的消息。 事实上，使用私钥对全部的消息进行加密比较耗费时间，一般是根据消息生成哈希值，然后对哈希值加密得到数字签名。 因为数字签名是使用私钥进行加密的，只有 $A$ 有私钥，所以 $A$ 无法事后否认。 在本小节比较强调数字签名在事后否认方面的作用，但是数字签名可以用来检测消息是否被篡改，因为数字签名的生成与消息的内容是有关的，如果消息被篡改了，那么生成的数字签名就不对，就可以得知消息被篡改了或者不是 $A$ 发送的消息。 数字证书因为数字签名没有解决公开密钥制作者的问题，所以如果 $X$ 假冒 $A$ 给 $B$ 发送消息，此时 $X$ 会生成一对公钥和私钥，并且将公钥发送给 $B$，因为公钥中没有携带发送者的信息，$B$ 就会使用该公钥来验证数字签名，对于 $B$ 来说他以为自己在和 $A$ 通信，实际上在与 $A$ 通信。 解决这个问题需要使用数字证书，假设 $A$ 给 $B$ 发送消息，通信过程如下： $A$ 将包含公开密钥以及自己的相关信息(如邮箱)的个人资料发送给认证中心 认证中心根据 $A$ 的资料使用自己的私钥生成一个数字签名，并且将数字签名以及资料放进同一个文件中 认证中心将该文件发送给 $A$，该文件就是 $A$ 数字证书 $A$ 将包含公开密钥的数字证书发送给 $B$，$B$ 收到证书后，首先对 $A$ 的身份进行确认(如邮箱是否是 $A$ 的邮箱)，接着获取认证中心的公开密钥，使用认证中心的公开密钥对数字签名进行确认，判断是否是认证中心给出的签名 如果确认 $A$ 的信息无误，以及签名是认证中心的签名，那么就从证书中取出 $A$ 的公开密钥 如果这时 $X$ 假冒 $A$ 给 $B$ 发送它的公开密钥，这时 $B$ 没有必要信任以非证书的形式发送的公开密钥；这时 $X$ 为了假冒 $A$ 在认证中心登记自己的公开密钥，但是 $X$ 无法使用 $A$ 的信息(如邮箱)，因此无法获得 $A$ 的证书。 通过数字证书，消息的接收者可以确认公开密钥的制作者。 但是目前还有一个疑问，$B$ 从认证中心得到的公开密钥真的来自于认证中心吗? 如果认证中心也是假冒的呢? 实际上，认证中心的公开密钥也是以数字证书的形式交付的，会有更高级别的认证中心对这个认证中心署名。 假设存在一个被社会广泛认可的认证中心 $A$，此时出现了一家新公司 $B$ 想开展认证中心业务，但是 $B$ 没有得到社会的认可，于是 $B$ 向 $A$ 申请发行数字证书，$A$ 会对 $B$ 是否能开展认证业务进行检测，如果通过了检测，$A$ 就会向 $B$ 发行证书，公司 $B$ 就可以向社会表示自己获得了公司 $A$ 的信任。 最顶端的认证中心被称为根认证中心，其自身的正当性由自己证明。如果根认证中心不被信任，整个过程就无法运转，所以根认证中心一般是大型企业或者与政府有关联且已经获得了社会信赖的组织。 参考资料 《我的第一本算法书》","tags":[{"name":"安全","slug":"安全","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%AE%89%E5%85%A8/"},{"name":"数字签名","slug":"数字签名","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"},{"name":"数字证书","slug":"数字证书","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"}]},{"title":"numpy之矩阵","date":"2020-10-31T11:41:00.000Z","path":"/numpy之矩阵/","text":"文章是使用 jupyter 写的，为了插入到博客中，使用 iframe 进行嵌入，所以阅读体验可能不是很好","tags":[{"name":"numpy","slug":"numpy","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/numpy/"}]},{"title":"numpy之数学方法","date":"2020-10-31T10:20:00.000Z","path":"/numpy之数学方法/","text":"文章是使用 jupyter 写的，为了插入到博客中，使用 iframe 进行嵌入，所以阅读体验可能不是很好","tags":[{"name":"numpy","slug":"numpy","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/numpy/"},{"name":"ndarray","slug":"ndarray","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/ndarray/"}]},{"title":"图的深度优先遍历","date":"2020-10-28T16:00:00.000Z","path":"/图的深度优先遍历/","text":"图的深度优先遍历所谓图的遍历就是按照某种顺序访问图中所有的节点，根据访问的顺序不同，可以分为两类： 深度优先遍历 广度优先遍历 在本节中讲解深度优先遍历。 所谓深度优先遍历(Depth First Search，简称 DFS)，是指在遍历时，尽可能深的访问图的节点。为了更好的理解图的深度优先遍历，我们先看看树的深度优先遍历，与图的深度优先遍历一样，树的深度优先遍历也是指尽可能深的访问树的节点，也就是说如果一个节点有孩子节点，那么我们下一步就应该遍历它的孩子节点(深度)，如下 从上面的动图可以看出，当我们遍历完当前节点以后，如果该节点有孩子节点，那么接下来我们去遍历孩子节点，我们的遍历策略就是尽可能深的遍历。类比于图，对于图来说，如果一个图的节点有邻接节点，那么在遍历完该节点后，我们下一步就去遍历它的邻接节点 这就是图的深度优先遍历，上图深度优先遍历访问的顺序是 $[0, 1, 3, 2, 4, 5]$，我们将在下面的编程中验证是否正确。 图的遍历与树的遍历有一处不同，那就是重复访问问题。树不会发生重复访问的问题，这是因为树的节点只能通过父节点访问到，只有一种路径到达该节点，所以我们不必担心；但是对于图来说，一个图中的节点可以与多个节点进行连接，这就意味着有多种路径到达该节点，这就会导致某节点已经通过一个相邻的节点被访问，但是它还是有可能通过别的相邻节点再次被访问。 所以我们需要通过一个标志来表示某个图的节点是否已经被访问过了，如果已经被访问过了，那么我们就不能再次访问，我们通过一个 visited 数组来表示图中的某个节点是否已经被访问过了，visited 数组是一个 boolean 类型的数组，值为 true 时就表示该节点已经被访问过了，例如 visited[0] = true 就表示节点 0 已经被访问过了。 下面我就将编程具体实现： import java.util.ArrayList;import java.util.Arrays;public class DFSGraph &#123; // 图的表示中定义的 Graph 接口 private Graph graph; // 保存深度优先遍历的顺序 private ArrayList&lt;Integer&gt; order; // 保存节点是否已经被访问过 private boolean[] visited; public DFSGraph(Graph graph) &#123; this.graph = graph; order = new ArrayList&lt;&gt;(graph.V()); // 初始化 visited 中的元素值为 false visited = new boolean[graph.V()]; Arrays.fill(visited, false); &#125; // DFS 的实现，首先从节点 0 开始遍历 public void dfs() &#123; dfs(0); &#125; private void dfs(int v) &#123; // 标记当前节点为访问过的状态 visited[v] = true; // 向 order 中添加当前节点 order.add(v); for (int w: graph.adj(v)) &#123; // 如果邻接节点没有被访问过，那么遍历该邻接节点 if (!visited[w]) &#123; dfs(w); &#125; &#125; &#125; public Iterable&lt;Integer&gt; order() &#123; return order; &#125; public static void main(String[] args) &#123; // 使用邻接表表示图 Graph graph = new AdjSet(\"g.txt\"); // 实例化一个 DFSGraph DFSGraph dfsGraph = new DFSGraph(graph); // 调用 dfs 方法进行深度优先遍历 dfsGraph.dfs(); // 打印出深度优先遍历的顺序 System.out.println(dfsGraph.order()); &#125;&#125; 其中 g.txt 的内容如下 6 50 10 21 32 42 5 这个文件表示的图与我们在上面的动图中看到的图是一样的，我们来看下打印的结果 [0, 1, 3, 2, 4, 5] 这与我们在动图中看到的遍历顺序是一致的。 但是上面我们实现的深度优先遍历有一个小 bug，那就是上面的深度优先遍历只适合只有一个联通分量的图，如果有多个联通分量，那么其他联通分量中的节点就永远不可能被访问到，如 既然图中有节点永远不会被访问到，那么还能叫图的遍历吗，图的遍历可是要求能够访问图中所有的节点的，所以我们对代码进行改进 这次我们不只是从节点 $0$ 开始遍历，在遍历完节点 $0$ 所在的联通分量以后，我们检查是否还有节点没有遍历，即是否存在别的联通分量，如果有，那么我们还有遍历该节点所在的联通分量。 在最后我们进行一个扩展，我们知道树的深度优先遍历分为三种 前序遍历 中序遍历 后序遍历 图没有中序遍历，它分为两种 深度优先前序遍历 深度优先后序遍历 刚刚我们所编程的只是图的深度优先前序遍历，现在我们不妨写一下后序遍历的代码。在写代码之前，我们先明确后序遍历的这个后指的是什么，这个后在树的遍历中指的是先访问当前节点的孩子节点，然后访问当前节点，也就是访问当前节点在访问当前节点的孩子节点之后。类比于图，这个后指的就是先访问当前节点的邻接节点，然后再访问当前节 上面后序遍历的顺序为 $[3, 1, 4, 5, 2, 0]$，我们重构一下上面的代码，我们使用 preorder 来保存前序遍历的结果，使用 postorder 来保存后序遍历的结果： import java.util.ArrayList;import java.util.Arrays;public class DFSGraph &#123; private Graph graph; private ArrayList&lt;Integer&gt; preorder; private ArrayList&lt;Integer&gt; postorder; private boolean[] visited; public DFSGraph(Graph graph) &#123; this.graph = graph; preorder = new ArrayList&lt;&gt;(graph.V()); postorder = new ArrayList&lt;&gt;(graph.V()); visited = new boolean[graph.V()]; Arrays.fill(visited, false); &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; dfs(i); &#125; &#125; &#125; private void dfs(int v) &#123; visited[v] = true; // 前序遍历：在遍历相邻节点前，遍历当前节点 preorder.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w); &#125; &#125; // 后序遍历：遍历相邻节点后，再遍历当前节点 postorder.add(v); &#125; public Iterable&lt;Integer&gt; preorder() &#123; return preorder; &#125; public Iterable&lt;Integer&gt; postorder() &#123; return postorder; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); DFSGraph dfsGraph = new DFSGraph(graph); dfsGraph.dfs(); System.out.println(dfsGraph.postorder()); &#125;&#125; 打印的结果为 [3, 1, 4, 5, 2, 0] 深度优先遍历的应用联通分量第一个问题是如何求解图中有多少个联通分量。其实这个问题非常的简单，在上面的我们修改 DFS 的小 bug 时就提到，因为有多个联通分量，我们无法遍历完所有图中的节点，所以我们修改了代码 每次当我们在 for 循环中调用一次 dfs 的时候，就说明存在一个联通分量(Connected Component)，所以我们只要在调用 dfs 时统计联通分量的个数就可以，我们使用一个成员变量 ccount 来保存联通分量的个数 import java.util.Arrays;public class CCGraph &#123; private int cccount; private Graph graph; private boolean[] visited; public CCGraph(Graph graph) &#123; this.graph = graph; this.cccount = 0; visited = new boolean[graph.V()]; Arrays.fill(visited, false); &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; // 联通分量个数增加 cccount++; dfs(i); &#125; &#125; &#125; private void dfs(int v) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w); &#125; &#125; &#125; public int getCccount() &#123; return cccount; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); CCGraph ccGraph = new CCGraph(graph); ccGraph.dfs(); int cccount = ccGraph.getCccount(); System.out.println(cccount); // 2 &#125;&#125; 上面的代码与 DFSGraph 类的代码几乎是一致的，只不过统计了联通分量的个数。g.txt 中的内容为： 7 60 10 21 32 52 44 5 对于的图的形状如下： 可见上面的图有两个联通分量。 第二个与联通分量有关的问题是，我们希望得到每个联通分量中有多少个节点，以及分别包含哪些节点，我们可以使用一个 ArrayList 数组保存每个联通分量包含的节点，修改 dfs 如下 import java.util.ArrayList;import java.util.Arrays;@SuppressWarnings(\"all\")public class CCGraph &#123; private int cccount; private Graph graph; private boolean[] visited; // 为什么不使用数组? 因为数组需要事先开辟空间，而我们事先不知道有多少个联通分量 private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists; // 构造函数对成员变量进行初始化 public CCGraph(Graph graph) &#123; this.graph = graph; this.cccount = 0; visited = new boolean[graph.V()]; Arrays.fill(visited, false); lists = new ArrayList&lt;&gt;(); &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; cccount++; // 每增加一个联通分量，新建一个 list 来保存该联通分量中包含的节点 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); lists.add(list); dfs(i, list); &#125; &#125; &#125; private void dfs(int v, ArrayList&lt;Integer&gt; list) &#123; visited[v] = true; // 将节点保存在所在联通分量对应的 list 中 list.add(v); for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, list); &#125; &#125; &#125; public int getCCcount() &#123; return cccount; &#125; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; getCCList() &#123; return lists; &#125; // 判断两个节点是否在同一个联通分量中(是否连接) public boolean isConnected(int v, int w) &#123; for (int i = 0; i &lt; cccount; i++) &#123; ArrayList list = lists.get(i); // 某联通分量中是否同时包含这两个节点 if (list.contains(v) &amp;&amp; list.contains(w)) &#123; return true; &#125; &#125; // 所有的联通分量都不同时包含这两个节点，说明这两个节点不在同一个联通分量中 return false; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); CCGraph ccGraph = new CCGraph(graph); ccGraph.dfs(); int cccount = ccGraph.getCCcount(); System.out.println(cccount); // 2 // 打印出联通分量 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = ccGraph.getCCList(); for (int i = 0; i &lt; cccount; i++) &#123; // 获得每个联通分量对应的 list，里面保存了该联通分量包含的节点 ArrayList&lt;Integer&gt; list = lists.get(i); // 打印出联通分量中包含的节点 System.out.print(i + \": \"); for (int v: list) &#123; System.out.print(v + \" \"); &#125; System.out.println(); &#125; System.out.println(ccGraph.isConnected(0, 5)); // true System.out.println(ccGraph.isConnected(0, 6)); // false &#125;&#125; 上述的打印结果为 20: 0 1 3 2 4 5 1: 6 truefalse 路径问题所谓的路径问题就是求两个节点之间是否有路径，这个问题很简单，直接使用我们上面的 isConnected 方法就可以知道两个节点之间是否有路径了。不过我们更想知道的是，两个节点之间的路径是什么，即一个节点到达另一个节点会经历哪些节点。 对于下面的一幅图，我们想知道从节点 $0$ 到节点 $5$ 之间的路径 我们需要记录遍历时当前节点的前一个节点，例如遍历节点 $1$ 后会接着遍历节点 $3$，那么节点 $3$ 的前一个节点就是 $1$，通过这些信息就可以知道两个节点之间具体的路径。首先使用 DFS 图，在遍历的过程中记录信息，如下 在上面我们从节点 $0$ 开始遍历，在遍历的过程中我们记录了当前节点之前的节点，最后得到这么一个结果 现在我们想知道节点 $0$ 是如何到达节点 $5$ 的，直接逆推就可以知道路径为 $5 \\leftarrow 4 \\leftarrow 2 \\leftarrow 0$，如下 这个算法可以求得节点 $0$ 与任何一个节点之间的路径，但是不能求得任意两点之间的路径，因为我们是从节点 $0$ 开始遍历的，如果我们想求得节点 $4$ 与节点 $5$ 之间的路径，那么我们需要从节点 $4$ 开始遍历，所以我们这种算法只能求解单源路径(Single Source Path) 问题。 在编程实现方面，我们使用一个 pre 数组来保存当前节点的前一个节点，例如，pre[3] = 1 就表示节点 $3$ 的前一个节点是节点 $1$ import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class SingleSourcePath &#123; private Graph graph; private boolean[] visited; private int[] pre; // 从节点 s 开始遍历 private int s; public SingleSourcePath(Graph graph, int s) &#123; this.graph = graph; this.s = s; visited = new boolean[graph.V()]; Arrays.fill(visited, false); pre = new int[graph.V()]; Arrays.fill(pre, -1); // 默认认为源的前一个节点为自己，这个值访问不到，可以是任何值 dfs(s, s); &#125; private void dfs(int v, int parent) &#123; visited[v] = true; pre[v] = parent; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, v); &#125; &#125; &#125; public boolean isConnected(int t) &#123; // 如果 pre[t] != -1，说明遍历到了该节点，则该节点与源节点是联通的 return pre[t] != -1; &#125; public Iterable&lt;Integer&gt; path(int t) &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); // 如果不是联通的，直接返回 if (!isConnected(t)) return path; int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); SingleSourcePath singleSourcePath = new SingleSourcePath(graph, 0); System.out.println(singleSourcePath.path(5)); &#125;&#125; 其中 g.txt 为 7 60 10 21 32 52 44 5 对应的图就是上面的动图，输出为 [0, 2, 4, 5] 假设现在我们只想求源点 $s$ 到点 $t$ 之间的路径，而不是 $s$ 到任意一个点的路径，很明显我们的要求降低了，这意味着我们记录的信息更少，那我们算法可不可以加快呢? 当然可以，在上面我们求解源点 $s$ 到任意一点的路径，所以需要对源点 $s$ 所在的联通分量做 $DFS$，需要遍历联通分量中所有的节点，但是现在我们只需要求解到固定点 $t$ 的路径，我们不需要完整的做一遍 $DFS$，当我们遍历到节点 $t$ 时，就已经可以退出遍历了，提前终止遍历可以获得更快的性能。 假设我们需要求解源点 $0$ 到节点 $1$ 的路径 在编码上，在我们在设计 dfs 函数时，我们需要返回一个布尔值，代表是否已经找到节点 $t$，如果已经找到，我们就不需要做后续的遍历了，直接终止遍历 import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class Path &#123; private Graph graph; private boolean[] visited; private int[] pre; private int s; private int t; public Path(Graph graph, int s, int t) &#123; this.graph = graph; this.s = s; this.t = t; visited = new boolean[graph.V()]; Arrays.fill(visited, false); pre = new int[graph.V()]; Arrays.fill(pre, -1); dfs(s, s); &#125; private boolean dfs(int v, int parent) &#123; visited[v] = true; pre[v] = parent; // 如果已经找到，直接返回，不再继续遍历 if (v == t) &#123; return true; &#125; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; // 如果在某相邻节点的深度优先遍历中找到节点 t，不再继续遍历其他相邻节点，提前返回 if (dfs(w, v)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean isConnected() &#123; return visited[t]; &#125; public Iterable&lt;Integer&gt; path() &#123; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); if (!isConnected()) &#123; return path; &#125; int cur = t; while (cur != s) &#123; path.add(cur); cur = pre[cur]; &#125; path.add(s); Collections.reverse(path); return path; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); Path path = new Path(graph, 0, 3); System.out.println(Arrays.toString(path.visited)); System.out.println(path.path()); &#125;&#125; 输出为 [true, true, false, true, false, false, false][0, 1, 3] 从打印结果可以看出，我们并没有遍历所有的节点，这样提前终止遍历可以提高查找的速度。 无向图的环检测我们怎么判断一幅图有没有环呢? 很简单，我们使用深度优先遍历，当访问到某节点时，如果该节点的某邻接节点已经被访问过，并且该邻接节点不是它的上一个节点，那么就说明该图中包含一个环 明白这一点以后我们就可以编写代码了 import java.util.Arrays;public class CircleDetection &#123; private Graph graph; private boolean[] visited; private boolean hasCircle; public CircleDetection(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; Arrays.fill(visited, false); hasCircle = false; &#125; public void dfs() &#123; // 任一联通分量中有环，那么图中就有环 for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; dfs(i, i); &#125; &#125; &#125; private void dfs(int v, int parent) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; dfs(w, v); // 进入下面的 if 判断就说明 w 已经访问过了 // 如果 w 不是它的上一个节点，说明有环 &#125; else if (w != parent)&#123; hasCircle = true; &#125; &#125; &#125; public boolean hasCircle() &#123; return this.hasCircle; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g.txt\"); CircleDetection circleDetection = new CircleDetection(graph); circleDetection.dfs(); System.out.println(circleDetection.hasCircle()); // true &#125;&#125; 其中 g.txt 的内容如下 7 60 10 21 32 52 44 5 所对应的图如下 如果我们将节点 $2$ 和 $5$ 之间的边断开，那么图中是没有环的，新建 g2.txt 如下 7 50 10 21 32 44 5 Graph graph2 = new AdjSet(\"g2.txt\");CircleDetection circleDetection2 = new CircleDetection(graph2);circleDetection2.dfs();System.out.println(circleDetection2.hasCircle()); // false 另外，我们可以提前返回进行优化，如果我们已经找到了环，那么我们可以提前终止，后面就不需要继续查找了，我们修改 dfs 的返回值为 boolean 类型，这时 dfs 函数的含义就是从顶点 $v$ 开始，判断图中是否有环 public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; if (dfs(i, i)) &#123; hasCircle = true; // 不用查找其他联通分量了 break; &#125; &#125; &#125;&#125;private boolean dfs(int v, int parent) &#123; visited[v] = true; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; if (dfs(w, v)) &#123; // 如果已经在某相邻节点中找到环，不用再遍历其他的相邻节点 return true; &#125; &#125; else if (w != parent)&#123; // 如果已经找到环，不用继续向后遍历 return true; &#125; &#125; return false;&#125; 二分图检测在这个小节我们来看一个二分图检测的问题，那么问题来了，什么叫二分图呢? 二分图需要满足一下两个特点： 图中的节点被划分为两部分 图中的边连接的是两个部分的节点 在上图中，节点 $0, 3, 4, 5$ 是一部分，节点 $1, 2, 6$ 是一部分，两部分的节点我使用不同的颜色进行填充；且图中所有的边都连接的是两个部分的节点。很明显上面的图满足二分图的两个特点，所以上面的图是一个二分图，那接下来的问题是如何检测一个图是否是一个二分图呢? 首先明白下面两个图是等价的 但是我们很难从右边的图中分辨出两部分的节点。 解决这个问题的关键是图中的所有边连接的是两个不同部分的节点，如果我们将对图进行深度优先遍历的过程中对节点染色，相同部分的节点染为一个颜色，因为所有的边都连接的是不同部分的节点，这意味着任意节点的邻接节点的颜色和自己都是不同的。 我们在遍历时将所有邻接节点的颜色染为和自己不一样，但是如果邻接节点已经染色，并且染的颜色和自己相同，与二分图的定义冲突，那么说明不是一个二分图，反之邻接节点染的颜色和自己不同，则继续遍历，如果遍历完整个图时都没有冲突，那么说明这个图就是一个二分图 代码如下： import java.util.Arrays;public class BinaryPartitionDetection &#123; private Graph graph; private boolean[] visited; // 以 0 1 表示不同颜色 private int[] colors; // 表示该图是否为二分图 private boolean isBipartite; public BinaryPartitionDetection(Graph graph) &#123; this.graph = graph; visited = new boolean[graph.V()]; Arrays.fill(visited, false); // 初始化 colors 为 -1，表示未染色 colors = new int[graph.V()]; Arrays.fill(colors, -1); isBipartite = true; &#125; public void dfs() &#123; for (int i = 0; i &lt; visited.length; i++) &#123; if (!visited[i]) &#123; // 如果在某联通分量中检测到不是二分图，不需要检测其他联通分量 if (!dfs(i, 0)) &#123; isBipartite = false; break; &#125; &#125; &#125; &#125; private boolean dfs(int v, int color) &#123; visited[v] = true; // 染色 colors[v] = color; for (int w: graph.adj(v)) &#123; if (!visited[w]) &#123; // 0 =&gt; 1 - color = 1 // 1 =&gt; 1 - color = 0 // 如果已经在遍历某邻接节点的过程中检测到不是二分图，不需要遍历其他邻接节点 if (!dfs(w, 1 - color)) &#123; return false; &#125; // 进入 else if 表示该节点已经被访问过 // 如果该节点的颜色与它的邻接节点相同，说明不是二分图，后面节点无需遍历 &#125; else if (colors[v] == colors[w]) &#123; return false; &#125; &#125; return true; &#125; public boolean isBipartite() &#123; return isBipartite; &#125; public static void main(String[] args) &#123; Graph graph = new AdjSet(\"g3.txt\"); BinaryPartitionDetection binaryPartitionDetection = new BinaryPartitionDetection(graph); binaryPartitionDetection.dfs(); System.out.println(binaryPartitionDetection.isBipartite()); // true &#125;&#125; 其中 g3.txt 的内容如下 7 60 10 21 32 42 54 6 所表示的图如下，与动图中的图相同 在上面的实现中也使用了提前终止的技术，使用该技术可以很方便的提前终止遍历，提高程序的性能。","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"向Hexo博客中插入Jupyter Notebook","date":"2020-10-27T16:05:42.000Z","path":"/向 Hexo 博客中插入 Jupyter Notebook/","text":"因为 Python 的笔记使用 Jupyter Notebook 进行记录十分的方便，并且 Jupyter Notebook 本身也支持 Markdown 的语法，所以在学习 Python 有关的内容时我喜欢使用 Jupyter Notebook 进行记录，但是一般我的笔记都分布在 Hexo 博客中，但是 Hexo 博客只能解析 Markdown，所以如何将 Jupyter Notebook 整合到 Hexo 博客中成了我的一大难题，经过几次的折腾，算是比较完美的解决了我的需求。 下面介绍我依次使用的方法 将 Jupyter Notebook 转 Markdown 文件 将 Jupyter Notebook 上传到 Github 上，然后通过 nbviewer.jupyter.org 查看，然后使用 iframe 插入到页面中 将 Jupyter Notebook 转为 HTML，上传到 Github(Gitee)，启动 Github(Gitee) Page 服务，通过 iframe 引入 HTML 页面进行插入 转为Markdown 通过上图方法将 jupyter notebook 转为 Markdown，然后放在 _post 目录下即可。转换出来的 Markdown 文件肯定跟 notebook 中的样式有所不同的，所以还要花时间调一下，不过相比 Jupyter Notebook 还是很丑。 上传到Github将 .ipynb 文件上传到 Github 中，然后复制文件在 Github 中的链接，例如 https://github.com/LastKnightCoder/numpy-note/blob/main/numpy%E5%85%A5%E9%97%A8.ipynb 然后打开 https://nbviewer.jupyter.org/ 然后回车，进入查看页面，复制该页面的链接 然后在 Markdown 文件中使用 iframe 标签引用该链接，如 &lt;iframe src=\"https://nbviewer.jupyter.org/github/LastKnightCoder/numpy-note/blob/main/numpy%E5%85%A5%E9%97%A8.ipynb\" width=\"100%\" height=\"600\"&gt;&lt;/iframe&gt; 效果如下 效果还不错，除了文档的开头和结尾有 nbviewer 的标志。 转为HTML插入上面的第二种方法我已经比较满意了，但是 Jupyter Notebook 的样式改变不了，例如字体，我对字体的要求还是比较高的。 目前我又找到一种更好的办法，可以更好的满足我的需求，那就是将 Jupyter Notebook 转为 HTML 文件，因为在 HTML 文件中可以引入自定义的样式，这样就可以对文档的样式进行更改，从而达到我的要求，首先将文件下载为 HTML 文件 因为下载的 HTML 文件会默认的引用当前目录下的 custom.css 的样式，所以我们只要在 HTML 文件所在的目录下新建 custom.css 文件即可修改样式了。 接下来就是如何将这个 HTML 文件插入到 Markdown 文件中了，当然还是使用 iframe 标签进行插入。首先我们将 HTML 文件及 custom.css 文件上传到 Gitee 的一个仓库中，然后启动 Gitee Page 服务，接着我们就可以访问该 HTML 文件了，例如可以通过 https://lastknightcoder.gitee.io/jupyter-for-iframe/numpy%E5%85%A5%E9%97%A8.html 访问我上传的 HTML 文件，接着我们就在 iframe 中引用即可 &lt;iframe src=\"https://lastknightcoder.gitee.io/jupyter-for-iframe/numpy%E5%85%A5%E9%97%A8.html\" width=\"100%\" height=\"600\"&gt;&lt;/iframe&gt; 效果如下 可见我对样式进行了修改，不过还有一个地方令我不满意的就是嵌入的 iframe 有滚动条，对于一个有强迫症的人来说真的很难受，我想到使用 jQuery 来获得页面的高度，然后将 iframe 的 height 值设为该高度 +50 作用即可，通过在生成的 HTML 文件的最后加入下面的脚本就可以获得文档的高度 &lt;script&gt; let script = document.createElement(\"script\"); script.src = \"https://cdn.bootcdn.net/ajax/libs/jquery/2.1.0/jquery.min.js\"; script.text = \"text/javascript\"; document.body.append(script); console.log($(\"#notebook\").height())&lt;/script&gt; 例如我获得的高度为 7191，我将高度设置 7200 就没有滚动条了，如下 &lt;iframe src=\"https://lastknightcoder.gitee.io/jupyter-for-iframe/numpy%E5%85%A5%E9%97%A8.html\" width=\"100%\" height=\"7200\"&gt;&lt;/iframe&gt; 从此就可以安心的使用 Jupyter Notebook 写程序了。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Hexo/"}]},{"title":"操作numpy数组","date":"2020-10-27T16:00:00.000Z","path":"/操作numpy数组/","text":"文章是使用 jupyter 写的，为了插入到博客中，使用 iframe 进行嵌入，所以阅读体验可能不是很好","tags":[{"name":"numpy","slug":"numpy","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/numpy/"}]},{"title":"2020-10 学习总结","date":"2020-10-27T09:50:00.000Z","path":"/2020-10 学习总结/","text":"目前来到哈工大一个半月了，简单的总结这一个半月完成了哪些工作： Java Java 并发编程 黑马的视频，看完了 感觉这个老师讲的特别的好，学到了很多东西，强烈推荐 JVM(上篇) 尚硅谷的视频，看完了 SpringBoot 框架入门 看了多个机构的视频，最终产出入门博客一篇 《Spring揭秘》 这本书是一本 Spring 进阶的书，感觉收获很多，目前看完一半以上，后续的内容有点吃力，目前打算重新看一遍 图论 在暑假期间把波波老师的图论看完了，目前打算把博客写出来，目前已经快完成图的深度优先遍历的所有内容了 感觉自己真的变强了，解一些算法题感觉开始有点想法了，并且看别人的题解终于能够静下心去看懂了 机器学习与深度学习 《Python深度学习》(keras作者写的书) 除了循环神经网络没看懂，其他都看完了，收获还是蛮大的 《深度学习…》 日本人写的一本书，零基础的写一个深度学习程序，里面关于一些优化的技巧让我收获很大 《动手学深度学习(Pytorch版)》 这是网上教程，也可以看做是一本书了，目前快看完第三章了 动手学深度学习是我毕设那会看的，当时出于电脑原因，没能继续学下去，现在再看一遍，感觉收获很多 《机器学习》 大名鼎鼎的西瓜书，感觉内容很偏数学，看起来挺吃力的，目前看完了第三章 《numpy…》 看了一本印度人写的 numpy 的一本书，整本书感觉大部分都在分析金融数据，不太习惯，看完后总结了里面与 numpy 有关的内容，做成了思维导图 现在打算根据思维导图写出四篇博客，目前完成一篇，第二篇也完成一半以上，感觉本周能写完 前端 《jQuery实战》 这本书是我第二次看了，这次花了两天快速的过了一遍，感觉使用 jQuery 真的是很方便 之前写过一篇博客，感觉不太好，最近希望拿出来改改 BootStrap 连续花了三天，肝完了 BootStrap 的官方文档，发现文档写的真的很不错 这个就不打算写博客了，因为官方文档写的很好 《JavaScript高级程序设计》 看完了这本书，收获也蛮大的，特别是对 DOM 以及 BOM 这一块 归纳了四五张思维导图，以及写了两篇博客，未来计划根据思维导图在肝几篇博客 这本书对于高级内容还是比较少了，目前在图书馆借到了《JavaScript忍者秘籍》，这本书在寒假看完了，觉得写的非常好，是关于JavaScript以及浏览器的高级内容，打算根据这本书归纳几个思维导图以及几篇博客 《CSS揭秘》 这本书的评价很高，目前看完了第一部分 这本书内容还是比较高级，理解了的话肝几篇博客 《HTML5实战》 目前看了这本书有关 video/audio 那一章节的内容，有点收获 echarts 和 React 王鹏伟老师给了一些 UI 图，现在想用 React 仿出来，为此特意学习了 echarts echarts 的官网现在也看了三遍了吧，对于 echarts 的使用感觉已经蛮熟练了，但是感觉 echarts 组织数据的方式不太舒服(主要是没有搞懂它的默认值选择) 专业相关 天线 因为老师上课老叫我，所以这门课真的是我读大学以来听的最认真的课了 因为没有天线基础，很多东西其实都不懂，不过我觉得我能听懂的我都听懂了，并且印象深刻 数值分析 老师讲课风格偏数学，其实我只关心怎么实现以及推导思路，具体推导不太关心 目前看了《数值分析》这本书的前五章，看了两遍，内容大致都会了 我对数值分析还是蛮感兴趣的 其他 计算机组成原理 刷完了慕课上哈工大的计算机组成原理的视频 这个视频我在大二学习微机原理的时候看过一次，这次再看一遍，就是为了补计算机基础 温习一遍，将之前搞不懂的除法运算过程搞懂了(真的觉得自己变强了) 这门课老师讲的真的很好，推荐 C语言 在《剑指offer》一直看到指针，当时指针半吊子水平，没学明白，搞不太懂，现在突然想把它搞懂 看了翁恺男神的 C 语言课程，这次看起来感觉毫无压力，配上老师磁性的声音，不知不觉将指针搞懂了，接着就用 C 语言手写几个排序算法(冒泡、选择、插入、归并、快速) 《我的第一本Docker书》 基本的了解了一下 Docker，对于容器、镜像等概念有了进一步的认识 以及了解了 Dockerfile 里面的一些命令 Linux 看了千锋的视频，废话实在太多，进度非常慢，目前看了 6 个视频左右","tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"numpy 入门","date":"2020-10-19T16:00:00.000Z","path":"/numpy入门/","text":"文章是使用 jupyter 写的，为了插入到博客中，使用 iframe 进行嵌入，所以阅读体验可能不是很好","tags":[{"name":"numpy","slug":"numpy","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/numpy/"},{"name":"ndarray","slug":"ndarray","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/ndarray/"}]},{"title":"图的表示","date":"2020-10-07T16:00:00.000Z","path":"/图的表示/","text":"首先我们来看看图的数据结构长什么样子 一个图它由顶点 Vertex 和边 Edge 组成，上图蓝色的节点表示顶点，而节点与节点之间的有条线连着，这就是顶点之间的边。为了在计算机中表示图，我们给图的顶点编了号，从 $0$ 开始。在实际的模型中，顶点可能表示的是一个地铁站点，社交网络中的一个人，我们可以通过哈希表将编号与顶点实际的意义映射起来，进而把顶点的具体意义抽象为编号或者下标，当图的顶点以编号表示时，它就不具有具体的意义，从而我们可以研究图的一般理论，而当我们需要结论的具体意义时，可以通过哈希表将编号映射为具体的意义。 图的分类根据边是否有方向可以分为有向图和无向图，根据边上有否有权值可以分为有权图和无权图 有向 无向 有权 有向有权图 无向有权图 无权 有向无权图 无向无权图 图的基本概念在进入正题之前，简单的介绍一下在后面会遇到的关于图的基本概念。 自环边：图中有一个顶点有条边指向自己 平行边：两个顶点之间有两条边 如果一幅图既没有自环边，也没有平行边，我们就称该图为简单图。我们只处理简单图，如果图中有自环边或者平行边，我们会忽略这种边，或者抛出异常。 在一个图中，并不是所有的顶点都是联通的，如下 例如顶点 6-7 和顶点 0-5 之间是不联通的，像上面这样的图，我们认为它有两个联通分量，顶点 0-5 和顶点 6-7 分别代表一个联通分量。 另外，根据图中是否有环，我们可以将图分为有环图和无环图 最后介绍一个有关图的概念，那就是度(degree)，对于无向图和有向图，度的定义是不同的，这里我们介绍无向图关于度的定义，度指的是某个顶点有多少个邻边，度是顶点的属性。比如对于下图 顶点 $0$ 的度为 $2$，因为顶点 $0$ 有两个邻边，同理，顶点 $2$ 的度为 $3$，因为它有三个邻边。 图的表示所谓图的表示，就是指如何在计算机中保存一个图的数据结构 如上图，怎么将它保存在计算机中。如果学习过其他数据结构的话，如栈，队列，树，它们是怎么表示的呢? 对于栈和队列这种线性的数据结构，我们一般使用数组或者链表来进行存储，而对于树这种数据结构，我们一般使用链表进行表示，每个节点都有两个指针分别指向它的左孩子和右孩子，当然对于某些树结构，如堆、线段树，我们也可以使用数组来进行表示，因为这两种数据结构都是满二叉树，它们的孩子节点与父节点之间含有某种关系，可以十分方便的使用数组进行表示。 邻接矩阵首先我们介绍使用一个矩阵来存储图，如果整个图有 $V$ 个节点，那么我们就用 $V \\times V$ 大小的矩阵来存储图，假设这个矩阵记做 $A$，如果 $A[i][j] = 1$，则说明顶点 $i$ 与顶点 $j$ 之间存在一条边，反之如果 $A[i][j] = 0$，则说明顶点 $i$ 与顶点 $j$ 之间不存在一条边 因为不存在自环边，所以 $A[i][i]$ 的值一定为 $0$，即矩阵对角线上的值一定是 $0$。 在构建一张图时，我们会读取一个 txt 的文件，根据这个文件我们使用矩阵来存储一张图，例如上图所对应的 txt 内容如下 6 70 10 21 32 32 43 54 5 这个 txt 表示什么意思呢? 第一行的两个数字表示图中的顶点数和边数，如上图有 $6$ 个顶点和 $7$ 条边，后面每行的两个数字表示两个顶点，表示这两个顶点之间存在一条边，如第二行就表示顶点 $0$ 和顶点 $1$ 之间存在一条边，因为总共有 $7$ 条边，所以第一行后应该有 $7$ 行表示有 $7$ 条边。 代码如下： import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;public class AdjMatrix &#123; // 图的边数 private int E; // 图的顶点个数 private int V; // 表示图的矩阵 private int[][] matrix; public AdjMatrix(String filename) &#123; // 从文件中读取图的数据 File file = new File(filename); Scanner scanner = null; try &#123; // 第一行是顶点数和边数 scanner = new Scanner(file); this.V = scanner.nextInt(); matrix = new int[this.V][this.V]; this.E = scanner.nextInt(); for (int i = 0; i &lt; this.E; i++) &#123; // 读取两个相邻的顶点 int a = scanner.nextInt(); int b = scanner.nextInt(); // 设置为 1 表示相邻 this.matrix[a][b] = 1; this.matrix[b][a] = 1; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; // 当打印对象时，将矩阵打印出来 @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int i = 0; i &lt; this.V; i++) &#123; for (int j = 0; j &lt; this.V; j++) &#123; stringBuilder.append(String.format(\"%d \", this.matrix[i][j])); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; AdjMatrix adjMatrix = new AdjMatrix(\"g.txt\"); System.out.println(adjMatrix); &#125;&#125; 打印结果为 V: 6, E: 70 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 1 0 0 1 1 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 AdjMatrix 类有三个属性 属性 含义 V 表示顶点数 E 表示边数 matrix 表示图的矩阵 但是上面的程序还不够健壮，因为我们没有对 g.txt 中读到的数字进行校验，例如读到的顶点个数为负数，读到的顶点编号不合理，例如有 $5$ 个顶点，但是它的编号为 $10$。另外，我们只处理简单图，对于自环边以及平行边也没有进行处理，所以我们需要对上面的代码进行改进 import java.io.File;import java.io.FileNotFoundException;import java.util.ArrayList;import java.util.Scanner;public class AdjMatrix &#123; private int E; private int V; private int[][] matrix; public AdjMatrix(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); // 如果读取到的 V 和 E 小于 0，那么抛出异常 this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; matrix = new int[this.V][this.V]; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; for (int i = 0; i &lt; this.E; i++) &#123; // 对读取到的顶点编号进行验证，是否在 [0, V) 的范围中 int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); // 如果存在自环边，抛出异常 if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; // 如果存在平行边，抛出异常 if (this.matrix[a][b] == 1) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; this.matrix[a][b] = 1; this.matrix[b][a] = 1; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; // 对顶点编号进行验证，是否合法 private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; // 返回顶点数 public int V() &#123; return this.V; &#125; // 返回边数 public int E() &#123; return this.E; &#125; // 返回与顶点 v 相邻的所有顶点 public ArrayList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; this.V; i++) &#123; if (this.matrix[v][i] == 1) &#123; res.add(i); &#125; &#125; return res; &#125; // 判断顶点 v 和 w 是否相邻 public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return this.matrix[v][w] == 1; &#125; // 返回顶点 v 的度，即与顶点 v 相邻的顶点的个数 public int degree(int v) &#123; return adj(v).size(); &#125; // toString 不变，节省篇幅，省略&#125; 在上面我们对读取到的数字都进行了检查，保证了代码的健壮性。除了增强了代码的健壮性以外，我们还在类中添加了五个方法，具体作用见下表 方法 作用 int V() 返回图的顶点数 int E() 返回图的边数 ArrayList adj(int v) 返回与顶点 v 相邻的顶点 boolean hasEdge(int v, int w) 判断两顶点是否相邻 int degree(int v) 返回顶点 v 的度 在最后我们分析一下使用邻接矩阵表示的空间复杂度和时间复杂度： 空间复杂度：$O(V^2)$ 时间复杂度： 建图：$O(E)$ 获得与顶点 $v$ 相邻的顶点：$O(V)$ 查看两个顶点是否相邻：$O(1)$ 对于建图来说，因为我们必须扫描所有的边才能获得必要的信息，所以建图的时间复杂度最少也是 $O(E)$，无法再优化；而查看两个顶点是否相邻，时间复杂度为 $O(1)$，无需优化，那么我们看看空间复杂度和获得与顶点 $v$ 相邻的顶点的时间复杂度能否进行优化。 因为我们平常遇到的图都是稀疏图，所谓稀疏图就是一幅图它的度平均值对于图的节点数目来说很小，这就会导致我们的邻接矩阵是一个稀疏矩阵，即大部分的元素是 $0$。例如对于一个社交网络，有一亿个节点，但是对于每个人来说，他认识的人最多几百个，也就是这幅图平均的度为几百，相对于一亿来说十分的小，所以社交网络是一个稀疏图。 建立一个图，我们只需要知道一幅图的顶点信息以及边的信息即可，也就是说我们只需要 $O(V + E)$ 的空间复杂度就可以表示一幅图，对于稀疏图来说，由于图的每个顶点度的平均值远远小于节点数，而 $E$ 的大小等于平均度的值乘以节点数，即$$E = degree * V$$从而有$$degree \\ll V \\Rightarrow E \\ll V^2$$得到$$O(V + E) \\ll O(V^2)$$所以使用邻接矩阵表示图，对于稀疏矩阵来说，其实浪费了很多的空间，下面将介绍使用另一种方法表示图，无论是对于稀疏图还是稠密图，都可以有更好的性能。 邻接表在这个小节中将讲解使用邻接表来表示矩阵，所谓的邻接表，是指对于每个顶点来说，我们使用一个链表来记录与它相邻的节点，如下图 图中表格第一列表示顶点编号，顶点编号后的一行表示与该顶点相邻的顶点，例如对于第一行，表示与顶点 $0$ 相邻的顶点有顶点 $1$ 和 $2$。 现在我们就要编码实现，因为大部分的逻辑与邻接矩阵是相同的，所以很多的代码与邻接矩阵表示的方式是一样的，不过因为底层保存图使用的是链表，有一些写法的不同，在下面的代码中我也会标出 import java.io.File;import java.io.FileNotFoundException;import java.util.LinkedList;import java.util.Scanner;public class AdjList &#123; private int E; private int V; // 对每一个顶点，使用一个链表来存储与它相邻的顶点 private LinkedList&lt;Integer&gt;[] lists; public AdjList(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; // 初始化链表 this.lists = new LinkedList[this.V]; for (int i = 0; i &lt; this.V; i++) &#123; this.lists[i] = new LinkedList&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; for (int i = 0; i &lt; this.E; i++) &#123; int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; // 平行边的判断 if (lists[a].contains(b)) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; // 将相邻顶点添加到自己的链表中 this.lists[a].add(b); this.lists[b].add(a); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public LinkedList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); // 直接返回顶点自己的链表即可 return lists[v]; &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return this.lists[v].contains(w); &#125; public int degree(int v) &#123; return adj(v).size(); &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (int w: adj(v)) &#123; stringBuilder.append(String.format(\"%d \", w)); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; AdjList adjList = new AdjList(\"g.txt\"); System.out.println(adjList); &#125;&#125; 输出为 V: 6, E: 70 : 1 2 1 : 0 3 2 : 0 3 4 3 : 1 2 5 4 : 2 5 5 : 3 4 下面分析一下使用邻接表实现图的时间复杂度和空间复杂度： 空间复杂度：$O(V + E)$ 时间复杂度： 建表：$O(VE)$ 获得与顶点 $V$ 相邻的顶点：$O(degree)$ 判断两个顶点是否相邻：$O(degree)$ 建表的时间复杂度为 $O(VE)$，是因为每次我们都要扫描一遍表判断是否有平行边，判断两个顶点是否相邻的时间复杂度为 $O(degree)$，是因为需要遍历表来判断两个顶点是否相邻。上面两个操作都比使用邻接矩阵实现图的操作更加的费时，都是因为查找的能力比较慢(在建图时需要查重判断是否有平行边，判断两个顶点是否相邻时也需要在链表中进行查找)，所以我们是否有办法可以提高查找表的速度。 说到查找速度，不得不说哈希表和红黑树，所以我们可以考虑使用 HashSet 或者 TreeSet 来替代上面的 LinkedList，以此来提高查找速度，二者查找的时间复杂度如下 数据结构 查找时间复杂度 HashSet $O(1)$ TreeSet $O(\\log v)$ 从时间复杂度上看，使用 HashSet 是更好的选择，但是 TreeSet 有一个优点那就是有序性，这会带来两个优点 复现我的代码时可以得到与我一致的结果(输出的顺序) 当我使用图片解释算法过程时，输出的结果可以与我演示的结果一致，可以更好的理解算法 所以这里我选择 TreeSet。我们新建一个 AdjSet 类，复制 AdjList 的代码，将其中所有的 LinkedList 改为 TreeSet 即可，如下 import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;import java.util.TreeSet;public class AdjSet &#123; private int E; private int V; private TreeSet&lt;Integer&gt;[] sets; public AdjSet(String filename) &#123; File file = new File(filename); Scanner scanner = null; try &#123; scanner = new Scanner(file); this.V = scanner.nextInt(); if (this.V &lt; 0) &#123; throw new IllegalArgumentException(\"V Must Be Positive\"); &#125; // 初始化链表 this.sets = new TreeSet[this.V]; for (int i = 0; i &lt; this.V; i++) &#123; this.sets[i] = new TreeSet&lt;&gt;(); &#125; this.E = scanner.nextInt(); if (this.E &lt; 0) &#123; throw new IllegalArgumentException(\"E Must Be Positive\"); &#125; for (int i = 0; i &lt; this.E; i++) &#123; int a = scanner.nextInt(); validateVertex(a); int b = scanner.nextInt(); validateVertex(b); if (a == b) &#123; throw new IllegalArgumentException(\"Self loop exists\"); &#125; // 平行边的判断 if (sets[a].contains(b)) &#123; throw new IllegalArgumentException(\"Parallel edge exists\"); &#125; // 将相邻顶点添加到自己的链表中 this.sets[a].add(b); this.sets[b].add(a); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; assert scanner != null; scanner.close(); &#125; &#125; private void validateVertex(int v) &#123; if (v &lt; 0 || v &gt;= this.V) &#123; throw new IllegalArgumentException(\"Vertex \" + v + \" is invalid\"); &#125; &#125; public int V() &#123; return this.V; &#125; public int E() &#123; return this.E; &#125; public TreeSet&lt;Integer&gt; adj(int v) &#123; validateVertex(v); // 直接返回自己的链表即可 return sets[v]; &#125; public boolean hasEdge(int v, int w) &#123; validateVertex(v); validateVertex(w); return this.sets[v].contains(w); &#125; public int degree(int v) &#123; return adj(v).size(); &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format(\"V: %d, E: %d\\n\", this.V, this.E)); for (int v = 0; v &lt; this.V; v++) &#123; stringBuilder.append(String.format(\"%d : \", v)); for (int w: adj(v)) &#123; stringBuilder.append(String.format(\"%d \", w)); &#125; stringBuilder.append(\"\\n\"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; AdjSet adjSet = new AdjSet(\"g.txt\"); System.out.println(adjSet); &#125;&#125; 在最后我们做一个改进，观察三个类的 adj 方法 // AdjMatrixpublic ArrayList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; this.V; i++) &#123; if (this.matrix[v][i] == 1) &#123; res.add(i); &#125; &#125; return res;&#125;// AdjListpublic LinkedList&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return lists[v];&#125;// AdjSetpublic TreeSet&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return sets[v];&#125; 这三个方法的返回值都不相同，这就会给使用者带来负担，它还需要记住每个类的返回值是什么，考虑到使用者拿到与顶点 $v$ 相邻的所有顶点，一般都是用来遍历，所以我们返回一个接口 Iterable，ArrayList LinkedList TreeSet 三个类都实现了该接口，如下 // AdjSet 其它两个类做相同修改public Iterable&lt;Integer&gt; adj(int v) &#123; validateVertex(v); return sets[v];&#125; 注意：记得还有修改 degree 方法，因为这是 adj 方法返回的是 Iterable 接口，该接口没有 size 方法，修改如下 public int degree(int v) &#123; validateVertex(v); return this.sets[v].size();&#125; 其它两个类做类似的修改。 总结在文章的最后，我们比较一下三种方法的空间复杂度和时间复杂度 空间 建图时间 两顶点是否相邻 查找顶点的邻边 邻接矩阵 $O(V^2)$ $O(E)$ $O(1)$ $O(V)$ 邻接表(LinkedList) $O(V + E)$ $O(EV)$ $O(degree)$ $O(degree)$ 邻接表(TreeSet) $O(V + E)$ $O(E\\log V)$ $O(\\log degree)$ $O(degree)$ 由上可见，底层使用 TreeSet 的邻接表来表示图，从空间和时间上都非常的优秀，在后面的文章，都将使用 TreeSet 版本的邻接表来表示图。 后面为了屏蔽差异，我们定义一个 Graph 的接口，这三个类都实现 Graph 接口，Graph 接口如下 public interface Graph &#123; int V(); int E(); int degree(int v); boolean hasEdge(int v, int w); Iterable&lt;Integer&gt; adj(int v);&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"DOM节点","date":"2020-09-29T02:25:00.000Z","path":"/DOM节点/","text":"DOM 的全称为 Document Object Model，翻译为对象文本模型，它是一个针对于 HTML 的 API，它将 HTML 文档描绘为一棵层次化的树，DOM 规范了操作这个文档树的规范，例如添加、删除、移动等等操作。所有的浏览器都实现了(除了早版本的 IE) DOM 规范，这意味着开发人员在所有的浏览器中写的代码都是一样，不同为每一个浏览器写着不同的代码(这就是标准带来的好处)。 下面给出了 HTML 文档翻译成 DOM 树的例子 document 节点是每一个文档的根节点，HTML 文档中的元素都会被转化为 DOM 树中的节点。 NodeDOM 规定了一个 Node 类型的接口，DOM 树上的节点都实现了该类型，因此所有的节点都有着 Node 接口中规定的属性和方法，下面我们就具体介绍一下 Node 类型。 节点信息虽然 HTML 元素以及文本内容都会被转化为节点，但是明显 document 节点，HTML 元素节点，以及文本节点等等它们之间的地位是不一样的，这意味着虽然大家都是 Node 类型的对象，但是却有着不同，每个节点都有着自己的类型，而 nodeType 属性正是用来表明节点类型的。 nodeType 的值为数字类型，根据 nodeType 的值不同，节点类型分为 12 种，如下 Node.ELEMENT_NODE(1) Node.ATTRIBUTE_NODE(2) Node.TEXT_NODE(3) Node.CDATA_SECTION_NODE(4) Node.ENTITY_REFERENCE_NODE(5) Node.ENTITY_NODE(6) Node.PROCESSING_NODE(7) Node.COMMENT_NODE(8) Node.DOCUMENT_NODE(9) Node.DOCUMENT_TYPE_NODE(10) Node.DOCUMENT_FRAGMENT_NODE(11) Node.NOTATION_NODE(12) 看到上面罗列的一大堆节点类型，你内心肯定已经吓尿了，但是上面列出来的节点类型并不是每个都很重要，有的这辈子可能都不会遇到，在本篇文章中只会讲解常用的几种节点类型。 上面这些 Node 常量，与后面对应括号中的数字的值相等，如 Node.ELEMENT_NODE == 1; // true 除了 nodeType 属性以外，我们还可以通过 nodeName 和 nodeValue 来了解节点的信息，这两个属性具体的取值，与具体的节点类型有关，不同类型的 Node 节点，取值有所不同，在后面介绍具体的节点类型时，将会提到它们。 节点关系DOM 树借鉴了家庭族谱的概念，使用父亲、孩子、兄弟等亲属关系来描述节点之间的关系，我们将对如下 DOM 树来描述节点之间的关系 每一个节点都有一个 childNodes 属性，它保存着它的所有子节点，该属性是一个 NodeList 对象，它是一个类数组，我们可以通过数字下标来访问父节点中的某个子节点，但它不是真正的数组。 对于上图来说，div 节点的 childNodes 就是由它的三个子节点 span h1 img 组成的 NodeList，我们可以通过下标是获取它的子节点，例如 div.childNodes[0] ==&gt; spandiv.childNodes[1] ==&gt; h1div.childNodes[2] ==&gt; img 每个节点都有一个 parentNode，该属性的值是该节点的父节点，例如对于上图，span h1 img 的父节点都是 div 节点，即 span.parentNode == h1.parentNode == img.parentNode == div; 通过节点的 previousSibling 和 nextSibling 属性可以访问该节点的兄弟节点，正如它们名字所暗示的那样，previousSibling 是表示该节点的前节点，nextSibling 表示该节点后一个节点，如果该节点没有前一个节点，那么 previousSibling 的取值为 null，对于 nextSibling 也是同理，如下 h1.previousSibling == span;h1.nextSibling == img;img.nextSibling == null; // img 后面没有节点，所以 nextSibling 属性值为 null 每个节点都有 firstChild 和 lastChild 属性，它们的值分别代表的是该节点的第一个孩子节点和最后一个孩子节点，如果该节点没有子节点，那么这两个属性的值为 null，如下 div.firstChild == span;div.lastChild == img;span.firstChild == null; 每个节点都有一个 ownerDocument 属性，该属性指向该节点所在文档的 document 节点。 下图形象的展示了节点之间的关系 操作节点Node 接口提供了几个方法用以操作节点，包括添加节点，删除节点，移动节点等等。 appendChild该方法接收一个参数，为 Node 类型的节点，而该方法的作用就是将接收的节点添加为最后一个节点 此时新添加的节点为最后一个节点，即 div.lastChild == a; 如果添加的节点是已经存在于文档树中的，那么此时会将该节点移动到最后一个节点，假设有如下的 DOM 树，现在我们将节点 img 添加到 div 的子节点中，那么此时就相当于将 h2 下的 img 移动到 div 下 任何一个节点都只能有一个父节点。 insertBeforeappendChild 方法是将节点插入到最后面，而 insertBefore 则是将节点插入到某个节点之前，所以该方法接收两个参数，第一个参数是要插入的节点，我们将这个节点插入到第二个参数表示的节点的前面 同理，如果添加的节点也在文档树种，那么会将该节点移动，任何一个节点都不可能有两个父节点。 removeChildremoveChild 是用来删除节点的，该方法接收一个参数，就是你要删除的节点，被删除的节点将会作为返回值返回，如下图 被删除的节点仍然属于文档树，但是在文档树中已经没有了它的位置。 replaceChildreplaceChild 参数是用一个节点替换一个节点，所以该方法接收两个参数，新的节点以及被替换的节点 其他方法cloneNodecloneNode 方法从名字可以看出，该方法是将自己克隆一份，并返回。复制后的节点归文档所有，但是没有为该节点指定父节点。 该方法接收一个 bool 类型的参数，当传入为 false 时，表示的是浅复制，当传入的参数为 true 时，表示的是深复制。浅复制只会复制当前节点，不会复制该节点的子节点，而深复制不仅会复制当前节点，并且会复制当前节点下面的子节点。举一个例子，假设有这个一个 HTML 结构 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 当我们对 ul 进行复制，如果是浅复制 let newUl = ul.cloneNode(false); 那么 newUl 为 &lt;ul&gt;&lt;/ul&gt; 里面没有任何的内容，但是如果是深复制的话，则会将其子节点(以及子节点的子节点)也复制过来 let newUl = ul.cloneNode(true); 这时 newUl 为 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; normalize该方法是用来处理节点中的文本节点，它会将空白节点删除，以及将连续的两个文本节点合并为一个文本节点 Document现在介绍文档的根节点 document，它的相关属性如下 属性 值 nodeType 9 nodeName #document nodeValue null 文档信息下面将介绍几个属性，这几个属性包含了文档的一些信息。 titledocument.title 属性保存的是标签 &lt;title&gt; 中的内容，我们可以通过 document.title 获得文档的标题，也可以通过 document.title 来改变文档的标题 let originTitle = document.title; // 获得文档的标题document.title = \"New Page Title\"; // 为文档设置新的标题 下面的三个属性与网页的请求有关 属性 值 URL 页面完整的 URL，与 location.href 的值相同 domain 页面的域名 referrer 链接当前网页的那个页面的 URL，如果没有来源页面，值为空字符串 查找元素document 对象有三个方法可以获得文档树中的节点，它们分别是 getElementById() getElementsByTagName() getElementsByName() 下面就将具体介绍这三个方法。 getElementById该方法根据 id 值来获得文档树中的一个节点，例如对于下面的 HTML 代码 &lt;div id=\"box\"&gt;&lt;/div&gt; 上面的 div 元素有一个 id 属性，它的值为 box，因此我们可以通过下面的代码来获得该节点 let box = document.getElementById(\"box\"); 需要注意的是，如果文档有多个节点它们的 id 相同，当我们使用 getElementById 去查找节点时，会返回第一个匹配的节点。 getElementsByTagName该方法根据标签名来获得文档树中的节点，该方法返回一个 HTMLCollection，与 NodeList 类似，它也是一个类数组，我们可以通过下标来访问该对象包含的元素。 let images = document.getElementsByTagName(\"img\"); // 获得文档中所以的 img 节点 我们获得 images 是一个 HTMLCollection 对象，它除了可以使用下标的形式获得集合中的元素，还可以通过 namedItem 来获得相应的元素，假设文档中有一个 img 如下 &lt;img name=\"img1\" src=\"\" /&gt; 该 img 有一个 name 属性为 img1，那么我们可以通过下面的方式来获得该节点 images.namedItem(\"img1\"); getElementByName该方法是根据 name 属性来获得节点的，该方法返回的是一个 NodeList，一般这个方法是用来取得单选按钮，因为单选按钮必须拥有相同的 name 属性。假设有如下单选按钮 &lt;input type=\"ratio\" value=\"green\" name=\"color\" /&gt;&lt;input type=\"ratio\" value=\"red\" name=\"color\" /&gt;&lt;input type=\"ratio\" value=\"blue\" name=\"color\" /&gt; 我们可以通过下面的方法获得所以的单选按钮 document.getElementsByName(\"color\"); 创建节点我们还可以通过 document 来创建其它类型的节点，如 createElement createTextNode createDocumentFeagment 具体的信息将在后面进行介绍。 ElementElement 类型是 HTML 中的标签所表示的节点类型，如 div h1 标签，它是除 Document 类型外，最常使用的类型。Element 元素提供了对元素标签名、子节点以及 attribute 访问的能力。 有关 Element 类型的信息如下 属性 值 nodeType 1 nodeName 元素标签名(大写)，如 DIV nodeValue null 除了可以通过 nodeName 访问元素的标签名，还可以通过 tagName 访问元素的标签名，二者的返回值是一样的(使用后者主要是为了清晰起见)。 HTMLElement所有的 HTML 元素都由 HTMLElement 表示，HTMLElement 继承自 Element，除此之外，还扩展了几个属性 属性 值 id 元素在文档中的唯一标识符 className 与元素的 class 属性对应 title 元素的附加信息 lang 元素内容的语言代码，很少使用 dir 元素的方向，默认为 ltr(从左往右)，很少使用 attribute下面将介绍有关操作元素 attribute 的有关方法及属性。与 attribute 有关的方法如下 getAttribute setAttribute removeAttribute 这些方法可以对任何 attribute 进行使用，包括 HTMLElement 定义的 attribute 或者自己自定义的 attribute。有如下 HTML 代码 &lt;div class=\"container\" id=\"box\"&gt; &lt;/div&gt; getAttribute 是用来获得节点的 attribute let box = document.getElementById(\"box\");let classValue = box.getAttribute(\"class\"); // container setAttribute 是用来来设置节点的 attribute，如果设置的 attribute，则会进行替换 box.setAttribute(\"class\", \"active\");box.getAttribute(\"class\"); // active removeAttribute 是用来删除节点的 attribute box.removeAttribute(\"class\"); 这个方法不仅会清除 attribute，而且会将 attribute 从元素中彻底删除，所以这个方法不太常用。 除了通过上面的三个方法操作元素的 attribute，还可以通过元素的 attributes 属性来访问元素的 attribute，元素的 attributes 属性是一个 NamedNodeMap，它同 HTMLCollection 和 NodeList 一样，也是一个伪数组，其中存储的是一个个 Attr 节点(没错，元素的 attribute 也是一种节点)；NamedNodeMap 提供以下方法来操作 attribute getNamedItem setNamedItem removeNamedItem item 前面三个方法都根据 Attr 节点的 nodeName 来访问(即 attribute 的名字)来操作 attribute，如 let attributes = box.attributes; // 获得 box 的 attributes 属性let classValue = attributes.getNamedItem(\"class\"); // containerattributes.setNamedItem(\"class\", \"active\");attributes.removeNamedItem(\"class\"); 最后一个方法是根据下标来获得 attributes 中的 Attr 节点，这个方法与通过数组下标的形式获得的结果是一样的 attributes.item(2) == attributes[2]; 创建元素创建元素是属于 document 对象的方法，我们使用 document.createElement 来创建一个元素节点，并且将该元素节点返回，例如 let div = document.createElement(\"div\"); // 创建一个 div 元素节点div.id = \"box\";div.className = \"container\"; 上面我们创建一个 div 节点元素，并且为该节点设置了 id 和 className(即 class 属性)，我们可以通过 appendChild 将该节点添加到文档树中，如 document.body.appendChild(div); Text文本节点使用 Text 类型进行表示，它的相关信息如下 属性 值 nodeType 3 nodeName #text nodeValue 节点所包含的文本 Text 类型的节点没有子节点。我们可以使用下面的方法来操作节点 appendData(text)：向节点中添加文本 text deleteData(offset, count)：从 offset 开始删除 count 个文本 insertData(offset, text)：在 offset 后插入文本 text replaceData(offset, count, text)：从 offset 开始，将 count 个文本替换为 text splitText(offset)：以 offset 为界，将文本分割为两个文本节点，并将第二个文本节点返回 substringData(offset, count)：取得从 offset 开始的 count 个文本 假设有下面的 HTML 代码 &lt;div&gt;Hello World&lt;/div&gt; div 元素节点中有一个文本节点，里面的文本内容为 Hello World let text = div.firstChild; // Text 节点是 div 的第一个子节点text.appendData(\"!\"); // Hello World!text.deleteData(0, 6); // 从 0 开始，删除 6 个字符 ==&gt; World!text.insertData(0, \"Hello \"); // 在 0 前面插入文本， Hello_(_代表空格) =&gt; Hello World!text.replaceData(0, 5, \"Hi\"); // 从 0 开始将后 5 个字符替换为 Hi =&gt; Hi World!let newText = text.splitText(3); // 以 3 为界，分为两个文本节点 =&gt;1. Hi_(_代表空格) 2. World!newText.substringData(0, 1); // W 我们可以通过 document 对象的 createTextNode 来创建一个文本节点，该方法接收一个参数，即文本节点所包含的文本 let text = document.createTextNode(\"JavaScript\"); 接着我们可以通过 appendChild 方法将该节点添加到文档树中。 DocumentFragment在所有的节点中，只有 DocumentFragment 在文档中没有对应的标记。DOM 规定 DocumentFragment 是一种轻量级的文档，它可以包含和控制节点，但是不会真正的文档占用额外的资源，它的相关信息如下 属性 值 nodeType 11 nodeName #document-fragment nodeValue null 一般将 DocumentFragment 当做一个仓库来使用，将要添加到文档树中的节点先添加到 DocumentFragment 中，因为如果大批量的向文档树种添加节点时，如果一个个像浏览器添加节点，就会导致浏览器反复渲染，如果我们将节点先添加到 DocumentFragment 中，然后在将 DocumentFragment 添加到文档树中，DocumentFragment 会将它包含的节点一次性添加到文档树(DocumentFragment 并不会被添加到文档树中)，这样可以提高浏览器的性能。 我们可以通过 document.createDocumentFragment 来创建一个 DocumentFragment，有下面的一个 ul 节点， &lt;ul id=\"list\"&gt; &lt;/ul&gt; 我们需要将下面的节点添加到文档树中 &lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;&lt;li&gt;item3&lt;/li&gt; 我们可以先将 li 元素添加到一个 DocumentFragment 中，然后在添加到文档数中，如下 let ul = document.getElementById(\"list\");// 创建一个 DocumentFragmentlet fragment = document.createDocumentFragment();for(let i = 0; i &lt; 3; i++) &#123; let li = document.createElement(\"li\"); li.appendChild(document.createTextNode(\"item\" + (i + 1))); fragment.appendChild(li);&#125;ul.appendChild(fragment);","tags":[{"name":"DOM","slug":"DOM","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/DOM/"}]},{"title":"BOM","date":"2020-09-23T05:51:00.000Z","path":"/BOM/","text":"BOM 指的是浏览器对象模型，它定义了如何操作浏览器(不是网页)，但是事实上并没有有关于 BOM 的标准，很多浏览器厂商对其实现不一致，下面的例子都是基于 Chrome 浏览器的，但是大多数对于其他的浏览器也是成立的。 在本篇中会介绍与浏览器有关的几个对象，包括 window location history windowwindow 对象有两重角色： 它是 JavaScript 访问浏览器的接口 它是在 EcmaScript 规范所规定的 Global 对象的实现 全局作用域所有在全局作用域中声明的变量都是 window 的属性，例如 let x = 1;function sayHello() &#123; console.log(\"Hello!\");&#125;console.log(window.x); // 1window.sayHello(); // Hello! 所以如果一个函数是一个全局变量，在函数内部使用了 this，那么这个 this 代表就是 window 对象，例如 function copy(x) &#123; this.x = x;&#125;copy(5); 上面 copy 函数的调用相当于 window.copy()，所以 copy 函数中的 this 就是 window 对象，调用上面的 copy(5) 以后，在 window 对象下有一个属性 x，它的值为 5 console.log(window.x); // 5 全局变量与 window 对象上的属性有一点不同，全局变量不能通过 delete 操作符删除，而 window 上的对象可以通过 delete 操作符删除 窗口位置通过 window 的以下属性，可以知道窗口的位置 属性 功能 screenLeft 或者 screenX 表示窗口离屏幕左边的距离 screenTop 或者 screenY 表示窗口离屏幕顶部的距离 建议使用 screenLeft 和 screenTop 两个属性。 窗口大小通过以下属性获得窗口的大小 属性 功能 innerWidth 页面的宽度 innerHeight 页面的高度，不包括工具栏和调试台 outerWidth 浏览器的宽度 outerHeight 浏览器的高度，包括工具栏和调试台 因为浏览器在横向没有工具栏等部件，所以 innerWidth 和 outerWidth 应该是相同的。 除了通过上面的属性得到窗口的大小以外，还可以通过 document.documentElement 对象的 clientWidth 和 clientHeight 属性以及 document.body 对象的 clientWidth 和 clientHeight 属性来得到页面的窗口信息，不过我试验了一下，发现它们的值并不相等，所以我建议还是只使用 innerXxx 和 outerXxx。 打开窗口通过 window.open 方法可以打开一个新的窗口，该方法接收四个可选参数 参数 含义 url 要加载的 URL name 规定窗口的 target 属性或者设定窗口的名字 feature 特性字符 replace 表示在 history 中列表中是新增一条记录，还是替代当前的记录true：替代fasle：新增 这里解释一下 name 属性，它可以用来设置窗口的 target 属性，或者表示打开窗口的名字。当为以下值时，表示规定的是 target 属性 _self _parent _blank _top 当为其他值时，表示的是打开的窗口的名字。 feature 字符串是用来表示在新窗口中有哪些特性，可以设置如下值 特性 值 功能 fullscreen yes/no 或者 1/0 窗口是否最大化，IE Only width 数值 窗口的宽度，最小值为 100 height 数值 窗口的高度，最小值为 100 left 数值 窗口离左边屏幕的距离，不能为负值 top 数值 窗口离顶部屏幕的距离，不能为负值 location yes/no 或者 1/0 是否显示地址栏，Opera Only menubar yes/no 或者 1/0 是否显示菜单栏 resizable yes/no 或者 1/0 是否可拖动窗口边框改变浏览器大小，only IE scrollbars yes/no 或者 1/0 如果内容在视口显示不下，是否允许滚动，IE Firefox Opera toolbar yes/no 或者 1/0 是否显示工具栏，IE Firefox status yes/no 或者 1/0 是否显示状态栏 下面给出一个示例写法 window.open(\"https://www.baidu.com\", \"baidu\", \"width=400,height=400,resizeable=yes\", true); 需要注意的是，特性字符串中不能有空格，要同时设置 width 和 height 才会起效果，单独设置一个是没有效的。 实际感受了一下特性字符串，感觉除了 width height top left 等属性设置有效，其他属性设置没有效果。 window.open() 方法会返回新打开窗口的 window 对象(如果失败的话会返回 null)，该对象的 opener 属性和 parent 属性都指向原窗口的 window 对象，即 let newWindow = window.open();newWindow.opener == newWindow.parent == window; // true 因为新窗口的 window 对象中的 opener 和 parent 属性保持着对原窗口的引用，可以使用它来进行两个窗口的通信，如果两个窗口之间不要通信的话，我们需要手动将 opener 属性设置为 null，以免发生安全问题 newWindow.opener = null; // 此时 newWindow.parent 也为 null 定时器在 JavaScript 中有两种定时器，分别为 setTimeout setInterval setTimeout 可以看做是延时函数，它接收两个参数，第一个参数是一个回调函数，第二个参数是时间，单位是毫秒，它会在经过指定的时间之后，来调用传入的回调函数，所以 setTimeout 可以看做是一个延时器，下面的程序会在 1s 后在控制台打印 Hello World! setTimeout(function() &#123; console.log(\"Hello World!\");&#125;, 1000); setTimeout 函数会返回一个值，表示该定时器的 id，这个 id 的作用一般是用来停止定时器，只要将这个 id 作为参数传入到 clearTimeout(id) 中，就会停止这个计时器 const timerId = setTimeout(function() &#123; console.log(\"Hello World!\");&#125;, 1000);clearTimeout(timerId); 在 1s 后，我们在控制台没有看到打印出了 Hello World!，因为在 1s 以内，这个定时器就被回收了。 另一个定时器是 setInterval，它也接收两个参数，第一个参数为一个回调函数，第二个参数为时间，单位为毫秒，它会每隔设定的时间就会调用一次回调函数，如下代码会每隔 1s 就在控制台打印一次 Hello World! setInterval(function() &#123; console.log(\"Hello World!\");&#125;, 1000); 使用 setInterval 要十分的小心，因为如果我们没有清理该定时器的话，它会一直工作下去，直到页面卸载，如果我们忘记清理这个计时器的话，那么它会一直在后台运行，占用资源。 同 setTimeout 的一样，该函数也返回一个 id，作用也是用来停止计时器的，将它作为参数传递给 clearInterval(id) 即可停止这个计时器。下面给出一个例子 const max = 100;let count = 0;let timerId = null;function increment() &#123; count++; if (count &gt; max) &#123; clearInterval(timerId); &#125;&#125;timerId = setInterval(increment, 1000); 上面的代码每隔一秒对 count 进行加一，当 count &gt; max 时，我们停止了该计时器。 其实上面的代码也可以使用 setTimeout 实现，如下 const max = 100;let count = 0;function increment() &#123; count++; if (count &lt;= max) &#123; setTimeout(increment, 1000); &#125;&#125;setTimeout(increment, 1000); 仔细阅读代码，该代码的功能同上面是一样的，使用 setTimeout 的好处就是不用跟踪定时器的 id，因为 setTimeout 每次执行完函数后，它会自动的停止，一般认为使用 setTimeout 来模拟 setInterval 是一种最佳实践，所以最好不用 setInterval，以免忘记停止定时器，浪费资源。 对话框浏览器通过以下三种方法调用系统对话框向用户显示消息 alert confirm prompt location属性location 对象不仅保存当前文档的 URL 信息，并且还将 URL 解析为独立的片段，假设当前页面的 URL 为 https://app.diagrams.net:80/#G1FX9ydf3wgzNVe15n9jNgaGP_XaJyEYKz?login=true，location 对象对于的属性如下 属性名 例子 说明 hash #G1FX9ydf3wgzNVe15n9jNgaGP_XaJyEYKz 返回 URL 中的 hash host app.diagrams.net:80 返回服务器名称和端口号(如果有的话) hostname app.diagrams.net 返回服务器名称 href https://app.diagrams.net:80/#G1FX9ydf3wgzNVe15n9jNgaGP_XaJyEYKz?login=true 当前页面的完整地址 pathname / URL 中的目录或文件名 port 80 返回 URL 中指定的端口号，如果 URL 中没有指定，那么返回空字符串 protocol https: 页面使用的协议 serach ?login=true URL 中的查询字符串 assign我们可以使用 location 对象来改变当前页面的 URL，首先最常用的方式就是使用 assign，该方法接收一个 URL location.assign(\"https://www.baidu.com\"); 这样就会马上打开 URL，并在 history 对象中产生一条新的记录。 我们还可以直接修改 location.href 属性，如 location.href = \"https://www.baidu.com\"; 或者直接修改 location window.location = \"https://www.baidu.com\" 其实不管是使用 location.href 还是直接修改 location，在底层都会调用 assign() 方法，所以上面三行代码的效果都是一样的。 除了跳转到新的页面，我们还可以设置 location 对象的其他属性，来改变当前加载的页面，每次修改 location 的属性(除 hash 外)，页面都会以新的 URL 重新加载。 replace我们还可以通过 replace 方法来改变当前页面的 URL，它也接收一个 URL 地址，并跳转到该地址，不过与 assign 不同的是，它不会再 history 对象产生一条新的记录，而是使用当前的记录替代之前的记录，如下 historyhistory 保存着当前页面访问过的页面的历史记录，出于安全考虑，安全人员无法得知用户浏览过的 URL，不过可以根据通过 go 方法在历史记录之间任意跳转。 该方法接收一个整数值，正数表示向前跳转，负数表示向后跳转，如下 history.go(1); // 向前跳转一步history.go(-2); // 向后跳转两步 除了给 go 方法传递数字以外，还可以传递字符串，浏览器会跳到历史记录中包含该字符串的页面中最近的一个，可能前进，也可能后退，如果历史记录中不包含该字符串，那么什么也不做 history.go(\"baidu\"); // 跳转到最近的包含 baidu 的页面 history 提供了两个简写方法 back() 和 forward() 来代替 go()，这两个方法分别代表后退一步和前进一步。 如果在后退到某页面时，出于某种原因，向 history 中添加了一条新的记录，那么此页面之后的记录全部作废，如下图所示 还有两个对象没有讲，navigator 和 screen，这两个对象我觉得没有什么用，所以不打算写了(另一个原因是是写到这里已经比较累了，不想继续写了)。","tags":[{"name":"BOM","slug":"BOM","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/BOM/"}]},{"title":"记一次 React 中 CSS 处理事件","date":"2020-09-22T05:51:00.000Z","path":"/记一次React CSS 处理事件/","text":"事件的起因是对一个使用传统网页开发的 Web 项目(即 html, css, javascript 分开写的项目)重构为 React 项目。 这个事情大部分都是复制粘贴，假设有以下的文件目录 Main index.jsx index.module.css index.module.css 的内容如下所示 .box-left &#123; /* 一些CSS样式 */&#125; 在 Main 组件的 index.jsx 中引入了 index.module.css import React from 'react'import styles from './index.module.css'function Main() &#123; return ( &lt;div className=&#123;styles.boxLeft&#125;&gt;&lt;/div&gt; )&#125;export default Main 当我绑定类名时，WebStorm 提示我写成 boxLeft，因为 box-left 中的 - 会被识别成减号，我以为 React 会根据 boxLeft 智能识别出 box-left，但是没想到样式失效了。 当时我还以为是 React 是不是不支持 CSS Module，为此我还上网搜了，并且使用 npm run eject 将配置文件弹出来改了，但是没有怀疑 boxLeft 并不能被对应为 box-left，这一切都是因为我很相信 WebStorm，以为这种写法是正确。 最后无计可施，就想着把 index.module.css 中的类名改为 boxLeft .boxLeft &#123; /* 一些CSS样式 */&#125; 然后样式就出来了。 这件事告诉我，不要太相信 IDE，就是因为太相信 WebStorm，以至于我根本没有考虑过写法的问题，导致在这上面浪费了几个小时；也是因为浪费了几个小时，我觉得这是一个宝贵的经验，所以记录下来。","tags":[{"name":"React 踩坑","slug":"React-踩坑","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/React-%E8%B8%A9%E5%9D%91/"}]},{"title":"SpringBoot入门","date":"2020-09-02T16:00:00.000Z","path":"/SpringBoot入门/","text":"本篇文章需要有 Spring 的使用经验，在本篇文章中，对于 Spring 的基本概念如 IOC DI AOP 不会进行介绍，以及对于在 Spring 中的常用注解，如 @Component @Autowired @Bean 等等注解默认你已经掌握，否则学习本篇文章会比较困难。 如果使用过 Spring 的话，我们一般要写 xml 配置文件，或者使用 @Configuration 注解来配置 Spring，这个过程非常的惹人讨厌，给我们带来很大的负担，比如对于我来说，Spring 的 xml 配置文件的头部我就记不下来，每次都要从官网复制或者从自己的博客笔记中复制，这种不能完全掌握的感觉我觉得很糟糕。 Spring Boot 的出现，使得我们不需要写这种繁琐的配置文件，它的优点就是约定大于配置，所谓约定，即默认使用大家一致认可的配置，而程序员只需要配置不符合约定部分，所以其实 Spring Boot 可以是零配置的，在下面的入门小节我们将看到不编写任何的配置文件搭建一个 Web 服务。 入门我们在这个小节中快速的搭建一个 Spring Boot 项目，有两种方法 在 Spring 官网 在线创建一个项目 上面的选项还是很容易看懂的，我们使用 Maven 来管理项目依赖，使用的语言是 Java，使用的版本是 2.3.3，以及项目的一些信息。因为我们需要搭建一个 Web 服务，所以还需要 web 的依赖，我们点击右上角的 ADD DEPENDENCIES 我们选择 Spring Web 这个依赖，选择好以后，我们点击 GENERATE 生成一个 zip 文件，我们下载下来 我们将它解压，然后使用 IDE，比如我使用的是 IDEA 去打开该文件夹 然后就可以快乐的写程序了。 使用 IDEA 来创建一个 Spring Boot 项目 首先打开 IDEA，新建一个 Project 然后我们选择 Spring Initializr 观察右侧的 Default 所对应的 URL，其实 IDEA 也是在 Spring 官网来生成一个 Spring Boot 项目的，不过在 IDEA 中直接创建 Spring Boot 方便了很多。 点击 Next，接着我们就要设置项目的一些信息，这些项目信息的选项同我们在官网看到的选项是一样的 配置好项目信息以后，我们点击 Next，这个页面是来添加依赖的 我们需要添加 Web 依赖，我们点击左侧的 Web 选项，接着勾选 Spring Web，如下 点击 Next，来到最后一项，设置项目的名称 点击 FINISH，完成项目的创建，可以愉快的写代码了。 接下来我们就来看生成的 Spring Boot 项目的文件结构，如下 我们不去看 .gitignore 等等配置文件，我们关注的是 src 文件夹的结构 src main java resources static templates application.properties test java 很明显这是一个典型的 Maven 项目的结构。我们的代码是放在 main/java 目录下的，main/resources 文件夹放的是资源文件，在该文件夹下有两个文件夹和一个文件 文件(夹) 作用 static 放置静态资源文件，如 js 文件，css 文件 templates 放置模板文件，在模板引擎小节讲述 application.properties SpringBoot 的配置文件 接下来我们来到 main/java 目录下，首先里面有一个包，如 com.xt.start，这是你在生成一个 Spring Boot 项目时填写好的，在这个包下有一个 Java 类 StartApplication，内容如下 package com.xt.start;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StartApplication.class, args); &#125;&#125; 这个类就是我们 Spring Boot 的启动类，我们运行这个类，就会将这个 Spring Boot 项目启动起来 这个项目启动在 8080 端口，我们可以通过 localhost:8080 访问该项目 因为我们没有对访问的路径做处理，所以只会得到上面的错误页面。 读到这里，你可能会疑惑，以往我们都是将项目打包，然后放在 tomcat 放置项目的路径下，然后启动 tomcat 访问项目，怎么我们没有配置 tomcat 就可以启动一个服务呢? 这是因为 Spring Boot 内部包含了 tomcat，如果仔细观察上面的日志，可以观察到 Spring Boot 也是使用了 tomcat 的。 接着我们来对一些请求路径做处理，我们需要注意的是，Spring Boot 会默认扫描 StartApplication(即启动类)所在的包及其子包下的类，所以我们的类都要写在 com.xt.start 包下，这样我们的类才有可能会被添加到 IOC 容器中。 我们在 com.xt.start 下新建一个包 controller，并在此包下新建一个类 HelloController package com.xt.start.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @GetMapping(\"/\") @ResponseBody public String hello() &#123; return \"Hello World!\"; &#125;&#125; 我假设你有使用 Spring MVC 的基础，所以上面的注解你是看的懂得。当我们访问项目的根目录时，会返回一个字符串Hello World!。重新启动项目，你可以直接在浏览器地址栏输入 localhost:8080/ 直接访问，在页面会呈现一个字符串 Hello World!，在这里我使用 PostMan 来访问该项目，如下 我们没有编写任何的配置文件，就创建一个 Web 项目，所以说 Spring Boot 大大的解放了我们的生产力。 关于 JSP： 在以往都是前端写好 html 页面，然后后端拿去修改为 JSP 页面，根据前端发送的请求返回相应的经过渲染的页面，这种开发方式需要前端写好页面，后端才能进行修改，前端与后端的开发并不是并行的，效率不能够最大化；并且像 JSP 前后端代码混杂在一起的情况，职责不清晰，代码混乱，没有限制。 现在的开发一般都是前后端分离了，前端只需要向后端请求所需要的数据就可以，而后端只需要发送数据即可，只要后端与前端开发之间规定好请求的接口，以及数据的格式，二者可以同时并行开发，效率可以得到最大化；并且此时前后端的职责更加的清晰，前端负责维护好前端页面，后端维护好后端的逻辑，减少了二者之间的协作，也就意味着可以有更高的开发效率。 所以在本篇中不会介绍有关使用模板引擎开发的内容，例如 Thymeleaf。 配置文件虽然我们说 Spring Boot 不需要配置文件，但是我们要配置一些特有的信息时我们还是需要写配置文件的，比如配置数据库的用户和密码等等信息。 在上面我们提到过，application.properties 文件是项目的配置文件，我们使用 properties 文件的格式写配置信息，比写 XML 配置文件好多了，如我们配置项目的端口号为 8081 server.port=8081 重新启动项目 端口号已经变为了 8081。 YAML配置文件在之前我们使用 properties，但是使用 properties 配置文件没有层级关系，如果上面配置端口换成使用 XML 配置，那么可能是如下的形式 &lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 使用 XML 配置文件虽然结构层次清晰，但是 XML 文件冗余信息太多，表达相同的信息需要更大的空间，以及还有那讨人厌的命名空间。所以有没有一种配置文件，能简单的表示信息，并且还能够有层级关系，那就是本小节所要讲的 YAML 配置文件。 如果使用 YAML 来配置上面的端口号，它是这样的 server: port: 8081 通过缩进可以清晰的表示层级关系，并且没有冗余的信息，在 : 的左边表示要配置的选项，在 : 的右边表示配置的具体值，需要注意的是，: 与值之间需要跟一个空格，如 port: 8081。 YAML表示数组和列表在 YAML 配置文件中如何表示一个数组，有两种方法，第一种是行内表示，如 scores: [97, 98, 99] 或者使用行间的表示，在每一项的前面加上 -，如下 scores: - 97 - 98 - 99 YAML表示对象假设我们使用 YAML 配置一个 Person 对象，它包含 name age gender 属性，那么我们可以使用下面的方式进行配置 person: name: Bob age: 21\" gender: male 需要注意的是，我们在配置字符串类型的值时，并不需要加上 &quot;。我们还可以通过行内的方式配置对象，如下 person: &#123;name: Bob, age: 21,gender: male&#125; YAML引用当我们想引用已经配置过的值时，我们可以通过 &amp; 设定锚点，然后通过 * 进行引用，例如 default: &amp;default username: root password: rootmysql: database: mysql &lt;&lt;: *default 首先我们通过 &amp;default 定义了一个锚点，然后我们在 mysql 通过 *default 引用了该锚点，&lt;&lt; 表示合并到此处，所以上面的配置等效于 default: &amp;default username: root password: rootmysql: database: mysql username: root password: root 配置文件的位置配置文件默认是放在类路径下的，即 application.properties 所在的位置，除此以外，还可以放在另外三个位置，这三个位置下的 application.properties 或 application.yml 都会被作为配置文件 classpath:/ classpath:/config file:/ file:/config/ 下面这张图注明了上面的四个位置 既然四个位置都可以配置，那么当这四个位置发生冲突时，以谁的为准呢? 所以这四个位置是有优先级的关系的，如下 file:/config/ &gt; file:/ &gt; classpath:/config/ &gt; classpath:/(默认) 数据访问在本小节中来讲如何使用 SpringBoot 访问数据库，在此之前，我们需要先在数据库中创建一个表，相关 sql 语句如下 create database test;use test;create table account( id int auto_increment, name varchar(20) not null, money double default 0 not null, constraint account_pk primary key (id));insert into account(name, money) values ('Alice', 2000.0), ('Bob', 3000.0) 上面我们创建了数据库 test，并在下面新建了一个 account 表，执行完上面的语句后，account 表的内容如下 JDBC配置好数据库的内容以后，我们就新建一个项目，新建一个项目的步骤在文章的开头，不同的是，我们在添加依赖的部分需要添加 JDBC API 以及 MySQL Driver，如下 接着我们在配置文件中配置数据库的相关配置，如下 spring: datasource: username: root password: root url: jdbc:mysql:///test driver-class-name: com.mysql.jdbc.Driver 接着我们在启动类所在包下新建包 controller 并新建类 HelloController package com.xt.jdbc.controller;import com.xt.jdbc.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.Map;@RestControllerpublic class HelloController &#123; @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\"/account/&#123;id&#125;\") public Map getAccountById(@PathVariable(\"id\") Integer id) &#123; Map map = jdbcTemplate.queryForMap(\"select * from account where id = ?\", id); return map; &#125;&#125; MyBatis新建一个工程，在添加依赖的部分，添加如下依赖 在 application.yml 配置数据源，同上 JDBC。接着我们新建一个包 entity 放置与表 account 对象的实体类，如下 package com.example.mybatis.entity;public class Account &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '&#125;'; &#125;&#125; 接着新建包 mapper，该包下放置的有关 MyBatis 操作数据库的接口，我们新建 AccountMapper 如下 package com.example.mybatis.mapper;import com.example.mybatis.entity.Account;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;@Mapperpublic interface AccountMapper &#123; @Select(\"select * from account where id = #&#123;id&#125;\") public Account findById(Integer id); @Update(\"update account set money = #&#123;money&#125; where id = #&#123;id&#125;\") public void updateById(Integer id, Double money);&#125; 我们使用 @Mapper 表示这是一个 MyBatis 的 Mapper 类，接着我们新建一个 controller 以及一个类，如下 package com.example.mybatis.controller;import com.example.mybatis.entity.Account;import com.example.mybatis.mapper.AccountMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Autowired private AccountMapper accountMapper; @GetMapping(\"/account/&#123;id&#125;\") public Account getAccountById(@PathVariable Integer id) &#123; return accountMapper.findById(id); &#125; @PostMapping(\"/account/&#123;id&#125;/&#123;money&#125;\") public void updateMoneyById(@PathVariable(\"id\") Integer id, @PathVariable(\"money\") Double money) &#123; accountMapper.updateById(id, money); &#125;&#125; 首先我们发现一个请求查询 id 为 2 的用户信息 接着我们发起请求修改 id 为 2 的账户的 money 最后我们再次查询 id 为 2 的账户，观察数据是否已经修改 JPA新建一个项目，并且添加如下依赖 使用 JPA 操作数据库，它会根据我们创建的实体类来自动的生成对应的表，不需要我们写创建表的 sql 语句，另外它提供了简单的 sql 语句，对于简单的查询，更新我们不需要写任何的 sql 语句，所以使用 JPA 操作数据库我们只需要编写实体类即可。 在 application.yml 中编写配置如下 spring: datasource: username: root password: root url: jdbc:mysql:///test driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update show-sql: true 在这里我们多添加了两项配置，其中 show-sql 设置为 true 表示在控制台显示 sql 语句，没什么说的，ddl-auto 的值设置为 update，我们讲一下，ddl-auto 有四种取值 取值 功能 create 会根据实体类创建表，如果数据库已有表，则会删除 create-drop 在 create 的基础上，在应用关闭前删除表 update 如果数据库中已有表，不会删除已有的表，在已有的表上进行更新操作 validate 会对数据库中已有的表进行验证，是否与实体类规定的结构相符 前面两个通常会导致数据消失，所以我们一般使用的是 update 和 validate，在这里我们使用了 update。接着我们新建一个实体类，JPA 会根据该实体类创建表 package com.example.jpa.entity;import javax.persistence.*;@Entity@Table(name = \"account\")public class Account &#123; @Id // 设置主键 @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键自增长 private Integer id; @Column(name = \"name\") // 设置列名 private String name; @Column(name = \"money\") private Double money;&#125; 我们使用 @Entity 表示这是一个实体类，使用 @Table 设置了该实体类对应的表名，使用 @Id 设置该属性为主键，使用 @GeneratedValue(strategy = GenerationType.IDENTITY) 来设置主键自增，使用 @Column 设置属性对于的列名。 接着我们新建包 repository，并且在该包下新建接口 AccountRepository package com.example.jpa.repository;import com.example.jpa.entity.Account;import org.springframework.data.jpa.repository.JpaRepository;public interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;&#125; 我们可以使用此接口来操作数据库。 接着我们新建 controller 包，并新建类如下 package com.example.jpa.controller;import com.example.jpa.entity.Account;import com.example.jpa.repository.AccountRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class HelloController &#123; @Autowired private AccountRepository accountRepository; @PostMapping(\"/account/&#123;id&#125;/&#123;name&#125;/&#123;money&#125;\") public List&lt;Account&gt; saveAccount(Account account) &#123; accountRepository.save(account); return accountRepository.findAll(); &#125;&#125; 上面的程序会在接到请求以后会自动将参数封装为一个 Account 对象，然后存储到数据库中，接着返回数据库中的所有 Account 对象","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Spring-Boot/"}]},{"title":"小球会停下来吗","date":"2020-08-30T10:40:00.000Z","path":"/小球会停下来吗/","text":"在高中的时候我有这么一个思考，灵感源于一道物理题目 一个小球从高度为 $h$ 的地方下落，落在地面上接着弹起，但是由于与地面碰撞造成能量损失，使得每次弹起的高度只有之前高度的 $1/4$。 这道题目看起来是没有什么问题，当时我的想法是每次球的高度都会变为原来的 $1/4$，所以球是会一直这样弹下去的，就像是庄子说的 一尺之棰，日取其半，万世不竭。 所以在这里我得到一个结论，小球会一直运动下去，所以小球的运动时间为无穷大。 但是当我计算时却发现不对劲，假设从高度为 $h$ 降落所需的时间为 $t_0$，由于下降所需时间 $t \\propto \\sqrt{h}$ ，那么 $h/4$ 下降所需的时间为 $t_0/2$，换句话说，每次上升然后下降所需的时间为之前所需时间的一半，所以耗费的时间的数列为$$t_0, , \\frac{t_0}{2}, , \\frac{t_0}{2^2}, , \\dots, ,\\frac{t_0}{2^n}, , \\dots$$这是一个等比数列，公比为 $1/2$，我们对这个数列求和$$t_0 \\lim_\\limits{n \\to \\infty}\\sum_{i=0}^{n} \\frac{1}{2^i} = 2t_0$$我们得到这么一个事实，小球的运动时间不会超过 $2t_0$，也就是说小球会在 $2t_0$ 后停下，这与我在之前得到的结论相反，小球应该会一直弹下去，怎么会停下来呢? 所以我当时一直在苦恼，小球到底会不会停下来? 我与身边的同学讨论过这个问题，但是显然他们不仅没有给我正确的答案，反而最后也有这个疑问。而且这个问题一直没有得到解答，渐渐的我也就忘了这个问题，毕竟这种问题不会再考卷上出现，也不会影响我的学习。 而现在我突然想起这个问题，是因为我最近在看一本书《上帝掷骰子吗?：量子物理史话》，这本书是讲量子力学的历史的，这本书给了我一个启发来解决我上面的疑惑。 想必在我们大部分的认知中，我们会觉得认为时间是连续的，空间是连续的，能量也是连续的。汽车速度从 $0km/h$ 加速到 $100km/h$，那么速度一定会经过 $25km/h$，因为速度它是连续变化的；温度从 $0^{o}C$ 上升到 $100^{o}C$，那么它一定会经过 $25^{o}C$，因为温度也是连续变化的。 量子力学的创始者普朗克在研究物理问题时，由于数学处理的需要，他假设能量它不是连续的，而是离散的，有着最小单位，而能量的大小只能为这些最小单位的整数倍。普朗克带来这么一种观念，能量是离散的，而不是连续的，这在当时简直就是异类学说，甚至在普朗克最初提出这么一个概念时，他自己都不相信。但是最后我们知道量子力学它是对的，能量并不是连续的，而是离散的，只是能量的最小单位非常小，察觉不出来而已。 所以这给我带来的启发就是，空间它是不是也是离散的，它是不是也有着最小的单位，只是这个单位特别小，我们察觉不出来而已。如果空间也有着最小的单位，那当我们的高度已经是最小单位时，它是不是就会停下来，因为它不可能达到最小单位的 $1/4$，因为已经是最小了，如果比最小单位还小，那还能叫做最小单位吗。 所以我的结论就是小球会停下来，它不会永远的弹下去，因为空间有最小单位。 在这里我又想起了一个悖论，那就是芝洛悖论： 一个人和一只乌龟进行赛跑，乌龟的速度为 $0.1m/s$，人的速度为 $10m/s$，乌龟在人前方 $100m$，那么这个悖论就是人永远追不上乌龟，只能在无限的逼近乌龟，这是怎么回事? 假设乌龟在点 $B$，人在点 $A$，人要追上乌龟就必须要经过 $B$ 点 但是当人到达 $B$ 点时，乌龟已经到达 $C$ 点了 同理，人如果要追上乌龟的话，就必须会经过 $C$ 点，而当人到达 $C$ 点时，乌龟已经去了 $D$ 点了，如此往复，人永远都不可能追上乌龟，只可能在无限的逼近。这与我们的实际不符，那么我们怎么来反对这么一个悖论? 我们假设时间和空间不是连续的，不能够永远的分割下去，它们都有着最小的单位，即时间和空间都是离散的。在这样的假设下，那么人就不会无限的逼近乌龟，所谓的无限的逼近乌龟，指的就是人与乌龟之间的距离无限的趋近于 $0$，但是我们假设空间它不是连续的，即人与空间之间的距离不会无限的小，最小也只可能是一个空间最小单位。 那什么时候人会超过乌龟呢? 我们不妨假设人在 $1$ 个时间最小单位中能够移动 $10$ 个空间最小单位，而乌龟在在 $1$ 个时间最小单位中能够移动 $1$ 个空间最小单位，当人与乌龟之间的距离小于 $9$ 个空间最小单位时，那么在下一个时间最小单位，人就超过了乌龟。 所以，我认为这个世界的本质不是连续的，而是离散的。","tags":[{"name":"世界观","slug":"世界观","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E4%B8%96%E7%95%8C%E8%A7%82/"}]},{"title":"两数之和","date":"2020-08-19T15:45:00.000Z","path":"/两数之和/","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案，但是，数组中同一个元素不能使用两遍。 示例： &gt;给定 nums = [2, 7, 11, 15], target = 9&gt;因为 nums[0] + nums[1] = 2 + 7 = 9&gt;所以返回 [0, 1] 解决该方法最容易的版本是，首先固定一个数 nums[i]，然后遍历数组查看是否包含 target-nums[i] 的数字，代码如下： public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; // 首先固定 nums[i] for (int i = 0; i &lt; nums.length - 1; i++) &#123; // 接着在剩下的数字查找是否有数字等于 target - nums[j] // 或者说 nums[i] + nums[j] = target for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; res[0] = i; res[1] = j; return res; &#125; &#125; &#125; return res;&#125; 使用这种双重循环的方法，它的时间复杂度是 $O(n^2)$。 那有没有只需要扫描一遍数组即可以确定答案的办法，答案是有，我们可以利用哈希表做这件事情。我们在遍历数组时，我们将数组中的数字以及对应的下标以键值对的形式添加到一个哈希表中，每次我们在遍历一个数字 nums[i] 时，在添加该数字到哈希表之前(之所以是之前，以防一个数字被用两次，可以自己举个例子想想)，都在哈希表中查看是否有数字为 target - nums[i]，因为向哈希表查询的时间复杂度为 $O(1)$，所以这种只用遍历一遍数组即可知道解的方法，它的时间复杂度为 $O(n)$，代码如下： public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; // 首先进行查询，查询完了在将 nums[i] 添加到哈希表中 if (map.containsKey(target - nums[i])) &#123; res[0] = map.get(target - nums[i]); res[1] = i; break; &#125; map.put(nums[i], i); &#125; return res;&#125; 现在我们对上面的题目加个条件，给定的数组是有序的，且是从小到大排序的，那么有没有更快的方法来找到答案。 如果数组是有序的话，那么我们可以使用双指针的解法，首先一个指针指向数组的开头，即最小的那个数字，另一个指针指向数组的末尾，即最大的那个数字。接着我们通过移动这两个指针来找到答案 如果这两个指针指向的数字之和大于 target，那么我们要将指向末尾的指针向前移，因为第一个指针指向的数是最小的数，所以这时任何数加上后一个指针指向的数都会比 target 大，所以该数不可能是解，排除 如果小于，那么指向开头的指针向前移，道理同上，因为这时任何一个数和第一个指针指向的数相加都小于 target，所以该指针指向的数不可能是解，排除 如果等于，那就是找到了 以下图为例： 代码如下： public int[] twoSum(int[] nums, int target) &#123; int p1 = 0; int p2 = nums.length - 1; int[] res = new int[2]; while (p1 &lt; p2) &#123; if (nums[p1] + nums[p2] == targets) &#123; res[0] = p1; res[1] = p2; break; &#125; if (nums[p1] + nums[p2] &lt; target) &#123; p1++; &#125; else &#123; p2--; &#125; &#125; return res;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/leetcode/"}]},{"title":"Webpack入门","date":"2020-07-18T16:00:00.000Z","path":"/Webpack入门/","text":"Webpack介绍webpack 是什么，以及它有什么作用，解决了什么问题，这些都是我们需要在学习 webpack 的用法之前需要了解的。 如果你上网去搜的话，一般的介绍是它是一个打包工具，那么什么又叫做打包工具? 由于现在的开发都是多人协作开发，所以一般会将功能分成一个个的模块由不同程序员开发，但是这些模块之间并不是毫无关联的，模块之间会有依赖关系。我们分开为了多个文件，由于依赖关系复杂，如果这些文件加载顺序不当，就有可能发生错误，另外分开成多个文件也意味着有多个网络请求，这会对服务器造成压力，所以我们就有需要将它们合并成一个文件的需要，而将多个文件合成成一个文件，我们就称之为打包。 这里贴一张官网的图片 通过官网的图片可以看出，webpack 可以将依赖的文件打包成单个的资源文件。 但是 webpack 除了打包之外还有什么作用，或者说我们有什么需求需要它帮我们去完成。例如我们希望在项目中使用高级的 JS 语法，比如 ES6 或者更高级的语法，可是浏览器对于 ES6 的支持可能并不完全，但是我们就是想用，这个时候我们就有将 ES6 及更高级的语法转化为 ES5 或更低级语法的需要。 另外，随着项目的复杂，使用 CSS 编写样式不能满足日益复杂的项目的需要，或者说 CSS 并不是一个工程语言，这个意思指 CSS 难以阅读、修改、扩展。所以就出现像 less scss/sass 这样的工程化的语言，它可以很方便的写样式，并且十分方便管理，但是浏览器并不认识 less scss 等编写的样式，所以我们就有将 less、scss/sass 文件转化为 CSS 文件的需要。 再一个，我们会在项目中用到 TypeScript，因为 JavaScript 的灵活以及动态特性，导致很多的错误只有在运行时才暴露出来，所以 JavaScript 很容易出现 bug，使用 TypeScript 可以大大减少这种情况的发生，错误往往在编译时就能够发现，但是浏览器并不支持 TypeScript，所以我们有将 TypeScript 转化为 JavaScript 的需要。 其实还有很多的需求，比如压缩文件，比如为 CSS 样式添加浏览器前缀等等，这些等到我们后面在介绍。 webpack安装及简易入门新建一个项目，这里我的项目名为 webpack-dev mkdir webpack-devcd webpack-devnpm init -y 通过 npm init 命令我们初始化了一个 npm 项目，接着我们下载 webpack 和 webpack-cli npm install webpack webpack-cli --save-dev 为什么是本地安装而不是全局安装，如果是全局安装的话，在不同的电脑大家的 webpack 的版本可能是不一样的，所以可能会因为版本的不同而带来问题，为了避免这种情况的发生，我们选择本地局部安装，版本信息会被保存在 package.json 中，这样大家安装时版本就会是一样的，避免了不必要的问题，这里我们 webpack 版本如下 \"webpack\": \"^4.43.0\",\"webpack-cli\": \"^3.3.12\" 下面我们新建一个 src 文件夹，src 文件夹一般是我们开发时所使用的文件夹，我们在这个文件夹下写代码，在 src 下新建 index.js 和 util.js，内容如下 // index.jsimport &#123;add&#125; from './util'let res = add(1, 2);console.log(res); // 3 // util.jsexport const add = (x, y) =&gt; &#123; return x + y;&#125;; 上面 index.js 依赖了 util.js，我们需要将这两个文件打包为一个文件，在命令行使用如下 webpack 命令进行打包 npx webpack --entry=./src/index.js --output=./dist/bundle.js --mode=development 在命令行有如下输出 如果出现上面的输出，说明打包成功了。接下来解释一下上面的命令：因为 webpack 是本地局部安装的，所以我们要使用 npx 来调用 webpack 命令，除此以外，我们还传递了三个参数 参数 功能 entry 指定打包的入口文件 output 指定打包后的文件输出在哪个目录 mode 指定模式 我们使用 entry 来指定打包的入口文件，即 webpack 会根据该入口文件，解析它所依赖的文件，将这些文件打包成一个文件；我们使用 output 来表明所打包后的那个文件放置在哪个目录，以及打包后的文件的文件名是什么，在上面我们设置在打包后的文件放在 dist 文件夹，文件名为 bundle.js，使用上面的命令之后，可以观察到自动生成了一个 dist 文件夹，以及在该文件夹下有一个 bundle.js 的文件 mode 是用来指定模式的，可选的选项有 development 和 production，development 指的是开发环境，这个时候我们打包出来的代码不会被压缩，当指定 mode 为 production 时，即生产环境下，那么打包后的代码会被压缩。 在上面我们使用的是 ES6 的模块语法，即 import 和 export，但是很多的 npm 项目使用的是 CommonJS 模块规则，即 require 和 module.exports，所以在项目中很可能我们会同时使用上面两种模块进行导出和导入，这样的代码是不可能在浏览器中执行的，使用 webpack 它可以处理这种情况，我们可以在项目中自由的使用这两种导入导出的规则，webpack 会自动帮我们处理为可以在浏览器中执行的代码，在 src 下新建 foo.js 如下 // foo.jsmodule.exports = &#123; sub: (x, y) =&gt; &#123; return x - y; &#125;&#125;; 并且修改 index.js 如下 // index.jsimport &#123;add&#125; from './util'const sub = require('./foo').sub;let res1 = add(1, 2);let res2 = sub(1, 2);console.log(res1); // 3console.log(res2); // -1 在 index.js 中，我们同时应用了两种模块语法，我们在命令行中再次执行 npx webpack --entry=./src/index.js --output=./dist/bundle.js --mode=development 为了观察打包后的文件是否能够在浏览器执行，我们在 dist 下新建 index.html 并引用 bundle.js，如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器打开 index.html，在控制台可以观察到如下 可见 webpack 为我们自动处理了这种语法。 为了不每次在命令行输入上面一行特长的命令，我们可以配置 package.json 中的 script 属性，如下 \"scripts\": &#123; \"build\": \"webpack --entry=./src/index.js --output=./dist/bundle.js --mode=development\",&#125; 下面我们只要在命令行输入 npm run build 它就会执行那一串命令，即可进行打包。 配置文件在上面的简易入门中，我们没有为 webpack 写配置文件，只是在命令行中设置了 entry output mode 这些参数，但是其实这些参数都有默认值 参数 默认值 entry src/index.js output dist/main.js mode production 这意味着即使我们在命令行不配置这些参数，也能够进行正常的打包，会在 dist 目录下生成一个 main.js 文件而不是 bundle.js 文件。所以可以说 webpack 是零配置，不需要配置对用户来说是一件好事，可以减少很多的心智负担，但是零配置也意味着功能较弱，为了使用 webpack 强大的功能，我们必须要学习 webpack 许许多多的配置，但是这些配置都写在命令行中，那是十分的不方便，这些东西应该放在配置文件中。 webpack 的默认配置文件名为 webpack.config.js 或者 webpackfile.js，由于业界大多数使用的都是 webpack.config.js，所以我们在这里也使用 webpack.config.js。在项目的根目录(而不是 src 目录)下新建 webpack.config.js，内容如下 const path = require('path');module.exports = &#123; entry: \"./src/index.js\", output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") &#125;, mode: \"development\"&#125;; 这时我们就不必在命令行中指定参数了，我们修改 package.json 的 script 字段如下 \"scripts\": &#123; \"build\": \"webpack\"&#125; 接着在命令行运行 npm run build 即可看到打包成功的消息。下面就更加详细的讲解一下 entry 和 output 的配置。 entryentry 指代的就是入口文件，这是我们在上面就已经介绍过的。其实 entry 可以有多个入口，webpack webpack 会根据每一个入口文件打包出一个 chunk 这个 chunk 可以有名字，当如下配置时 entry: \"./src/index.js\" 打包出的 chunk 的名字默认为 main。我们也可以使用对象的方式配置 chunk 的名字 entry: &#123; index: \"./src/index.js\" // index 表示 chunk 名字，对应的值表示对应的入口文件&#125;,output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"dist\")&#125;, 在上面有两处改动，第一个就是将 entry 的值设置为了一个对象，该对象的值表示入口文件，而键表示入口文件打包后的 chunk 的名字；第二个改动就是在 output 中我们设置打包后的文件名称为 [name].js，这个 [name] 是一个变量，指的就是 chunk 的名字，我们没有手动的写死一个值，而是使打包后的文件名与 chunk 名字相同，所以此时运行 npm run build 可以在 dist 目录下打包出 index.js 文件。下面是运行打包命令在命令行的输出 outputoutput 的常见配置选项如下 选项 功能 filename 指定文件名称，可以为 [name] [chunkHash] 以及它们的组合 path 打包后的文件放置的路径 publicPath filename 是用来指定打包后的文件名的，我们除了可以指定特定的名称如 bundle.js 外，还可以使用 [name] [chunkHash] 等变量，分别指打包后的 chunk 的名称和打包后文件内容计算出的 hash 值。二者可以进行组合使用，如 output: &#123; filename: \"[name][chunkHash].js\", path: path.resolve(__dirname, \"dist\")&#125; 本地服务器上面我们的开发过程为 每次我们更改程序后，都要重新刷新网页以观察最新的结果，而我们希望在我们更改程序后，页面能够自动的刷新，不需要再次使用 webpack 进行打包，然后手动刷新页面，这个时候我们就需要使用 webpack-dev-server 了，它可以在本地开启一个服务器，并且当我们修改程序时，自动的刷新页面。 首先下载 webpack-dev-server npm install webpack-dev-server --save-dev 接着我们在 webpack.config.js 中加入 devServer 配置项 const path = require('path');module.exports = &#123; // webpack-dev-server 的配置 devServer: &#123; port: 3000, contentBase: path.resolve(__dirname, 'dist') &#125;, entry: &#123; \"bundle\": \"./src/index.js\" &#125;, output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"dist\") &#125;, mode: \"development\"&#125;; 在上面我们配置了两个选项 选项 功能 port 配置端口号 contentBase 配置服务器的根目录 接着我们为 package.json 中的 script 字段添加 dev 选项 \"scripts\": &#123; \"build\": \"webpack\", \"dev\": \"webpack-dev-server\"&#125; 接着我们运行 npm run dev 即可在本地启动一个服务器了 接着我们在浏览器输入 http://localhost:3000 即可访问页面了。 注意： 这里有一点需要注意的是，使用 webpack-dev-server 并不会输出打包后的文件，它会根据入口文件的依赖关系进行打包，但是打包后的内容放在内存中，而不是输出一个文件到硬盘上，所以不会生成 bundle.js 文件，因为它只存在于内存中。 loaderloader 又是一个新的概念，我们可以简单的理解为处理器，处理什么呢? 比如我们需要将 ES6 转换为 ES5，这就需要一个 loader 进行转换；比如我们需要将 less 转换为 CSS，这需要一个 loader 进行转换，比如需要将 TypeScript 转换为 JavaScript，这也需要一个 loader 进行转换；等等。 下面我们就介绍一些常用的 loader。 babel-loader我们常常有需要将 ES6 或更高级的语法转化为 ES5的需要，这个时候我们就要用到 babel-loader，我们需要下载这些安装包 npm install babel-loader @babel/core --save-dev @babel/core 是 babel 的核心包，具体的转换要依赖该包，接着我们需要在 webpack.config.js 中进行配置 const path = require('path');module.exports = &#123; devServer: &#123; port: 3000, contentBase: path.resolve(__dirname, 'dist') &#125;, entry: &#123; \"bundle\": \"./src/index.js\" &#125;, output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"dist\") &#125;, mode: \"development\", module: &#123; rules: [ // 配置 loader &#123; test: /\\.js$/, use: \"babel-loader\" &#125; ] &#125;&#125;; 我们在 module.rules 中配置 loader，其中最少需要配置两项 test 和 use，test 用来表示对什么文件进行转换，比如上面对所有以 .js 结尾的文件进行转换；use 用来指定使用什么 loader 进行转换，这里指定为 babel-loader。综合上面两个配置，表示的意思就是对所有以 .js 结尾的文件使用 babel-loader 进行处理。 其中 use 也可以是一个对象，如下 use: &#123; loader: \"babel-loader\", options: &#123; &#125;&#125; 当 use 是一个对象时，我们可以通过 options 为 loader 配置一些参数。 除了配置 test 和 use，还可以配置两个选项 选项 功能 include 指定检查的路径 exclude 指定排除的路径 上面的两个选项指定只对哪些路径下的文件进行检查，或者不检查哪些路径下的文件，一般来说二者只需要配置一个即可，但是如果两个都配置了，并且有冲突，那么 exclude 的优先级高。 我们接着修改 index.js 的内容，为其中添加 ES6 的语法 let x = 1;let y = 2;const add = (x, y) =&gt; &#123; return x + y;&#125;;let result = add(1, 2);let p = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;).then(value =&gt; &#123; console.log(value);&#125;); 在 index.js 中，我们使用了 ES6 才出现的语法，如 let const Promise 箭头函数，现在我们运行 npm run build 进行打包，部分内容如下 eval(\"let x = 1;\\nlet y = 2;\\n\\nconst add = (x, y) =&gt; &#123;\\n return x + y;\\n&#125;;\\n\\nlet result = add(1, 2);\\nlet p = new Promise((resolve, reject) =&gt; &#123;\\n resolve(1);\\n&#125;).then(value =&gt; &#123;\\n console.log(value);\\n&#125;);\\n\\n//# sourceURL=webpack:///./src/index.js?\"); 发现并没有将 ES6 的语法转化为 ES5 的语法，因为 babel 需要特定的插件支持，babel 为了实现按需加载的功能，它将 ES6 转 ES5 的功能分为了 20+ 个插件，你需要哪个就下哪个，但是这样却是有点麻烦，好在 babel 推出了一个插件集合 preset，我们直接下载 @babel/preset-env 即可，里面包含了所有的 ES6 语法转 ES5 语法的插件合集 npm install @babel/preset-env --save-dev 接着我们在 webpack.config.js 中进行配置 test: /\\.js$/,use: &#123; loader: \"babel-loader\", options: &#123; \"presets\": [ \"@babel/preset-env\" ] &#125;, exclude: path.resolve(__dirname, \"node_modules/\") // 对 node_modules 中的文件不进行转换&#125; 但是观察打包后的文件，let const 和箭头函数都被转为了 ES5，但是 Promise 并没有被转换，因为这是新增的 API 而不是语法，这种新增的 API 靠 preset-env 是转化不了的，它只能转化语法，所以 class 以及 Object.assign 等这些新增的 API 它是不能转换的，如果在版本比较低的浏览器中，由于不支持这些 API，那么就会报错。 这个时候需要 polyfill 为浏览器提供 ES6 的环境，即使用 ES5 或更低的语法去实现上面的 API，有两种解决办法。 下载 @babel/polyfill，并且在入口文件即 index.js 中引入 npm install @babel/polyfill --save 接着在 index.js 中引入 // 引入 @babel/polyfillimport '@babel/polyfill'let x = 1;let y = 2;const add = (x, y) =&gt; &#123; return x + y;&#125;;let result = add(1, 2);let p = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;).then(value =&gt; &#123; console.log(value);&#125;); @babel/polyfill 使用 ES5 的语法实现低版本浏览器中没有的 API，所以即使在低版本的浏览器中也能够运行上面的程序，但是 @babel/polyfill 同时也覆盖了原有的 API，另外我们直接导入了 @babel/polyfill 中的所有内容，其中有一些 API 我们根本没有用到，比如 class，这就会导致打包出的文件体积较大。 为了实现按需加载，我们使用另一种解决办法，下载一个插件 @babel/plugin-transform-runtime，因为 @babel/plugin-transform-runtime 依赖于 @babel/runtime，所以我们也要下载 @babel/runtime，并且 @babel/runtime 生产环境下也要用到，所以不能使用 --save-dev 安装 npm install @babel/plugin-transform-runtime --save-devnpm install @babel/runtime 接着我们在 webpack.config.js 中加入插件的配置 test: /\\.js$/,use: &#123; loader: \"babel-loader\", options: &#123; \"presets\": [ \"@babel/preset-env\" ], \"plugins\": [ \"@babel/plugin-transform-runtime\" ] &#125;&#125; 接着我们去掉 index.js 头部添加的 import &#39;@babel/polyfill&#39;，再次使用 webpack 进行打包即可。 css-loader、style-loader除了可以对 JavaScript 进行打包以外，还可以对 CSS 进行打包，不过 webpack 只能处理 JavaScript，即不能把 CSS 文件当做入口文件进行打包，不过我们可以在 JavaScript 中导入 CSS，当对 JavaScript 进行打包，也会同时对导入的 CSS 进行打包，在 src 中新建 index.css 和 foo.css /* index.css */@import \"foo.css\";body &#123; background-color: #5d4141;&#125; /* foo.css */body &#123; color: white; font-size: 4em;&#125; 我们在 index.css 中通过 @import 语法引入了 foo.css，接着我们在 index.js 中引入 index.css import './index.css'document.write(\"Hello World\"); 我们通过 import &#39;./index.css&#39; 引入了 CSS，webpack 将一切都看作是模块，CSS 文件也可以看做是模块，我们就可以通过 import 将该模块导入。 我们希望有一个 loader 来处理 import &#39;./index.css&#39; 的语法，使样式生效，这里我们需要两个 loader，分别为 css-loader 和 style-loader，首先进行安装 npm install css-loader style-loader --save-dev css-loader 的作用是处理 CSS 文件中 @import 和 url() 这样的语法的，而 style-loader 是将解析完的 CSS 样式作为 style 标签插入到页面的 head 元素中。我们在 webpack.config.js 对 loader 进行配置 test: /\\.css$/,use: [\"style-loader\", \"css-loader\"] loader 的执行是有先后顺序，webpack 会根据 use 中定义的 loader 从后往前执行，所以我们把 css-loader 写在 style-loader 后面，这样就会先执行 css-loader，然后执行 style-loader。 我们运行 npm run dev，在 http://localhost:3000 可以观察到下面的页面 说明我们的配置成功了。 除了处理 CSS 文件，有时候我们会使用 less sass/scss 编写样式，但是这些文件浏览器不能解析，所以我们需要使用相应的 loader 将 less sass/scss 转为 CSS 文件，例如 less-loader sass-loader npm install less less-loader node-sass sass-loader --save-dev 接着我们在 webpack.config.js 中添加相应的配置 &#123; test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"]&#125;,&#123; test: /\\.(sass|scss)$/, use: [\"style-loader\", \"css-loader\", \"sass-loader\"]&#125; less-loader 和 sass-loader 只是把要处理的文件转化为 CSS 文件，最后我们还是需要通过 css-loader 和 style-loader 来处理路径以及将 CSS 插入到页面中。 file-loader、url-loader下面介绍有关处理图片相关的 loader，假设在 index.js 的中引用了图片 let img = new Image();img.src = \"./beauty.jpg\";document.body.appendChild(img); 我们进行打包，发现在浏览器中并没有出现我们想要的图片，因为我们在文件中引用的图片是在 src 目录下的，在 dist 目录下并没有这张图片，所以我们也需要将图片打包到 dist 目录下，如下 import beauty from './beauty.jpg'let img = new Image();img.src = beauty;document.body.appendChild(img); 我们将图片作为模块导入，希望得到该图片的打包后的地址，然后将 img.src 设置为这个地址。这件事情需要一个 loader 去做，这里我们使用 file-loader，它的作用就是将引入的文件(一般是图片)打包到(或者说移动到) 指定目录下，并返回打包后的文件所在的路径，我们需要安装 file-loader npm install file-loader --save-dev 并在 webpack.config.js 中进行配置 &#123; test: /\\.(png|jpe?g|gif|svg)$/, use: &#123; loader: \"file-loader\", options: &#123; name: \"[name].[ext]\", outputPath: \"img/\" &#125; &#125;&#125; 其中 name 是用来配置输出的文件名的，这里我们使用了两个变量 [name] 和 [ext]，[name] 代表打包前文件的名称，[ext] 表示扩展名；outputPath 用来指定打包后文件输出的位置，这个位置是相对于 output.path 的路径。所以会在 dist/img 下打包出一张与原文件名相同的一张图片，并且将该打包后的图片的地址返回，这样在页面中就会出现图片。 有时候对于较小的图片，我们希望将它转为 base64，这样可以减少 http 请求次数。我们使用 url-loader 来做这个事情，它提供了一个 limit 选项，该选项指定一个值，当图片的大小小于该值时就转化为 base64，当大于该值时，就使用 file-loader 进行转换，我们修改 webpack.config.js 的配置 test: /\\.(png|jpe?g|gif|svg)$/,use: &#123; loader: \"url-loader\", options: &#123; name: \"[name].[ext]\", limit: 200*1024 // 小于 200KB 就转化为 base64 编码 &#125;&#125; ts-loader我们在项目中也经常使用 TypeScript 来写程序，因为 TypeScript 的种种好处，可以帮我们减少 bug 产生的几率，但是浏览器也是不认识 TypeScript，我们需要将 TypeScript 转化为 JavaScript，这需要 ts-loader 来帮我们做这件事情，首先我们需要下载相关的包 npm install typescript ts-loader --save-dev 接着我们需要配置 webpack.config.js 以及 tsconfig.json(在项目根目录下新建该文件) test: /\\.ts$/,use: \"ts-loader\" &#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"target\": \"es5\", \"allowJs\": true &#125;, \"include\": [ \"./src/\" ], \"exclude\": [ \"./node_modules/\" ]&#125; 关于 tsconfig.json 的配置不是重点，可以去网上了解相关内容。现在我们就可以自由的写 TypeScript 了。 pluginplugin 是 webpack 的另一大特色，它为我们提供了相当多的功能，在 webpack 打包的整个生命周期中会广播出很多事件，而 plugin 可以监听这些事件，在合适的时机通过 webapck 提供的 API 改变输出的结果。下面就介绍一些常用到的 plugin。 mini-css-extract-plugin在处理 CSS 的 loader 中，我们最后使用 style-loader 将最后的样式以 style 标签的形式插入到页面中，但是如果我们希望将样式抽离出一个 CSS 文件呢? 这个时候我们就需要用到 mini-css-extract-plugin 插件了。首先进行下载 npm install mini-css-extract-plugin --save-dev 接着在 webpack.config.js 中进行配置 const path = require('path');const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; // 省略其他配置 module: &#123; rules: [ // 省略其他 loader 配置 &#123; test: /\\.css$/, use: [MiniCssExtractPlugin.loader, \"css-loader\"] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"main.css\" // 抽离出的 css 文件名称 &#125;) ]&#125;; 首先我们通过 require(&#39;mini-css-extract-plugin&#39;) 引入该插件，接着在 plugins 选项中配置了该插件，并设置了抽离后的 CSS 文件的名称，接着因为我们希望最后抽离出一个 CSS 文件而不是将文件以 style 标签的形式插入到页面中，所以我们使用了 MiniCssExtractPlugin.loader 来替换了 style-loader。 我们运行 npm run build 就可以观察到在 dist 目录下生成了一个 main.css 文件。为了观察到效果，我们在 dist/index.html 中将该 main.css 引入 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;link rel=\"stylesheet\" href=\"./main.css\"&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开该 html 就可以看到效果了。 clean-webpack-plugin该插件的作用是在每次打包前删除 dist 文件夹，这样我们每次都可以看到最新的打包文件。可能你还不能理解这个应用场景，现在我们修改 output.filename 如下 output: &#123; filename: \"[name]@[chunkHash].js\", path: path.resolve(__dirname, \"dist\")&#125; 每次生成的文件由名字和文件内容生成的 hash 值组成，每次我们修改程序，然后打包，就会产生不同的哈希值，所以 dist 下的文件会不断的增多，我们根本不知道哪个文件是我们最新打包出来的，如下 所以我们就有这个需要，在生成新的打包文件之前，将之前的打包文件进行删除。首先下载 clean-webpack-plugin npm install clean-webpack-plugin --save-dev 接着配置 webpack.config.js // 省略其他const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin');module.exports = &#123; // 省略其他配置 plugins: [ new MiniCssExtractPlugin(&#123; filename: \"main.css\" &#125;), new CleanWebpackPlugin() ]&#125;; 再次进行打包，发现之前的 dist 文件夹下之前的打包文件都被删掉了。 html-webpack-plugin使用 clean-webpack-plugin 会将我们之前在 dist 下新建的 index.html 文件也会删除掉，为了观察打包效果，我们不得不在 dist 目录下再次新建 index.html 并且将打包后的 JavaScript 文件和 CSS 文件引入，每次打包一次都要这么做实在令人恼火，我们使用 html-webpack-plugin 来解决这个问题。 html-webpack-plugin 会根据一个 html 文件模板，在 dist 文件夹下生成一个 html 文件，并且会将打包后的 JavaScript 和 CSS 自动引入，大大的解放了我们的双手。首先我们下载 html-webpack-plugin npm install html-webpack-plugin --save-dev 接着在 webpack.config.js 中进行配置 // 省略其他const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // 省略其他配置 plugins: [ new MiniCssExtractPlugin(&#123; filename: \"main.css\" &#125;), new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: \"./src/index.html\", filename: \"index.html\" &#125;) ]&#125;; 其中我们在 HtmlWebpackPlugin 中传入了两个配置项 配置项 作用 template 指定模板的路径 filename 指定生成的 html 文件的文件名 在上面，我们将模板指定为 src/index.html，所以我们在 src 新建 index.html 如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 只是一个标准的 html 文件，里面什么都没有。运行 npm run build 即可观察到在 dist 文件夹下生成了一个 index.html 文件 生成的 index.html 的内容如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;link href=\"main.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"bundle%4063ea546939ae13c70c31.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可见它已经自动为我们引入了打包后的 JavaScript 文件和 CSS 文件。 参考文章 webpack loader和plugin编写 Webpack配置Typescript 你真的会用 Babel 吗? @babel/preset-env, @babel/polyfill和@babel/plugin-transform-runtime webpack 4.0 Babel：plugin、preset的区别与使用 webpack4.0 clean-webpack-plugin 插件跳坑指南","tags":[{"name":"Webapck","slug":"Webapck","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Webapck/"}]},{"title":"使用CSS和JavaScript做一个时钟","date":"2020-07-08T15:31:00.000Z","path":"/使用CSS和JavaScript做一个时钟/","text":"在 Youtube 看到一个使用 CSS 和 JavaScript 实现的时钟效果，觉得是个比较好的练手项目，就跟着做了一个，在深入研究代码的过程中的确学习到了很多的东西，成品效果如下 首先我们搭建基本的页面结构，新建 clock.html 如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"clock.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"clock\"&gt; &lt;div id=\"hour\"&gt;&lt;/div&gt; &lt;div id=\"minute\"&gt;&lt;/div&gt; &lt;div id=\"second\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=\"digits\"&gt;&lt;/div&gt; &lt;script src=\"clock.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结构很简单，分为上下两部分，上面的部分为时钟，下面的部分为时钟的数字显示，所以我们先在 clock.css 写出这样的样式 * &#123; margin: 0; padding: 0; box-sizing: border-box; font-family: Consolas;&#125;body &#123; min-height: 100vh; background-color: #060415; display: flex; justify-content: center; align-items: center; flex-direction: column;&#125; 我们设置了 body 为一个 flex 盒子，并设置了水平和垂直方向都居中，因为是分为上下两部分，所以我们设置了 flex-direction 为 column。这时页面除了 body 的背景颜色，什么效果都没有，接下我们为 clock 写样式 #clock &#123; width: 350px; height: 350px; border: 8px solid #FFFFFF; border-radius: 50%; display: flex; justify-content: center; align-items: center;&#125; 同理，我们把 clock 也设置为了 flex 盒子，并使得它内部的子元素能够居中对齐，目前效果如下 接着我们在时钟的中间添加一个点 #clock::before &#123; position: absolute; content: \"\"; width: 15px; height: 15px; background-color: #2196f3; z-index: 100; border-radius: 50%;&#125; 上面我们设置 ::before 伪元素为绝对定位 position: absolute;，这是为什么呢? 当设置为绝对定位之后，它脱离了文档流，此时它不会受到 flex 盒子的影响，并且此时并没有设置 left, top 等的值，这时的默认位置是它没有脱离文档流时的位置(static position)。那么它没有脱离文档流时的位置在哪里，因为它在 clock 中，并且 clock 中的子元素是居中的，所以它没有脱离文档流时它是居中的，所以这时它是居中的 但是还是没有理解到为什么要设置为绝对定位，我们知道这个点，还有时针，分针和秒针全部都是在中间重合的，如果不设置绝对定位脱离文档流，这些元素是绝对不会重合的，像是这样 但是当它们设置 position: absolute，并且没有设置 top, left 等值时，它们位置会在 static position，在这个例子中即是居中对齐的位置。接着我们为三个针编写样式 #hour, #minute, #second &#123; position: absolute; display: flex; justify-content: center;&#125;#hour &#123; width: 200px; height: 200px;&#125;#hour::before &#123; content: \"\"; width: 8px; height: 50%; background-color: #FFFFFF;&#125;#minute &#123; width: 230px; height: 230px;&#125;#minute::before &#123; content: \"\"; width: 4px; height: 50%; background-color: #FFFFFF;&#125;#second &#123; width: 250px; height: 250px;&#125;#second::before &#123; content: \"\"; width: 2px; height: 50%; background-color: #2196f3;&#125; 上面的代码虽长，但很多都是重复的，观察代码，我们把 hour, minute, second 也全部设置为了绝对定位，就是为了使得它们能够在中间重合。另外我们设置了 hour, minute, second 为 flex 盒子，并设置了水平居中，此时的时钟如下 接下来我们就要让它动起来，并且设置下面的时钟显示，我们使用 JavaScript 实现这个功能 const hour = document.querySelector(\"#hour\");const minute = document.querySelector(\"#minute\");const second = document.querySelector(\"#second\");setInterval(() =&gt; &#123; let day = new Date(); let hours = day.getHours(); let minutes = day.getMinutes(); let seconds = day.getSeconds(); let hourRotateDeg = hours * 30; let minuteRotateDeg = minutes * 6; let secondRotateDeg = seconds * 6; hour.style.transform = `rotateZ($&#123;hourRotateDeg + minuteRotateDeg/12&#125;deg)`; minute.style.transform = `rotateZ($&#123;minuteRotateDeg&#125;deg)`; second.style.transform = `rotateZ($&#123;secondRotateDeg&#125;deg)`; hours = hours &lt; 10 ? \"0\" + hours : hours; minutes = minutes &lt; 10 ? \"0\" + minutes : minutes; seconds = seconds &lt; 10 ? \"0\" + seconds : seconds; let ampm = hours &gt; 12 ? \"PM\" : \"AM\"; let digits = document.querySelector(\"#digits\"); digits.innerHTML = `$&#123;hours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125; $&#123;ampm&#125;`;&#125;, 1000); JavaScript 的代码还是比较简单的，设置了一个每隔 1s 执行一次的定时器，每次我们获得当前的时间，计算出时针、分针以及秒针旋转的角度，设置样式即可。在这其中有一个小的知识点，就是当小时、分钟、秒小于 10 时，我们要在前面补 0。 最后我们通过 innerHTML 设置了要显示的时钟点数，以及相关 CSS 如下 #digits &#123; color: #FFFFFF; font-size: 4em;&#125; 最后成品的效果如下 在最后我总结一下我在这个小小的项目获得的知识，如下 position: relative 不会脱离文档流 position: absolute, float 会脱离文档流 position: absolute 未设置 left, top 等属性时，默认是 static position 而不是 0 display: flex 对处于文档流(normal flow)的元素产生影响，对脱离文档流的元素不产生影响","tags":[{"name":"CSS","slug":"CSS","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"}]},{"title":"JavaScript加号运算符","date":"2020-07-04T16:03:00.000Z","path":"/JavaScript加号运算符/","text":"今天看到几道有关加号的题目，觉得很怪异如下 [] + &#123;&#125; // '[object Object]'[] + [] // ''&#123;&#125; + [] // 0&#123;&#125; + &#123;&#125; // NaN[] + &#123;&#125; == &#123;&#125; + [] // true&#123;&#125; + [] != [] + &#123;&#125; // true 当时我就完全没有搞懂，所以决定探索一下 JavaScript 中的 + 号运算符，另外，对于 toString 和 valueOf 这两个方法一直搞不清会调用哪个，在探索 + 号运算符的过程中也一并搞懂了，我将会在下面仔细讲解。 一元运算符+ 既可以作为一元运算符，也可以作为二元运算符，首先我们先讲解较简单的一元运算符，如下表： 类型 转换规则 undefiend NaN null 0 boolean true =&gt; 1false =&gt; 0 number 原样返回，如 +1 =&gt; 1 string 1. 如果字符串为纯数字组成，如 &quot;5678&quot; =&gt; 56782. 如果不为纯数字，那么返回 NaN3. 空字符串会被转化为 0，即 &quot;&quot; =&gt; 0 symbol 抛出 TypeError 异常 object 分为两步：1. 先进行 toPrimitive 转化为基本数据类型，得到返回值 ret2. 然后对 ret 进行上面描述过程的转换，例如如果返回 true，得到 1 下表是 ECMAScript 中的规范，上面的内容来自这里： Argument Result Undefined NaN Null +0 Boolean The result is 1 if the argument is true. The result is +0 if the argument is false. Number The result equals the input argument (no conversion). String See grammar and note below. Object Apply the following steps:1. Let primValue be ToPrimitive(input argument, hint Number).2. Return ToNumber(primValue). 下面来看几个例子，来验证上面的内容 console.log(+undefined); // NaNconsole.log(+null); // 0console.log(+true); // 1console.log(+false); // 0console.log(+2); // 2console.log(+Symbol()); // Uncaught TypeError: Cannot convert a Symbol value to a numberconsole.log(+\"123\"); // 123console.log(+\"1aa1\"); // NaN 对于对象首先要进行 toPrimitive 转化为原始类型，然后将原始类型转化为数字 let obj1 = &#123; valueOf() &#123; return 12; &#125;&#125;;console.log(+obj1); // 12let obj2 = &#123;&#125;;console.log(+obj2); // NaN 对于空对象，在转化为原始值时得到的是 &quot;[object Object]&quot;，将它转化为数字时，这个字符串不是纯数字，所以会被转化为 NaN。 二元运算符当把 + 作为二元运算符时，遵循以下过程： Let lref be the result of evaluating AdditiveExpression. Let lval be GetValue(lref). ReturnIfAbrupt(lval). Let rref be the result of evaluating MultiplicativeExpression. Let rval be GetValue(rref). ReturnIfAbrupt(rval). Let lprim be ToPrimitive(lval). ReturnIfAbrupt(lprim). Let rprim be ToPrimitive(rval). ReturnIfAbrupt(rprim). If Type(lprim) is String or Type(rprim) is String, then Let lstr be ToString(lprim). ReturnIfAbrupt(lstr). Let rstr be ToString(rprim). ReturnIfAbrupt(rstr). Return the String that is the result of concatenating lstr and rstr. Let lnum be ToNumber(lprim). ReturnIfAbrupt(lnum). Let rnum be ToNumber(rprim). ReturnIfAbrupt(rnum). Return the result of applying the addition operation to lnum and rnum. See the Note below 12.7.5. 上面是 ECMAScript 中的规范，如果英文不太熟的话，下面我将以中文简单翻译如下： 首先将 + 号两边的值通过 toPrimitive 转化为基本数据类型(如果已经是基本数据类型，则原样返回) 如果得到的两个基本数据类型中有字符串，那么将二者转化为字符串拼接起来，将结果返回 如果两个基本数据类型中没有字符串，那么就将两个值转化为数字，然后进行相加 下面来看几个例子： // 两个值中有一个为字符串，则调用二者的 toString 方法，然后进行相加\"\" + 2; // \"2\"true + \"abc\"; // \"trueabc\"// 两个值中没有字符串，那么转化为数字然后相加2 + true; // =&gt; 2 + 1 = 3null + 2; // =&gt; 0 + 2 = 2[] + 2; // =&gt; \"\" + 2 = \"2\" 对于对象要转化为原始类型，然后进行相加，那么对象转化为原始类型的过程是什么? 下面是调用的过程： 如果有 [Symbol.toPrimitive] 方法，则调用 [Symbol.toPrimitive]() 方法转化为原始类型，该方法的返回必须为原始类型 如果没有 [Symbol.toPrimitive] 方法，那么调用 valueOf 方法，如果 valueOf 返回的不是原始值(基本数据类型)，那么就调用 toString 方法，如果 toString 返回的也不是原始值，那么就会报错 [] + 2; // \"\" + 2 = \"2\" 数组也是对象，因为数组没有 [Symbol.toPrimitive] 方法，所以首先会调用数组的 valueOf 方法，因为数组的 valueOf 方法返回的是数组本身，并不是基本数据类型，所以接着会调用数组的 toString 方法，得到一个空字符串 &quot;&quot; ，通过我们上面的讲解，如果两个值中有一个是字符串的话，则会将二者转化为字符串进行拼接，所以 [] + 2 =&gt; &quot;&quot; + 2 = &quot;2&quot;。下面在来看一个例子： let obj = &#123; [Symbol.toPrimitive](hint) &#123; return 20; &#125;, valueOf() &#123; return 0; &#125;&#125;;2 + obj; // 22 由于对象 obj 有 [Symbol.toPrimitive] 方法，所以在转化为基本数据类型时会调用该方法，得到的值为 20，所以 2 + obj =&gt; 2 + 20 = 22。 题目讲解回到开头我们提出的几个例子： [] + &#123;&#125; // '[object Object]' 首先将两个东西转化为基本数据类型，因为它们都没有 [Symbol.toPrimitive] 方法，所以接着会调用它们的 valueOf 方法，但是它们的 valueOf 方法返回的都是它们本身，所以接着会调用它们的 toString 方法，[] 的 toString 方法得到的是 &#39;&#39; 空字符串，{} 的 toString 方法得到的是 &#39;[object Object]&#39;，二者都是字符串，将二者进行拼接，得到的结果是 &#39;[object Object]&#39;。 [] + [] // '' 有上题的经验，[] =&gt; &#39;&#39;，两个空字符串进行拼接得到的结果是 &#39;&#39;。 &#123;&#125; + [] // 0 接着看 {} + []，因为 JavaScript 会将以 { 开头的语句解析为代码块而不是一个空对象，所以 {} + [] 相当于 +[]，这时的 + 相当于是一个一元运算符，根据一元运算符上面讲解的内容，首先将 [] 转化为基本数据类型，得到 &quot;&quot;，接着将 &quot;&quot; 转化为数字，得到的结果为 0。 &#123;&#125; + &#123;&#125; // NaN 根据上一道题的讲解，{} + {} 相当于 +{}，{} 转换为基本数据类型得到的是 &quot;[object Object]&quot;，该字符串转换为数字得到的 NaN，所以结果是 NaN。 [] + &#123;&#125; == &#123;&#125; + [] // true [] + {} 得到的结果是 &#39;[object Object]&#39;，{} + [] 得到的结果并不是 0，因为这时 {} 并不是在语句的开头，会被看做是空对象，所以 {} + [] 得到的结果也是 &#39;[object Object]&#39;，二者是相等的，结果是 true &#123;&#125; + [] != [] + &#123;&#125; // true {} + [] 因为在开头，得到的结果是 0，而 [] + {} 的结果是 [object Object]，二者不相等，所以 {} + [] != [] + {} 的结果也是 true。 参考文献 JavaScript 加号运算符详解 valueOf() vs. toString() in Javascript The Addition operator ( + ) ToNumber ECMAScript7规范中的ToPrimitive抽象操作 Object to primitive conversion Symbol.toPrimitive 与 [] + {} == {} + []","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"},{"name":"+号运算","slug":"号运算","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%8F%B7%E8%BF%90%E7%AE%97/"}]},{"title":"股票的最大利润","date":"2020-07-01T06:35:00.000Z","path":"/股票的最大利润/","text":"题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少? 例如，一只股票在某些时间节点的价格为 $[9, 11, 8, 5, 7, 12, 16, 14]$。如果我们能在价格为 $5$ 的时候买入并在价格为 $16$ 时卖出，则能收获最大的利润 $11$。 如果我们使用蛮力法来解决这个问题，在访问数组中的数字时买入，然后寻找后面的最大值卖出，得到买卖的差值，而我们使用变量保存最大的买卖差值，这样的算法的时间复杂度为 $O(n^2)$。 如果我们换一种思路，如果我们以 $diff(i)$ 表示以数组中第 $i$ 数字将股票卖出能够获得的最大利润($i$ 从 $0$ 开始)，在卖出的价格一定时，买入的价格越低越好，所以我们只要找出前面 $i-1$ 个数字中的最小值即可得到买卖的最大利润，但是我们不用扫描前面的数字，我们完全可以使用一个变量将前面的最小值记录下来。所以这样做的时间复杂度为 $O(n)$，我们只需要扫描一遍数组即可。 代码如下 public static int maxDiff(int[] data) &#123; if (data == null || data.length &lt;= 1) &#123; return 0; &#125; // 最大差值 int maxDiff = 0; int min = data[0]; for (int i = 2; i &lt; data.length; i++) &#123; if (data[i] &gt; min) &#123; // 计算以 data[i] 卖出时的最大差值 int diff = data[i] - min; if (diff &gt; maxDiff) &#123; maxDiff = diff; &#125; &#125; else &#123; // 更新最小值 min = data[i]; &#125; &#125; return maxDiff;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"圆圈中最后剩下的数字","date":"2020-07-01T06:25:00.000Z","path":"/圆圈中最后剩下的数字/","text":"题目：$0, 1, …, n-1$ 这 $n$ 个数字排成一个圈，从数字 $0$ 开始，每次从这个圆圈里删除第 $m$ 个数字。求出这个圆圈里剩下的最后一个数字。 这道题就是有名的约瑟夫环问题，下面介绍两种介绍，第一种是使用链表模拟该环，第二种方法是使用动态规划。 对于使用环形链表模拟环，可以很快的写出这样的代码 public static int lastRemaining(int n, int m) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 将 0 ~ n-1 共 n 个数字添加到链表中 for (int i = 0; i &lt; n; i++) &#123; list.add(i); &#125; // 要删除的元素的下标，因为是环形链表，我们要对链表的长度求余 int currentIndex = (m - 1) % list.size(); // 当链表中有一个以上的元素 while (list.size() &gt; 1) &#123; // 删除元素 list.remove(currentIndex); // 更新下一次要删除的元素的下标 currentIndex = (currentIndex + m - 1) % list.size(); &#125; // 返回链表中仅剩的元素 return list.get(0);&#125; 而另一种方法就是使用动态规划，我们使用 $f(n, m)$ 表示 $n$ 个数字中删除第 $m$ 个数字剩下来的数字。第一个被删除的数字是 $(m-1) % n$，记为 $k$，还剩下 $n - 1$ 个元素，我们来做一个映射 $x$ $y$ $0$ $k + 1$ $1$ $k+2$ $…$ $…$ $n- k - 2$ $n - 1$ $n- k -1$ $0$ $…$ $…$ $n - 2$ $k - 1$ $y$ 序列是删除了元素 $k$ 剩下的元素排序，我们与一个 $0-(n-2)$ 的元素映射起来，$x$ 与 $y$ 之间的对应关系为 $y = (x + k + 1) % n$。因为 $k = (m - 1) % n$，所以 $(k + 1) % n = m % n$，所以上式的关系进一步更改为 $y = (x + m) % n$。 假设 $y$ 序列最后剩下的数字为 $f^{‘}(n-1, m)$，记为 $u$，设 $x$ 序列最后剩下的值为 $v$，那么有这样的一个关系 ​$$f^{‘}(n-1, m) = u = (v + m) % n = (f(n-1, m) + m) % n$$又因为$$f(n,m) = f^{‘}(n-1, m)$$所以们得到了 $f(n,m)$ 与 $f(n-1, m)$ 的递推公式$$f(n,m) = f^{‘}(n-1, m) = u = (f(n-1, m) + m) % n$$所以们得到了 $f(n,m)$ 与 $f(n-1, m)$ 的递推公式$$f(n,m) =\\begin{cases}0, &amp; n = 1 \\\\\\left[f(n-1,m) + m \\right] % n, &amp; n &gt; 1\\end{cases}$$编程如下 public static int lastRemaining(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) &#123; return 0; &#125; int last = 0; for (int i = 2; i &lt;= n; i++) &#123; last = (last + m) % n; &#125; return last;&#125; 虽然我们分析了这么多，但是实际上的代码却是非常的短。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"n个骰子的点数","date":"2020-07-01T05:43:00.000Z","path":"/n个骰子的点数/","text":"题目：把 $n$ 个骰子扔在地上，所有骰子朝上一面的点数之和为 $s$。输入 $n$，打印出 $s$ 所有可能的值出现的概率。 一个骰子总共有 $6$ 面，所以总共有 $6^n$ 总情况，所以我们需要统计出所以 $s$ 可能出现的次数，然后除以 $6 ^ n$ 就可以得到所有值出现的概率。 现在的问题就是怎么统计 $s$ 点出现的次数，我们以 $f(i, s)$ 表示 $i$ 个骰子投出 $s$ 点的次数，因为第 $i$ 个骰子能够投出 $1, 2, 3, 4, 5, 6$ 点 $6$ 种情况，所以只要前 $i - 1$ 个骰子投出 $s-1, s-2, s-3, s-4, s-5, s-6$ 的点数，均可以使得 $i$ 个骰子投出 $s$ 点，所以我们可以得到这样的关系式$$f(i,s) = f(i-1, s-1) + f(i-1, s-2) + f(i-1, s-3) + f(i-1, s-4) + f(i-1, s-5)+ f(i-1, s-6)$$代码如下 public static double[] probability(int n) &#123; if (n &lt; 1) &#123; return new double[]&#123;0&#125;; &#125; // 有n个骰子，为了方便从1开始，所以设置 n + 1 个数组，点数最大为 6n，也是从 1 开始 int[][] numbers = new int[n + 1][6*n + 1]; for (int i = 1; i &lt;= 6; i++) &#123; numbers[1][i] = 1; &#125; // i 表示骰子数 for (int i = 2; i &lt;= n; i++) &#123; // s 表示 i 个骰子投出的点数 for (int s = i; s &lt;= 6 * i; s++) &#123; // cur 表示第 i 个骰子投出的点数 for (int cur = 1; cur &lt;= 6; cur++) &#123; // s - cur 表示前 i - 1 个骰子应该投出的点数 // 前 i - 1 个骰子投出的点数最小值为 i - 1 // 如果 s - cur 小于 i - 1 说明不可能 if (s - cur &lt; i - 1) &#123; break; &#125; numbers[i][s] += numbers[i - 1][s - cur]; &#125; &#125; &#125; double total = Math.pow(6, n); // 最小点数为 n，最大点数为 6n，总共有 6n - n + 1 = 5n + 1种可能 double[] ans = new double[5 * n + 1]; for (int i = n; i &lt;= 6 * n; i++) &#123; ans[i - n] = numbers[n][i] / total; &#125; return ans;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"二叉搜索树的第k大节点","date":"2020-07-01T02:02:00.000Z","path":"/二叉搜索树的第k大节点/","text":"题目：给定一棵二叉搜索树，请找出其中第 $k$ 大的节点。例如，下图的二叉搜索树中，第 $3$ 大的节点是 $7$ 其实解决这道题的算法十分的简单，因为对于二叉搜索树来说，它的中序遍历是排好序的结果，我们要查找第 $k$ 大的节点，只要中序遍历到第 $k$ 个节点即可，这个节点即是第 $k$ 大的节点 public class GetKthNode &#123; // 以全局变量表示还需遍历多少个节点 private static int count; private static class BinaryTreeNode &#123; BinaryTreeNode left; BinaryTreeNode right; int value; public BinaryTreeNode(int value) &#123; this.value = value; this.left = null; this.right = null; &#125; &#125; public static BinaryTreeNode getKthNode(BinaryTreeNode root, int k) &#123; if (root == null || k &lt;= 0) &#123; return null; &#125; count = k; return getKthNode(root); &#125; private static BinaryTreeNode getKthNode(BinaryTreeNode root) &#123; BinaryTreeNode target = null; if (root.left != null) &#123; target = getKthNode(root.left); &#125; if (target == null) &#123; if (count == 1) &#123; target = root; &#125; count--; &#125; if (target == null &amp;&amp; root.right != null) &#123; target = getKthNode(root.right); &#125; return target; &#125; public static void main(String[] args) &#123; BinaryTreeNode root = new BinaryTreeNode(8); root.left = new BinaryTreeNode(6); root.right = new BinaryTreeNode(10); root.left.left = new BinaryTreeNode(5); root.left.right = new BinaryTreeNode(7); root.right.left = new BinaryTreeNode(9); root.right.right = new BinaryTreeNode(11); BinaryTreeNode target = getKthNode(root, 3); System.out.println(target != null ? target.value : \"null\"); // 7 &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"两个链表的第一个公共节点","date":"2020-07-01T01:00:00.000Z","path":"/两个链表的第一个公共节点/","text":"题目：输入两个链表，找出它们的第一个公共节点。链表节点定义如下： private static class ListNode &#123; ListNode next; int value; public ListNode(int value) &#123; this.value = value; this.next = null; &#125;&#125; 首先我们会考虑蛮力法，我们在遍历第一个链表时，每访问一个节点，我们都会去第二个链表查看是否有相同的节点，如果有说明它们重合，这个节点即是它们的公共节点。如果第一个链表的长度为 $m$，第二个链表的长度为 $n$，那么时间复杂度为 $O(mn)$。 如果我们能从链表的尾部开始遍历的话，那么最后一个相同的节点即是它们第一个公共节点。但是由于题目所给出的链表是单向链表，不能从尾部开始遍历。但是我们可以考虑使用栈，我们在遍历两个链表时将节点添加到栈中，接着从栈中取出元素，是不是就相当于从尾部开始遍历链表了。使用这种方法需要 $O(m+n)$ 的时间复杂度和 $O(m + n)$ 的空间复杂度。 现在在考虑一种解法，我们首先获得两个链表的长度，假设第一个链表比第二个链表长 $k$，那么我们先让第一个链表先走 $k$ 步，接着同时遍历两个链表，这时它们会同时到达第一个公共节点，所以当它们遍历的节点相同时，我们就可以知道这个节点是第一个公共节点。该种方法的时间复杂度是 $O(m + n)$，但是不需要额外的空间复杂度。 public static ListNode findFirstCommonNode(ListNode root1, ListNode root2) &#123; if (root1 == null || root2 == null) &#123; return null; &#125; int length1 = getListLength(root1); int length2 = getListLength(root2); ListNode ahead = root1; ListNode after = root2; // 如果链表 2 比链表 1 长，链表 2 先走 if (length2 - length1 &gt; 0) &#123; ahead = root2; after = root1; &#125; // 长的先走 k 步 for (int i = 0; i &lt; Math.abs(length2 - length1); i++) &#123; ahead = ahead.next; &#125; // 当访问的节点相同时，即是第一个公共节点 while (ahead != null &amp;&amp; after != null) &#123; if (ahead == after) &#123; return ahead; &#125; ahead = ahead.next; after = after.next; &#125; return null;&#125;// 获得链表的长度private static int getListLength(ListNode root) &#123; ListNode cur = root; int length = 0; while (cur != null) &#123; length++; cur = cur.next; &#125; return length;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"最大子数组和以及最长子字符串","date":"2020-06-29T14:30:00.000Z","path":"/最大子数组和以及最长子字符串/","text":"题目：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 $O(n)$。 我们假设使用 $f(i)$ 表示以第 $i$ 个数字结尾的子数组的最大和，那么 $f(i +1)$ 与 $f(i)$ 的关系为 $$ f(i) = \\begin{cases} f(i - 1) + data[i], & f(i - 1) > 0 \\\\ data[i], & f(i) \\leq 0 \\end{cases} $$ 如果 $f(i - 1)$ 小于 $0$ 的话，那么 $f(i - 1) + data[i] &lt; data[i]$，所以以第 $i$ 个数字结尾的数组最大和为 $data[i]$。我们最终的目标是寻找 $max [ f(i) ], i = 0, 1, …, n - 1$，所以代码如下 public static int findGreastSumOfSubArray(int[] data) &#123; if (data == null || data.length == 0) &#123; throw new RuntimeException(\"数组为空或null\"); &#125; // f(i) int sum = 0; // max&#123;f(i)&#125; int greastSum = sum; // 遍历数组 for (int i = 0; i &lt; data.length; i++) &#123; if (sum &lt;= 0) &#123; sum = data[i]; &#125; else &#123; sum += data[i]; &#125; // 更新 max&#123;f(i)&#125; if (sum &gt; greastSum) &#123; greastSum = sum; &#125; &#125; return greastSum;&#125; 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含 &#39;a&#39;~&#39;z&#39; 的字符。例如，在字符串 &quot;arabcacfr&quot; 中，最长的不含重复字符的子字符串是 &quot;acfr&quot;，长度为 $4$。 我们定义 $f(i)$ 表示以第 $i$ 个字符结尾的不包含重复字符的子字符串的最长长度，那么 $f(i)$ 与 $f(i - 1)$ 的关系是什么呢? 第 $i$ 个字符从来没有出现过，那么 $f(i) = f(i - 1) + 1$ 第 $i$ 个字符以前出现过，这个时候要分两种情况考虑 以前出现过的字符在以 $f(i - 1)$ 表示的子字符串之中，记这两个重复的字符间的距离为 $d$，并且满足 $d \\leq f(i - 1)$，这时 $f(i)$ 就是 $d$ 如果以前出现的字符在 $f(i - 1)$ 表示的子字符串以外，那么该字符对于 $f(i)$ 来说还是未重复的，所以 $f(i) = f(i - 1) + 1$ 代码如下 public static int getLongestStringWithoutDuplication(String string) &#123; if (string == null || string.length() == 0) &#123; return 0; &#125; char[] str = string.toCharArray(); // 保存字符之前出现过的位置，初始为 -1，表示未出现过 int[] position = new int[26]; for (int i = 0; i &lt; 26; i++) &#123; position[i] = -1; &#125; // f(i) int curLength = 0; // max&#123;f(i)&#125; int maxLength = 0; for (int i = 0; i &lt; str.length; i++) &#123; int prevIndex = position[str[i] - 'a']; // 如果之前未出现过或者 d &gt; f(i - 1)，那么 f(i) = f(i -1) + 1 if (prevIndex &lt; 0 || (i - prevIndex) &gt; curLength) &#123; curLength++; &#125; else &#123; // 如果 f(i) 大于当前的 max&#123;f(i)&#125;，那么更新 max&#123;f(i)&#125; if (curLength &gt; maxLength) &#123; maxLength = curLength; &#125; // d &lt; f(i - 1) 时，f(i) = d = i - preIndex curLength = i - prevIndex; &#125; // 设置字符出现的位置 position[str[i] - 'a'] = i; &#125; if (curLength &gt; maxLength) &#123; maxLength = curLength; &#125; return maxLength;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"数组中出现次数超过一半的数字","date":"2020-06-29T05:01:00.000Z","path":"/数组中出现次数超过一半的数字/","text":"题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为 $9$ 的数组 ${ 1, 2, 3, 2, 2, 2, 5, 4, 2 }$。由于数字 $2$ 在数组中出现了 $5$ 次，超过数组长度的一半，因此输出 $2$。 如果这个数组是排好序的数组，那么我们很容易就可以统计出每个数字出现的次数，但是题目并没有说明数组是排序的，如果我们使用排序算法进行排序，它的时间复杂度为 $O(n\\log n)$，但是这并不是最快的方法，下面介绍两种更快的解法。 如果我们将数组排好序，由于有一个数字的次数超过数组长度的一般，那么中位数一定是该数，即排好序的数组的 $n/2$ 的位置处就是我们需要输出的数字，换句话说，我们需要查找数组中第 $n/2$ 大的数字，对于查找第 $k$ 大的数字，我们可以通过 $partition$ 算法。 $partition$ 是快速排序用到的算法，它将数组分为两部分，前半部分的数小于后半部分的数，返回前半部分和后半部分分界处的下标 $index$($index$ 是前半部分的最后一个数的下标)，如果该下标为 $n/2$，那么找到了我们要输出的数，如果大于 $n/2$，那么数字在前半部分，我们对前半部分继续使用 $partition$ 算法；如果 $index$ 小于 $n / 2$，那么输出的数字在后半部分，我们对后半部分使用 $partition$ 算法。以此往复，直到 $index$ 的值为 $n/2$，我们就将该数输出。 代码如下 // partition 算法private static int partition(int[] data, int start, int end) &#123; if (end &lt; start) &#123; throw new RuntimeException(\"参数错误\"); &#125; int num = data[end]; int more = end + 1; int cur = start; while (cur &lt; more) &#123; if (data[cur] &lt;= num) &#123; cur++; &#125; else &#123; int number = data[cur]; data[cur] = data[--more]; data[more] = number; &#125; &#125; return cur - 1;&#125;public static int findMoreThanHalfNumber(int[] data) &#123; int start = 0; int end = data.length - 1; int index = partition(data, start, end); // middle 代表是 n /2 的位置 int middle = start + (end - start) / 2; while (index != middle) &#123; if (index &lt; middle) &#123; start = index + 1; index = partition(data, start, end); &#125; else &#123; end = index - 1; index = partition(data, start, end); &#125; &#125; return data[index];&#125; 下面讲解第二种解法，题目说有一个数字超过数组长度的一半，说明该数字出现的次数比其他数字出现的次数加起来都多，所以我们可以考虑在遍历数组时保存两个变量，一个保存的是数组中的数字，一个是次数；如果下一个数字与保存的数字不同，那么次数减一，如果相同，那么次数加一。如果次数已经为 $0$，那么设置保存的数字为目前的数字，因为输出的数字出现的次数比其他所有数字出现的次数加起来都多，所以最后保存的数字一定是我们想要输出的数字。 代码如下 public static int moreThanHalfNumber(int[] data) &#123; if (data == null || data.length == 0) &#123; throw new RuntimeException(\"参数操作\"); &#125; // 保存次数 int count = 1; // 保存数字 int result = data[0]; for (int i = 1; i &lt; data.length; i++) &#123; if (count == 0) &#123; result = data[i]; count = 1; continue; &#125; if (result != data[i]) &#123; count--; &#125; else &#123; count++; &#125; &#125; return result;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"字符串的排列","date":"2020-06-29T02:33:00.000Z","path":"/字符串的排列/","text":"题目：输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串 abc，则打印出由字符 a、b、c 所能排列出来的所有字符串 abc、acb、bac、bca、cab 和 cba。 我们要打印出字符串中字符的所有排列，就是要让字符能够出现在所有的位置上。我们的方法如下，首先将字符串分为两部分，第一部分只有首字符一个字符，第二部分是剩下的部分。接着我们分为两步出来 第一步让所有的字符都能够出现在首位，将首字符依次与后面的字符进行交换，这样能够保证首字符可以出现在后面的每个位置上，也可以保证后面的字符出现在第一个位置上 第二步我们固定第一个字符，接着处理第二部分，而第二部分的处理也是将第二部分也分为两部分，首字符与剩下的部分两部分，这是一个递归的过程，通过这样的处理，我们确保每个字符都能够出现在每个位置上 代码如下： public static void permutation(String string) &#123; char[] str = string.toCharArray(); permutation(str, 0);&#125;private static void permutation(char[] str, int index) &#123; if (index == str.length) &#123; System.out.println(new String(str)); &#125; for (int i = index; i &lt; str.length; i++) &#123; // 首字符与后面的字符进行交换 char temp = str[i]; str[i] = str[index]; str[index] = temp; // 固定首字符，处理第二部分 permutation(str, index + 1); // 将字符交换回来，以便首字符能够出现在后面的每个位置 temp = str[i]; str[i] = str[index]; str[index] = temp; &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"复杂链表的复制","date":"2020-06-28T06:06:00.000Z","path":"/复杂链表的复制/","text":"题目：请实现函数 ComplexListNode Clone(ComplexListNode root)，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 sbling 指针指向链表中的任意节点或者 null。复杂链表的节点定义如下： private static class ComplexListNode &#123; ComplexListNode next; ComplexListNode sibling; int value; public ComplexListNode(int value) &#123; this.value = value; &#125;&#125; 一个复杂链表的示例如下所示 看到这个问题，很多人的解决方案是首先复制链表的每一个节点，并使用 next 指针连接起来，第二步再次遍历链表，并且逐次设置 sbling 指针。考虑该链表的长度为 N，那么在每次设置 sbling 节点时都要搜索整个链表，搜索的时间复杂度是 $O(N)$，对于每一个节点都有这个搜索过程，所以整个时间复杂度为 $O(N^2)$。 现在我们可以考虑第二种方法，第一步仍然是根据原始链表的节点 N 创建复制的节点 N&#39;，并将 &lt;N,N&#39;&gt; 放入到一个哈希表中，那么这样一来，第二步就不需要去搜索整个链表，只需要以 $O(1)$ 的复杂度就可以从哈希表中拿到想要的节点。这种情况就是以空间换时间，我们需要 $O(N)$ 的空间复杂度把时间复杂度从 $O(N^2)$ 降到 $O(N)$。 现在我们在考虑一种方法，首先第一步还是根据原始链表的节点 N 复制节点 N&#39;，并且将 N&#39; 链接到 N 之后，如下所示 private static void cloneNodes(ComplexListNode root) &#123; ComplexListNode cur = root; while (cur != null) &#123; ComplexListNode cloneNode = new ComplexListNode(cur.value); cloneNode.next = cur.next; cur.next = cloneNode; cur = cloneNode.next; &#125;&#125; 第二步设置复制出来的节点的 sbling，如果节点 N 的 sbling 指针指向的是 S，那么 N&#39; 的 sbling 指向的就是 S.next，如下 private static void siblingNodes(ComplexListNode root) &#123; ComplexListNode cur = root; while (cur != null) &#123; if (cur.sibling != null) &#123; cur.next.sibling = cur.sibling.next; &#125; cur = cur.next.next; &#125;&#125; 最后一步就是选择这些链表的第偶数个节点通过 next 连接起来，然后返回根节点 private static ComplexListNode reconnect(ComplexListNode root) &#123; ComplexListNode cur = root; ComplexListNode cloneRoot = null; ComplexListNode curClone = null; if (cur != null) &#123; cloneRoot = cur.next; &#125; while (cur != null) &#123; curClone = cur.next; cur = cur.next.next; curClone = curClone.next; &#125; return cloneRoot;&#125; 我们把上面三步接合起来，就是复制链表的完整过程 public static ComplexListNode clone(ComplexListNode root) &#123; cloneNodes(root); siblingNodes(root); return reconnect(root);&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"手写Promise","date":"2020-06-27T16:00:00.000Z","path":"/手写Promise/","text":"Promise的使用回调地狱首先我们了解一下 Promise 出现的背景，假设有下面的程序 let name = getUserNameById(id);let score = getScoreByName(name);let scholarship = getScholarshipByScore(score);console.log(scholarship); 这个程序首先根据 id 去获取名字，接着根据拿到的名字取获得分数，最后根据分数去获取奖学金，最后打印出奖学金。但是这个程序真的能达到预期的效果吗? 答案是不能，因为 JavaScript 是异步的，对于一般的耗时操作并不会立即执行，而是将函数保存在一个队列中，直到代码执行完毕，才会拿出队列中的函数执行。所以上面的函数都不会被立即执行，所以当然没有返回值，所以上面的 name, score, scholarship 都是 undefined。 为了解决这种情况，我们一般会使用回调函数的形式，等我们根据 id 拿到 name 之后，将 name 传入回调函数，这样就可以保证”同步”的效果，所以我们将上面的代码修改如下 getUserNameById(id, function(name) &#123; getScoreByName(name, function(score) &#123; getScholarshipByScore(score, function(scholarship) &#123; console.log(scholarship) &#125;) &#125;)&#125;) 但是上面的程序看起来还是怪吓人的，函数套着函数，像这样的情况我们称之为回调地狱。回调地狱不能使用 try... catch 捕获异常，不能使用 return，并且代码的可读性差，还容易出错。可能现在你还体会不到，上面我们只是嵌套了三层，实际的情况可能有更多的层，使得代码很难阅读。 Promise的简单使用正是为了解决这样的问题，在 ES6 中提出了 Promise 来解决这个问题，我们来看如何使用 Promise，看下面的程序 let p = new Promise(resolve =&gt; &#123; // fn1 setTimeout(() =&gt; &#123; console.log(\"1s\") resolve(1); &#125;, 1000);&#125;);p.then(value =&gt; &#123; // fn2 console.log(value);&#125;); Promise 构造函数接受一个回调函数 fn1，并返回一个对象，该对象有一个 then 方法，then 方法也接受一个回调函数 fn2，只有当 fn1 中接收 resolve 函数执行(当 resolve 执行以后，我们就说该 Promise 对象进入了 fulfilled 状态)，fn2 才会被执行。 以上面的代码为例，首先我们往 Promise 中传递了一个回调函数 fn1，该函数会立即执行 // 向构造函数中传入的回调函数 fn1resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"1s\") resolve(1); &#125;, 1000);&#125; 当该 fn1 的 resolve 函数执行之后，fn2 才会被执行，所以 1s 之后 fn2 才会执行 // then 接收的回调函数 fn2value =&gt; &#123; console.log(value);&#125; fn2 接收的参数 value 是通过 resolve 传入的，在上面我们通过 resolve(1) 传入了参数 1，所以 fn2 接受到的参数为 1。上面执行的结果为 可见 fn2 是在 resolve 函数之后执行的，这样就可以保证代码执行的顺序，并且不用写嵌套的回调函数，而是使用 then 方法进行”平行”的调用。 链式调用所谓的链式调用是指在调用 then 方法之后还可以继续调用 then 方法，如下 let p = new Promise(resolve =&gt; &#123; // fn1 resolve(1);&#125;);p.then(value =&gt; &#123; // fn2 console.log(value); return 2;&#125;).then(value =&gt; &#123; // fn3 console.log(value);&#125;); 输出如下 12 如上所示，我们连续调用了两次 then，在执行时，fn3 是在 fn2 之后执行的，并且 fn3 中的参数 value 是 fn2 的返回值。其实 then 方法也可以不传递任何的参数 let p = new Promise(resolve =&gt; &#123; // fn1 resolve(1);&#125;);p.then(value =&gt; &#123; // fn2 console.log(value); return 2;&#125;) .then() // 没有传递任何的参数 .then(value =&gt; &#123; // fn3 console.log(value);&#125;); 在上面我们调用了没有传入回调函数 then 之后又继续调用了一个 then，根据我们上面所讲的，fn3 接受的参数 value 是第二个 then 回调函数的返回值，但是由于第二个 then 没有回调函数，意味着根本没有返回值，这个时候会把上一层的返回值即 fn2 返回值传到 fn3 所以上面的输出是 12 then 中的回调函数除了可以返回普通的值以外，还可以返回一个 Promise 对象，当返回 Promise 对象时，下面如果继续调用 then，那么 then 中的回调函数要等到这个 Promise 对象中的 resolve 方法执行后才会被执行，即进入了 fulfilled 状态 ，并且这个 then 中回调函数所需的参数是返回的 Promise 对象 resolve 传入的值，如下 let p = new Promise(resolve =&gt; &#123; resolve(1);&#125;);p.then(value =&gt; &#123; // fn1 console.log(value); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"then 返回的Promise\"); resolve(2); &#125;, 1000); &#125;)&#125;) .then(value =&gt; &#123; // fn2 console.log(value);&#125;); fn2 在 fn1 返回的 Promise 进入了 fulfilled 状态之后才会被执行 上面的执行结果为 原型方法上面我们介绍了 resolve 和 then 方法，当我们执行 resolve 方法之后，then 接收的回调函数才会执行。其实传入 Promise 的回调函数有两个参数，一个是 resolve，另一个是 reject，当函数产生错误时，那么我们会调用 reject 方法，这时我们说 Promise 对象进入了 rejetced 状态，这时后面的 then 方法不会执行，与 then 方法相对的是一个 catch 方法，该方法也是接收一个回调函数，该回调函数时用来处理错误的，当该 Promise 对象进入了 rejected 状态，catch 中的回调函数才会被执行，与 then 相似，catch 中回调函数接收的参数是 reject 调用时传入的参数，如下 let p = new Promise((resolve, reject) =&gt; &#123; reject(\"error\");&#125;).then(() =&gt; &#123; console.log(\"then方法执行了\");&#125;).catch(error =&gt; &#123; console.log(\"catch方法执行\"); console.log(\"message: \" + error);&#125;); 结果为 catch方法执行message: error 上面我们调用了 reject，这时后面的 then 中的回调函数是不会执行的，而是会执行 catch 中的回调函数。 其实 then 方法可以接受两个回调函数，第一个回调函数用来处理 resolve 之后的结果，而第二个回调函数则是用来处理 reject 之后的结果，比如上面的程序可以写为 let p = new Promise((resolve, reject) =&gt; &#123; reject(\"error\");&#125;).then(() =&gt; &#123; console.log(\"then方法执行了\");&#125;, error =&gt; &#123; console.log(\"catch方法执行\"); console.log(\"message:\" + error);&#125;) 执行的结果与上面的相同，其实 catch(onError) 函数本质上就是 then(null, onError)。 有的时候无论是成功以否，我们都希望执行一个函数，该函数的作用一般是用来资源的回收，用来完成这个功能的是 finally 函数，该函数也是接收一个回调函数，该回调函数无论是在 fulfilled 状态还是 rejected 状态都是会被执行的 let p = new Promise((resolve, reject) =&gt; &#123; // rejected状态 reject();&#125;).then(() =&gt; &#123; console.log(\"then方法执行了\");&#125;, () =&gt; &#123; console.log(\"catch方法执行\");&#125;).finally(() =&gt; &#123; console.log(\"finally执行了\")&#125;); 最后的执行结果为 catch方法执行finally执行了 现在我们将 reject() 改为 resolve() let p = new Promise((resolve, reject) =&gt; &#123; // fulfilled 状态 resolve();&#125;).then(() =&gt; &#123; console.log(\"then方法执行了\");&#125;, () =&gt; &#123; console.log(\"catch方法执行\");&#125;).finally(() =&gt; &#123; console.log(\"finally执行了\")&#125;); 这时执行的结果为 then方法执行了finally执行了 所以不论出于哪个状态，finally 中的回调函数都会被执行。 静态方法静态方法指的就是通过 Promise 直接调用的方法。 resolve我们首先来介绍 resolve 方法，该函数接收一个参数，返回一个 Promise 对象，根据参数的不同情况，返回值也不相同 参数是一个 Promise 对象，直接返回 let p1 =new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;);let p2 = Promise.resolve(p1);console.log(p1 === p2); // true 参数是一个含有 then 方法的对象(我们也称之为 thenable 对象)，那么会立即执行该 then 方法，该 then 方法接收两个参数，这两个参数分别为返回的 Promise 的 resolve, reject 方法 let p = Promise.resolve(&#123; then(resolve, reject) &#123; resolve(123); &#125;&#125;);p.then(value =&gt; &#123; console.log(value); // 123&#125;); 参数不是上面两种情况，那么会返回的一个 fulfilled 状态的 Promise，该 Promise 会将参数传给后面的 then let p = Promise.resolve(\"123\");p.then(value =&gt; &#123; console.log(value); // 123&#125;); all该方法也会返回一个 Promise 对象，它接受一个由 Promise 对象组成的数组，只有当该数组中的所有 Promise 对象都变为 fulfilled 状态之后，返回的 Promise 对象才会变为 fulfilled 状态 let p1 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p1\"); resolve(1); &#125;, 1000);&#125;);let p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p2\"); resolve(2); &#125;, 2000);&#125;);let p3 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p3\"); resolve(3); &#125;, 3000);&#125;);Promise.all([p1, p2, p3]).then(results =&gt; &#123; console.log(results); // [ 1, 2, 3 ]&#125;); 在上面我们定义三个 Promise 对象，这个三个对象分别在 1s, 2s, 3s 后变为 fulfilled，所以返回的 Promise 对象在 3s 后变为 fulfilled 状态，并且会将这三个 Promise 对象向 resolve 传入的值形成数组传入到返回的 Promise 的 resolve 中 上面代码的执行结果为 racerace 方法它也会返回一个 Promise 对象，同 all 方法一样，它也接受一个由 Promise 对象组成的数组，但是不是当所有的 Promise 对象变为 fulfilled 后，返回的 Promise 对象才会变为 fulfilled，而是这些 Promise 对象进行竞赛，当最快的一个 Promise 对象变为 fulfilled 状态时，返回的 Promise 对象就会变为 fulfilled let p1 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p1\"); resolve(1); &#125;, 1000);&#125;);let p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p2\"); resolve(2); &#125;, 2000);&#125;);let p3 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p3\"); resolve(3); &#125;, 3000);&#125;);Promise.race([p1, p2, p3]).then(result =&gt; &#123; console.log(result);&#125;); 并且会将向最快变为 fulfilled 状态的 Promise 对象的 resolve 传入的值传入到返回的 Promise 对象的 resolve 方法中 所以上面程序的执行结果为 可见当 p1 变为 fulfilled 之后，返回的 Promise 也变为了 fulfilled 状态，并且拿到了向 p1 的 resolve 中传入的值。 实现Promise简单实现下面就将简单实现一个 Promise。首先我们要明确，Promise 有三个状态，分别为 pending, fulfilled, rejected 三个状态，初始时的 Promise 是 pending 状态，当调用 resolve 方法后就会变为 fulfilled 状态，当处于 fulfilled 状态时，then 中的第一个回调函数才会被执行；调用 reject 方法就会变为 rejected 状态，当处于 rejected 状态时，then 中的第二个回调函数才会被执行或者 catch 中的回调函数才会被执行。并且 fulfilled 和 rejected 状态只能由 pending 状态转变而来，并且一般转变为 fulfilled 状态或者 rejected 状态，那么状态就不能再次进行转变 class Promise &#123; // Promise的三个状态 PENDING = 'pending'; FULFILLED = 'fulfilled'; REJECTED = 'rejected'; // 当前状态 state = this.PENDING; // 传给 then 中回调函数的值 value = null; // 构造函数，接收一个回调函数，立即执行该函数并将 _resolve 和 _reject 传入 constructor(fn) &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; // 当执行到 then 方法但还未变为 fulfilled 状态时，那么将向 then 中传入的回调函数先保存起来 callbacks = []; _resolve(value) &#123; // 如果状态不为 pending，说明状态已发生改变，不再执行 if (this.state !== this.PENDING) &#123; return; &#125; // 将要传给 then 中回调函数的值保存起来 this.value = value; // 改变状态 this.state = this.FULFILLED; // 执行向 then 中传入的 onFulfilled 函数 this.callbacks.forEach(callback =&gt; callback.onFulfilled(this.value)); &#125; _reject(error) &#123; // 过程同 reject if (!this.PENDING) &#123; return; &#125; this.value = error; this.state = this.REJECTED; this.callbacks.forEach(callback =&gt; callback.onRejected(this.value)); &#125; then(onFulfilled, onRejected) &#123; // 如果当前的状态为 pending，那么将回调函数保存到 callbacks 函数中，等到状态改变时执行 if (this.state === this.PENDING) &#123; this.callbacks.push(&#123; onFulfilled, onRejected &#125;); return; &#125; // 如果状态为 fulfilled 状态，则执行 onFulfilled 方法 if (this.state === this.FULFILLED) &#123; onFulfilled(this.value); return; &#125; // 同上 if (this.state === this.REJECTED) &#123; onRejected(this.value); return; &#125; &#125;&#125; 上面的程序的注释描述了程序的功能，相比还是不难理解的，现在我们来测试一下是否有效 let p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"1s后\"); resolve(1); &#125;, 1000);&#125;);p.then(value =&gt; &#123; console.log(value);&#125;); 结果如下 链式调用现在我们来实现链式调用，要实现链式调用就需要返回一个 Promise，每次调用 then 方法我们都返回一个新的 Promise，修改如下 _resolve(value) &#123; if (this.state !== this.PENDING) &#123; return; &#125; this.value = value; this.state = this.FULFILLED; // 修改了这里，由于需要将 then 中的回调函数的返回值返回，所以不能简单的调用 this.callbacks.forEach(callback =&gt; this._handle(callback));&#125;_reject(error) &#123; if (!this.PENDING) &#123; return; &#125; this.value = error; this.state = this.REJECTED; // 同 resolve this.callbacks.forEach(callback =&gt; this._handle(callback));&#125;then(onFulfilled, onRejected) &#123; // 返回新的 Promise return new Promise((resolve, reject) =&gt; &#123; this._handle(&#123; onFulfilled, onRejected, resolve, reject &#125;) &#125;)&#125;_handle(callback) &#123; // 如果是 pending 状态，将 callback 延迟执行 if (this.state === this.PENDING) &#123; this.callbacks.push(callback); &#125; if (this.state === this.FULFILLED) &#123; // 如果 then 方法没有传入 onFulFilled 回调函数，那么将上一层返回的值传入 if (!callback.onFulfilled) &#123; callback.resolve(this.value); return; &#125; // 如果有 onFulFilled 函数，那么将 onFulFilled 函数的返回值传入到返回的 Promise 对象的 resolve 中 try &#123; // 用户传入的回调函数可能会出错，所以使用 try...catch 包裹起来 let ret = callback.onFulfilled(this.value); callback.resolve(ret); &#125; catch (e) &#123; // 当传入的回调函数出错时，Promise 变为 rejected状态 callback.reject(e); &#125; &#125; if (this.state === this.REJECTED) &#123; if (!callback.onRejected) &#123; callback.reject(this.value); return; &#125; let ret = callback.onRejected(this.value); callback.reject(ret); &#125;&#125; 现在我们来测试一下是否能够进行链式调用 let p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"1s后\"); resolve(1); &#125;, 1000);&#125;);p.then(value =&gt; &#123; console.log(value); return 2;&#125;).then() // 什么回调函数都没有传入，会将上一个 then 返回的值传入 .then(value =&gt; &#123; console.log(value);&#125;); 上面的执行结果为 上面我们还要最后一个问题没有解决，就是如果 then 中的回调函数返回的是 Promise 对象，那么我们就要在 _resolve 对值进行判断，如果值是 Promise 对象，记作 p1，那么 then 返回的 Promise 对象 p2 的 resolve 方法应当在 p1 对象的 resolve 执行之后执行。修改 _resolve 如下 _resolve(value) &#123; if (this.state !== this.PENDING) &#123; return; &#125; // 只增加了下面的代码 if (value instanceof Promise) &#123; // 当前 resolve 的执行应当在 value 的 resolve 执行之后 value.then(this._resolve.bind(this), this._reject.bind(this)); return; &#125; this.value = value; this.state = this.FULFILLED; this.callbacks.forEach(callback =&gt; this._handle(callback));&#125; 现在我们来验证一番 let p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"1s后\"); resolve(1); &#125;, 1000);&#125;);p.then(value =&gt; &#123; console.log(value); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"又1s后\"); resolve(2); &#125;, 1000) &#125;);&#125;).then(value =&gt; &#123; console.log(value);&#125;); 执行结果为 原型方法接下来继续实现 Promise 对象的几个原型方法，分别是 catch 和 finally。catch 的实现很简单 catch(onRejected) &#123; return this.then(null, onRejected);&#125; 接下来是实现 finally 方法，最容易想到的版本是 finally(onDone) &#123; return this.then(onDone, onDone);&#125; 不管是处于 fulfilled 的状态还是 rejected 的状态，onDone 方法都会得到执行，但是使用这样的方式有缺点 onDone 方法是无论失败还是成功时都会执行的，所以它应该没有参数，但是使用 then(onDone, onDone) 的方式就会传入参数 如果 onDone 返回一个 Promise 对象的话，那么会改变 finally 返回的 Promise 的状态 处于上述考虑，我们使用下面的实现方式 finally(onDone) &#123; if (typeof onDone !== 'function') &#123; return this.then(); &#125; // 无论成功与否，onDone() 都会执行，且不需要参数 // 另外执行 finally 不会影响之前的 Promise 状态 return this.then( value =&gt; Promise.resolve(onDone()).then(() =&gt; value), error =&gt; Promise.resolve(onDone()).then(() =&gt; &#123;throw error&#125;) );&#125; 静态方法最后来实现 Promise 的静态方法，首先实现 resolve 方法，对于该方法的使用我们在用法那里已经介绍过了，所以这里直接贴出实现的代码 static resolve(value) &#123; // 如果传入的是 Promise 对象，直接返回 if (value instanceof Promise) &#123; return value; &#125; // 如果传入的是 thenable 对象，则立即执行对象的 then，并将 resolve 和 reject 传入 if (value &amp;&amp; typeof value === 'object' &amp;&amp; typeof value.then === 'function') &#123; return new Promise((resolve, reject) =&gt; value.then(resolve, reject)); &#125; if (value) &#123; // 如果不是上面两种情况，并且 value 存在，那么直接将 value 传入 resolve return new Promise(resolve =&gt; resolve(value)); &#125; else &#123; return new Promise(resolve =&gt; resolve()); &#125;&#125; all 方法在上面也介绍过了，只有当所有传入的 Promise 对象都变为 fulfilled 状态，返回的 Promise 对象才会变为 fulfilled 状态，所以我们使用一个变量来统计已经变为 fulfilled 状态的 Promise 对象的个数，当所有 Promise 对象都变为 fulfilled 状态时，执行 resolve 方法，将返回的 Promise 对象变为 fulfilled 状态，如下 static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; // Promise 对象的个数 let itemLength = promises.length; // 统计已变为 fulfilled 状态的 Promise 对象个数 let finishedPromise = 0; // 返回的数组 let results = Array.from(&#123;length: itemLength&#125;); promises.forEach(promise =&gt; &#123; promise.then(result =&gt; &#123; results[finishedPromise] = result; finishedPromise++; // 当所有的 Promise 对象变为 fulfilled 时，返回的 Promise 对象状态变为 fulfilled if (finishedPromise == itemLength) resolve(results); &#125; &#125;, error =&gt; &#123; // 只要有一个变为 rejected，那么直接变为 rejected 状态 reject(error); &#125;) &#125;) &#125;)&#125; race 方法的用法也介绍过，在这里我们利用 resolve 方法只会执行一次的特性，我们很快可以写出这样的代码 static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; promise.then(result =&gt; &#123; resolve(result); &#125;, error =&gt; &#123; reject(error); &#125;) &#125;) &#125;)&#125; 由于 resolve 只会执行一次，只有最先变为 fulfilled 状态的 Promise 对象能将它 resolve 的值传入。 完整代码class Promise &#123; PENDING = 'pending'; FULFILLED = 'fulfilled'; REJECTED = 'rejected'; state = this.PENDING; value = null; constructor(fn) &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; callbacks = []; _resolve(value) &#123; if (this.state !== this.PENDING) &#123; return; &#125; if (value instanceof Promise) &#123; value.then(this._resolve.bind(this), this._reject.bind(this)); return; &#125; this.value = value; this.state = this.FULFILLED; this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125; _reject(error) &#123; if (!this.PENDING) &#123; return; &#125; this.value = error; this.state = this.REJECTED; this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125; then(onFulfilled, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; this._handle(&#123; onFulfilled, onRejected, resolve, reject &#125;) &#125;) &#125; catch(onRejected) &#123; return this.then(null, onRejected); &#125; finally(onDone) &#123; if (typeof onDone !== 'function') &#123; return this.then(); &#125; return this.then( value =&gt; Promise.resolve(onDone()).then(() =&gt; value), error =&gt; Promise.resolve(onDone()).then(() =&gt; &#123;throw error&#125;) ); &#125; _handle(callback) &#123; if (this.state === this.PENDING) &#123; this.callbacks.push(callback); &#125; if (this.state === this.FULFILLED) &#123; if (!callback.onFulfilled) &#123; callback.resolve(this.value); return; &#125; try &#123; let ret = callback.onFulfilled(this.value); callback.resolve(ret); &#125; catch (e) &#123; callback.reject(e); &#125; &#125; if (this.state === this.REJECTED) &#123; if (!callback.onRejected) &#123; callback.reject(this.value); return; &#125; let ret = callback.onRejected(this.value); callback.reject(ret); &#125; &#125; static resolve(value) &#123; if (value instanceof Promise) &#123; return value; &#125; if (value &amp;&amp; typeof value === 'object' &amp;&amp; typeof value.then === 'function') &#123; return new Promise((resolve, reject) =&gt; value.then(resolve, reject)); &#125; if (value) &#123; return new Promise(resolve =&gt; resolve(value)); &#125; else &#123; return new Promise(resolve =&gt; resolve()); &#125; &#125; static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let itemLength = promises.length; let finishedPromise = 0; let results = Array.from(&#123;length: itemLength&#125;); promises.forEach(promise =&gt; &#123; promise.then(result =&gt; &#123; results[finishedPromise] = result; finishedPromise++; if (finishedPromise == itemLength) &#123; resolve(results); &#125; &#125;, error =&gt; &#123; reject(error); &#125;) &#125;) &#125;) &#125; static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; promise.then(result =&gt; &#123; resolve(result); &#125;, error =&gt; &#123; reject(error); &#125;) &#125;) &#125;) &#125;&#125; 参考文章 图解 Promise 实现原理（一）：先写一个基础的 Promise 图解 Promise 实现原理（二）： Promise 链式调用 图解 Promise 实现原理（三）：Promise 原型方法实现 图解 Promise 实现原理（四）：Promise 静态方法实现 Promise.all和Promise.race源码实现","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Promise/"}]},{"title":"从上到下打印二叉树","date":"2020-06-25T16:00:00.000Z","path":"/从上到下打印二叉树/","text":"题目：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。例如下面的二叉树 依次打印出 8, 6, 10, 5, 7, 9, 11。二叉树节点的定义如下： private static class BinaryTreeNode &#123; private BinaryTreeNode left; private BinaryTreeNode right; int value; public BinaryTreeNode(int value) &#123; this.left = null; this.right = null; this.value = value; &#125;&#125; 这道题考察的是树的层序遍历，对于按层遍历的方法，我们使用队列来辅助遍历，具体方法如下，对于根节点，我们将它放入队列中，然后从队列中取出一个元素进行打印，然后将该节点的左右子节点放入队列中，接着从队列中取出一个元素，打印该元素，然后将该元素的左右子节点添加到队列中，重复上面的过程，直到队列为空，我们从下图来看上面的过程 代码如下 public static void printFromTopToBottom(BinaryTreeNode root) &#123; if (root == null) &#123; return; &#125; Queue&lt;BinaryTreeNode&gt; queue = new LinkedList&lt;&gt;(); // 先将根节点添加进队列 queue.offer(root); // 队列不为空时 while (!queue.isEmpty()) &#123; // 每次将队首元素弹出并打印 BinaryTreeNode node = queue.poll(); System.out.println(node.value); // 然后将该元素的左右子节点添加进队列 if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; 题目：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。如打印下面二叉树的结果为： 8 6 10 5 7 9 11 这道题目和上面的题目类似，不过我们要用两个变量两保存当前层还要打印的节点数目和下一层要打印的节点数目。我们使用 toBePrinted 来保存当前层还需要打印的节点的数目，nextLevel 来保存下一层要打印的节点数目。当 toBePrinted 不为 0，每添加一个元素时 nextLevel++，每弹出一个元素 toBePrinted--，当 toBePrinted 为 0 时，我们打印换行，并将 nextLevel 赋值给 toBePrinted，并且设置 nextLevel 为 0，代码如下 public static void printWithLevel(BinaryTreeNode root) if (root == null) &#123; return; &#125; Queue&lt;BinaryTreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int nextLevel = 0; int toBePrinted = 1; while (!queue.isEmpty()) &#123; BinaryTreeNode node = queue.poll(); System.out.print(node.value + \"\\t\"); toBePrinted--; if (node.left != null) &#123; queue.offer(node.left); nextLevel++; &#125; if (node.right != null) &#123; queue.offer(node.right); nextLevel++; &#125; if (toBePrinted == 0) &#123; System.out.println(); toBePrinted = nextLevel; nextLevel = 0; &#125; &#125;&#125; 题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三层再按照从左到右的顺序打印，其他行以此类推。 按之字形打印树的过程还是比较复杂的，可能一时难以想到解决方案，可能需要使用具体的例子一步步分析看是否能找到解决方案。以下面的树为例 对于奇数层(从 1 开始)，我们将节点保存到一个栈中，如 stack1，对于偶数层，我们将节点保存到另一个栈中，如 stack2。在奇数层时，我们每次从栈 stack1 中弹出一个元素并打印，并将元素的左孩子(先)和右孩子添加到 stack2 中，当 stack1 为空时，说明该层的元素已全部打印完毕，切换到 stack2，我们每次从 stack2 中弹出一个元素并打印，并将该元素的右孩子(先)和左孩子(后)添加到 stack1 中，当 stack2 为空时，切换到 stack1，直到 stack1 和 stack2 同时为空时，打印过程结束 public static void printZhi(BinaryTreeNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;BinaryTreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;BinaryTreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root); // 表示所在的层数，从 1 开始 int level = 1; while (!stack1.isEmpty() || !stack2.isEmpty()) &#123; // 奇数层从stack1中取出元素，并将元素的左孩子和右孩子添加到stack2中 if (level % 2 == 1) &#123; BinaryTreeNode node = stack1.pop(); System.out.print(node.value + \"\\t\"); if (node.left != null) &#123; stack2.push(node.left); &#125; if (node.right != null) &#123; stack2.push(node.right); &#125; // 当 stack1 为空，来到下一层 if (stack1.isEmpty()) &#123; System.out.println(); level++; &#125; &#125; else &#123; // stack2 的过程同上，不过先将右孩子先添加到stack1中 BinaryTreeNode node = stack2.pop(); System.out.print(node.value + \"\\t\"); if (node.right != null) &#123; stack1.push(node.right); &#125; if (node.left != null) &#123; stack1.push(node.left); &#125; if (stack2.isEmpty()) &#123; System.out.println(); level++; &#125; &#125; &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"链表的倒数第k个节点","date":"2020-06-15T16:00:00.000Z","path":"/链表中倒数第k个节点/","text":"题目：输入一个链表，输出该链表的倒数第 $k$ 个节点。为了符合大多数人的习惯，本题从 $1$ 开始计数，即链表的尾节点是倒数第一个节点。例如，一个链表有 $6$ 个节点，如下 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，这个链表的倒数第 $3$ 个节点是值为 $4$ 的节点。链表的定义如下： private static class ListNode &#123; public ListNode next; public int value; public ListNode(int value) &#123; this.next = null; this.value = value; &#125;&#125; 我们的第一个思路就是先遍历链表，直到结尾，接着回溯 $k - 1$ 步即可获得倒数第 $k$ 个节点 但是从上面链表的定义可以看出，该链表是一个单向的链表，我们根本无法进行回溯。 所以我们自然的想到了第二种办法，首先遍历一遍链表，并且统计链表中节点的个数 $n$，这样我们只要向前走 $n - k$ 步即可到倒数第 $k$ 个节点 这种方法需要遍历两遍链表，如果面试官告诉你只需要遍历一遍即可，我们应当怎么做。这个时候我们可以定义两个前后指针，首先第一个指针先走 $k - 1$ 步，然后两个指针同时向前走，当第一个指针到达尾节点时，第二个指针也就到达了倒数第 $k$ 个节点，该种方法只需要遍历一遍链表 代码如下： public class FindKthToTail &#123; private static class ListNode &#123; public ListNode next; public int value; public ListNode(int value) &#123; this.next = null; this.value = value; &#125; &#125; public static ListNode findKthToTail(ListNode root, int k) &#123; if (root == null || k &lt;= 0) &#123; return null; &#125; ListNode ahead = root; ListNode after = root; // 第一个指针先走 k - 1 步，如果链表的长度小于 k ，则返回 null for (int i = 0; i &lt; k - 1; i++) &#123; if (ahead.next == null) &#123; return null; &#125; ahead = ahead.next; &#125; // 二者同时走，当第一个指针到达尾节点，第二个指针到达倒数第 k 个节点 while(ahead.next != null) &#123; ahead = ahead.next; after = after.next; &#125; return after; &#125; public static void main(String[] args) &#123; ListNode root = new ListNode(1); root.next = new ListNode(2); root.next.next = new ListNode(3); root.next.next.next = new ListNode(4); ListNode result = findKthToTail(root, 2); System.out.println(result != null ? result.value : \"null\"); // 3 &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"链表中环的入口节点","date":"2020-06-15T16:00:00.000Z","path":"/链表中环的入口节点/","text":"如何链表中包含环，如何找出环的入口节点? 例如，在如图所示的链表中，环的入口节点是节点 $3$。 解决这道题的思路分为两步，第一步是确定该链表有没有环，我们定义两个指针，一个快指针，一个慢指针，快指针一次性走两步，慢指针一次性走一步。如果有环的话，那么快指针和慢指针就会相遇，并且是在环内相遇；如果没有环的话，那么快指针就会到达尾节点，慢指针与快指针不会相遇。 public static ListNode meetingNode(ListNode root) &#123; if (root == null) &#123; return null; &#125; // 慢指针先走一步 ListNode slow = root.next; if (slow == null) &#123; return null; &#125; // 快指针先走两步 ListNode fast = slow.next; while (slow != null &amp;&amp; fast != null) &#123; if (slow == fast) &#123; return fast; &#125; slow = slow.next; fast = fast.next; if (fast != null) &#123; fast = fast.next; &#125; &#125; return null; 第二步就是确定环的入口节点，首先我们拿到在第一步中快慢指针相遇的节点，让这个节点遍历环以统计环的数目，当这个节点回到原地时即走了一圈。拿到环的数目 $k$ 以后，我们继续定义两个指针，一个指针先走 $k$ 步，然后两个指针继续走，当两个指针相遇时，即是环的入口节点 public static ListNode entryNodeOfLoop(ListNode root) &#123; // 获得相遇的节点 ListNode meetingNode = meetingNode(root); if (meetingNode == null) &#123; return null; &#125; // 统计环中节点数目 int count = 1; ListNode loopNode = meetingNode; while (loopNode.next != meetingNode) &#123; count++; loopNode = loopNode.next; &#125; ListNode ahead = root; ListNode after = root; // ahead 先走 count 步 for (int i = 0; i &lt; count; i++) &#123; ahead = ahead.next; &#125; // 相遇节点即为环的入口节点 while (ahead != after) &#123; ahead = ahead.next; after = after.next; &#125; return after;&#125; 测试如下 public static void main(String[] args) &#123; ListNode root = new ListNode(1); root.next = new ListNode(2); root.next.next = new ListNode(3); root.next.next.next = new ListNode(4); root.next.next.next.next = new ListNode(5); root.next.next.next.next.next = new ListNode(6); root.next.next.next.next.next.next = root.next.next; ListNode entryNode = entryNodeOfLoop(root); System.out.println(entryNode != null ? entryNode.value : \"null\"); // 3&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"表示数值的字符串","date":"2020-06-12T16:00:00.000Z","path":"/表示数值的字符串/","text":"题目：请实现一个函数用来判断字符串是否表示数值(包括整数和小数)。例如，字符串 +100, 5e2, -123, 3.14e+1 都表示数值，而 12e, 1a3.12, 1.2.3, +-5 都不是。 首先我们要明白数值的格式为 A.B[e|E]C，其中 A, B, C 代表的是数字，有一点不同的是 A, C 中的前方可以有正负号，而 B 不能有正负号。我们变成的思路便是，首先扫描字符串，看是否匹配 A，即字符串的前方是否是数字(可包含正负号)，接着如果碰到小数点，则扫描小数点后的字符是否是数字(不能包含正负号)；最后匹配科学计数法，如果碰到 e|E，那么扫描后面的字符是否是数字(可包含正负号)。 代码如下： public class IsNumberic &#123; // 全局变量，控制从哪里开始扫描字符串 private static int index; public static boolean isNumberic(char[] str) &#123; if (str == null) &#123; return false; &#125; // 扫描字符串开头是否是数字(可带正负号) boolean numberic = scanInteger(str, 0); if (index &lt; str.length) &#123; // 如果有小数点 if (str[index] == '.') &#123; index++; // 扫描小数点后的数字(不带正负号) // 使用 || 是因为 A. 或者 .B都算有效的数值 numberic = scanUnsignedInteger(str, index) || numberic; &#125; &#125; if (index &lt; str.length) &#123; // 如果扫描到 e|E if (str[index] == 'e' || str[index] == 'E') &#123; index++; // 扫描 e|E 字符后面是否为数字(可带正负号) numberic = numberic &amp;&amp; scanInteger(str, index); &#125; &#125; // 符合A.B[e|E]C的形式，并且字符串全部扫描完毕 return numberic &amp;&amp; index == str.length; &#125; // 判断从某个位置开始，后面是否有数字(可带正负号) private static boolean scanInteger(char[] str, int start) &#123; if (start &gt;= str.length) &#123; return false; &#125; if (str[start] == '+' || str[start] == '-') &#123; return scanUnsignedInteger(str, start + 1); &#125; return scanUnsignedInteger(str, start); &#125; // 判断从某个位置开始，后面是否有数字(不带正负号) private static boolean scanUnsignedInteger(char[] str, int start) &#123; index = start; if (index &lt; str.length) &#123; while(str[index] &gt;= '0' &amp;&amp; str[index] &lt;= '9') &#123; index++; if (index == str.length) &#123; break; &#125; &#125; &#125; return index &gt; start; &#125; public static void main(String[] args) &#123; System.out.println(isNumberic(\".123\".toCharArray())); // true System.out.println(isNumberic(\"123.\".toCharArray())); // true System.out.println(isNumberic(\"+.123\".toCharArray())); // true System.out.println(isNumberic(\"-.123\".toCharArray())); // true System.out.println(isNumberic(\".123e-2\".toCharArray())); // true System.out.println(isNumberic(\"1.2.2\".toCharArray())); // false System.out.println(isNumberic(\"1.2e+2\".toCharArray())); // true &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"二进制中1的个数","date":"2020-06-10T16:00:00.000Z","path":"/二进制中1的个数/","text":"题目：请实现一个函数，输入一个整数，输出该数二进制表示中 $1$ 的个数。例如，把 $9$ 表示成二进制是 $1001$，有 $2$ 位是 $1$。因此，如果输入 $9$，则该函数输出 $2$。 我们通过将数字与 $1$ 相与，即可知道数字的二进制的最后一位是否为 $1$，我们只要逐渐的将数字进行右移，即可统计出数字中 $1$ 的数目，所以会写下这样的代码 public static int numbersOfOne(int n) &#123; int count = 0; while (n != 0) &#123; if ((n &amp; 1) != 0) &#123; count++; &#125; n = n &gt;&gt; 1; &#125; return count;&#125; 但是上面的代码有一个问题，那就是如果输入的整数为负数呢? 根据负数的表示原则，它的首位是 $1$ 来表示数字的正负性，在右移的过程中，首位会进行补 $1$ 以表示它的符号还是负的，这个时候统计出的数字就是错误的了，并且会造成上面代码的死循环，如下以 $8$ 位表示的 $-7$ 为例 为了解决负数引起的问题，我们可以反其道而行之，让 $1$ 进行左移，然后与数字相与，同样也可以统计出数字 $1$ 的个数，所以修改代码如下 public static int numbersOfOne(int n) &#123; int count = 0; int flag = 1; while (flag != 0) &#123; if ((n &amp; flag) != 0) &#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count;&#125; 但是我们发现统计负数中 $1$ 的个数的结果与我们想象的不符，比如我们统计 $-7$ 的个数，结果为 public static void main(String[] args) &#123; System.out.println(numbersOfOne(-7)); // 30&#125; 结果是 $30$ 而不是 $4$，难道是我们的算法错了，其实不是，而是计算机存储数字是以其补码进行存储的，对于正数来说，它的补码是它本身，而对于负数，则是将除符号位进行取反，然后加 $1$，所以 $-7$ 的补码为 上面计算出一个数字二进制表示的 $1$ 的个数需要进行 $32$ 次循环(对于 int 类型的数据)，我们可以进一步对算法进行改进，使得二进制中有几个 $1$ 则进行几次循环。为了理解下面讲的算法，我们来看一下将一个数字减去 $1$ 它的二进制会发生什么变化? 先说结论，假设数字二进制最右边的 $1$ 在第 $m$ 位，即第 $m$ 位后面的位全是 $0$，在减去 $1$ 之后，第 $m$ 位的 $1$ 变成 $0$，后面的 $0$ 全部变为 $1$，而第 $m$ 位前面的数字保持不变，以 $8$ 位表示的 $10$ 为例 那么我们将数字 $n$ 与 $n - 1$ 进行相与会得到什么，因为 $n - 1$ 第 $m$ 位前面的数字不变，所以 $n - 1$ 的第 $m$ 位以前的数字与 $n$ 相同，所以 $n$ &amp; $n - 1$ 得到的第 $m$ 位以前的二进制是不变的，而 $n - 1$ 第 $m$ 位变成 $0$，以及第 $m$ 位以后的 $0$ 变为 $1$，所以 $n$ &amp; $n - 1$ 得到的第 $m$ 位及第 $m$ 位以后的二进制是 $0$，所以 $n$ &amp; $n - 1$ 的效果就是将数字 $n$ 中最右边的 $1$ 给去除了 所以我们就可以写出这样的代码 public static int numbersOfOne(int n) &#123; int count = 0; while(n != 0) &#123; count++; n = (n - 1) &amp; n; &#125; return count;&#125; 每次循环会去除一个 $1$，所以二进制中有几个 $1$，便会进行几次循环。 扩展： 用一条语句判断一个整数是不是 $2$ 的整数次方。一个整数如果是 $2$ 的整数次方，那么它的二进制表示中有且只有一位是 $1$，而其他所有位都是 $0$。所以我们统计该数二进制中 $1$ 的个数，如果是一个，那么就是 $2$ 的整数次方。 输入两个整数 $m$ 和 $n$，计算需要改变 $m$ 的二进制表示中的多少位才能得到 $n$。比如 $10$ 的二进制表示为 $1010$，$13$ 的二进制表示为 $1101$，需要改变 $1010$ 中的 $3$ 位才能得到 $1101$。我们可以分两步解决这个问题，首先将这两个数进行异或，这样 $m$ 和 $n$ 二进制不同的位会得到 $1$，相同的位是 $0$，我们只要统计异或后二进制中 $1$ 的个数，即可得到需要改变的位数。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"offsetX,pageX,clientX和screenX","date":"2020-06-02T16:00:00.000Z","path":"/offsetX,pageX,clientX,screenX/","text":"在使用的 JavaScript 的过程中，对 offset，page，client 等等所表示的距离一直不是很清楚，现趁有时间系统的学习了一下。上面所述的 offsetX，pageX 等等都是事件对象 event 的属性，当有鼠标事件触发时，可以获得相应的事件对象，该对象中包含着鼠标的各种距离，现总结如下 offsetX：离触发事件元素左边的距离 pageX：离页面左边的距离 clientX：离浏览器左边的距离 screenX：离电脑显示器左边的距离 现在就演示一下，假设有下面的页面结构 上图已经基本可以明白 offsetX 和 clientX的大小，如果没有横向的滚动条的话，pageX 与 clientX 的大小是一样的。如果有滚动条的话，那么 pageX 的距离一般是大于 clientX 的距离的，如下 上图应该已经阐释了 pageX 与 clientX 的不同，那么只剩最后一个 screenX，这个也较好理解，就是鼠标位置离电脑显示器左侧的位置，如果浏览器是最大化的话，屏幕的左侧与浏览器的左侧相同，那么 screenX 的大小与 clientX 的大小相同，如果不是最大化，那么 上面介绍的是横向距离，纵向距离也是相似，offsetY，pageY，clientY，screenY 计算将左侧距离换为上侧距离。 这里还可以在扩展一个距离，scrollX 指的是横向滚动的距离，其实通过分析可以发现$$scrollX = pageX - clientX$$如下图所示","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"}]},{"title":"TypeScript入门指南","date":"2020-05-29T16:00:00.000Z","path":"/TypeScript入门指南/","text":"介绍TypeScript是什么TypeScript 是什么? 引用官方的定义 TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source. 简单翻译就是 TypeScript 是 JavaScript 的超集，并且可以被编译成 JavaScript。它可以运行在任何浏览器，任何主机，任何操作系统上。并且它是开源的。 看到这里你可能对 TypeScript 还是没有什么感觉，其实在我看来 TypeScript 是对 JavaScript 做了各种限制，这里说的限制并不是贬义的意思，因为 JavaScript 实在是太灵活了，很多的问题只有在运行的时候才会暴露出来，比如对于函数，即使定义时要求传两个参数，但是在使用时却可以传入任意的参数，所以你无法限制使用该函数的用户传入正确的参数，如果碰到不仔细看 API 文档的用户，鬼知道它使用的时候会传入什么，出了问题说不定会甩锅你兼容性做的不好。而 TypeScript 则限制了这一点，在使用时传入的参数必须与定义传入的相同，并且有提示每个参数的作用，用户使用该函数时必须按规定的来。 TypeScript的优势那么 TypeScript 可以为我们带来什么好处： 错误在编译时就可以暴露出来，而不必等到运行时才暴露出来 如下 js 文件 如上，一不小心将变量名写错了，写成了 MyNane，这种错误是很有可能发生的，但是在很多的时候我们自己却很难发现，只有当我们运行该程序报错的时候，我们才有可能根据报错信息，确定报错的原因；更糟糕的是，如果报错的信息不明确，你几乎无法确定是哪里出现问题，到时候要靠一双肉眼去找出这么一个小小的不同，曾经我就有因为变量名写错的问题，我找了半个小时。但是如果我们使用 TypeScript 的话，这样的问题在编译时就会被发现，如下 ts 文件 我们可以发现，在 MyNane 下面出现了红色的波浪线，将鼠标放在上面，还会贴心的给出提示。 智能提示 对于现代的程序员来说，代码的智能提示那是能够大大的提高工作效率的，不仅如此，还可以减少出错的概率，如果你手动写出一个对象的方法名，出错的概率可是很高的，特别是对于一些英语不好的同学。但是问题来了，因为 JavaScript 不是静态类型，而是动态类型，所有的变量都使用 var, let, const 声明，而不是像 C 语言这样静态类型语言，不同的类型使用不同的关键字，如 int, char[] 等等。所以这就意味着 JavaScript 这个类型是可变的，一会儿这是字符串类型，一会儿是数字类型，编译器根本在编译阶段根本不能确定你是什么类型，所以无法给出相应类型的特有方法，比如字符串类型的 toUpperCase() 方法，如下 js 文件 如上，上面的函数的功能是将传入的单词首字母大写，我们只是简单的调用字符串对象的函数 toUpperCase()，但是我们发现当我们打出 word. 时没有给出任何的提出，因为 JavaScript 根本不能确定你传入的是不是字符串，毕竟 JavaScript 是如此的灵活，使用时你可以传入任何类型的参数。但是对于 TypeScript 就不一样了，因为它会对参数的类型做出限制，如下 我们限制了传入的参数必须为 string 类型，在编译的阶段，我们能够肯定传入的一定是 string 类型，所以在函数的方法里面，当我们输入 word. 时会给出字符串对象的所有方法。除此之外，我们还规定了函数必须传入什么类型，这样用户在使用时就不能随便的传入参数，所有的一切必须按规定的来，这又无形的减少了 bug 的产生，并且用户在调用该方法时，还会给出提出，需要传入什么参数类型，必要的时候还可以给出传入参数的意义，如下 TypeScript 的好处还不止这一些，不过就我列举的这两个，就有足够的理由来学 TypeScript 了，TypeScript 更多的好处就需要你在使用的过程中慢慢理会了。 入门使用下面就将介绍 TypeScript 的安装，以及如何将 TypeScript 转化为 JavaScript 代码，毕竟浏览器和 Node 只能运行 JavaScript 代码。 安装TypeScript在安装 TypeScript 之前，确保你的计算机按照好了 Node，如果没有安装，可以去网上搜如何安装，教程很多。安装完成之后，使用 npm 下载 typescript npm install -g typescript 查看版本(主要是验证是否成功安装) tsc -VVersion 3.8.3 编写TypeScript程序新建 greeter.ts function greeter(person: string) &#123; return \"Hello \" + person;&#125;let user = 'XT';console.log(greeter(user)); 在命令行中使用 tsc 命令将它编译为 js tsc greeter.ts 这时会在该目录下生成 greeter.js，greeter.js 的内容为 function greeter(person) &#123; return \"Hello \" + person;&#125;var user = 'XT';console.log(greeter(user)); 接着我们使用 node 运行该 js 文件 node greeter.js 输出为 Hello XT 所以我们一般的流程为，编写 ts 文件，然后使用 tsc 编译为 js 文件，然后使用 node 运行 js 文件查看结果，那有没有什么工具帮我们做这件事情，一个命令直接到位。这里我们推荐使用 ts-node，该命令可以一步到位，就相当于是直接运行 ts 文件，首先下载 ts-node npm install -g ts-node 现在我们可以直接使用 ts-node greeter.ts 查看结果。 基本类型TypeScript 与 JavaScript 最大的不同就是 TypeScript 是一个有类型的语言，我们一般使用下面的方式声明变量 let 变量名: 类型 = 值; 那么 TypeScript 有哪些类型呢? 下面就简单介绍一下。 boolean// 值只能为true或者falselet isDone: boolean = false; numberlet decNumber: number = 20; // 十进制let hexNumber: number = 0x14; // 十六进制 20let binNumber: number = 0b10100; // 二进制 20let octNumber: number = 0o24; //八进制 20 stringlet name: string = \"bob\"; // 单引号，双引号都可以let greetStr: string = `Hello $&#123;name&#125;`; // 支持模板字符串 数组(Array)let list: number[] = [1, 2, 3]; // 数字数组let list: Array&lt;number&gt; = [1, 2, 3]; // 数组泛型 元祖(Turple)规定了数组的长度，以及每个元素的类型 let x: [string, number]; // x有两个元素，第一个元素为字符串，第二个元素为数字x = [\"hello\", 1] enum枚举类型 enum Color &#123; Red, Green, Blue&#125;let colorName: Color = Color.Blue; any任意类型，与写 JavaScript 一样 // 不清楚是什么类型，或者不希望做语法检查，就相当于写JavaScriptlet notSure: any = 4;notSure = false;let list: any[] = [1, true, \"a\"] voidvoid 一般用于表示函数不返回任何值，将它声明为一个变量没有意义 // 不返回任何值function printUser(user): void &#123; console.log(user)&#125;// 声明一个void类型变量是没有意义的let x: void = null; // 只能被赋值为null和undefined undefined, nulllet u: undefined = undefined; // 通常声明变量意义不大let n: null = null; never函数抛出异常或者死循环是可以使用 nerver 作为返回值 // 表示不存在的数据类型 函数抛出异常的时候就可以用never // never是任何类型的子类型，可以赋值给任何的类型function error(message: string): never &#123; throw new Error(message)&#125;function fail() &#123; return error(\"something error\");&#125;// 无限循环，函数不能结束，也可以返回neverfunction inifiniteLoop(): never &#123; while (true) &#123; &#125;&#125; object// 表示非原始类型declare function create(o: object | null): void;create(&#123;prop: 0&#125;); 注意：当没有将变量声明为某个基本类型时，TypeScript 会进行类型推断，如 let str = 'hello'; // str 会被推断为 string 类型 如上，变量 str 会被推断为 string 类型，这时 str 不能被赋值为别的类型 如果变量在声明时并没有被赋值，那么它的类型会被推断为 any，这时它可以被赋予任何类型的值 let str; // str 被推断为 any，可以为赋予任何类型的值str = 'hello';str = 2; 高级类型枚举类型我们使用 enum 来定义枚举类型，如 enum Week &#123; Mon, Tue, Wen, Thu, Fri, Sat, Sun&#125; 枚举类型会被编译为从零递增的数字 var Week;(function (Week) &#123; Week[Week[\"Mon\"] = 0] = \"Mon\"; Week[Week[\"Tue\"] = 1] = \"Tue\"; Week[Week[\"Wen\"] = 2] = \"Wen\"; Week[Week[\"Thu\"] = 3] = \"Thu\"; Week[Week[\"Fri\"] = 4] = \"Fri\"; Week[Week[\"Sat\"] = 5] = \"Sat\"; Week[Week[\"Sun\"] = 6] = \"Sun\";&#125;)(Week || (Week = &#123;&#125;)); 通过编译后的代码可以看出，枚举名和枚举值可以互相引用 console.log(Week[0] === 'Mon'); // trueconsole.log(Week[1] === 'Tue'); // trueconsole.log(Week[2] === 'Wen'); // trueconsole.log(Week[3] === 'Thu'); // trueconsole.log(Week['Fri'] === 4); // trueconsole.log(Week['Sat'] === 5); // trueconsole.log(Week['Sun'] === 6); // true 我们还可以为枚举名手动赋值，如 enum Week &#123; Mon = 1, Tue, Wen, Thu, Fri, Sat, Sun&#125; 我们为 Mon 手动赋值为 1，未手动赋值的项会接着上一项递增，所以 Tue 的值为 2，Wen 的值为 3，以此递增。如果后面递增的数字与前面定义数字重复了，这时是不会报错的，而是会覆盖之前的项 enum Week &#123; Mon = 3, Tue = 1, Wen, Thu, Fri, Sat, Sun&#125; 可见 Thu 的值也是 3，这个时候它的值与 Mon 重复了，但是此时 Week[3] 的值是 Thu 而不是 Mon，因为后面的 Thu 将前面的 Mon 覆盖了 var Week;(function (Week) &#123; Week[Week[\"Mon\"] = 3] = \"Mon\"; Week[Week[\"Tue\"] = 1] = \"Tue\"; Week[Week[\"Wen\"] = 2] = \"Wen\"; Week[Week[\"Thu\"] = 3] = \"Thu\"; // Week[3] 被重新赋值为了\"Thu\" Week[Week[\"Fri\"] = 4] = \"Fri\"; Week[Week[\"Sat\"] = 5] = \"Sat\"; Week[Week[\"Sun\"] = 6] = \"Sun\";&#125;)(Week || (Week = &#123;&#125;)); 函数类型对于函数来说，我们使用函数类型来规范它，一个函数有输入和输出，所以我们使用如下的形式来表示函数类型 (x: number, y:number) =&gt; number 上面就规范这个函数类型的输入为两个 number 类型的参数，输出为 number 类型的参数，如 let add:(x: number, y:number) =&gt; number = (x, y) =&gt; &#123; return x + y;&#125; 上面的 add 函数是一个 (x: number, y:number) =&gt; number 类型的函数，它必须接受两个 number 类型的参数，返回一个 number 类型的参数，如果 add 函数不满足此规则，那么就会报错 在上面 add 返回的是一个 string 类型的值，而不是 number 类型，这时编译器就会报错。 现在考虑有一个减法函数，它也满足上面的函数类型，所以它可以被声明如下 let substract: (x: number, y: number) =&gt; number = (x, y) &#123; return x - y;&#125; 如果还有很多的函数也满足上面的函数类型的话，那是不是每次都要写一般函数类型，所以我们可不可以为这个函数类型起一个别名，这样方便引用，我们可以通过 type 起别名，如下 type compute = (x: number, y: number) =&gt; number;let substract: compute = (x, y) &#123; return x - y;&#125;let add: compute = (x, y) &#123; return x + y;&#125; 如果还有别的函数时这个函数类型的话，我们使用起的别名 compute 进行申明就可以了。 如果我们使用匿名函数的形式声明一个函数，那么它会进行类型推断，如 function add(x: number, y: number): number &#123; return x + y;&#125; 那么 add 会被自动推断为 (x: number, y:number) =&gt; number，如果参数没有注明类型，那么会被推断为 any。 联合类型联合类型表示取值可以为多种类型的一种，如下 let score: string | number; // score 可以为数字，也可以为字符串score = 97;score = \"97\"; // 不会报错 当我们为联合类型进行赋值时，会根据类型推断推断出一个类型，这个时候我们就可以访问该类型所拥有的属性和方法，如 let score: string | number;score = \"97\"; // 被推断为 string 类型score.length; // 可以访问 string 类型的属性和方法 当 TypeScript 不能确定联合类型的具体类型时，那么只能访问联合类型中这些类型的共有的属性和方法，如 function getLength(something: string|number): number &#123; return something.length;&#125; 因为 something 为 string 或者 number 类型，所以它只能访问 string 和 number 类型共有的属性和方法，但是因为 number 类型没有 length 属性，所以上面会报错，如下 接口接口可以看做是对象的类型，接口规定了对象的结构，我们使用 interface 来定义一个接口 interface Person &#123; name: string; age: number;&#125; 上面我们定义一个叫做 Person 的接口，如果某个对象时这个接口类型，那么这个对象就必须含有 name 和 age 属性，并且 name 属性的值为 string，age 属性的值为 number，如下 let person: Person = &#123; name: 'bob', age: 13&#125; 可以说接口规定了对象的结构，定义了对象所必须拥有的属性名，不能多，也不能少，否则会报错，如下 let person: Person = &#123; name: 'bob', age: 13, gender: 'male'&#125; person 中含有接口 Person 不曾定义过的属性 gender，这时就会报错 可选属性有时候我们并不需要对象完全匹配一个形状，这个时候可以定义可选属性，定义的规则如下 interface Person &#123; name: string; age: number; gender?: string;&#125; 在上面我们定义了一个可选属性 gender，这个时候类型为 Person 的对象，可以有 gender 属性，也可以没有 let person: Person = &#123; name: 'bob', age: 13, gender: 'male'&#125; 或者 let person: Person = &#123; name: 'bob', age: 13&#125; 都是可以的。 只读属性有时候我们希望对象的某些属性在定义时被赋值，并且以后不能被更改，那么可以在这个属性定义为只读属性。我们使用 readonly 定义某个属性为只读属性 interface Person &#123; readonly id: number; name: string; age: number;&#125; 当对象的类型为 Person 时，在创建时要为 id 赋值(初始化)，并且这时 id 是只读的，不能被改变 let tom: Person = &#123; id: 1, name: 'Tom', age: 3&#125;tom.id = 2; 上面我们尝试修改 tom 对象的 id，但是因为 id 是只读的，不能被修改，所以上面的程序会报错 任意属性如果我们希望某个接口可以有任意的属性，我们可以使用如下方式 interface Person &#123; name: string; age?: number; [propName: string]: any;&#125; 我们定义了 Person 接口可以有任意的属性，该属性的键值为 string 类型，值为 any 类型。一旦定义了任意属性，那么确定属性和可选属性的类型必须为任意属性所规定的类型的子集。比如修改上面的接口 interface Person &#123; name: string; age?: number; [propName: string]: string;&#125; 因为 age 的值类型为 number，而任意属性规定的值类型为 string，所以会报错 类类可以看做是创建对象的模板，我们使用 class 来定义一个类，一个类中有属性和方法 class Person &#123; public name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;let tom = new Person(\"Tom\", 3); 我们可以通过类来大量的创建对象。在类中有一个方法 constructor()，这个方法叫做构造函数，它的功能是用来初始化属性的。 类的继承我们使用 extends 关键字来实现继承 class Person &#123; public name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person &#123; public score: number; constructor(name: string, age: number, score: number) &#123; super(name, age); this.score = score; &#125;&#125; 通过继承，我们复用父类的属性和方法。在上面我们使用了 super，该方法的作用是调用父类的构造函数初始化父类的属性。 访问权限访问权限有三种，分别为 public，private，protected 三种，在上面我们使用的都是 public 访问权限，使用该权限，可以在任何地方被访问到，例如 class Person &#123; public name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;let tom = new Person(\"Tom\", 3);// 可以直接访问console.log(tom.name, tom.age); // Tom 3 如果使用 private，那么该属性只能在类内部才能被访问，在类的外部不能被访问，如 class Person &#123; private name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;let tom = new Person(\"Tom\", 3);console.log(tom.name, tom.age); 我们将 name 的访问权限修改为了 private，这个时候不能再类外被直接访问，所以上面通过 tom.name 访问属性 name 会报错 如果使用 protected 修饰，那么该属性只能在该类内部及其子类中才能被访问，除此之外不能被访问，如下 class Person &#123; protected name: string; public age: number; constructor(name:string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person &#123; public score: number; constructor(name: string, age: number, score: number) &#123; super(name, age); this.score = score; &#125; // 在子类中可以被访问 public getName(): string &#123; return this.name; &#125;&#125;let alice = new Student(\"Alice\", 4, 5);console.log(alice.getName()); // Alice// 下行语句会报错console.log(alice.name); 如上所示，父类 Person 的 name 属性使用 protected 修饰，所以在子类 Student 中可以访问，但是在父类和子类的外部不能访问 静态属性我们可以使用 static 关键声明静态属性以及静态方法，静态属性和方法是属于类的，而不是具体的对象，使用属性和方法要使用类名调用，如下 class Person &#123; public static max_age:number = 100; public name:string; public age:number; constructor(name:string, age:number) &#123; this.name = name; this.age = age; &#125;&#125;let person = new Person(\"Tom\", 15);// 通过类对象访问实例属性console.log(person.name); // Tom// 通过类访问静态属性console.log(Person.max_age); // 100 readonly我们可以使用 readonly 来修饰类的属性，来表示该属性是只读的，只有在构造函数中初始化该属性，如下 class Person &#123; public readonly name:string; public age:number; constructor(name:string, age:number) &#123; this.name = name; this.age = age; &#125;&#125;let person = new Person(\"Alice\", 12);person.name = \"Bob\"; 在上面我们声明了 name 属性为 readonly，表明 name 属性是只读的，但是在后面我们试图修改该属性，这个时候将会报错 实现接口接口的另一个作用就是对类进行抽象，一个类可以实现接口，当类实现接口时，要求类中必须有接口中定义的属性和方法，如下 interface IPerson &#123; name: string; age: number; gender: string;&#125;class Person implements IPerson&#123; public name:string; public age:number; public gender: string; constructor(name:string, age:number, gender:string) &#123; this.name = name; this.age = age; this.gender = gender; &#125;&#125;let person = new Person(\"Alice\", 12, \"male\"); 其实我对接口的理解，其实就是定义了一个标准。定义了标准之后，对于具体的实现就不关心了，可以和具体的实现解耦。假设我们有一个方法接受一个操作数据库的对象，但是对于不同的厂家(数据库)，具体怎么操作数据库都是不一样的，所以这个对象不能写死是怎么类型。所以我们应该定义操作数据库的标准，比如操作数据库的方法名，方法接收的参数，而对于具体的实现应该由各自的产商编写。只要这些厂商实现了我们的标准，那么它就可以用，类比过来，我们定义的标准就是接口，而各自厂商的实现就是实现了接口的类。 interface OperateDatabase &#123; save: () =&gt; void;&#125;function saveData(obj: OperateDatabase): void &#123; obj.save();&#125; 在上面我们定义一个操作数据库的接口 OperateDatabase，并且定义了一个方法 saveData()，该方法接收一个接口，注意这里我们没有指定是某个特定的对象类型，否则的就会与该类型绑定在一起。接着我们可以两个类实现该接口 class MysqlDatabase implements OperateDatabase &#123; save() &#123; console.log(\"mysql 保存数据\"); &#125;&#125;class RedisDatabase implements OperateDatabase &#123; save() &#123; console.log(\"redis 保存数据\"); &#125;&#125; 这两个类就相当于是这个标准的具体实现。当我们调用 saveData 方法时，将具体的实现类传入即可 saveData(new MysqlDatabase()); // mysql 保存数据saveData(new RedisDatabase()); // redis 保存数据 声明合并函数的合并现在有这么一个函数，它可以接受一个参数，这个参数可以是字符串或者数字，它的功能是将传入的数字或者字符串反转，比如输入 123，则输出 321，输入 hello，则输出 olleh，我们可以定义类如下 function reverse(x: number | string): number|string&#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.toString().split('').reverse().join(''); &#125;&#125; 这个函数的定义有一个缺点，不能精确的表达输入数字时，输出也是数字，输入是字符串时，输出也是字符串。我们可以重载 reverse 的多个定义 function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number|string&#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.toString().split('').reverse().join(''); &#125;&#125; 接口的合并当我们定义了两个相同名字的接口时，接口中的属性会自动进行合并 interface Person &#123; name: string;&#125;interface Person &#123; age: number;&#125; 相当于 interface Person &#123; name: string; age: number;&#125; 如果两个接口有相同的属性，只要它们返回的值的类型相同，就不会有问题，如下 interface Person &#123; name: string; gender: string;&#125;interface Person &#123; age: number; gender:string;&#125; 在两个接口中，它们有相同的属性名 gender，并且它们的定义时一样的，它们的合并也没有问题，相当于如下 interface Person &#123; name: string; age: number; gender:string;&#125; 但是如果有相同的属性，但是定义却不同，即值的类型不同，那么会报错 interface Person &#123; name: string; gender: string;&#125;interface Person &#123; age: number; gender:number;&#125; 上面两个接口的 gender 的定义不同，报错如下 类型断言有时候我们需要将一个不确定的类型断言为具体的类型，比如将一个联合类型断言为其中的某一个具体的类型，这样就可以使用它特有的方法。类型断言的语法为 值 as 类型 或者 &lt;类型&gt;值 上面两种方法都是将值断言为某个具体的类型。因为在 React 中只支持 as 语法，所以推荐使用第一种方法。 联合类型断言为其中具体类型就如上面所说，有时候我们希望将联合类型断言为具体的类型，这样我们就可以使用类型特有的方法，否则只能使用二者公共的方法。我们第一个形状类型 interface Circle &#123; radius: number;&#125;interface Square &#123; size: number;&#125;interface Rectangle &#123; width: number; height: number;&#125;type Shape = Circle | Square | Rectangle; 接着我们定义一个方法，该方法接收 Shape 类型的参数，返回面积，我们可能会这么写 function getArea(s: Shape): number &#123; if (typeof s.radius === 'number') &#123; return 3.14159 * s.radius * s.radius; &#125; else if (typeof s.size === 'number') &#123; return s.size * s.size; &#125; else &#123; return s.width * s.height; &#125;&#125; 但是你会发现一片报红 因为传入的类型 s 根本无法确定是什么具体的类型，我们只能访问 Circle, Square, Rectangle 的公共属性和方法，所以当我们访问他们特有的属性时就会报错，比如 s.radius，所以在访问具体的属性进行判断时，我们要断言为具体的类型，修改如下 function getArea(s: Shape): number &#123; if (typeof (s as Circle).radius === 'number') &#123; s = s as Circle; return 3.14159 * s.radius * s.radius; &#125; else if (typeof (s as Square).size === 'number') &#123; s = s as Square; return s.size * s.size; &#125; else &#123; s = s as Rectangle; return s.width * s.height; &#125;&#125; 我们首先进行断言为具体的类型，然后进行判断。 父类或接口断言为子类或实现类有时候我们需要将父类或接口断言为具体的子类，这样就可以使用子类特有的属性或方法。首先定义一个父类和两个子类 class Person &#123; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person&#123; score: number; constructor(name:string, age: number, score: number) &#123; super(name, age); this.score = score; &#125;&#125;class Teacher extends Person&#123; level: number; constructor(name:string, age: number, level: number) &#123; super(name, age); this.level = level; &#125;&#125; 接着定义一个方法，该方法接收 Person 类型的参数，我们需要断言为具体的子类才能使用子类的属性和方法 function isStudent(p: Person) &#123; if (typeof (p as Student).score === 'number') &#123; return true; &#125; else &#123; return false; &#125;&#125;console.log(isStudent(new Student('Bob', 15, 100))); // true 泛型在定义函数、类和接口时，并不具体指定具体的类型，而是使用一个占位符表示类型，具体的类型在使用的时候传入决定。 函数泛型我们定义一个函数创建一个数组，并设置默认值，数组中存储的具体类型等到使用时确定 function createArray&lt;T&gt;(length: number, defaultValue: T): Array&lt;T&gt; &#123; let x = new Array&lt;T&gt;(length); for (let i = 0; i &lt; length; i++) &#123; x.push(defaultValue); &#125; return x;&#125; 该函数接收两个参数，第一个参数为数组的长度，第二个参数为默认值。该数组的类型我们使用泛型 T 代替，具体的类型在使用时确定，如创建一个长度为 5，类型为 number，默认值为 0 的数组，如下 let arr = createArray&lt;number&gt;(5, 0);console.log(arr); // [ &lt;5 empty items&gt;, 0, 0, 0, 0, 0 ] 因为我们不知道泛型的具体类型，所以不能随意操作它的属性和方法，这个时候我们可以对象泛型做出约束，以便我们可以使用特定的属性或方法，如要求泛型必须符合某个接口 interface Length &#123; length: number;&#125;function getLength&lt;T extends Length&gt;(t: T):number &#123; return t.length;&#125; 上面我们要求泛型 T 继承了接口 Length，即传入的对象 t 必须含有属性 length console.log(getLength(\"123\")); // 3 接口泛型同样的，我们也可以在接口中使用泛型 interface CreateArrayFunc&lt;T&gt; &#123; (length: number, defaultValue: T): Array&lt;T&gt;&#125;let createArray: CreateArrayFunc&lt;number&gt;;createArray = function&lt;T&gt;(length: number, defaultValue: T) &#123; let x: T[] = []; for(let i = 0; i &lt; length; i++) &#123; x.push(defaultValue); &#125; return x;&#125;console.log(createArray(5, 3)); // [ 3, 3, 3, 3, 3 ] 类泛型我们也可以在类中使用泛型 class Stack&lt;T&gt; &#123; data: T[]; size: number; constructor(capacity: number) &#123; this.data = new Array&lt;T&gt;(capacity); this.size = 0; &#125; push (item: T): void &#123; this.data.push(item); this.size++; &#125; pop (): T &#123; this.size--; return this.data.pop() as T; &#125; printStack(): void &#123; console.log(this.data); &#125;&#125; 我们定义了一个 Stack 栈，它里面存储的类型是一个泛型，在我们使用的时候确定，如下 // 定义了一个存储 number 类型数据的栈 容量为10let stack = new Stack&lt;number&gt;(10); stack.push(10);stack.push(5);stack.printStack(); // [ &lt;10 empty items&gt;, 10, 5 ] 参考文献 TypeScript入门教程 TypeScript安利指南","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/TypeScript/"}]},{"title":"JavaScript之正则表达式","date":"2020-05-27T16:00:00.000Z","path":"/JavaScript之正则表达式/","text":"在字符串的处理中，我们经常要进行字符串的匹配，校验等等操作。比如校验字符串的格式是否符合邮箱，电话号码的格式，校验密码是否符合要求，密码中是否包含数字和字母等等；又或者匹配得到某种规则的字符串。这一些操作如果使用常规的方法进行字符串操作，会花费较大的代价，包括时间和精力。 正则表达式是用来表达字符串的规则，它可以检验字符串是否符合某个特定的规则，或者匹配字符串中符合规则的字符，在一般的使用中，正则表达式一般用来匹配字符串中的字符或者字符串中特定的位置。 正则对象JavaScript 正则对象的创建有两种常见的方法，一是使用 RegExp 构造函数进行创建，二是使用字面量的方法进行创建，如下 let regex1 = new RegExp('hello', 'g');let regex2 = /hello/g; 其中 hello 表示字符串的规则，用来匹配字符串中的&quot;hello&quot;，g 表示进行全局匹配(global)，像这样的标志还有两个，m 表示进行多行匹配(multiline)，i 表示忽略大小写(ignoreCase)，这三个标志互不冲突，可以同时使用，如 let regex = /hello/igm; 具体标志的作用在后面讲解。在实际的使用中，我们一般会使用字面量的形式创建正则对象，相对于使用构造函数，字面量的创建比较简便，不过如果需要动态的创建正则对象，或者根据字符串创建正则对象，那么可以考虑使用构造函数的方式。 正则对象中的属性 global：布尔值，是否设置了 g 标志 ignoreCase：布尔值，是否设置了 i 标志 lastIndex：整数，从字符串的某个位置开始匹配，默认为 0 multiline：布尔值，是否设置了 m 标志 source：正则表达式的字符串表示 let regex = /\\d&#123;3&#125;hello$/ig;console.log(regex.global); // trueconsole.log(regex.ignoreCase); // trueconsole.log(regex.multiline); // falseconsole.log(regex.lastIndex); // 0console.log(regex.source); // \\d&#123;3&#125;hello$ 正则对象中的方法testtest()，该方法接收一个字符串参数，返回一个布尔值，用来判断该字符串是否符合正则对象的规则，如下 let regex = /hello/g;let string1 = \"hello world\";let string2 = \"Hello World\";console.log(regex.test(string1)); // trueconsole.log(regex.test(string2)); // false execexec() 方法是用来捕获匹配到的字符，该方法接收一个字符串，返回一个数组，数组的第一项表示与整个模式匹配的字符串，第二项表示第一个捕获组(捕获组的概念如果不懂，可以看了括号的作用在回来看)，第三项表示第二个捕获组，以此类推。返回的数组与普通数组不同的是，该数组还有三个属性，index 、 input 和 groups，index 表示匹配到的字符在原始字符串中的位置，从 0 开始；input 表示输入的原始字符串，groups 表示捕获组的名称。 let regex = /(he)(ll)(o)/g;let string = \"so hello\";let result = regex.exec(string);console.log(result); 输出为 [ 'hello', 'he', 'll', 'o', index: 3, input: 'so hello', groups: undefined] 如果正则对象的标志有 g 的话，那么在执行 exec() 方法后会改变 lastIndex 为匹配字符串后字符的 index，接下来再次执行 exec() 方法时将会从 lastIndex 处开始匹配，如 let string = \"ab abc abc\";let regex = /ab/g;console.log(regex.lastIndex); // 0regex.exec(string);console.log(regex.lastIndex); // 2regex.exec(string);console.log(regex.lastIndex); // 5regex.exec(string);console.log(regex.lastIndex); // 9regex.exec(string); // 匹配不到会返回 nullconsole.log(regex.lastIndex); // 重新变为 0 构造函数RegExp的属性构造函数 RegExp 中有一些静态属性，这些属性会保存最近一次正则对象操作的一些信息，并且这些属性有两种方法访问，一种是具有语义的长属性名，一种是简短的短属性名，具体如下： input：短属性名为 $_，最近一次要匹配的字符串 lastMatch：$&amp;，最近一次的匹配项 leftContext：$`， input 中 lastMatch 的左边部分 rightContext：$&#39;，input 中 lastMatch 的右边部分 $1, $2, ...：后面介绍 let regex = /hello/g;let string = \"he hello llo\";regex.exec(string);console.log(RegExp.input); // he hello lloconsole.log(RegExp.lastMatch); // helloconsole.log(RegExp.leftContext); // he_ (从_表示空格)console.log(RegExp.rightContext); // _llo 字符串方法在字符串中，有许多的方法也是与正则表达式有关的，如 replace，match，下面就简单介绍一下。 replacereplace() 方法的作用是使用新的字符串替换字符串中的某些内容，该方法接收两个参数，第一个参数表示字符串中要被替换的内容，它可以是一个具体的字符串或者是一个正则对象，第二个参数为一个字符串，这个参数是用来替换第一个参数的，如 let string = \"gello\";string = string.replace('g', 'h'); // 将 string 中的 g 替换为 hconsole.log(string); // hello let string = \"abc\";string = string.replace(/[ab]/g, '#'); // 将字符串中的 a 或 b 替换为 #console.log(string); // ##c 在上面中使用了 [ab]，这个表示 a 或者 b，具体会在元字符那里讲解。 matchmatch 方法的作用与 exec 的作用差不多，不过一个是 RegExp 对象的方法，一个是 String 对象的方法。match 方法接收一个正则对象，它返回一个数组，根据正则对象是否设置了 g 标志，返回的结果也不相同。 如果没有设置 g 标志，即不会全局匹配，只会匹配一次，那么它返回的结果与 exec 返回的结果相同，数组的第一个元素表示匹配的字符串，后面的元素表示捕获组，并且也有 input，index，groups等属性，表示的含义也痛 exec，如下 let string = \"hello\";let result = string.match(/(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/);console.log(result); 输出为 [ 'hello', 'he', 'll', 'o', index: 0, input: 'hello', groups: [Object: null prototype] &#123; h: 'he', l: 'll' &#125;] 这次的正则表达式跟以往的不同，这次我设置了捕获组的名称，如 (?&lt;h&gt;he) 即将捕获组 (he) 的名称设置为了 h，设置捕获组名称的格式如下 (?&lt;捕获组名称&gt;捕获组内容) 为捕获组设置名称，可以方便在后面进行引用。 如果设置了 g 标志，这时返回值与 exec 方法就不同了，它会将字符串中所有符合正则表达式规则的内容都匹配出来，并放入数组中，如 let string = \"hello\";let re = /(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g;let result = string.match(re);console.log(result); // [ 'hello' ]string = \"hello helloworld\";result = string.match(re);console.log(result); // [ 'hello', 'hello' ] 这时设置的捕获组的信息就提取不到了，所以从某种程度上说，exec 的功能比 match 更加的强大，不过 exec 并不能一次提取出字符串中所有符合规则的内容，而是需要做一个循环，如下 let string = \"hello helloworld\";let re = /(?&lt;h&gt;he)(?&lt;l&gt;ll)(o)/g;let result;let results = new Array();// 当 re.exec()不为 null 时while (result = re.exec(string)) &#123; results.push(result[0]); // result 中还包含了捕获组的信息&#125;console.log(results); // [ 'hello', 'hello' ] 字符匹配上面使用正则表达式进行匹配都是进行精确的匹配，如 /hello/，匹配字符串中的 hello 内容，这样我们根本无法领会到正则表达式的强大，正则表达式正是强大在它模糊匹配的能力，比如我们在 Windows 中进行文件查找，有时我们不记得文件的具体名称，比如忘了某个字母，这个时候我们会用 . 去表示任意的字母去进行查找。现在我们就来讲讲正则表达式模糊匹配的能力。 字符组在进行匹配的时候，如果我们不确定某个位置的字符是什么，我们可以使用表示特定含义的字符来占据这个位置，比如 [abc] 表示这个位置是 a，b，c 中的某个字符。如果我们想表示这个字符是小写字母，按照上面的写法，你可能会这么写 [abcdefghijklmnopqrstuvwxyz]，这样的写法有点反人类，我们可以使用范围表示法来代替上面的写法，如 [a-z] 的写法就表示所有的小写字母，同理 [A-Z] 就表示所有的大写字母，[0-9] 就表示数字，[0-9a-zA-Z] 表示这个位置可以是数字，小写字母，大写字母。如下 let re = /[a-zA-Z0-9]/;console.log(re.test('0')); // trueconsole.log(re.test('s')); // trueconsole.log(re.test('S')); // trueconsole.log(re.test('?')); // false 我们可以在 [] 中加入 ^ 表示取反，如 [^0-9] 表示非数字，即它可以匹配所有的非数字 let re = /[^0-9]/;console.log(re.test(\"2\")); // falseconsole.log(re.test(\"a\")); // trueconsole.log(re.test(\"?\")); // true 我们还可以使用元字符来占据位置，比如 \\d 就代表数字，它的作用与 [0-9] 是一样的，常见的元字符如下所示(不包含表示位置的元字符，表示位置的元字符在后面介绍) 元字符 含义 \\d 表示数字 \\s 表示空白字符，包括空格，回车，制表符等等 \\w 表示数字，大小写字母和下划线，相当于 [0-9a-zA-Z_] . 表示任意一个字符 来看几个例子 // 表示数字let re1 = /\\d/;console.log(re1.test(\"2\")); // true// 空白字符let re2 = /\\s/;console.log(re2.test(\" \")); // trueconsole.log(re2.test(\"\\t\")); // trueconsole.log(re2.test(\"\\n\")); // true// 表示大小写字母，数字和下划线let re3 = /\\w/;console.log(re3.test(\"2\")); // trueconsole.log(re3.test(\"a\")); // trueconsole.log(re3.test(\"A\")); // trueconsole.log(re3.test(\"_\")); // true 与在 [] 中加入 ^表示取反，上面的元字符也有对应的元字符表示取反的概念 元字符 含义 \\D 与 \\d 相反，表示非数字 \\S 与 \\s 相反，表示非空白字符 \\W 与 \\w 相反，表示非单词 let re1 = /\\D/;console.log(re1.test(\"2\")); // falseconsole.log(re1.test(\"\\n\")); // truelet re2 = /\\S/;console.log(re2.test(\" \")); // falseconsole.log(re2.test(\"9\")); // truelet re3 = /\\W/;console.log(re3.test(\"0\")); // falseconsole.log(re3.test(\"\\t\")); // true 量词现在我们假设使用正则表达式去匹配电话号码，假设电话号码就是 11 位数字，所以写出来的正则表达式是这样的 \\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d，这种写法也相当的反人类，不仅难读(需要一个个数才知道有多少个数)，而且写起来也麻烦，我们可以使用量词来简写上面的表达式，如 \\d{11} 就表示 \\d 连续出现 11 次，常见的量词写法如下 量词 含义 {n} 表示连续出现 n 次 {m,n} 表示连续出现 m-n，最少出现 m，最多出现 n 次 {n,} 表示连续出现最少 n 次(包括 n 次) * 表示连续出现任意多次 + 表示连续出现 1 次或 1 次以上 ? 表示出现 0 次或 1 次 // 匹配连续出现的 5 位数字let re = /\\d&#123;5&#125;/g;let string = \"123 1234 12345 654321\";console.log(string.match(re)); // [ '12345', '65432' ] // 匹配连续出现的 2-3 位数字let re = /\\d&#123;2,3&#125;/g;let string = \"12 123 1234\";console.log(string.match(re)); // [ '12', '123', '123' ] // 匹配连续出现 4 位及 4 位以上的数字let re = /\\d&#123;4,&#125;/g;let string = \"12 123 1234 12345\";console.log(string.match(re)); // [ '1234', '12345' ] // b 可以出现任意次let re = /ab*c/g;let string = \"ac abc abbc abbbc\";console.log(string.match(re)); // [ 'ac', 'abc', 'abbc', 'abbbc' ] // b 出现 1 次或 1 次以上let re = /ab+c/g;let string = \"ac abc abbc abbbc\";console.log(string.match(re)); // [ 'abc', 'abbc', 'abbbc' ] // b 出现 0 次或 1 次let re = /ab?c/g;let string = \"ac abc abbc abbbc\";console.log(string.match(re)); 贪婪匹配与惰性匹配所谓的贪婪匹配就是尽可能的多匹配，如 let re = /ab+/g;let string = \"abbbb\";console.log(string.match(re)); // [ 'abbbb' ] 明明匹配 ab 也可以，但是它会尽可能多的匹配，这就是贪婪模式，与此相对的是惰性匹配，惰性匹配就是在满足条件的情况下会尽可能的少匹配，如上例就会匹配 ab，在默认的情况下是贪婪匹配，要使用惰性匹配就要使用惰性量词 贪婪 惰性 + +? * *? ? ?? {n,m} {n,m}? {n,} {n,}? let re = /ab+?/g;let string = \"abbbb\";console.log(string.match(re)); // [ 'ab' ] 现在考虑根据 html 字符串获得某 id 属性，如 &lt;div id=&quot;container&quot; class=&quot;active&quot;&gt;&lt;/div&gt;，如果我们使用贪婪匹配的话，考虑这样的匹配规则 /id=&quot;.*&quot;/，那么捕获到的并不是我们想要的 let re = /id=\".*\"/;let string = \"&lt;div id=\\\"container\\\" class=\\\"active\\\"&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // id=\"container\" class=\"active\" 我们发现匹配到的是 id=&quot;container&quot; class=&quot;active&quot;，因为在贪婪模式下再符合条件的情况下会尽可能多的匹配，所以会直接匹配到最后一个双引号，解决办法有两种，其中简单的解决办法就是使用惰性匹配 let re = /id=\".*?\"/;let string = \"&lt;div id=\\\"container\\\" class=\\\"active\\\"&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // id=\"container\" 另一种办法就比较 trick，我觉得只可意会，难以言传 let re = /id=\"[^\"]*\"/;let string = \"&lt;div id=\\\"container\\\" class=\\\"active\\\"&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // id=\"container\" 仔细体会上面的写法吧，我觉得很好用，比如获得某标签的标签名 let re = /&lt;[^&gt;]*&gt;/;let string = \"&lt;div&gt;&lt;/div&gt;\";console.log(re.exec(string)[0]); // &lt;div&gt; 分支有时候我们需要在多个分支之间进行选择，比如匹配十六进制表示的颜色，有两种表示，一种是 #F4E242 六位的，一种是简写的 #FFF 三位表示的，我们可以使用 | 来表示或的关系 let regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;let string1 = \"#FFF\";let string2 = \"#F34E23\"console.log(string1.match(regex)); // [ '#FFF' ]console.log(string2.match(regex)); // [ '#F34E23' ] 括号的作用分组与分支假设我们要匹配 I love Java 和 I love C 这两句话，你可能会写出这样的正则表达式 /I love Java|C/ 但是这个正则表达式表示的是 I love Java 或者 C 而不是 I love C，正确的写法应该是这样 /I love (Java|C)/ Java 和 C 选其一。 捕获数据假设我们要匹配一个格式为 yyyy-mm-dd 格式的日期，并且希望获得年月日，那么可能会这么写 let re = /\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/;let string = \"2020-05-27\";let result = re.exec(string)[0]; // 2020-05-27let results = result.split(\"-\");console.log(\"year:\" + results[0]); // year:2020console.log(\"month:\" + results[1]); // month:05console.log(\"day:\" + results[2]); // day:27 其实我们可以通过添加括号来捕获数据，对于被括号包起来的数据，其匹配的内容会被提取出来，添加到返回的数组中，如 let re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;let string = \"2020-05-27\";let result = re.exec(string);console.log(\"year:\" + result[1]); // 第一个捕获组 \\d&#123;4&#125; 匹配的内容console.log(\"month:\" + result[2]); // 第二个捕获组 \\d&#123;2&#125; 匹配的内容console.log(\"day:\" + result[3]); // 第三个捕获组 \\d&#123;2&#125; 匹配的内容 上面我们对年月日的规则使用括号包了起来，在进行匹配时，对应被匹配到的数据会添加到数组中，在介绍 exec 方法时，其返回的数组，第一个元素表示匹配到的字符串，后面的元素表示捕获组(括号包起来)中捕获的内容。 RegExp的属性$1…除了可以根据返回的数组 result 来得到捕获的数据，还可以通过在上面提过一嘴的 RegExp 构造函数的属性 $1, $2, $3 ... 等等来获得所捕获的内容，其中 $1 表示第一个捕获组所匹配的内容，如下 let re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;let string = \"2020-05-27\";let result = re.exec(string);console.log(\"year:\" + RegExp.$1); // year:2020console.log(\"month:\" + RegExp.$2); // month:05console.log(\"day:\" + RegExp.$3); // day:27 每次在使用正则表达式进行匹配时，RegExp 中的 $1, $2, $3 ... 也会相应的更新。 括号嵌套现在考虑如果括号有嵌套的情况，比如上面日期格式捕获更精准的表达式 /(\\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\\d)|(3[0-1]))/ 上面括号嵌套的很复杂，在原理上，被括号包起来的规则所匹配的内容都会被捕获，那么嵌套带来的问题就是，捕获的顺序哪个在前，哪个在后，其实也很简单，根据左括号来，比如上式中的捕获顺序为 (\\d{4}) ((0\\d)|(1[0-2])) (0\\d) (1[0-2]) ((0[1-9])|([1-2]\\d)|(3[0-1])) (0[1-9]) ([1-2]\\d) (3[0-1]) 所以如果使用上面的正则表达式进行捕获得到年月日的信息，根据分析年是第一捕获组，月是第二捕获组，日是第五捕获组 let re = /(\\d&#123;4&#125;)-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2]\\d)|(3[0-1]))/;let date = \"2020-05-27\";let result = re.exec(date);console.log(result[1], result[2], result[5]); // 2020 05 27 由于无用的捕获组太多，导致想要提取包含信息的捕获组获取困难，其实仔细观察，里面的大多数括号主要是为分支做准备的，对于这些捕获组，我们可以考虑不捕获，仅仅作为分支使用，我们在括号里面的前方加入 ?: 表示该括号匹配的内容不进行捕获，如下 let re = /(\\d&#123;4&#125;)-((?:0[1-9])|(?:1[0-2]))-((?:0[1-9])|(?:[1-2]\\d)|(?:3[0-1]))/;let date = \"2020-05-27\";let result = re.exec(date);console.log(result[1], result[2], result[3]); // 2020 05 27 如果作为分支的括号太多，为每一个分支添加 ?: 也比较费力，那么可以考虑给包含信息的捕获组命名，命名的方法在上面有提到过 let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;(0[1-9])|(1[0-2]))-(?&lt;day&gt;(0[1-9])|([1-2]\\d)|(3[0-1]))/;let date = \"2020-05-27\";let result = re.exec(date);let groups = result.groups;console.log(groups.year, groups.month, groups.day); // 2020 05 27 通过给捕获组命名，可以方便的通过 groups 对象得到想要的数据。 反向引用现在再次考虑匹配日期，已知下面这三种日期格式都可以 2017-02-122017 02 122017/02/12 所以你可能会写出这样的正则表达式 /\\d&#123;4&#125;(-| |\\/)\\d&#123;2&#125;(-| |\\/)\\d&#123;2&#125;/ 经过测试，发现能符合要求 console.log(re.test(\"2017-02-17\")); // trueconsole.log(re.test(\"2017 02 17\")); // trueconsole.log(re.test(\"2017/02/17\")); // true 但是你会发现一些意外的情况 console.log(re.test(\"2017-02/17\")); // trueconsole.log(re.test(\"2017-02 17\")); // trueconsole.log(re.test(\"2017 02-17\")); // true 前后的分隔符不一致的情况也能够匹配，而我们要求的是前后的分隔符是一样的，这个时候我们可以通过引用分组，使得前面和后面的分隔符是一样的，如下 let re = /\\d&#123;4&#125;(-| |\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;console.log(re.test(\"2017-02-17\")); // trueconsole.log(re.test(\"2017 02 17\")); // trueconsole.log(re.test(\"2017/02/17\")); // trueconsole.log(re.test(\"2017-02/17\")); // falseconsole.log(re.test(\"2017-02 17\")); // falseconsole.log(re.test(\"2017 02-17\")); // false 注意到我们对于后面的分组，我们使用了 \\1 去进行替代，\\1 的意思就是代表引用第一个分组，这样就可以做到这个地方与前面的分组相同。同理我们也可以使用 \\2 表示引用第二个分组(如果有的话，如果没有就单纯的表示匹配字符串 &quot;\\2&quot;)。 位置匹配相关元字符正则表达式中的最后一个内容就是关于位置的匹配，与字符匹配不同，位置匹配时匹配字符间的位置，常见有关位置的元字符如下 元字符 含义 ^ 开头位置 $ 结尾位置 \\b 单词边界，即 \\w 与 \\W 之间的位置 (?=p) 匹配 p 模式前面的位置，具体见例子 (?&lt;=p) 匹配 p 模式后面的位置 let string = \"[JS] hello\";let result = string.replace(/^/,\"#\");console.log(result); // #[JS] helloresult = string.replace(/$/, \"#\");console.log(result); // [JS] hello#result = string.replace(/\\b/g, \"#\"); // \\b 是 \\w 与 \\W 之间的位置，表示单词的边界console.log(result); // [#JS#] #hello#result = string.replace(/(?=hello)/, \"#\"); // hello 前面的位置console.log(result); // [JS] #helloresult = string.replace(/(?&lt;=hello)/, \"#\"); // hello 后面的位置console.log(result); // [JS] hello# 同理，也有元字符表示与上面相反的意义 元字符 含义 \\B 与 \\b 相反，表示非单词边界 (?!p) 与 (?=p) 相反，表示不是 p 前面位置的所有位置 (?&lt;!p) 与 (?&lt;=p) 相反，表示不是 p 后面位置的所有位置 let string = \"[JS] hello\";let result = string.replace(/\\B/g,\"#\");console.log(result); // #[J#S]# h#e#l#l#oresult = string.replace(/(?!hello)/g, \"#\"); // 不是 hello 前面位置的所有位置console.log(result); // #[#J#S#]# h#e#l#l#o#result = string.replace(/(?&lt;!hello)/g, \"#\"); // 不是 hello 后面位置的所有位置console.log(result); // #[#J#S#]# #h#e#l#l#o 千位分隔符案例现在来做一个案例，将数字转化为千位分隔符表示法，如 12345678 转化为 12,345,678，我们首先找到后三位数字的前面位置，然后添加逗号，如下 let string = \"12345678\";result = string.replace(/(?=(\\d&#123;3&#125;)$)/g,\",\");console.log(result); // 12345,678 进一步弄出所有的逗号 result = string.replace(/(?=(\\d&#123;3&#125;)+$)/g,\",\"); // 12,345,678 但是还是有一个小小问题，测试的数字个数是三的倍数的时候，在开头也会添加一个逗号 let string = \"123456789\";result = string.replace(/(?=(\\d&#123;3&#125;)+$)/g,\",\");console.log(result); // ,123,456,789 我们可以修改正则表达式如下 result = string.replace(/(?=(?!^)(\\d&#123;3&#125;)+$)/g,\",\"); 其中 (?!^) 表示不是开头的位置。如果希望支持更多的格式，比如 1234567 12345678 转换为 1,234,567 12,345,678，只要将上面的表达式中的开头，结尾替换为 \\b 即可 let string = \"1234567 12345678\";result = string.replace(/(?=(?!\\b)(\\d&#123;3&#125;)+\\b)/g,\",\");console.log(result); // 1,234,567 12,345,678 考虑到 (?!\\b) 就相当于 \\B，所以上面的表达式也可简写如下 /(?=\\B(\\d&#123;3&#125;)+\\b)/g 多行模式正则表达式有三个常见的标志，分别为全局模式 g，表示进行全局匹配，如果不设置该标志，那么只会匹配一次，如果字符串后面还要符合规则的字符串，是不会被匹配的，对于 exec() 方法，非全局模式下不会更改 lastIndex，即 lastIndex 始终是 0。 let string = \"hello hello\";let re1 = /hello/;let re2 = /hello/g;// 非全局替换 只会替换匹配到的第一个 helloconsole.log(string.replace(re1, \"#\")); // # hello// 全局替换 字符串中所以的 hello 都会被替换console.log(string.replace(re2, \"#\")); // # # 第二标志 i 很好理解，即忽略大小写 let re1 = /hello/;let re2 = /hello/i;let string = \"Hello\";// 不忽略大小写console.log(re1.test(string)); // false// 忽略大小写console.log(re2.test(string)); // true 第三个标志 m 表示多行模式，它只会影响 ^,$，如果不是多行模式，那么 ^, $ 就表示字符串的开头和结尾，如果是多行模式，那么 ^,$ 就表示每一行的开头和结尾。 非多行模式 let string = \"I \\nlove \\njava\";// 非多行 ^,$ 表示字符串的开头和结尾console.log(string.replace(/^|$/g, \"#\")); 输出如下 #I love java# 多行模式 let string = \"I \\nlove \\njava\";// 多行模式 ^,$ 表示每一行的开头和结尾console.log(string.replace(/^|$/gm, \"#\")); 输出如下 #I ##love ##java#","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"}]},{"title":"Spring常见注解","date":"2020-05-21T16:00:00.000Z","path":"/Spring常见注解/","text":"介绍 Spring 框架中的常见注解(NO XML)，在介绍 Spring 注解之前，简要的介绍一下 IoC。 IoC简要介绍IoC(Inverse of Control) 的意思是控制反转，意思就是控制权发生转换，以前我们需要某个类的对象，都是直接 new 出来的，现在有了IoC，对象创建的控制权交给 Spring，如果我们需要某个对象，向 IoC 容器拿，如下 上面将 Dog 类对象放入容器的过程我们成为注入，容器我们一般称为 IoC 容器或者 Spring 容器。上面做的好处可以减少类与类之间的耦合性，耦合性这个词可能高大尚，我举个例子，比如 Dog 类发生了改变，高耦合性意味着如果有类依赖 Dog 类的话，那么相应的该类有可能也要发生改变，如果耦合度低的话，也就是根本察觉不到自己依赖了 Dog 类，根本就不需要改变。 我们在像容器要某个对象时，察觉不到某个类的所在(因为一般使用接口去接收从容器中拿的对象)，比如 Animal animal = ioc.getObject('dog'); 假设 Dog 实现了 Animal 接口，ioc 对象表示 IoC 容器，getObject() 表示从容器中获得对象的方法，而传入的参数表示对象在容器中的 id。如果 Dog 类发生改变(但是他在容器中的 id 是不会变的)，我们获取 Dog 对象的方式还是和上面一样，不需要发生改变。假设如果是直接 new Dog() 的话，如果 Dog 的类名变了，那么所有直接依赖 Dog 类的所有类都要发生改变，这就是低耦合的好处。 注意：要使用 Spring IoC，记得在 pom.xml(Maven) 中导入坐标 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; @Configuration@Configuration 的定义： @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor( annotation = Component.class ) String value() default \"\"; boolean proxyBeanMethods() default true;&#125; 被 @Configuration 修饰的类是 Spring 的配置类，所谓的配置类就是用来配置用的，可以配置扫描哪些包，将这些包下的类注入到 IoC 容器中，也可以配置将特定的类注入到 IoC 容器中。 被 @Configuration 修饰的类也会被注入到 IoC 容器中，@Configuration 有一个 value 值，它是用来设置该类对象在 IoC 容器中的 id，如果不设置，那么默认是类名，不过首字母要改为小写，比如 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configurationpublic class SpringConfiguration &#123;&#125; SpringConfiguration 是 Spring 的配置类，由于 @Configuration 没有配置id，所以它在 IoC 容器中的 id 为 springConfiguration，我们可以在测试类中测试，如下 import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); SpringConfiguration springConfiguration = ac.getBean(\"springConfiguration\", SpringConfiguration.class); System.out.println(springConfiguration); &#125;&#125; AnnotationConfigApplicationContext 可以看做是 IoC 容器，我们传入配置类所在的包 config 给它，它会扫描该包找到配置类，然后根据配置类为容器注入对象，在上面我们在配置类中什么都没有做，所以不会向 IoC 容器注入别的对象。 接着我们通过获得对象的方法 getBean() 获得了配置类 SpringConfiguration 的对象，该方法需要传入在 IoC 容器中的 id，因为没有指定，默认是 springConfiguration。 @ComponentScan@ComponentScan 注解的定义 @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123; @AliasFor(\"basePackages\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class; ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; String resourcePattern() default \"**/*.class\"; boolean useDefaultFilters() default true; ComponentScan.Filter[] includeFilters() default &#123;&#125;; ComponentScan.Filter[] excludeFilters() default &#123;&#125;; boolean lazyInit() default false; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;&#125;) public @interface Filter &#123; FilterType type() default FilterType.ANNOTATION; @AliasFor(\"classes\") Class&lt;?&gt;[] value() default &#123;&#125;; @AliasFor(\"value\") Class&lt;?&gt;[] classes() default &#123;&#125;; String[] pattern() default &#123;&#125;; &#125;&#125; 该注解的作用是扫描包或者类，将扫描到类注入到 IoC 容器中。由上面可见，该类的属性还是挺多的，这里介绍几个重要的属性。 value和basepackages这两个属性放在一起讲是因为他们互为别名 @AliasFor(\"basePackages\")String[] value() default &#123;&#125;;@AliasFor(\"value\")String[] basePackages() default &#123;&#125;; 它们的作用是一样的，规定要扫描哪些包，从定义看，它们的值都是字符串数组，我们在 com.xt.service 下定义 ServiceTest 类如下 package com.xt.service;public class ServiceTest &#123; public void service() &#123; System.out.println(\"service...\"); &#125;&#125; Spring 的配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.xt.service\")public class SpringConfiguration &#123;&#125; 我们在配置类中规定了要扫描的包为com.xt.service，接着我们在测试类中测试 import com.xt.service.ServiceTest;import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); ServiceTest serviceTest = ac.getBean(\"serviceTest\", ServiceTest.class); serviceTest.service(); &#125;&#125; 但是却发生异常，在容器中没有名为 serviceTest 的对象 这是因为即使扫描了 ServiceTest 所在的包，但并不是该包下所有的类都会被注入到容器中，而是被 @Component 注解所修饰的类才会被注入到容器中，所以我们要为 ServiceTest 加上 @Component 注解，如下 package com.xt.service;import org.springframework.stereotype.Component;@Componentpublic class ServiceTest &#123; public void service() &#123; System.out.println(\"service...\"); &#125;&#125; 再次运行测试类，结果如下 注意：@Component 还有几个衍生注解，@Controller，@Service，@Repository，这些注解的作用与 @Component 一毛一样，那为什么要创建这些注解，主要是他们所代表的的语义，@Controller 主要用在 Web 层的类上，@Service 主要用在 Service 层上，而 @Repository 主要用在 Dao 层上，程序员看到某类被什么注解修饰，就可以明白该类的职责是什么了。 如果 @ComponentScan 没有指定任何值，那么默认会扫描该类所在的包及其子包，如 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class SpringConfiguration &#123;&#125; @ComponentScan 没有指定任何值，那么就会默认扫描 config 包下的类及其子包下的类。 basePackageClassesbasePackageClasses 的定义如下： Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;; 该属性的值是一个字节码数组，当设置指定字节码时，会扫描指定字节码所在包及其子包，假设有如下结构 UserServiceImpl 实现了 UserService 接口，二者内容如下 package com.xt.service;public interface UserService &#123; void doService();&#125; package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; Spring 的配置类如下 package config;import com.xt.service.UserService;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackageClasses = UserService.class)public class SpringConfiguration &#123;&#125; 我们配置 basePackageClasses 为 UserService.class，所以会扫描 UserService 所在的包及其子包，所以 UserServiceImpl 会被注入到容器中，我们在测试类中测试如下 import com.xt.service.UserService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); UserService userService = ac.getBean(\"userServiceImpl\", UserService.class); userService.doService(); &#125;&#125; 结果如下 nameGenerator该属性的作用是设置注入到容器中的对象(我们一般称这个对象为 bean)的 id 名称的生成规则，如下 Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; 在上面我们可以看到，默认使用了 BeanNameGenerator 这个类去生成 id 的名称，而生成的规则在上面介绍过，即 id 为类名，不过首字母要小写， Spring 中的有关默认 id 名称生成的部分源码如下 public static String decapitalize(String name) &#123; if (name == null || name.length() == 0) &#123; return name; &#125; if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp; Character.isUpperCase(name.charAt(0)))&#123; return name; &#125; char chars[] = name.toCharArray(); chars[0] = Character.toLowerCase(chars[0]); return new String(chars);&#125; 我们可以看到，如果对于第一个字母和第二个字母都为大写的这种特殊的类名是不会将首字母变为小写的。 除了可以使用默认的生成规则，我们还可以自己自定义 id 的生成规则，在 custom 包下新建 CustomBeanNameGenerator 类，该类的作用就是 id 名称的生成规则，该类需要实现 BeanNameGenerator 接口，详细如下 package custom;import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanNameGenerator;import org.springframework.core.annotation.AnnotationAttributes;import org.springframework.core.type.AnnotationMetadata;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import org.springframework.util.ClassUtils;import org.springframework.util.StringUtils;import java.beans.Introspector;import java.util.Map;import java.util.Set;public class CustomBeanNameGenerator implements BeanNameGenerator &#123; public String generateBeanName(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry) &#123; String beanName = null; // 判断该类是否是由注解注入的 if (beanDefinition instanceof AnnotatedBeanDefinition) &#123; // 如果是强转为 AnnotatedBeanDefinition 以获得有关注解的信息 AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition; // 获得注解的信息 AnnotationMetadata annotationMetadata = annotatedBeanDefinition.getMetadata(); // 获得所有注解 Set&lt;String&gt; types = annotationMetadata.getAnnotationTypes(); // 遍历所有注解 for (String type: types) &#123; // 获得注解的属性 AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(annotationMetadata.getAnnotationAttributes(type, false)); // 如果该注解为Component或其衍生注解(暂不考虑 JSR 规范，如 @Resource)且value属性有值 // 并且 annotationAttributes 不为null if (annotationAttributes != null &amp;&amp; isStereotypeWithNameValue(type, annotationMetadata.getMetaAnnotationTypes(type), annotationAttributes)) &#123; // 获得 value 属性的值 Object value = annotationAttributes.get(\"value\"); // 如果value为String，则强转 if (value instanceof String) &#123; String strValue = (String) value; // value 值长度不为 0 if (StringUtils.hasLength(strValue)) &#123; // 如果 beanName 有值，说明已经设置过了 此时 value 与 beanName 不同，说明产生了冲突，抛出异常 if (beanName != null &amp;&amp; !strValue.equals(beanName)) &#123; throw new IllegalArgumentException(\"多个注解设置了value，产生了冲突\"); &#125; else &#123; beanName = strValue; &#125; &#125; &#125; &#125; &#125; &#125; // 没有 Component 及其衍生注解或者没有设置 value 值，则采用默认自定义的类名生成规则 return beanName != null ? beanName : buildDefaultBeanName(beanDefinition); &#125; // 判断该注解是否是Component及其衍生注解 并且有 value 属性 private boolean isStereotypeWithNameValue(String annotationType, Set&lt;String&gt; metaAnnotationTypes, @Nullable Map&lt;String, Object&gt; attributes) &#123; boolean isStereotype = annotationType.equals(\"org.springframework.stereotype.Component\") || metaAnnotationTypes.contains(\"org.springframework.stereotype.Component\") || annotationType.equals(\"javax.annotation.ManagedBean\") || annotationType.equals(\"javax.inject.Named\"); return isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(\"value\"); &#125; // 默认 bean id 生成 private String buildDefaultBeanName(BeanDefinition beanDefinition) &#123; // 获得全限定类名，如com.xt.service.impl.UserServiceImpl String beanClassName = beanDefinition.getBeanClassName(); // 获得类名 如UserServiceImpl String shortClassName = ClassUtils.getShortName(beanClassName); // 默认生成规则为 my + 类名 return \"my\" + shortClassName; &#125;&#125; 上面的 id 生成规则为如果 @Component 及其衍生注解设置了 id 名称，则使用设置的名称，否则默认的 id 名称为 my + 类名。现在将 SpringConfiguration 的 @ComponentScan 的 nameGenerator 设置为 CustomBeanNameGenerator.class，如下 package config;import com.xt.service.UserService;import custom.CustomBeanNameGenerator;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(nameGenerator = CustomBeanNameGenerator.class, basePackages = \"com.xt.service.impl\")public class SpringConfiguration &#123;&#125; UserServiceImpl 的内容如下 package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 可见使用 @Service 修饰了，但是没用设置 value 值，所以默认生成的 id 是 myUserServiceImpl，在测试类中测试如下 import com.xt.service.UserService; import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); // id 已经改为了 myUserServiceImpl UserService userService = ac.getBean(\"myUserServiceImpl\", UserService.class); userService.doService(); &#125;&#125; 输出如下 可见我们的自定义 id 生成规则生效了，现在修改 UserServiceImpl 如下，这次设置 id 值 package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Service;@Service(\"userService\")public class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 根据我们的规则，这时的 id 名为设定的值，即 userService，修改测试类 UserService userService = ac.getBean(\"userService\", UserService.class); 在此修改 UserServiceImpl，这次使用多个注解修饰，如下 package com.xt.service.impl;import com.xt.service.UserService;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;@Service(\"userService\")@Component(\"userServiceImpl\")public class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 运行测试类，这时会抛出异常，如下 useDefaultFilters在 @ComponentScan 中有一个属性 useDefaultFilters boolean useDefaultFilters() default true; 它的值默认为 true，即如果被扫描的类被 @Component，@Controller，@Service，@Repository这四个注解修饰时，那么将该类对象注入到容器中，如果为 false，那么被这四个注解修饰的类不会被添加到容器中(但是有可能通过其他注解或属性将该类添加到容器中，如 includeFilters，@Import)。 includeFiltersincludeFilters 属性的作用是允许符合过滤规则的类对象注入到容器中，它的值是一个 Filter 注解 @Retention(RetentionPolicy.RUNTIME)@Target(&#123;&#125;)public @interface Filter &#123; FilterType type() default FilterType.ANNOTATION; @AliasFor(\"classes\") Class&lt;?&gt;[] value() default &#123;&#125;; @AliasFor(\"value\") Class&lt;?&gt;[] classes() default &#123;&#125;; String[] pattern() default &#123;&#125;;&#125; 该注解有一个 type 属性，它的默认取值为 FilterType.ANNOTATION，表示过滤的规则为注解，如果我们设置 value 属性为某注解的字节码对象，那么被该注解修饰的类对象可以注入到容器中，比如允许自定义 @MyAnno 注解所修饰的类注入到容器中 @ComponentScan(includeFilters = @ComponentScan.Filter(MyAnno.class)) 在扫描的类中，如果该类被自定义注解 @MyAnno 修饰，那么该类对象会被注入到容器中。 excludeFilters与 includeFilters 的作用相反，对于符合过滤规则的类对象不能被注入到容器中，如 @ComponentScan(excludeFilters = @ComponentScan.Filter(Service.class)) 上面的注解的作用是，扫描到的类如果被 @Service 修饰，那么该类对象不能被加入到容器中。 在上面我们知道 Filter 注解中，它的 type 属性为 FilterType.ANNOTATION，即被某注解修饰，他会(includeFilters)/不可以(excludeFilters)加入到容器中，其实 type 还可以有多种取值，如下 package org.springframework.context.annotation;public enum FilterType &#123; ANNOTATION, ASSIGNABLE_TYPE, ASPECTJ, REGEX, CUSTOM; private FilterType() &#123; &#125;&#125; 在这里我们在介绍 FilterType.CUSTOM，这表示我们可以自定义过滤规则，定义过滤规则的类需要实现 TypeFilter 接口。在 custom 中新建 CustomFilter 类 package custom;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.core.type.filter.TypeFilter;import java.io.IOException;public class CustomFilter implements TypeFilter &#123; public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; return true; &#125;&#125; 修改配置类如下 package config;import custom.CustomFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.stereotype.Service;@Configuration@ComponentScan( basePackages = \"com.xt.service\", includeFilters = @ComponentScan.Filter( type = FilterType.CUSTOM, classes = CustomFilter.class ))public class SpringConfiguration &#123;&#125; 因为 CustomFilter 实现的 match 始终返回 true，所以被扫描到的类对象会被无条件的注入到容器中，我们修改 com.xt.service.impl.UserServiceImpl 如下 package com.xt.service.impl;import com.xt.service.UserService;public class UserServiceImpl implements UserService &#123; public void doService() &#123; System.out.println(\"do service...\"); &#125;&#125; 该类没有被任何注解修饰，就是一个普通的类，但是它的对象还是会注入到容器中，测试类如下 import com.xt.service.UserService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); UserService userService = ac.getBean(\"userServiceImpl\", UserService.class); userService.doService(); &#125;&#125; 输出为 @Bean对于我们自己写的类，我们可以通过 @Component 及其衍生注解，使得被扫描到时被注入到容器中，但是对于第三方的类库，由于已经被编译为了字节码，我们已经无法修改，即不能再别人的源码上加上注解，那么我们如果想将第三方类库对象注入到容器，我们该怎么办呢，使用 @Bean 可以解决这个问题。@Bean 的定义为 @Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Bean &#123; @AliasFor(\"name\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] name() default &#123;&#125;; /** @deprecated */ @Deprecated Autowire autowire() default Autowire.NO; boolean autowireCandidate() default true; String initMethod() default \"\"; String destroyMethod() default \"(inferred)\";&#125; 以数据源对象 DataSource 对象为例，首先导入坐标 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置类如下 package config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;@Configurationpublic class SpringConfiguration &#123; @Bean public DataSource createDataSource() &#123; return new DriverManagerDataSource(); &#125;&#125; 在扫描配置类时，会扫描配置类中被 @Bean 注解的方法，会将该方法返回的对象注入到容器中，这是默认的 id 名称为方法名。测试类如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;import javax.sql.DataSource;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); DataSource dataSource = ac.getBean(\"createDataSource\", DataSource.class); System.out.println(dataSource); &#125;&#125; 输出为 可见容器中有 DataSource 对象了。 如果被 @Bean 注解的方法重载了的话，那么会将重载的方法返回的对象注入容器，如 package config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;@Configurationpublic class SpringConfiguration &#123; @Autowired private DataSource dataSource; @Bean public DataSource createDataSource() &#123; return new DriverManagerDataSource(); &#125; @Bean public JdbcTemplate createJdbcTemplate() &#123; System.out.println(\"无参函数\"); return new JdbcTemplate(dataSource); &#125; @Bean public JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; System.out.println(\"有参函数\"); return new JdbcTemplate(dataSource); &#125;&#125; 有两个 createJdbcTemplate 方法，根据上面所说，重载的方法，即下面那个有参数的函数返回的对象会被注入到容器中，可以在测试类中测试如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); JdbcTemplate jdbcTemplate = ac.getBean(\"createJdbcTemplate\", JdbcTemplate.class); System.out.println(jdbcTemplate); &#125;&#125; name和value@AliasFor(\"name\")String[] value() default &#123;&#125;;@AliasFor(\"value\")String[] name() default &#123;&#125;; 按照上面的定义，name 和 value 互为别名，它们的作用就是设置注入到容器对象的 id 名称。 autowireCandidateboolean autowireCandidate() default true; 该属性的作用与 @Autowired 有关，当我们使用 @Autowired 自动注入时，如 @Autowiredprivate DataSource dataSource; 容器会将其中的 dataSource 对象注入到成员变量中，但是如果 autowireCandidate 设置为 false，那么该对象就不能使用 @Autowired 自动注入，如 @Autowiredprivate DataSource dataSource;@Bean(autowireCandidate = false)public DataSource createDataSource() &#123; return new DriverManagerDataSource();&#125; 这时就不能将 dataSource 对象通过 @Autowired 注解自动注入到成员变量 dataSource 中，再次运行测试代码，会抛出异常。 @Import在实际的开发中，可能有多个配置类，比如数据库的配置类，那么主配置类就要导入数据库配置类的配置，这时就需要用到 @Import 注解。@Import 注解的定义如下 @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123; Class&lt;?&gt;[] value();&#125; @Import 注解的作用是导入 value 属性所指明的类，将这些类对象注入到容器中，如有下面的数据库配置类 package config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfiguration &#123; @Bean(\"dataSource\") public DataSource createDataSource() &#123; return new DriverManagerDataSource(); &#125; @Bean(\"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 我们在主配置类中导入该配置类 package config;import org.springframework.context.annotation.Import;@Configuration@Import(JdbcConfiguration.class)public class SpringConfiguration &#123;&#125; 我们在导入 JdbcConfiguration 时，会扫描 JdbcConfiguration 中的方法，将被 @Bean 注解的方法返回的对象注入到容器中，所以这时 DataSource 对象和 JdbcTemplate 对象会被注入到容器中，在测试类测试如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); DataSource dataSource = ac.getBean(\"dataSource\", DataSource.class); JdbcTemplate jdbcTemplate = ac.getBean(\"jdbcTemplate\", JdbcTemplate.class); assert dataSource != null; assert jdbcTemplate != null; &#125;&#125; 运行测试类顺利运行，没有报错 JdbcConfiguration 它也会被注入容器中，这时它的 id 为它的全限定类名，而不是类名首字母小写，即config.JdbcConfiguration ImportSelector当我们需要动态的决定导入哪些类时，或者需要大量导入类时，我们可以为 @Import 传入自定义导入类，该类需要实现 ImportSelector 接口。该接口中有一个方法 String[] selectImports(AnnotationMetadata annotationMetadata)，该方法返回一个字符串数组，这个数组包含的是要添加到容器中的类名。 因为我们过滤规则使用 AspectJ 表达式，所以需要导入相关坐标 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; 现在我们完成这么一个功能，读取配置文件中的过滤规则和要扫描的包，将扫描包中符合过滤规则的类对象添加到容器中，在 resources 下新建 customImport.properties 如下 custom.expression=com.xt.service.impl.*custom.basePackage=com.xt 过滤规则使用 ASPECTJ 格式的过滤规则，扫描的包为 com.xt，新建类 custom.CustomImport 如下 package custom;import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.io.support.PropertiesLoaderSupport;import org.springframework.core.io.support.PropertiesLoaderUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AspectJTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.HashSet;import java.util.Properties;import java.util.Set;public class CustomImport implements ImportSelector &#123; // 使用 AspectJ 表达式表示过滤规则 private String expression; // 扫描的包 private String basePackage; public CustomImport() &#123; // 读取配置文件 初始化 try &#123; // 根据配置文件获得过滤规则和扫描的包 Properties properties = PropertiesLoaderUtils.loadAllProperties(\"customImport.properties\"); expression = properties.getProperty(\"custom.expression\"); basePackage = properties.getProperty(\"custom.basePackage\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 实现的方法 public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false); // 根据 aspectj 表达式转换为对应的过滤器 TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImport.class.getClassLoader()); // 将过滤器添加到扫描器中 scanner.addIncludeFilter(typeFilter); // 创建 Set 集合保存扫描到的符合过滤规则的类 Set&lt;String&gt; classes = new HashSet&lt;String&gt;(); // 使用过滤器扫描指定包，得到符合过滤规则的类 并添加到 classes 中 scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName())); // 将 classes 转换为字符串数组返回 return classes.toArray(new String[classes.size()]); &#125;&#125; 根据上面的过滤规则，只有 UserServiceImpl 会被添加到容器中(除配置类)，在测试类中测试一番 import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); String[] names = ac.getBeanDefinitionNames(); for (String name: names) &#123; System.out.println(name); &#125; &#125;&#125; 测试类是获得容器所有对象的 id，并打印出来，如下 除了前面五个做初始化工作的对象以及配置类对象，只有 UserServiceImpl 被添加到容器中，这次我们修改过滤规则为 custom.expression=com.xt..*custom.basePackage=com.xt Aspectj 表达式为将 com.xt 包及其子孙包下的所有类都添加到容器中，再次运算测试类，输出为 这时 com.xt.utils.Logger 对象也被添加到容器中了。 注意：上面的 UserServiceImpl 和 Logger 都没有使用任何注解进行修饰，就是一个普通的 Java 类。 ImportBeanDefinitionRegistrarImportBeanDefinitionRegistrar 的功能同 ImportSelector，不过二者的返回值不同，ImportSelector 返回一个要添加到容器中类名名称组成的数组，而 ImportBeanDefinitionRegistrar 什么都不返回，说明在 ImportBeanDefinitionRegistrar 内部已经将扫描包下符合规则的类添加到容器中去了。现在我们要实现与上面相同的功能，新建 custom.CustomImportBeanDefinitionRegistrar，如下 package custom;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.io.support.PropertiesLoaderUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AspectJTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.Properties;public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; private String expression; private String basePackage; public CustomImportBeanDefinitionRegistrar() &#123; try &#123; Properties properties = PropertiesLoaderUtils.loadAllProperties(\"customImport.properties\"); expression = properties.getProperty(\"custom.expression\"); basePackage = properties.getProperty(\"custom.basePackage\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 得到扫描器 ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false); // 得到过滤器 TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader()); scanner.addIncludeFilter(typeFilter); // 扫描指定包 将符合过滤规则的类对象直接注入到容器中 scanner.scan(basePackage);&#125; 该类的大部分工作与 CustomImport 是一样的，就是最后使用了 ClassPathBeanDefinitionScanner 对象直接扫描包，将符合过滤规则的类对象注入到容器中。配置文件和配置类如下 custom.expression=com.xt..*custom.basePackage=com.xt package config;import custom.CustomImportBeanDefinitionRegistrar;import org.springframework.context.annotation.Import;@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125; 测试类与上面相同，运行测试类，结果如下 与 ImportSelector 实现的效果相同，不过有一点不同的是，ImportSelector 的 id 生成规则为全限定类名，而 ImportBeanDefinitionRegistrar 的 id 为类名首字母小写。 @PropertySource@PropertySource 注解的作用是用来读取资源文件，该注解的定义如下 @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource &#123; String name() default \"\"; String[] value(); boolean ignoreResourceNotFound() default false; String encoding() default \"\"; Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;&#125; 他不仅可以读取 properties 文件，还可以读取 xml 文件，甚至可以通过自定义 yml 文件解析器读取 yml 文件。 主配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.PropertySource;@Configuration@PropertySource(\"jdbc.properties\")@Import(&#123;JdbcConfig.class&#125;)public class SpringConfiguration &#123;&#125; 在主配置类中读取了配置文件 jdbc.properties，配置文件和 JDBC 配置类 JdbcConfig 如下所示 jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/sbjdbc.username=rootjdbc.password=root package config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(\"dataSource\") public DataSource createDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean(\"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 我们将通过 PropertySource 读取到的资源，通过 @Value 注解，以 Spring EL 表达式的形式注入到了成员变量中。同时也可以读取 xml 文件，我们新建 jdbc.xml， 内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;entry key=\"jdbc.driver\"&gt;com.mysql.jdbc.Driver&lt;/entry&gt; &lt;entry key=\"jdbc.url\"&gt;jdbc:mysql://localhost:3306/sb&lt;/entry&gt; &lt;entry key=\"jdbc.username\"&gt;root&lt;/entry&gt; &lt;entry key=\"jdbc.password\"&gt;root&lt;/entry&gt;&lt;/properties&gt; 修改 @PropertySource 的值 @PropertySource(\"jdbc.xml\") 由上面可以看出，xml 文件相对于 properties 有更加明显的层级关系，结构比较清楚，但是这种优点的代价就是冗余性性很高，为了表达真正有用的信息，加入很多无用的内容。为了整合 properties 和 xml 的优点，人们提出了一个新的格式的文件 YAML(文件后缀名为.yml)，它不仅书写简单，并且可以表达层级关系，新建 jdbc.yml 如下 jdbc: driver: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/sb username: root password: root 但是 @PropertySource 默认只支持 propeties 和 xml 文件的读取，如果要支持 yml 文件的读取，就需要自己定义解析类，我们可以借助第三方的类库来解析 yml 文件，在 pom.xml 中导入解析 yml 类库的坐标 &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.23&lt;/version&gt;&lt;/dependency&gt; 然后在配置类中修改如下 @PropertySource(value = \"jdbc.yml\", factory = CustomYAMLPropertySourceFactory.class) 新建 custom.CustomYAMLPropertySourceFactory 实现 PropertySourceFactory 接口，如下 package custom;import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.core.env.PropertiesPropertySource;import org.springframework.core.env.PropertySource;import org.springframework.core.io.support.EncodedResource;import org.springframework.core.io.support.PropertySourceFactory;import java.io.IOException;import java.util.Properties;public class CustomYAMLPropertySourceFactory implements PropertySourceFactory &#123; public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource encodedResource) throws IOException &#123; YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean(); // 解析 yaml 文件 factoryBean.setResources(encodedResource.getResource()); // 将解析的文件转换为 properties Properties properties = factoryBean.getObject(); // spring 默认能解析 properties，使用 spring 源码的类去解析 return name != null ? new PropertiesPropertySource(name, properties) : new PropertiesPropertySource(encodedResource.getResource().getFilename() ,properties); &#125;&#125; @DependsOn有的时候一个 Bean 对象需要在另一个 Bean 对象注入到容器之后才能注入到容器，比如 One 类对 Two 类有依赖关系，在逻辑上需要先注入 Two 对象，One, Two 的定义如下 package example;import org.springframework.stereotype.Component;@Componentpublic class One &#123; public One() &#123; System.out.println(\"one被创建了\"); &#125;&#125; package example;import org.springframework.stereotype.Component;@Componentpublic class Two &#123; public Two() &#123; System.out.println(\"Two被创建了\"); &#125;&#125; 主配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"example\")public class SpringConfiguration &#123;&#125; 测试类如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); &#125;&#125; 运行输出为 One 先于 Two 先注入容器中，如果需要 One 在 Two 后，可以加上 @DependsOn,如下 package example;import org.springframework.context.annotation.DependsOn;import org.springframework.stereotype.Component;@Component@DependsOn(\"two\")public class One &#123; public One() &#123; System.out.println(\"one被创建了\"); &#125;&#125; 再次运行测试类 这时 Two 类对象先被创建。 @Lazy@Lazy 是用来延迟加载时机的，一般我们在初始化容器时，就会将扫描到的类对象注入到容器中，如果对于一个大型的项目，可能会有成千上万个类，如果在一开始就将全部的对象注入到容器，会大大的延缓项目的启动时间，所以为了提高效率，我们可以在需要该类对象时才把对象注入到容器中，还是在上例中，新建 Three package example;import org.springframework.context.annotation.Lazy;import org.springframework.stereotype.Component;@Componentpublic class Three &#123; public Three() &#123; System.out.println(\"three被创建了\"); &#125;&#125; 运行测试类 import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); &#125;&#125; 输出为 我们只是在测试类中初始化了容器，但是 Three 类对象已经被注入到容器中了。这时我们对 Three 使用 @Lazy 注解，再次运行测试类 这时 Three 类对象并没有被创建，只有我们第一次向容器获取所需对象时，才会被注入到容器中，修改测试类如下 import example.Three;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); System.out.println(\"===========================\"); Three three = ac.getBean(\"three\", Three.class); &#125;&#125; 结果为 注意：@Lazy 注解对于范围为单例的类有效。 @Conditional@Conditional 注解是用来设定注入条件的，当扫描到某类或者方法时，是否将该类对象或返回对象注入到容器，根据 @Conditional 指定的条件决定。@Conditional 注解的定义如下 @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Conditional &#123; Class&lt;? extends Condition&gt;[] value();&#125; 该注解只有一个 value 属性，该属性的值是一个继承了 Condition 接口的字节码对象，Condition 接口有一个 match 方法，该方法返回一个布尔值，当返回 true 时，可以将对象注入到容器中，否则不行。 现在我们有两个数据源，一个是 Windows 下的数据源，一个是 Linux 下的数据源，现在我们的任务根据操作系统来决定使用哪个数据源注入到容器中，JdbcConfig 类定义如下 package config;import condition.LinuxCondition;import condition.WindowsCondition;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(\"dataSource\") @Conditional(WindowsCondition.class) public DataSource createWindowsDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); // 用以观察哪个数据源被注入到容器中 System.out.println(\"Windows Env\"); return dataSource; &#125; @Bean(\"dataSource\") @Conditional(LinuxCondition.class) public DataSource createLinuxDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); // 用以观察哪个数据源被注入到容器中 System.out.println(\"Linux Env\"); return dataSource; &#125;&#125; 在上面我们对 Windows 和 Linux 的数据源都使用了 Conditional 注解，分别使用 WindowsCondition 和 LinuxCondition 类来决定是否注入到容器中，二类的内容如下 package condition;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class WindowsCondition implements Condition &#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 获得环境对象 Environment environment = context.getEnvironment(); // 获得操作系统名称 String osName = environment.getProperty(\"os.name\"); System.out.println(osName); // 如果包含 Windows 则可以注入 if (osName.contains(\"Windows\")) &#123; return true; &#125; return false; &#125;&#125; package condition;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class LinuxCondition implements Condition &#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment environment = context.getEnvironment(); String osName = environment.getProperty(\"os.name\"); System.out.println(osName); if (osName.contains(\"Linux\")) &#123; return true; &#125; return false; &#125;&#125; 配置类和测试类如下所示 package config;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.PropertySource;@Configuration@PropertySource(\"classpath:jdbc.properties\")@Import(JdbcConfig.class)public class SpringConfiguration &#123;&#125; import org.springframework.context.annotation.AnnotationConfigApplicationContext;import javax.sql.DataSource;public class SpringTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); DataSource dataSource = ac.getBean(\"dataSource\", DataSource.class); &#125;&#125; 运行测试类，输出为 @Profile有的时候我们在不同的环境下注入到容器中的类是不同的，比如开发环境、测试环境和生产环境下三者注入的类是不同的，要实现这样的效果，我们可以使用上面提及的 @Conditional 注解，但是考虑到上述问题比较常见，所以 Spring 为我们提供了 @Profile 注解来实现这样的功能， @Profile 的定义如下 @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; 可以观察到 @Profile 的底层也是使用了 @Conditional 注解，@Profile 注解只有一个属性值 value，它是用来定义环境名称的，比如我们一般使用 dev 代表开发环境，test 代表测试环境，prod 代表生产环境。 在配置好类属于哪个环境后，可以通过容器对象中环境对象中的setActiveProfiles()方法来激活对应的环境，这样只有对应环境的类会被注入到容器中，我们新建三个测试类 package example;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;@Profile(\"dev\")@Componentpublic class Dev &#123; public Dev() &#123; System.out.println(\"开发环境\"); &#125;&#125; package example;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;@Profile(\"test\")@Componentpublic class Test &#123; public Test() &#123; System.out.println(\"测试环境\"); &#125;&#125; package example;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;@Profile(\"prod\")@Componentpublic class Prod &#123; public Prod() &#123; System.out.println(\"生产环境\"); &#125;&#125; 配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"example\")public class SpringConfiguration &#123;&#125; 测试类如下 import config.SpringConfiguration;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; // 不能传入配置类的所在包 或者配置字节码对象 否则所有三个类都不会被注入 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(); // 设置激活的环境 ac.getEnvironment().setActiveProfiles(\"dev\"); // 设置配置类 ac.register(SpringConfiguration.class); // 刷新容器 ac.refresh(); &#125;&#125; 输出为 自动注入我们一般在 Service 层中会用到 Dao 层中的对象，所以在 Service 中一般会有一个 Dao 层的成员变量，这个对象一般是在容器中的，所以 Service 层需要向容器索取对象，我们可以使用注解使得容器中的对象自动注入到对应的成员变量中，下面就介绍几个常用的自动注入注解。 @Autowired和@Qualifier@Autowired 注解首先会根据成员变量的类型去容器中找对应类型的注解，如果有多个相同类型的对象，那么会使用成员变量的名称作为 id 去容器中寻找对应的对象。 JdbcConfig 类如下 package config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Bean(\"dataSource1\") public DataSource createDataSource1() &#123; return new DriverManagerDataSource(); &#125; @Bean(\"dataSource2\") public DataSource createDataSource2() &#123; return new DriverManagerDataSource(); &#125;&#125; 我们向容器中注入了两个 DataSource 对象，这时我们在 TestAutowired 中使用 @AutoWired 注解，如下 package test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.sql.DataSource;@Componentpublic class TestAutowired &#123; @Autowired DataSource dataSource;&#125; 由于在容器中有两个 DataSource 类型的对象，所以 @Autowired 无法根据类型自动注入，所以 @Autowired 会根据变量名 dataSource 作为 id 去容器中寻找对象注入，但是在容器中并没有 id 为 dataSource 的对象，所以不能够成功注入。 为了解决上面 @Autowired 注解存在的问题，我们可以通过 @Qualifier 注解指定自动注入的 id 名称，如 @Autowired@Qualifier(\"dataSource1\")DataSource dataSource; 注意： @Qualifier 注解不能单独使用，必须配合 @Autowired 注解或后面提到的 @Inject 注解使用 @Autowired 有一个属性为 required，该属性是规定是否要求一定要注入成功，默认为 true，即必须注入成功，否则抛出异常。 @Inject和@Named使用 @Inject 和 @Named 需要导入对象的坐标 &lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; @Inject 注解是 JSR330 规范规定的注解，它的作用也是实现自动注入注解，它的规则是根据类型自动注入，如果有多个相同类型的对象，那么会保错，与 @Autowired 注解不同，并不会以变量名作为 id 继续寻找。 @Named 注解也是 JSR330 规范规定的注解，它可以和 @Inject 注解配合使用，它是用来设置在容器中的 id 名称的，与 @Qualifier 注解一样，@Named 注解不能单独使用，必须配合 @Autowired 注解或 @Inject 使用 @Inject@Named(\"dataSource1\")DataSource dataSource; @Resource@Resource 注解是 JSR250 规范规定的注解，它有一个 name 属性，该属性是用来指定自动注入对象在容器中的 id，同 @Named 和 @Qualifier 不同，他可以单独使用，如 @Resource(name = \"dataSource1\")DataSource dataSource; @Primary当我们仅仅使用 Autowired 时，如果容器中有多个相同类型的对象且容器没有与成员变量名相同的对象，那么注入是会失败的，如 package config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;public class JdbcConfig &#123; @Bean public DataSource createDataSource1() &#123; return new DriverManagerDataSource(); &#125; @Bean public DataSource createDataSource2() &#123; return new DriverManagerDataSource(); &#125;&#125; @AutowiredDataSource dataSource; 这时自动注入会失败，这时我们可以使用 @Primary 来表明那个对象时主要的，当有多个类型相同的对象时，优先注入该对象，如 @Bean@Primarypublic DataSource createDataSource1() &#123; return new DriverManagerDataSource();&#125; 这时使用 @Autowired 注解，会默认注入这个 DataSource 对象。 @PostConstruct和@PreDestroy在创建 Bean 后，可能需要做一些初始化的工作，这时我们可以使用 @PostConstruct 注解，在对象被销毁前，可能需要做一些资源的回收工作，这时我们可以使用 @PreDestroy，这两个注解只能放在方法上，新建一个 utils.Logger 类如下 package utils;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Componentpublic class Logger &#123; public Logger() &#123; System.out.println(\"对象创建\"); &#125; @PostConstruct public void init() &#123; System.out.println(\"初始化工作...\"); &#125; @PreDestroy public void destroy() &#123; System.out.println(\"资源回收工作...\"); &#125;&#125; 我们使用 @PostContruct 注解了 init 方法和使用 PreDestroy 注解了 destroy 方法，这意味着当创建Logger 对象后会执行 init 方法进行初始化，在 Logger 对象销毁前，会执行 destroy 执行资源回收工作。现进行验证，配置类如下 package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"utils\")public class SpringConfiguration &#123;&#125; 测试类如下 import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class SpringTest &#123; public static void main(String[] args) &#123; // 在创建容器时 会创建 Logger 对象并注入，创建对象后会执行 init 方法 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(\"config\"); // 销毁容器， Logger 对象会被一同销毁 在销毁前会执行 destroy 方法 ac.close(); &#125;&#125; 结果如下 参考资料 Spring高级之注解驱动开发 @Profile进行环境切换","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/IOC/"}]},{"title":"Ajax跨域","date":"2020-04-21T16:00:00.000Z","path":"/Ajax跨域/","text":"同源策略什么是同源策略：同 domain(或IP)，同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源，这种安全限制称为同源策略。我们看几个例子判断两个链接是否是同源 url1 url2 是否同源 原因 http://example.com:8080 http://example.com:80 否 端口不同 http://example.com:8080 https://example.com:8080 否 协议不同 http://www.baidu.com http://www.taobao.com 否 域名不同 http://127.0.0.1:8080 http://localhost:8080 否 域名与域名对应的IP地址不同源 http://example.com:8000/a.js http://example.com:8000/b.js 是 协议，域名，端口相同，子域名不同 我们首先启动一个 Node 程序作为服务端，启动在本地的 4000 端口，如下 const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; res.end('hello world');&#125;)server.listen(4000, function() &#123; console.log('服务启动在4000端口...');&#125;) 现在我们同时在本地的 5501 端口启动一个静态服务器显示网页，在网页中我们发起一个 ajax 请求，向本地的 4000 端口请求数据，即我们刚刚搭的 Node 程序 const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; xhr.onerror = function() &#123; console.error('出错了') &#125;xhr.open('get', 'http://127.0.0.1:4000');xhr.send(null); 这个时候我们打开控制台，发现给出这样的错误信息 因为网页的地址 http://127.0.0.1:5501 与服务器的地址 http://127.0.0.1:4000 它们的端口是不同的，所以它们是不同源的，所以这个请求是跨域的请求，而浏览器是不允许跨域请求的。那么浏览器为什么会提出同源策略，这是出于安全的考虑。同源策略包括两种： DOM 同源策略：禁止对不同源页面 DOM 进行操作，这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的 XMLHttpRequest 同源策略：禁止使用 xhr 对象向不同源的服务器地址发起 HTTP 请求 在这里我们只关注 Ajax 跨域，我们来看一下如果没有同源策略会有什么危害： 用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识 用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 Ajax 请求代码 http://evil.com 向 http://mybank.com 发起 Ajax HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据，此时数据就泄露了 而且由于 Ajax 在后台执行，用户无法感知这一过程 所以有了同源策略我们才能够安全的上网，但是很多时候我们还是有跨域的需求的，并且现在随着前后端分离的流行，前端与后端不同源是很有可能，所以迫切需要解决这个问题，下面就介绍两种跨域的方法。 JSONP同源策略提升了 Web 前端的安全性，但牺牲了 Web 拓展上的灵活性。设想若把 html、js、css、flash、image 等文件全部布置在一台服务器上，小网站这样凑活还行，大中网站如果这样做服务器根本受不了的。所以，现代浏览器在安全性和可用性之间选择了一个平衡点。在遵循同源策略的基础上，选择性地为同源策略开放了后门， 例如 img script style 等标签，都允许垮域引用资源，严格说这都是不符合同源要求的。 正是利用 script 标签引用的资源没有同源策略的限制，我们可以通过 script 向服务器发送请求，而服务器返回一个回调，将数据作为参数返回，这一样就可以拿到想要的数据。可能你现在不能明白是什么意思，看下面的代码，我们在页面中添加下面的内容 &lt;script&gt; function getData(data) &#123; console.log(data); &#125; // 创建一个 script 标签用以请求数据 let scriptElement = document.createElement('script'); // 设置请求的地址 并且设置了处理数据的回调函数名称 scriptElement.src = 'http://127.0.0.1:4000?callback=getData'; // 这一步很重要，不设置的话浏览器会报错 Uncaught SyntaxError: Unexpected identifier scriptElement.setAttribute('type', 'text/javascript'); // 将这个 script 标签添加到 body 中 document.getElementsByTagName('body')[0].appendChild(scriptElement);&lt;/script&gt; Node 服务端的代码 const http = require('http');const querystring = require('querystring');const server = http.createServer();server.on('request', function(req, res) &#123; let qs = querystring.parse(req.url.split('?')[1]); // 解析请求参数 let data = \"Hello World\"; // 返回的数据 // 一定要在 $&#123;data&#125; 两端加上双引号，否则浏览器得到的是 getData(Hello World)会报错 res.end(`$&#123;qs.callback&#125;(\"$&#123;data&#125;\")`); // 即getData(data)&#125;)server.listen(4000, function() &#123; console.log('服务启动在4000端口...');&#125;) 结果如下 我来理一下上面的步骤 首先创建了一个函数 getData，该函数的作用是用来处理数据的，接收的那个参数就是数据 function getData(data) &#123; console.log(data);&#125; 创建一个 script 标签，并且设置了请求的地址，以及将处理数据函数的名称即 getData 作为参数传入 script.src = 'http://127.0.0.1:4000?callback=getData'; 服务器接到请求，将要返回的数据作为传入的回调函数的参数传入 res.end(`$&#123;qs.callback&#125;(\"$&#123;data&#125;\")`); // 即getData(data) script 标签得到服务器返回的数据，即 getData(&quot;Hello World&quot;)，script 得到的数据是可执行的代码，所以会执行 getData() 方法，这样数据 Hello World 就作为参数传递给了 getData() 优点： 使用简便，没有兼容性问题，是目前最流行的跨域方法 缺点： 只支持 GET 请求，并且代码是从其他域得到的，不排除可能有恶意代码，所以使用该方法，服务端必须确保值得信任 要确定 JSONP 请求失败并不容易 CORSCORS(Cross-origin resource sharing，跨域资源共享) 是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 对于开发者来说，我们只要正常的发出 Ajax 请求即可，与之前没有任何区别，如 const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; xhr.onerror = function() &#123; console.error('出错了') &#125;xhr.open('get', 'http://127.0.0.1:4000');xhr.send(null); 但是在服务端，我们要设置一下信赖的请求来源，如下 const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; // 表示来自 http://127.0.0.1:5501 的请求可以拿到数据 res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5501') res.end('hello world');&#125;)server.listen(4000, function() &#123; console.log('服务启动在4000端口...');&#125;) 除了可以设置请求来源，还可以设置允许的方法，允许的头部等等 响应头 作用 Access-Control-Allow-Origin 设置允许的请求来源，如果允许任意来源，可以设置为 * Access-Control-Allow-Methods 允许的方法，多个以逗号分隔，如 GET, POST Access-Control-Allow-Headers 允许的请求头，多个以逗号分隔 浏览器将 CORS 请求分为两类，分别为简单请求和非简单请求。如果满足以下两类请求，就是简单请求 请求方法是以下三种方法之一： GET POST HEAD HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 如果不满足以上的两大条件，那么就是非简单请求，而浏览器对于简单请求和非简单请求的处理是不一样的。 简单请求 在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：Origin: http://127.0.0.1:5501 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息(如果是公共资源，可以回发 *)，例如：Access-Control-Allow-Origin：http://127.0.0.1:5501 没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求，注意，请求和响应都不包含 cookie 信息 如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true 非简单请求 非简单请求可能对服务器数据产生副作用，浏览器必须首先使用 OPTIONS 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求， Origin：与简单的请求相同 Access-Control-Request-Method: 请求自身使用的方法 Access-Control-Request-Headers: (可选)自定义的头部信息，多个头部以逗号分隔 Origin: http://127.0.0.1:5501Access-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求，一旦服务器通过 Preflight 请求，允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。 优点： CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护 支持所有类型的 HTTP 请求 缺点： 存在兼容性问题，特别是 IE10 以下的浏览器 第一次发送非简单请求时会多一次请求 参考链接 跨域的那些事儿 浏览器同源策略及跨域的解决方法","tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Ajax/"}]},{"title":"JavaScript柯里化","date":"2020-04-20T16:00:00.000Z","path":"/JavaScript柯里化/","text":"柯里化介绍函数柯里化指的是函数处理一部分的参数，然后返回一个函数来处理剩余的参数，如比如有一个加法函数如下 function add(x, y) &#123; return x + y;&#125;add(1, 2); // 3 现在如果这个函数被柯里化，那么我们可以如下使用 const increment = add(1); // 接收第一个参数，返回一个函数处理第二个参数increment(2); // 3increment(4); // 5 柯里化实现现在怎么实现这种效果，如果只是针对上面的加法函数，那么可以如下实现 function add(x, y) &#123; return function(y) &#123; return x + y; &#125;&#125; 但是这种方法明显只对加法函数有效，我们现在是想设计一个函数，它接收一个函数为参数，作用就是把这个函数柯里化，并将这个柯里化的函数返回，比如 curryAdd = curry(add); // 接收add函数，将函数add柯里化const increment = curryAdd(1);increment(2); // 3increment(4); // 5 首先实现一个简单版本的 function curry(fn, ...args1) &#123; return function(...args2) &#123; fn(...args1, ...args2) &#125;&#125; 但是这个函数明显有一个缺陷，那就是只能传入两次参数，怎么解决，肯定使用递归了 function curry(fn, ...args1) &#123; if (fn.length == args1.length) &#123; return fn(...args1); &#125; else &#123; return function(...args2) &#123; return curry(fn, ...args1, ...args2) &#125; &#125;&#125; 上面的函数首先判断接收的参数的个数与函数要求参数的个数是否相同，如果相同则直接执行函数，否则返回一个函数来处理剩下的参数，这样就可以实现函数的柯里化。 柯里化应用举例现在来看一下柯里化有什么用处，假设有一个 ajax 请求的函数如下 function ajax(type, url, data) &#123; let xhr = new XMLHttpRequest(); xhr.onReadystateChange = function() &#123; // ... &#125; xhr.open(type, url); xhr.send(data);&#125; 现在我们将这个函数柯里化 let curriedAjax = curry(ajax);let post = curriedAjax('post'); 我们向 curriedAjax 传入一个参数 post，得到一个函数，这个函数的作用是用来发 post 请求的，我们每次发 post 请求时，只需要使用 post 方法即可，这样函数的复用性有了极大的增强，我们可以继续传入参数 let postGoogle = post('https://www.google.com'); 我们又得到了一个函数，该函数的作用是向 https://www.google.com 发送 post 请求，函数的复用性又进一步的提升。 使用过 jQuery 的都知道，可以使用 $.ajax() 这样的通用方法，但是也有 $.get() 和 $.post() 这样的语法糖，但是 jQuery 底部是不是这样实现的就不得而知了。 参考链接 大佬，JavaScript 柯里化，了解一下 JavaScript专题之函数柯里化","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"},{"name":"柯里化","slug":"柯里化","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"}]},{"title":"JavaScript闭包","date":"2020-04-17T16:00:00.000Z","path":"/JavaScript闭包/","text":"JavaScript的作用域JavaScript 的作用域有两种 全局作用域 函数作用域 与其他语言不同的是，JavaScript 没有块级作用域，参考以下程序 if (true) &#123; var x = 1;&#125;console.log(x); // 1 上面的变量 x 定义在 if 的语句块中，在其他的语言中，x 在语句块外是访问不到的，但是由于 JavaScript 没有块级作用域，所以变量 x 是全局变量，所以在语句块外也可以被访问到。 注意： 上面的讨论是基于 ES5 的，在 ES6 中，通过关键字 let 或 const 声明的变量，可以实现块级作用域的效果 if (true) &#123; let x = 1;&#125;console.log(x); // not defined JavaScript 作用域链JavaScript 作用域链指的是查找变量的顺序，比如下面的程序 var i = 1;function foo() &#123; var i = 2; function bar() &#123; var i = 3; console.log(i); &#125; bar();&#125;foo(); // 3 在上面的程序中，我们在 bar() 函数中访问了变量 i，这时 bar() 会先在 bar() 函数内部查找是否有变量 i，如果没有，则会去 bar() 函数的上一级作用域即 foo() 函数中寻找，如果还没有，则会去全局作用域寻找，如果没有找到，则会报错变量未定义，所以上述 bar() 函数的作用域链为 bar --&gt; foo --&gt; 全局作用域 编译器会根据作用域链去寻找变量，如果没有找到则会报错。 闭包介绍什么是闭包，简单的说就是允许函数访问并操作函数外部的变量，只要该变量处于该函数的作用域链中，比如 function foo() &#123; var x = 1; return function() &#123; console.log(x); &#125;&#125;var func = foo();func(); // 1 函数 foo() 返回了一个函数，返回的这个函数中访问了变量 x，根据我们的讲解，会根据这个函数的作用域链去寻找这个变量 x，该匿名函数定义时的作用域链 返回的匿名函数 --&gt; foo --&gt; 全局作用域 所以当执行该匿名函数时，会根据上述的作用域链去寻找变量 x，会在 foo 中找到变量 x，所以输出的结果是 1。 你可能会有这样的疑惑，当执行完函数 foo() 后，变量 x 不是应该已经被销毁了吗，为什么还能够被访问。之所以会有这样的想法，可能是受其他编程语言的影响，如 C，Java 等，但是要明白 JavaScript 与这些编程语言不同，至少 Java 不能够返回函数，因为返回的函数还保存着对变量 x 的引用，所以变量 x 在执行完 foo() 之后是不会被清除的，这就是还能够访问 x 的原因。 那接下来看一个例子，看看你是否明白了闭包 for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;, i * 100)&#125; 上面的程序的效果是延时 i * 100 ms 打印输出 i，你可能希望得到下面这样的输出 0123456789 但是真正的结果是 10101010101010101010 这是因为 setTimeout 是一个异步函数，当执行 setTimeout 时，并不会立即执行传入的回调函数，这些回调函数等到延迟时间到了以后，会将这些回调函数放入事件队列中，简单来说，当执行到 setTimeout 函数时，不会有任何的阻碍直接进入下一轮循环，等到循环执行完毕，编译器会取出事件队列中的函数执行(这些回调函数并不是执行到 setTimeout 方法时立即被添加到事件队列中的，而是等到设定的延迟时间后再添加到事件队列中的)，所以当执行这些回调函数时，循环已经执行完毕，变量 i 的值已经变为了 10，这些回调函数根据它的作用域链找到的变量 i 的值就全部是 10 了。 闭包实现私有变量在 JavaScript 中是没有关键字去声明私有变量的，但是我们可以通过闭包来实现这样的效果，如下 function Person () &#123; var name = 'ninja'; this.setName = function (value) &#123; name = value; &#125; this.getName = function () &#123; return name; &#125;&#125;var person = new Person();console.log(person.name); // 访问不到 undefinedconsole.log(person.getName()); // ninjaperson.setName('dummy');console.log(person.getName()); // dummy 通过闭包，setName 和 getName 可以对 name 进行访问和操作，但是却不能够被实例变量 person 访问到，因为 name 并不是 person 的属性，这样我们就实现了私有变量。 闭包处理回调函数假设有这么一个动画函数 var tick = 0;function animateIt(id) &#123; var element = document.getElementById(id); var timer = setInterval(function () &#123; if (tick &lt; 100) &#123; element.style.left = element.style.top = tick + \"px\"; tick++; &#125; else &#123; clearInterval(timer); &#125; &#125;, 10);&#125; 该函数实现在 1s 内将元素向下和向右平移 100px，如下 document.getElementById(\"box1\").addEventListener('click', function () &#123; animateIt(\"box1\");&#125;) 但是当我们同时对两个元素使用动画时，由于二者共享变量 tick，则会导致二者的动画状态发生冲突，所以我们改动如下 function animateIt(id) &#123; var tick = 0; var element = document.getElementById(id); var timer = setInterval(function () &#123; if (tick &lt; 100) &#123; element.style.left = element.style.top = tick + \"px\"; tick++; &#125; else &#123; clearInterval(timer); &#125; &#125;, 10);&#125;document.getElementById(\"box1\").addEventListener('click', function () &#123; animateIt(\"box1\");&#125;)document.getElementById(\"box2\").addEventListener('click', function () &#123; animateIt(\"box2\");&#125;) 我们将 tick 定义在函数内，由于闭包，setInteval 中的回调函数可以访问到tick，并且两个不同id 元素的tick是不同的，不会相互干扰","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"从尾到头打印链表","date":"2020-04-14T16:00:00.000Z","path":"/从尾到头打印链表/","text":"题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下： private static class ListNode &#123; private int value; private ListNode next; public ListNode(int value) &#123; this.value = value; &#125;&#125; 如果只是反过来打印节点的值，那么很简单，只要遍历链表，将节点的值 push 到一个栈里面，因为栈的特点是后进先出，所以最后我们遍历栈，达到的效果就是将链表从尾到头打印，如下 public static void printListReverse(ListNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode cur = root; // 遍历链表 将值添加到栈中 while (cur != null) &#123; stack.push(cur.value); cur = cur.next; &#125; // 遍历栈 打印栈头的值 while (!stack.isEmpty()) &#123; System.out.println(stack.pop()); &#125;&#125; 另外一种方法就是使用递归，对于任意一个节点，反过来打印即先打印下一个节点，然后在打印当前节点，如下 public static void printListReverse2(ListNode root) &#123; // 既是递归退出的条件 也是对传入的链表进行检查 if (root == null) &#123; return; &#125; printListReverse2(root.next); System.out.println(root.value);&#125;","tags":[{"name":"剑指offer 链表","slug":"剑指offer-链表","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8/"}]},{"title":"二维数组中的查找","date":"2020-04-11T16:00:00.000Z","path":"/二维数组中的查找/","text":"题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 首先将这个二维数组看做是一个矩阵，考虑这么一个思路，首先在矩阵中选取一个数，如果要查找的数大于这个数，那么该数应该在选取数字的下方或者右方，如果该数小于选取的数，那么这个数应该在选取数字的上方或者左方，无论怎样，查找的数都会在选取位置的两个区域都出现，并且这两个区域有重叠的部分，这使得问题较为复杂， 现在不妨换一种思路，我们从右上角开始进行查找，如果查找的数比右上角的数小，那么该数只可能在左方，如果查找的数比右上角大，那么该数只可能在下方，查找的数都只会在一个区域出现，要么在左方，要么在下方，每一次查找都会使得查找的区域变小，下面以查找数字5为例 代码如下 public class Test &#123; public static boolean findInMatrix(int[][] matrix, int number) &#123; boolean found = false; // 获得矩阵的行数和列数 int rows = matrix.length; int columns = matrix[0].length; if (matrix != null &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0) &#123; // 从右上角开始查找 int row = 0; int column = columns - 1; // 继续查找的条件 while (row &lt; rows &amp;&amp; columns &gt;= 0) &#123; if (matrix[row][column] == number) &#123; // 找到退出while循环 found = true; break; &#125; else if (matrix[row][column] &gt; number) &#123; // 比右上角小 在左方 column--; &#125; else &#123; // 否则比右上角大 在下方 row++; &#125; &#125; &#125; return found; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;2, 4, 6&#125;, &#123;3, 6, 9&#125;&#125;; boolean found = findInMatrix(matrix, 2); System.out.println(found); &#125;&#125;","tags":[{"name":"数组查找","slug":"数组查找","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"}]},{"title":"jQuery系统教程","date":"2020-04-07T15:00:00.000Z","path":"/jQuery系统教程/","text":"本篇文章是在完整学习 jQuery 以后，系统整理的教程，大纲如下 jQuery 的核心函数 $, jQuery 操作 jQuery 集合 操作 DOM 元素的属性和类属性 操作样式 操作 DOM 元素(添加，删除…) jQuery 事件 jQuery 显示与隐藏 jQuery 动画 jQuery 扩展及实用函数 Ajax jQuery核心函数jQuery 这个库中最重要的就是它提供的核心函数 jQuery() ，它提供了非常强大的功能，因为这个函数用的十分的频繁，所以提供了 jQuery() 的别名，那就是 $() ，在后面的演示中都将会以 $ 为例，现在我们来看一下该核心函数提供了哪些功能 选择多个 DOM 元素 将 HTML 字符串得解析为一个 DOM 元素 作为入口函数 将 DOM 元素转换为 jQuery 集合 上面有些名词可能没有听过，这里只是感性了解一下，下面就具体讲解。 选择元素考虑下面的 DOM 结构 &lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 如果使用原生的 JavaScript 选择上面的元素的写法如下 document.getElementById(\"box\");document.getElementsByClassName(\"container\")[0];document.getElementsByTagName(\"p\")[0]; 而现在使用 $() 函数，为其传入 CSS 的选择器即可选中元素 $(\"#box\");$(\".container\");$(\"p\"); 使用 $() 得到的是一个集合，即使使用了 id 选择器 #box ，得到也是一个只有一个元素的集合，如下 我们把它称为 jQuery 对象或者 jQuery 集合，在下面我将不会区分二者，可能会混合使用，请注意。由上可见， jQuery 对象的结构像是一个数组，但它不是真正的数组，因为他不是 Array 的实例，只是使用对象来模拟数组， jQuery 对象中的元素(借用数组的概念)是被选择的 DOM 元素。 jQuery 的核心函数支持几乎所有的 CSS 选择器，如 属性选择器 input[value] /* 选择有 value 属性的 input 标签 */input[type='text'] /* 选择 type 为 text 的 input 标签 */a[href^='http://'] /* 选择 href 以 http:// 开头的 a 标签 */a[href$='pdf'] /* 选择 href 以 pdf 结尾的 a 标签 */a[href*='jquery'] /* 选择 href 属性包含 jquery 的 a 标签 */ 伪类选择器 a:firstp:oddp:evenul li:last-child 过滤器 :animated /* 处于动画状态的元素 */:checkbox /* 相当于 input[type='chexkbox'] */:checked /* 选择处于选中状态的多选框或单选框 */:disabled... … 选择器十分的多，由于重点不在于选择器，另外这个也没有什么原理可讲，也就是 API 的使用，随着使用 jQuery 的增多，自然会掌握，所以这里就点到即止。 将 HTML 字符串转化为 jQuery 对象这里首先解释一下什么叫做 HTML 字符串，不给出具体的定义，很好理解，形如下面的字符串就叫做 HTML 字符串 \"&lt;p&gt;123&lt;/p&gt;\"\"&lt;h1&gt;一级标题&lt;/h1&gt;\" 当我们向 jQuery 的核心函数传递这样的字符串时，核心函数会将该字符串解析得到一个 jQuery 对象，如 作为入口函数因为我们一般会在 JavaScript 中操作 DOM ，所以我们一般会等到 DOM 树渲染完毕之后再去执行 JavaScript 代码，所以我们一般把 script 标签放在 body 元素的最后面，或者将代码放在 window.onload 中，如下 window.onload = function() &#123; // 要执行的代码&#125; onload 方法会在 DOM 树渲染完毕，并且外部资源如图片等等加载完毕后会执行，虽然能够满足我们的需求，但是在等待静态资源加载的时候，用户是不能与页面进行交互的，这时用户就会感觉页面卡死了，体验感十分不好。我们只是希望在 DOM 树渲染完毕后就执行代码，那么可以使用 ready() 函数，如下 $(document).ready(function() &#123; // 要执行的代码&#125;) 这里要执行的代码在 DOM 树渲染完毕后即可执行，而不必等到资源加载完毕。上面的写法可以简写为 $(function() &#123; // 要执行的代码&#125;) 将 DOM 元素转化为 jQuery 对象为核心函数传入 DOM 元素，会返回一个 jQuery对象，该对象包含了这个 DOM 元素，如下 将 DOM 元素转化为 jQuery 对象可以使用 jQuery 对象原型上的方法，这些方法想较于原生方法方便很多。 如何将 jQuery 对象转化为DOM元素呢? 我们知道 jQuery 对象的结构是类似于数组，其中的每一个元素都是 DOM 对象，我们可以使用下标的方式获取 DOM 元素，如下两种方法都是可以的 jQuery对象[index] jQuery对象.get(index)，该方法可以接受负数，表示倒数 操作 jQuery 集合在本节会使用 jQuery 集合这一叫法，因为往里面添加元素或者删除元素等等操作，集合的叫法比对象的叫法更加的符合。如果不做说明，下面操作的DOM为以下 &lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 添加元素使用 jQuery 集合调用 add 方法为集合添加元素， add 方法可以接收不同类型的参数，如下 jQuery 选择器：将与 jQuery 选择器匹配的所有 DOM 元素添加到集合中 DOM 元素或 DOM 元素组成的数组：将 DOM 元素或数组中的元素添加到集合中 HTML 字符串：将 HTML 字符串解析为 DOM 元素后添加到集合中 该方法会返回一个新的 jQuery 集合，例子如下 let collection = $(\"#box\");collection = collection.add(\".container\"); // 添加一个 jQuery 选择器collection = collection.add(document.getElementsByTagName(\"p\")[0]); // 添加一个 DOM 元素collection = collection.add(\"&lt;h1&gt;123&lt;/h1&gt;\"); // 添加一个 HTML 字符串console.dir(collection); 过滤元素过滤集合中的元素有两种方法，一个是 not，一个是 filter，两个方法的侧重点不同， not 方法会删除掉集合中符合条件的元素，返回新集合；而 filter 的语义是保留集合中符合条件的元素，返回一个新集合。二者接收的参数同 add 方法一样，除此之外，还可以接受一个函数，集合中的每一个元会素调用该函数，根据函数的返回值来决定元素的去留，比如对于 not 方法，如果函数返回 true，则删除此元素，对于 filter 则相反，如果返回 true，则保留此元素。这些传入的函数中的上下文(也就是 this)指向调用该函数的元素。 let collection = $(\"#box\");collection = collection.add(\".container\"); // 添加一个 jQuery 选择器collection = collection.add(document.getElementsByTagName(\"p\")[0]); // 添加一个 DOM 元素collection = collection.add(\"&lt;h1&gt;123&lt;/h1&gt;\"); // 添加一个 HTML 字符串collection = collection.not(function() &#123; return $(this).html() === \"123\"; // 删除掉 html 内容为 123 的，也就是 h1 标签&#125;)console.dir(collection); 根据上面的代码，此时集合中只有三个元素，将 h1 元素滤除了 let collection = $(\"#box\");collection = collection.add(\".container\"); // 添加一个 jQuery 选择器collection = collection.add(document.getElementsByTagName(\"p\")[0]); // 添加一个 DOM 元素collection = collection.add(\"&lt;h1&gt;123&lt;/h1&gt;\"); // 添加一个 HTML 字符串collection = collection.filter(function() &#123; return $(this).html() === \"123\"; // 保留 html 内容为 123 的，也就是 h1 标签&#125;)console.dir(collection); 将上面的 not 改为 filter，这时集合里面就只有一个元素，那就是 h1 元素 通过上面几个方法的学习，我们知道这些方法返回的都是一个新的 jQuery 集合，这意味着可以接着.，如下 let collection = $(\"#box\") .add(\".container\") .add(document.getElementsByTagName(\"p\")[0]) .add(\"&lt;h1&gt;123&lt;/h1&gt;\") .filter(function() &#123; return $(this).html() === \"123\"; &#125;); 这样写起来明显比上面写起来爽多了，这种写法叫做链式编程，像链子一样，一个接着一个。 遍历集合使用 each 方法遍历集合，该方法接收一个函数，集合中的每一个元素都会调用 each 中传入的函数，该函数的上下文会被设定为该元素，如 &lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt; $(\"div\").each(function() &#123; console.log($(this).html())&#125;) 集合查找 is(selector)：判断是否集合中是否包含与选择器匹配的元素，包含返回 true，否则返回 false has(test)：test 可以为选择器，也可以为 DOM 元素，它判断的是集合中的元素的后代中是否包含与 test 匹配的元素，如果集合中某元素 e 的后代包含与 test 匹配的元素，则将元素 e 添加到新的集合中，最后返回该集合，如 &lt;div&gt; &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; // $(\"div\")中有两个元素，只有第一个div元素的后代有ol元素// 所以返回的新的集合中包含一个元素，是第一个div元素$(\"div\").has(\"ol\"); // 两个元素的后代都有li元素，所以新集合中的元素与原集合相同$(\"div\").has(\"li\"); find(selector)：该方法会遍历集合中的所有元素，在这些元素的后代找到匹配 selector 的元素，然后将这些匹配的元素添加到一个新的集合中，并返回该新的集合 $(\"div\").find(\"img\") // 在所有div标签中找到img标签，返回这些img标签组成的集合 转换集合jQuery 对象有一个 map 方法，该方法与数组的 map 方法一样，接收一个回调函数，集合中的每一个元素都会调用该函数，该函数的返回值会被添加到新的集合中并返回(如果返回的是 null 或者 undefined 则不会添加到新的集合中)，该函数有两个参数，第一个参数是元素在集合中的下标，第二个参数是调用该函数的元素。 &lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt; $(\"div\").map(function(index, element) &#123; return index; // get()方法会将集合转变为一个真正的数组&#125;).get().join(\", \"); //\"0, 1, 2, 3, 4\" 操作 DOM 元素的属性和类属性操作属性我们可以使用attr()方法方便的操作 DOM 元素的属性 attr(name, value)：为名字为 name 的属性设置值为 value $(\"div\").attr(\"id\", \"box\"); // 将所有 div 标签的 id 设置为 box attr(name)：获取集合中第一个元素中属性名字为 name 的值 attr(attributes)：以对象的形式来设置属性值 $(\".attr\").attr(&#123; title: \"cat\", // 设置 title 属性为 cat id: \"cat\" // 设置 id 属性为 cat&#125;) removeAttr(name)：删除指定名称的属性 经过测试，发现 attr() 方法可以设置任意属性的值(我的意思是指即使这些属性是不存在的，比如 dog 也可以设置，而这些不存在的属性称为自定义属性)，比如 attr(\"dog\", \"dog\"); // 为 dog 属性设置值为 dog 上面的 dog 就是自定义的属性名。在 HTML5 中建议自定义属性名以 data- 开头，如 data-dog， HTML5 会将 data- 开头的属性名添加到 dataset 的对象中，我们可以通过 dataset[&quot;属性名&quot;] dataset.属性名 的方式访问，这时的属性名不需要加上 data- 前缀，如 dataset[&quot;dog&quot;] dataset.dog 如果属性名之间使用 - 连接，如 data-my-name，则访问时需要使用驼峰命名法访问，即 dataset[&quot;myName&quot;] dataset.myName 在新的页面打开标签现在使用 attr() 方法来做几个例子，第一个要求页面内的链接都要在新的页面打开，做法就是将 a 标签的 target 属性设置为 _blank ，这种事情当然可以在写的时候就写好，但是有两个问题 首先这个工作是重复性的工作，每写一个 a 都要重复同样的事情，既累又不够优雅 如果页面内的链接是用户加入的呢，比如百科，这时打开的链接就不一定是在新的页面打开了 所以我们可以使用 attr() 批量设置 a 标签的 target 属性为 _blank ，但是并不是所有的 a 标签，因为有的 a 标签是在页面内跳转的，我们并不需要在新的页面内打开，所以应该设置 href 属性以 http:// 开头的 a 标签在新的页面打开 $(\"a[href^='http://']\").attr(\"target\", \"_blank\") 解决双重提交在提交表单时，有的时候由于不能够及时给予用户反馈，导致用户不确定是否提交成功，用户会多次点击提交按钮，这样会给服务器端带来麻烦，我们在捕获 submit 事件时，当用户第一次提交时，我们接着将 disabled 属性设置为 true (或者为 disabled )，如下 // 绑定表单的提交事件$(\"form\").submit(function() &#123; // :submit 表示 type 为 submit 的元素 // 提交之后将submit按钮设置为disabled $(\":submit\", this).attr(\"disabled\", \"disabled\") &#125;) 在上面中设置 disabled 属性时，disabled 属性的值不重要，重点是设置了 disabled 这个属性，所以即使将它设置为空字符串 &quot;&quot;，它也是生效的，如果想 disabled 属性设置为不生效，那么就将它的值设置为 false (注意不要设置为字符串 &quot;false&quot; )，下面的写法作用是一样的，都是使得 disabled 生效 attr(&quot;disabled&quot;, &quot;disabled&quot;) attr(&quot;disabled&quot;, &quot;&quot;) attr(&quot;disabled&quot;, &quot;false&quot;) attr(&quot;disabled&quot;, true) 只有将 disabled 设置为布尔值 false 才会使得 disabled 失效 attr(&quot;disabled&quot;, false) 操作类属性为什么类属性要单独拿出来呢? 假设有这么一个需求，为所有的 div 标签添加一个类 box，那下面这样的写法对不对 $(\"div\").attr(\"class\", \"box\"); 上面的写法是错误的，因为上面的写法是为 class 属性赋值为 box，但是之前的类属性就会被覆盖掉，我们想做的仅仅是添加的操作，所以我们需要知道之前的类属性是什么，所以正确的写法如下 // 获得原来的类名列表 转化为数组const classList = $(\"div\").attr(\"class\").split(\" \");// 将要添加的类名添加到数组中classList.push(\"box\");// 将数组中的元素以空格拼接为一个字符串const newClassList = classList.join(\" \");// 设置class属性$(\"div\").attr(\"class\", newClassList); 经过千辛万苦终于添加了一个类，考虑到这样的操作很频繁，所以最好将上面的操作抽象为一个方法，而 jQuery 为我们做了这件事情： addClass(names) names 可以是单个类名，也可以是一个以空格分隔的字符串表示的多个类名 names 还可以是一个函数，函数的返回值作为单个类名或者多个类名，这个函数会传入两个参数，元素的下标(元素在 jQuery 集合中的下标)和当前类名的值 removeClass(names) 参数同 addClass ，作用是删除单个或多个类名 toggleClass(names) 该函数的作用是切换类名，什么意思呢? 比如如果该元素存在 names 指定的类，则删除掉指定的类，如果不存在指定的类，则添加指定的类 参数同上 addClass(\"box\"); // 为元素添加 box 类addClass(function(index, value) &#123; // index 是元素在 jQuery 中的下标 // value 是元素当前类名的值 // return \"active big\" return \"box\"; // 返回值将会被作为类名添加&#125;)removeClass(\"box\"); // 删除该元素 box 类toggleClass(\"box\"); // 如果存在 box 类，则删除 box 类，如果不存在 box 类，则添加 box 类 hasClass(name) 判断是否包含类名为 name 的类，包含则返回 true，否则返回 false HTML5 其实也提供了原生的操作类的方法，每个元素都有一个 classList 对象，它的原型对象提供了操作类名的方法 classList.add()：为元素添加一个类 classList.remove()：为元素删除指定的类 classList.toggle()：切换指定的类，存在则移除，不存在则添加 classList.contains()：判断是否存在指定的类，存在返回 true，反之返回 false 据我试验所知，上面的每次操作只能对一个类操作，意思就是不能同时添加多个类或删除。 操作样式使用 css() 方法来设置样式，使用的方法与 attr() 类似 css(name, value)：设置样式 name 为 value css(properties)：传入一个对象，通过对象来设置样式 css(name)：获得样式，如果是含有多个元素的 jQuery 集合调用此方法，那么返回的是第一个元素的计算样式值 看一个例子，有下面的 div 标签 &lt;div&gt;&lt;/div&gt; 现为它设置高度和宽度 $(\"div\").css(&#123; width: \"100px\", height: \"100px\"&#125;) css(name, value)：其中 value 可以是一个函数，该函数的返回值将作为 value 值，这个函数会接收两个参数，第一个参数是元素在 jQuery 集合中的位置，第二个参数是样式当前的值，同时函数的内部上下文 this 指向当前元素 获取元素宽度下面我们来获取某元素的 width 值 $(\"div\").css(\"width\"); // 100px 得到的结果是一个一个字符串，而不是数字，很多时候我们是希望得到数字用来计算或者其他用途，所以如果想得到数字的话就需要对字符串进行解析，但是 jQuery 有考虑这一方面，我们可以很方便的使用 width(), height() 方法获得数字的结果，如 $(\"div\").width(); // 100 这里的 width 的大小是设置样式时的大小吗? 比如 div&#123; width: 100px;&#125; 使用 width() 方法得到的数字是100吗? 为什么在这里我会提出这么一个疑问，因为这里设置的 width 不一定是标签的内容宽度，也可能包括 padding, border (当 box-sizing 设置为 border-box 时)，所以这里的 width 得到的是 content-width 还是在 style 标签中设置的 width ，我们设置 div 的样式为 div &#123; box-sizing: border-box; padding: 10px; width: 100px;&#125; 这个时候在 style 里面设置的 width 为 100 ，但是实际的 content-width 应该是 80 ，我们来看一下 width() 方法得到的结果是多少 $(\"div\").width(); // 80 上面得到的结果是 80 ，所以 width() 方法得到的宽度是 content-width ，即是实际内容的宽度， height() 方法也是同理。 除了可以使用 width() 方法获得元素的宽度以外，还可以设置元素的宽度 width(value) value 的值可以是一个数字，单位默认为 px 也可以是带单位的字符串(如果没有指定单位，则默认为 px) 还可以是一个函数，函数的返回值作为要设置的值，该函数的上下文(this)是该元素 这里又有一个疑问，如果我设定宽度，那么这里的宽度我设定的是内容宽度 conetnt-width 还是元素的 width 样式，这里我们还是以上面的 div 为例 div &#123; box-sizing: border-box; padding: 10px; width: 100px;&#125; 这里我们设定 width 为 200 ，然后通过 width() 方法获得宽度，如果得到的值是 200 ，那说明设定的是 content-width ，如果得到的是 180 ，说明设定的是 width 样式的值 $(\"div\").width(200);console.log($(\"div\").width()); // 200 得到的结果是 200 ，说明设定的是 content-width 。 在这里我突然又有一个想法，那就是 css(&quot;width&quot;) 与 width() 得到的结果是相同的吗，还是以上面的 div 为例 div &#123; box-sizing: border-box; padding: 10px; width: 100px;&#125; console.log($(\"div\").width()); // 80console.log($(\"div\").css(\"width\")); // 100px 惊讶的发现二者得到的结果是在数值上是不一样的，可见使用 css(&quot;width&quot;) 获得的是 width 样式的值，那么使用 css(&quot;width&quot;, 200) 设定的是 width 样式的值吗，测试一下 $(\"div\").css(\"width\", 200);console.log($(\"div\").width()); // 180console.log($(\"div\").css(\"width\")); // 200px 果然 css() 方法设置的值也是 width 样式的值，所以这里总结一下： width()(height())方法设定或者获取的值是指内容的宽度(高度) css() 设定或获取的宽度(高度)是指样式里面的 width 值的大小 在 box-sizing 为 content-box 下二者得到的数值结果是一样的，但是在 box-sizing 为 border-box 的情况下，由于 padding 和 border 的影响，二者的结果是不同的(在 padding 和 border 为 0 的情况下是相同的)。 经过一次实践，我发现上面的描述也不太准确，css(&quot;width&quot;)与width()方法获得的值符合上面情况的条件是，它的大小没有超过它父元素的大小，如果超过了，那么css(&quot;width&quot;)就是父元素的width样式的大小，而width()方法的大小我觉得很复杂，还不知道怎么计算，自己动手试试吧。 除了 width() 和 height() 方法，jQuery 还提供了特别的方法来获得特殊的宽度和高度 方法 描述 innerwidth() 内容宽度+内边距宽度 innerHeight() 同上 outerWidth(margin) margin为false时，内容宽度 + 内边距宽度 + 边框宽度margin为true时，再加上外边距的宽度 outerHeight(margin) 同上 获取元素位置offsetoffset()，获取元素离文档原点的距离，返回一个对象，里面有 left 和 top 两个属性，表示离文档原点经过测试，应该是元素的 border 的左上角离文档原点的距离。 position另一个获取位置有关信息的是 position() ，它是获得与它元素左上角之间的距离，这个父元素是它所有父元素中使用了定位 position 且离他最近的父元素，虽然有点拗口，不过使用过绝对定位的话，就会很容易明白，因为它与绝对定位的规则是一样的。 经过我的实验，发现这个距离不是边框与边框的距离，而是子元素 margin 离父元素 padding 之间的距离。 操作 DOM 元素设置 html 内容以及文本内容 html()：获取jQuery集合中第一个元素的 html 内容 html(content)：将传入的 HTML 片段，设置 jQuery 集合中元素的 HTML 内容 text()：获得 jQuery 集合中所有元素的文本内容拼接的字符串 text(content)：将 jQuery 集合元素的文本内容设置为传入的值 content 可以为字符串，也可以是一个函数，函数的返回值作为要设置的内容，函数接受两个参数，第一个参数是元素在 jQuery 集合中的位置，第二个参数是当前html(text)的值。 追加元素 append(content)：将 content 追加元素内容的最后面(子元素级别) prepend(content)：将 content 追加元素内容的最前面 before(content)：将 content 追加到元素的前面(兄弟元素级别) after(content)：将 content 追加到元素的后面 content 的值可以为字符串，元素，jQuery集合，函数，函数的返回值将被添加，函数将接受两个参数，元素的下标和原先的内容。 如果选择现有的DOM元素添加到某元素的最后，那么这是一个移动操作，而不是一个复制操作，比如有这么一个结构 &lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 执行下面的语句 $(\"div\").append($(\"p\")); 得到的结果是 &lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 而不是 &lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 如果jQuery集合中有多个元素，那么被添加的元素会复制多份，添加到这些元素内容的后面(如果添加的是DOM中已有的元素，也是移动操作)，其它的操作(prepend…)也是同理。 appendTo(target) prependTo(target) insertBefore(target) insertAfter(target) 这些方法的作用同上面介绍的是个方法是一一对应的，不过是主动变为了被动，如 $(\"div\").append(content); // 向div中添加content$(\"div\").appendTo(target); // 将div添加到target中 target 只能为元素或者字符串 删除元素 remove(selector)：删除 jQuery 集合中的元素，selector 是一个可选的选择器，用来进一步筛选要删除的元素，被删除的元素会放入一个新的 jQuery 集合中返回，所以被删除的元素可以继续插入到 DOM 中，但是这个时候之前绑定的事件和数据全部被删除了。 empty()：删除 DOM 元素中的内容，与 remove 不同， remove 是删除这个 DOM 元素，包括这个元素包括的内容，但是 empty 只是清除该 DOM 元素的内容。 detach(selector)：该方法的作用与 remove 是一样的，但是保留绑定的事件和绑定的数据。 复制元素 clone(cloneHandler)：复制 jQuery 集合中的元素，生成一个新的 jQuery 集合返回。 cloneHandler 如果为 true，那么就会复制绑定的事件，如果为 false 就不会复制绑定的事件 替换元素 replaceWith(content)：使用 content 去替换 jQuery 集合中的元素，返回被替换的元素， content 可以是字符串，元素和函数，函数的返回值作为替换的内容，函数的上下文被设置为当前的元素，不传递任何的参数；如果 content 是已经在DOM中的元素，那么就相当于是移动到 jQuery 集合中元素的位置，如果 jQuery 集合中有多个元素，会复制多个 content 副本 replaceAll(selector)：使用 jQuery 集合中的所有元素去替换匹配 selector 的元素，如果jQuery集合中的元素是已经在 DOM 中的元素，那么就相当于将符合 selector 的元素删除，然后将 jQuery 集合中的元素移动到这里，如果符合 selector 的元素有多个，那么会复制多个 jQuery 集合的副本移动 处理表单元素 val()：获得集合中第一个元素的 value 值，如果该元素是一个可以多选的元素，那么返回所有选择项组成数组(比如&lt;select mupltiple=&quot;mupltiple&quot;&gt;&lt;/select&gt;) 如果第一个元素不是表单元素，则会返回空字符串 val(value)：设置集合中表单元素的 value 值 value值也可以是函数，函数的返回值作为被设置的内容，函数接收两个参数，元素的下标和当前的value值 val(values)：使得多选框，单选框，或者select元素中的可选项中，如果这些选项的值在values中，则它变为选中状态 jQuery 事件绑定事件jQuery 使用 on 方法绑定事件，如下 on(eventType, childSelector, data, listener) eventType，必需，要绑定的事件的类型，如 click childSelector，可选，规定把事件绑定到子元素上 data，可选，规定传递到函数的额外数据 listener，可选，规定事件发生时运行的函数 on 方法除了给已经存在于DOM中的元素绑定事件以外，还可以给现在还不存在于 DOM 中但是未来会添加到 DOM 中的元素绑定事件，如 &lt;div&gt;&lt;/div&gt; 此时 DOM 中只有 div 标签，这时我想给未来会被添加到 DOM 中的 p 标签绑定点击事件 $(\"p\").appendTo($(\"div\")); // 将p标签添加到div中// 为div标签中的p标签绑定事件，即使p标签一开始并不在DOM中，也可以绑定成功$(\"div\").on(\"click\", \"p\", function() &#123; &#125;) 使用 one() 绑定事件，该事件在执行完一次后会被删除 one(eventType, data, listener) 各参数的含义与 on 是一致的 除了可以使用上面的方法绑定事件以外，jQuery 还提供了十分方便的绑定特定事件方法，如 // 为div标签绑定点击事件$(\"div\").click(function() &#123; &#125;) 这样直接以事件的名字绑定事件，既方便，语义又明确，支持这种方式的 eventTypeName 如下 解绑事件 off(event, selector, listener)：移除通过 on 方法绑定的事件 触发事件 trigger(event, data) 这个方法是用来触发事件的，比如 $(&quot;#foo&quot;).trigger(&quot;click&quot;) 会触发 id 为 foo 的点击事件 data 是可选参数，是传递给事件处理的额外参数，它是一个数组或者对象 来解释一下 data，加入在绑定事件时需要额外的参数，如 // 需要额外的参数a, b$(\"#foo\").click(function(event, a, b) &#123; &#125;) 这时我们在触发事件时就需要传入额外的参数 $(\"#foo\").trigger(\"click\", [\"foo\", \"bar\"]) triggerHandler(event, data) triggerHandler 的作用与 trigger 类似，不过有几点不同 .triggerHandler() 方法并不会触发事件的默认行为(例如，表单提交)。 .trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素。 使用 .triggerHandler() 创建的事件，并不会在 DOM 树中向上冒泡。 .triggerHandler() 返回最后一个处理的事件的返回值，而不是 jQuery 集合，即不能进行链式调用 除了上述的方法外，jQuery 还提供了可以直接通过名字直接触发事件，如 $(\"#foo\").click() // 触发点击事件 其他事件 toggle(listener1, listener2, ...) 当点击元素时会依次触发事件 比如第一次点击触发 listener1 ，第二次点击触发 listener2 ，以此类推，如果 toggle 中的事件触发完了，那么会循环触发 hover(enterHandle, leaveHadnler) 当鼠标进入元素时触发 enterHandle ，离开元素时触发 leaveHadnler hover(handler) 当鼠标进入元素以及离开元素时均会触发 handler Event实例我们向元素绑定事件时，会向监听器(绑定的处理函数)传入一个 event 对象，那么 event 对象中有什么信息可以为我们所用呢? 属性 含义 altKey 当事件触发时，如果 Alt 键被按下，设置为 true，否则为 false ctrlKey 当事件触发时，如果 Ctrl 键被按下，设置为 true，否则为 false shiftKey 当事件触发时，如果 Shift 键已被按下，则设置为 true，否则为 false target 触发事件的元素 currentTarget 冒泡阶段的当前元素，它和事件处理器中 this 对象是同一个对象 relatedTarget 对于鼠标事件，找出触发事件时光标离开或者进入的元素 pageX/pageY 对于鼠标事件，指定触发事件时光标相对于页面原点的水平/垂直坐标 screenX/screenY 对于鼠标事件，指定触发事件时光标相对于屏幕原点的水平/垂直坐标 timestamp jQuery.Event实例创建时的时间戳，以毫秒为单位 方法 含义 preventDefault() 阻止默认动作(表单提交，链接跳转，复选框状态改变) stopPropagation() 停止冒泡 stopImmediatePropagation() 停止冒泡，包括当前元素上的事件 isDefaultPrevented() 如果已经在此实例上调用了 preventDefault() 方法，则返回 true isPropagationStopped() 如果已经在此实例上调用了 stopPropagation() 方法，则返回 true isImmediatePropagationStopped() 如果已经在此实例上调用了 stopImmediatePropagation() 方法，则返回 true jQuery 显示与隐藏显示和隐藏元素 hide()：隐藏元素 show()：显示元素 隐藏元素是将元素的 display 属性设置为 none，而显示属性会将 display 属性设置为与隐藏前的 display 相同，比如在隐藏前某元素的 display 为 block， hide 会将 dispaly 设置为 none，show 会将 display 设置为与之前相同为 block。 toggle()：切换，如果为显示，则隐藏，如果隐藏，则显示 显示隐藏动画上面的方法其实还可以接受两个参数 hide(speed, callback) speed 用来规定隐藏的速度，默认是没有动画效果的，元素瞬间消失，可以传入数字，单位是毫秒，也可以传入以下预定义的字符串，slow, normal, fast callback 是动画执行完毕后会执行的回调函数 同理，show() 和toggle() 也由这两个参数，与hide() 的用法一模一样，所以不再赘述。 假设有一个 div 标签，当我们点击它时，它会先隐藏，会显示 $(\"div\").click(function() &#123; $(this).hide(\"slow\").show(\"fast\")&#125;) 除了上面方法显示和隐藏元素以外，jQuery 还提供了很多的方法，如 淡入淡出(只改变元素的不透明度)： fadeIn(speed, callback) fadeOut(speed, callback) fadeTo(speed, opacity, callback)：逐渐改变元素的透明度到设定的opacity 我们在使用 hide 或者 show 时，除了改变透明度以外，还会改变高度和宽度，而 fade... 方法只会改变不透明度，当 opacity 为 0 时，将 display 设置为 none $(\"div\").click(function() &#123; $(this).fadeOut(\"slow\").fadeIn(\"fast\")&#125;) 滑入滑出： slideDown(speed, callback)：改变元素的垂直尺寸，使元素逐渐显示出来 slideUp(speed, callback)：改变元素的垂直尺寸，使元素逐渐消失 slideToggle(speed, callback)：隐藏则显示，显示则隐藏 $(\"div\").click(function() &#123; $(\"div\").slideUp(\"slow\").slideDown(\"fast\")&#125;) jQuery 动画 animate(properties, duration, easing, callback) properties：元素最后达到的 CSS 状态 duration：持续时间 easing：动画曲线，jQuery 提供两个函数曲线 linear 和 swing callback：动画执行完毕后的会执行的回调函数 我们通过给定希望元素最后能够达到的 CSS 状态，比如位置的变化，宽高的变化，而 jQuery 会自动根据持续的时间以及初始的状态计算出中间的过程，也就是帧，如 $(\"div\").click(function() &#123; $(\"div\").animate(&#123; width: \"200px\" &#125;, 500, \"swing\")&#125;) 自定义缩放动画$(\"div\").hover(function() &#123; // 鼠标放上去时，放大两倍 $(\"div\").animate(&#123; width: $(this).width() * 2, height: $(this).height() * 2 &#125;)&#125;, function () &#123; // 离开时恢复原样 $(\"div\").animate(&#123; width: $(this).width() / 2, height: $(this).height() / 2 &#125;)&#125;) 自定义掉落动画$(\"div\").click(function() &#123; $(this).css(&#123; position: \"relative\" &#125;).animate(&#123; opacity: 0, // 计算要下降的高度 top: $(window).height() - $(this).height() - $(this).position().top &#125;, \"slow\", function() &#123; // 因为 opacity 为 0 只是不可见，但是仍然占据位置，所以最后要hide隐藏一下 // 可以将 opacity 最后的状态设置为 hide，那么这个回调函数可以省略 $(this).hide() &#125;)&#125;) 将 $.fx.off 设置为 true 会禁用动画 jQuery扩展及实用函数jQuery与其他库并存 $.noConflict()：将 $ 控制权给其他库，在执行该行代码后不能使用 $，只能使用 jQuery jQuery实用函数 $.trim(value)：去除字符串前后的空白字符(不仅仅是空格，还有回车等等) $.each(container, callback)：会为 container (数组|对象)中的每个元素调用 callback，callback 的参数就是 container 中的每个元素 $.grep(array, callback, invert)：为数组中的每个元素调用 callback，根据 callback 的返回值决定是否将元素添加到新的数组，如果 invert 为 true，那么 callback 返回 false 则将元素添加到新数组，反之若 invert 为 false，则 callback 返回 true 则将元素添加到新的数组，最后将新数组返回 $.map(array, callback)：这个方法不想多解释 $.inArray(value, array)：方法 value 在 array 中第一次出现的下标 $.makeArray(object)：将一个伪数组转换为一个真正的数组 $.unique(array)：返回 array 中不重复的元素组成的数组 $.merge(array1, array2)：将第二个数组合并到第一个数组中，并返回第一个数组 上面的方法大多数 JavaScript 已经有原生的实现了 扩展jQuery$.fn.xxx：该方法会被添加到 jQuery 对象的原型上，通过这种方法可以扩展 jQuery Ajax启动一个Node来进行服务端测试const http = require('http');const server = http.createServer();server.on('request', (req, res) =&gt; &#123; // 处理跨域 // 允许http://127.0.0.1:5500 跨域请求 res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); res.end(\"Hello World\");&#125;)server.listen(4000, () =&gt; &#123; console.log(\"服务启动在4000端口\");&#125;) 回顾Ajax&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;发送请求&lt;/button&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; $(\"button\").click(function () &#123; let xhr = new XMLHttpRequest(); // 设置请求方法和请求路径 xhr.open(\"GET\", \"http://localhost:4000\"); // 监听onreadystatechange，当readyState改变时会触发此函数 xhr.onreadystatechange = function () &#123; // readyState为4表示处理请求完成 if (this.readyState == 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; // 成功 $(\"ul\").append(`&lt;li&gt;$&#123;this.responseText&#125;&lt;/li&gt;`) &#125; else &#123; // 失败 alert(\"失败\"); &#125; &#125; &#125; // 发送的请求体数据 get方法不传参数，或者传入null xhr.send(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码是当点击button时发送一个ajax请求，并且获得的内容添加到ul中，效果如下 XMLHttpRequest 对象拥有的属性和方法为 属性和方法 含义 abort() 取消当前请求 getAllResponseHeaders() 获得所以的响应头及相应的值组成的字符串 getResponseHeader() 获得指定名称的响应头和值 open(method, url, async, username, password) 设置请求方法和 URL，可以设置同步请求和异步请求，也可以提高基于容器认证需要的用户名和密码 send(content) 发送带有指定内容的请求 setRequestHeader(name, value) 设置请求头 onreadystatechange 当状态改变时，触发此方法接收的回调函数 readyState 目前的请求状态：0：已创建 XHR 对象，但是未调用 open 方法1：已调用 open 方法，但是请求还未发出2：已调用 send 方法3：服务端正在处理，responseText 中已有部分数据4：响应已经接收完成 reponseText 响应体中的数据 responseXML 如果返回的内容指定为 XML，会复制一份 reponseText 的内容到这里 status 服务端返回的状态码 statusText 返回的文本状态信息，如 success ok jQuery 发起 Ajax 请求 get(url, parameters, callback, type) url：请求的路径 parameters：请求参数，会被拼接到 url 后 callback：请求成功后调用的函数 type：以何种方式处理响应数据，如 html，json getJSON(url, parameters, callback)：相当于是 get(url, parameters, callback, type) 中 type 为 json 的快捷写法 post(url, parameters, callback, type)：同 get，不过请求的方法是 POST，而且请求数据是放在请求体中的 ajax(options)： 通过传入的选项 options 可以控制发送 ajax 请求的各种细节 参数 含义 url 请求的地址 type 请求的方法，如 GET POST，默认为 GET data 请求参数，如果是 GET，则把参数放入请求地址中，如果是 POST，则把数据作为请求主题 processData 将上面的 data 进行处理为 URL 编码格式，如果指定为 false，则不进行此操作 contentType 指定请求内容的类型 cache 是否启动浏览器缓存，默认为 true timeout 超时时间(单位毫秒)，超过改时间没有得到应答，则调用处理错误的回调函数 async 如果指定 false，则将请求作为同步请求来提交，默认为异步 beforeSend 在发起请求之前调用的函数 success 返回成功状态码时调用的函数，第一个参数为响应主体，第二个参数为消息字符串，第三个参数为 XHR 实例的引用 error 返回错误状态码时调用的函数，第一个参数为 XHR 实例，第二个参数为消息字符串，第三个参数为异常对象 complete 请求结束时调用的方法，无论成功还是失败，接收两个参数，第一个参数为 XHR 实例，第二个参数为消息字符串 xhr 用来提供 XHR 实例自定义实现的回调函数 jQuery 的 ajax 方法为我们提供了这么多可选项，如果没有设置一些选项的话，就会使用默认值，使用 ajaxSetup 方法来设置默认值 ajaxSetup(options) $.ajaxSetup(&#123; type: 'POST', timeout: 5000&#125;) 那么后面的每个 ajax 调用都会使用这些默认值($.get() 的 HTTP 方法不会被改为 POST)。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/jQuery/"}]},{"title":"使用before和after实现一个hover遮罩效果","date":"2020-04-04T16:00:00.000Z","path":"/使用before和after实现一个hover遮罩效果/","text":"今天开始学习CSS效果，记录一下，成品如下 实现的思路很简单，使用到了::before和::after两个伪元素，默认两个伪元素的width为0，height与父元素的高度相同，当鼠标放上去时，伪元素的width变为100%，注意到两个伪元素变化的方向不一样，因为::before被设置为了 top: 0;left: 0; 而::after被设置为 bottom: 0;right: 0; talk is cheap, show me the code，直接上代码吧 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; width: 100%; height: 100%; background-color: #fff; &#125; a &#123; font-size: 50px; display: block; width: 300px; height: 100px; line-height: 100px; margin: auto; text-decoration: none; text-align: center; text-transform: uppercase; color: #666; border: 1px solid black; position: absolute; top: 0; left: 0; bottom: 0; right: 0; font-family: Arial, Helvetica, sans-serif; transition: all 0.5s; z-index: 1; &#125; a::before, a::after &#123; content: \"\"; display: block; width: 0; height: 100px; position: absolute; background: #333; transition: all 0.5s; z-index: -1; &#125; a::before &#123; top: 0; left: 0; &#125; a::after &#123; bottom: 0; right: 0; &#125; a:hover::before, a:hover::after &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#\"&gt;Move&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码不难理解，就一个地方需要注意的是，在a标签中设置了 margin: auto;position: absolute;top: 0;left: 0;bottom: 0;right: 0; 这样的写法，这样做的目的是使得a标签在body中居中显示，因为设置了定位的属性 top: 0;left: 0;bottom: 0;right: 0; 四个都为0，要达到这样的效果，设置margin为auto会为a元素四周充满外边距，如下 这样就可以到居中的效果。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/CSS/"}]},{"title":"数组中的重复的数字","date":"2020-04-03T16:00:00.000Z","path":"/数组中的重复的数字/","text":"题目一：找出数组中重复的数字 在一个长度为n的数组里的所有数组都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数组2或者3。 考虑如果没有数组中没有重复的数字，那么排序后会有arr[i] = i(因为元素在 0~n-1 的范围内)，那么现在我们遍历数组，让第i个位置的元素的值为i(从0开始)，做法是当arr[i] != i的时候，与第arr[i]的位置进行交换，这样可以使得第arr[i]个位置上的数是arr[i]，即arr[arr[i]] = arr[i] int temp = arr[i];arr[i] = arr[temp];arr[temp] = temp; 如果有重复的数，由于arr[arr[i]]位置上的数已经被占了，所以这个时候我们就知道有重复的数，算法如下 public class Test01 &#123; public static boolean duplicate(int[] arr) &#123; if (arr.length &lt;= 0 || arr == null) &#123; return false; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; while(arr[i] != i) &#123; if (arr[arr[i]] == arr[i]) &#123; return true; &#125; swap(arr, i, arr[i]); printArr(arr); &#125; &#125; return false; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; private static void printArr(int[] arr) &#123; System.out.print(\"[\"); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]); if(i != arr.length - 1) &#123; System.out.print(\", \"); &#125; &#125; System.out.println(\"]\"); &#125; public static void main(String[] args) &#123; int[] arr = &#123;2, 3, 1, 0, 2, 3, 5&#125;; // int[] arr = &#123;7, 5, 6, 3, 4, 1, 0, 2&#125;; boolean duplicated = duplicate(arr); System.out.println(duplicated); &#125;&#125; 题目二：不修改数组找出重复的数字 在一个长度为 n+1 的数组里的所有数字都在 1~n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。 该算法有两种思路，第一种需要大小为 n+1 的辅助数组，我们遍历数组，将数组中的元素都复制到辅助数组中，原则如下，假设要复制的元素为m，那么将该数复制到辅助数组中下标为m的位置，这样很容易知道哪个元素重复了。 public class Test02 &#123; public static int duplicate(int[] arr) &#123; int N = arr.length; int[] helpArr = new int[N]; for(int i = 0; i &lt; N; i++) &#123; if (arr[i] == helpArr[arr[i]]) &#123; return arr[i]; &#125; else &#123; helpArr[arr[i]] = arr[i]; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] arr = &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;; int num = duplicate(arr); System.out.println(num); // 3 &#125;&#125; 另一种思路是二分查找，首先我们将数字分成两半，比如 1~m 和 m+1~n，接着我们在数组中统计数字在 1~m 区间中的个数，如果数量大于 m ，那么就说明在 1~m 中有重复的数字，否则在 m+1~n 中有重复的数字，假设在 1~m 中有重复的数字，那么继续分成两半，如此往复，直到两边只有一个元素，代码如下 public class Test03 &#123; public static int duplicate(int[] arr) &#123; int start = 1; int end = arr.length - 1; while (end &gt;= start) &#123; int middle = start + (end - start) / 2; // 获得数字范围在[start, middle]范围内的数目 int countNum = count(arr, start, middle); if (start == end) &#123; if(countNum &gt; 1) &#123; return start; &#125; else &#123; // 如果范围只剩最后一个元素，但是数目不大于1，说明没有重复的 break; &#125; &#125; if (countNum &gt; (middle - start + 1)) &#123; // 在[start, middle]中继续找 end = middle; &#125; else &#123; // 在[middle + 1, end]中继续找 start = middle + 1; &#125; &#125; return -1; &#125; // 统计数组中数字范围在[start, end]范围内的数目 private static int count(int[] arr, int start, int end) &#123; int count = 0; for(int i = 0; i &lt; arr.length; i++) &#123; if (start &lt;= arr[i] &amp;&amp; arr[i] &lt;= end) &#123; count++; &#125; &#125; return count; &#125; public static void main(String[] args) &#123; int[] arr = &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;; int num = duplicate(arr); System.out.println(num); // 3 &#125;&#125;","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"单例模式","date":"2020-04-02T16:00:00.000Z","path":"/单例模式/","text":"题目：设计一个类，我们只能生成该类的一个实例。 如果只能生成一个实例，这意味着构造方法必须为私有的，该类实例的创建不能由用户创建，一个容易想到的版本如下 public class Test01 &#123; private Test01() &#123; &#125; private static Test01 instance; public static Test01 getInstance() &#123; if (instance == null) &#123; instance = new Test01(); &#125; return instance; &#125; public static void main(String[] args) &#123; Test01 one = Test01.getInstance(); Test01 two = Test01.getInstance(); System.out.println(one == two); // true &#125;&#125; 我们在类里面声明了一个instance变量，它是该类的一个实例，用户通过getInstance()来获得该类的实例，在该方法中，首先判断instance是不是为null，如果是null说明还没有创建过该实例，那么创建一个实例，如果不为null，说明已经创建过该实例，将之前创建过的实例返回，从而达到创建的始终是一个实例的效果。 但是使用上面的方法有一个缺点，那就是在多线程的情况下可能创建出多个实例，考虑这么一种情况，第一个线程执行if (instance == null)时，这时是成功的，会进入到if语句中，但是这个时候它失去了执行权，这个时候第二个线程执行if (instance == null)时，由于instance还没有赋值，它的值还为null，它也能够进入到if语句中，这个时候第一个线程和第二个线程都会使用new关键字创建出一个实例，它们是不同的。 简单的解决上面的问题就是加锁，上面会出现问题的语句为 if (instance == null) &#123; instance = new Test01();&#125; 所以我们为这个语句块加上锁就行，这就出现了第二个版本 public class Test02 &#123; private static Test02 instance; private Test02() &#123; &#125; private static Test02 getInstance() &#123; synchronized(Test02.class) &#123; if (instance == null) &#123; instance = new Test02(); &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Test02 one = Test02.getInstance(); Test02 two = Test02.getInstance(); System.out.println(one == two); // true &#125;&#125; 但是这个方法还有一个小的缺点，那就是每次我们获取实例的时候，都需要加锁，这意味着性能的损失，当instance不为null的时候，已经不会由于多线程而产生问题了，也就不用加锁了，所以再次修改getInstance()，产生了第三个版本 public class Test03 &#123; private static Test03 instance; private Test03() &#123; &#125; private static Test03 getInstance() &#123; if (instance == null) &#123; synchronized(Test03.class) &#123; if (instance == null) &#123; instance = new Test03(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Test03 one = Test03.getInstance(); Test03 two = Test03.getInstance(); System.out.println(one == two); // true &#125;&#125; 在这个版本中，只有在instance为null的时候，我们才加锁。 上面的方法已经比较好了，这里再次推荐更好的办法，我们在instance声明的时候就为它赋值 public class Test04 &#123; // 在声明的时候就赋值 private static Test04 instance = new Test04(); private Test04() &#123; &#125; public static Test04 getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; Test04 one = Test04.getInstance(); Test04 two = Test04.getInstance(); System.out.println(one == two); // true &#125;&#125; 但是由于instance是静态变量，静态变量在类被主动使用时就会被初始化，而不是等我们需要创建类的实例时才被初始化，简单的说就是创建的时机过早，从而降低内存的使用效率，我们使用静态内部类来解决按需加载的问题 public class Test05 &#123; private Test05() &#123; &#125; private static final class InnerTest &#123; private static Test05 instance = new Test05(); &#125; public static Test05 getInstance() &#123; return InnerTest.instance; &#125; public static void main(String[] args) &#123; Test05 one = Test05.getInstance(); Test05 two = Test05.getInstance(); System.out.println(one == two); //true &#125;&#125; 这个时候，只有我们需要用到类的实例时，才会初始化instance。 在上面5种实现单例模式的方法中： 第一种方法在多线程的环境下不能工作 第二种模式虽然能够在多线程的环境下工作，但是效率很低 第三种方法通过两次判断确保能够在多线程的情况下高效的工作 第四种方法在声明时就初始化，且只会被初始化一次，确保只创建一个实例 第五种方法利用内部类，做到只要在真正需要的时候才会创建实例，提高空间使用效率","tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JavaScript中的冒泡与捕获","date":"2020-03-16T16:00:00.000Z","path":"/JavaScript中的冒泡与捕获/","text":"JavaScript中的冒泡与捕获首先来看一个例子来明白什么是冒泡和捕获，来看下面的一个html结构 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .outer &#123; width: 200px; height: 200px; background-color: black; margin: 100px auto; &#125; .inner &#123; width: 100px; height: 100px; background-color: greenyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 就是一个大盒子里面套着一个小盒子，为两个盒子设置了背景颜色以作区分，如下 现在为二者都添加一个点击方法 &lt;script&gt; let outer = document.querySelector('.outer'); let inner = document.querySelector('.inner'); outer.addEventListener('click', (e) =&gt; &#123; console.log('outer被点击了'); &#125;); inner.addEventListener('click', (e) =&gt; &#123; console.log('inner被点击了'); &#125;);&lt;/script&gt; 现在如果点击里面的盒子inner，那么outer的点击事件会不会触发，因为按道理也算是点击了outer的区域，所以outer的点击事件应该被触发。现在问题又来了，是先触发inner还是先触发outer的点击事件呢? 按照二者触发顺序的不同分为捕获和冒泡。 现在点击绿色的小盒子，看看输出是什么 当我们点击里面的盒子即 inner 时，触发了它的点击事件，随后触发了 outer 的点击事件，这样触发子元素事件之后触发父元素事件的行为就叫做冒泡；捕获就是随之相反了，先处理 outer，然后处理 inner 的事件。 要实现捕获的效果，首先我们为 addEventListener 方法的第三个参数设置为 true，如下 outer.addEventListener('click', (e) =&gt; &#123; console.log('outer被点击了');&#125;, true);inner.addEventListener('click', (e) =&gt; &#123; console.log('inner被点击了');&#125;, true); 这时我们在点击里面的盒子 这时是outer的点击事件先被执行，然后是inner的点击事件被执行。 冒泡和捕获的出现是因为以前的两大浏览器厂商 Netscape 和 Microsoft 对事件模型处理方法，Microsoft 采取的从目标元素(比如点击 inner，inner 就是目标元素)开始，按 DOM 树向上冒泡；而 Netscape 采取的是相反的原则，即从顶部元素开始，直到事件目标元素。通过上面的例子可以知道，可以通过设置 addEventListener 方法的第三个参数可以设置是冒泡还是捕获，当设置为 true 时，是捕获，当设置为 false 时，是冒泡，默认是 false。 现在考虑一个比较复杂的 DOM 结构，如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .one &#123; width: 200px; height: 200px; background-color: black; margin: 100px auto; &#125; .two &#123; width: 150px; height: 150px; background-color: aliceblue; &#125; .three &#123; width: 100px; height: 100px; background-color: greenyellow; &#125; .four &#123; width: 50px; height: 50px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt; &lt;div class=\"three\"&gt; &lt;div class=\"four\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let one = document.querySelector('.one'); let two = document.querySelector('.two'); let three = document.querySelector('.three'); let four = document.querySelector('.four'); one.addEventListener('click', (e) =&gt; &#123; console.log('one被点击了'); &#125;, true); two.addEventListener('click', (e) =&gt; &#123; console.log('two被点击了'); &#125;, false); three.addEventListener('click', (e) =&gt; &#123; console.log('three被点击了'); &#125;, true); four.addEventListener('click', (e) =&gt; &#123; console.log('four被点击了'); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面四个盒子套在一起，我们为one和three设定为捕获模式，为two和four设定为冒泡模式，如果我们点击four，这时的输出会是什么呢? 我们观察到输出的顺序为one -&gt; three -&gt; four -&gt; two，代码是怎么执行的呢? 首先事件处理器会从顶部开始即 one(严格的说是从 window)，一直到目标元素，在这个路径中，如果遇到设置为捕获模式的则执行，碰到冒泡模式的则跳过，达到目标元素后，开始转换为冒泡模式，向上冒泡到one，在这个路径中，如果碰到设置为冒泡模式的则执行，否则跳过。 现在我们来看看上面的执行流程： 首先从one开始向下捕获，one设置为捕获模式，执行 遇到two，two设置为冒泡模式，不执行跳过 遇到three，three设置为捕获模式，执行 遇到four，到达目标元素，执行(此时不管four是冒泡还是捕获都没有关系，都会执行的) 接着转变为冒泡模式，遇到three，three为捕获模式，跳过 遇到two，two为冒泡模式，执行 遇到one，one为捕获模式，不执行，此时已经到达顶部，结束 通过上面的流程，不难知道输出的顺序为什么是one -&gt; three -&gt; four -&gt; two。 在父元素上代理事件我们来看一个运用冒泡的小例子，假设有这个一个DOM结构 &lt;ul&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt;&lt;/ul&gt; 我们希望当点击 li 标签时，将 li 标签里面的文字变为红色，所以很有可能你会写出这样的代码 document.querySelectorAll(\"ul li\").forEach(item =&gt; &#123; item.addEventListener('click', (e) =&gt; &#123; e.target.style.color = 'red'; &#125;)&#125;) 这样写当然能达到效果，但是如果 ul 下面有成千上万个 li，这样写未免性能太低，我们可以利用冒泡的特性，为 ul 绑定点击事件，如下 document.querySelector('ul').addEventListener('click', (e) =&gt; &#123; e.target.style.color = 'red';&#125;); 这样不管 ul 下面有多少个 li 都没有关系。 解释： 这里可能有人不太懂 e.target 是什么，e.target 是指触发点击事件的元素，而不是 ul，因为我们点击的是 li 标签，所以这里的 e.target 是被点击的 li 元素。如果想在 addEventListener 里面访问 ul 元素，可以使用 this。 阻止事件冒泡有的时候我们不希望事件有冒泡操作，我们可以通过 event 对象的 stopPropagation 方法来阻止事件冒泡，以文章开头的 inner 和 outer 为例(outer 和 inner 都设置为冒泡模式)，我们给 inner 的 addEventListener 修改为 inner.addEventListener('click', (e) =&gt; &#123; e.stopPropagation(); console.log('inner被点击了');&#125;); 这时我们点击inner，这时只有inner的点击事件被执行了","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JavaScript/"},{"name":"冒泡与捕获","slug":"冒泡与捕获","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7/"}]},{"title":"SSM整合","date":"2020-03-01T16:00:00.000Z","path":"/SSM整合/","text":"在学习完Spring, SpringMVC, MyBatis三大框架后，现在将记录如何整合这三个框架。 准备工作首先新建一个Maven工程，在pom.xml中导入以下包 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 接着创建一个User表 use mybatis;drop table if exists user;create table user(username varchar(20), age int, sex varchar(10)) character set utf8;insert into user values(\"张三\", 18, \"male\");insert into user values(\"李四\", 19, \"male\"); 此时的user表为 +----------+------+------+| username | age | sex |+----------+------+------+| 张三 | 18 | male || 李四 | 19 | male |+----------+------+------+ Spring整合Dao层首先在包com.pojo下新建实体类User如下 package com.pojo;public class User &#123; private String userName; private Integer age; private String sex; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + \", sex='\" + sex + '\\'' + '&#125;'; &#125;&#125; 接下来在com.dao包下新建UserDao接口，如下 package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 接下来在resources目录下新建MyBatis的配置文件mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.pojo\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 只是在其中配置了别名，数据源的配置会在Spring配置文件中配置，现在在resources下新建database.properties文件，如下 jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=root 最后新建spring-dao.xml文件，这是Spring整合MyBatis的配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 读取数据库信息 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 配置连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 扫描com.dao下的包 动态生成实现类注册到Spring中 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;property name=\"basePackage\" value=\"com.dao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在resources下新建applicationContext.xml配置文件，将spring-dao.xml导入，该文件是Spring的主配置文件，主要的功能就是导入配置文件，如spring-dao.xml, spring-service.xml以及spring-mvc.xml，如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"classpath:spring-dao.xml\"/&gt;&lt;/beans&gt; 现在便是在test/java下新建TestSpringDao测试类，来验证Spring是否整合了MyBatis，如下 import com.dao.UserDao;import com.pojo.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class TestSpringDao &#123; @Autowired private UserDao userDao; @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for (User user: users) &#123; System.out.println(user); &#125; &#125;&#125; 输出为 User&#123;userName='张三', age=18, sex='male'&#125;User&#123;userName='李四', age=19, sex='male'&#125; 可见Spring以及整合MyBatis成功了。 Spring整合Service层简单的模拟业务层，在com.service下新建UserService接口如下 package com.com.service;import com.pojo.User;import java.util.List;public interface UserService &#123; List&lt;User&gt; findAll();&#125; 接着建立它的实现类UserServiceImpl，如下 package com.com.service;import com.dao.UserDao;import com.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125;&#125; 接着新建spring-service.xml，如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.service\"/&gt;&lt;/beans&gt; 在applicationContext.xml中导入该配置文件 &lt;import resource=\"classpath:spring-service.xml\"/&gt; 接着新建TestSpringService测试类 import com.pojo.User;import com.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class TestSpringService &#123; @Autowired private UserService userService; @Test public void testUserService() &#123; List&lt;User&gt; users = userService.findAll(); for (User user: users) &#123; System.out.println(user); &#125; &#125;&#125; 输出为 User&#123;userName='张三', age=18, sex='male'&#125;User&#123;userName='李四', age=19, sex='male'&#125; Spring Service层整合成功。 Spring整合Controller层首先点击项目，右键选择Add Framework Support…，并选择Web Application 这时的项目就成为了一个Web项目，我们在web.xml中配置如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在resources下新建spring-mvc.xml，内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;context:component-scan base-package=\"com.controller\"/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 并且在applicationContext.xml中导入该配置文件 &lt;import resource=\"classpath:spring-mvc.xml\"/&gt; 在com.controller包下新建UserController类，如下 package com.controller;import com.pojo.User;import com.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping(value = \"/users\", produces = \"text/html;charset=utf-8\") public String getUsers() &#123; List&lt;User&gt; users = userService.findAll(); return users.toString(); &#125;&#125; 接着启动Tomcat(在启动Tomcat之前记得添加依赖的包)，在地址栏后输入/users 至此，SSM整合结束。","tags":[{"name":"SSM Spring SpringMVC MyBatis","slug":"SSM-Spring-SpringMVC-MyBatis","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/SSM-Spring-SpringMVC-MyBatis/"}]},{"title":"Spring MVC笔记","date":"2020-02-29T16:00:00.000Z","path":"/Spring MVC笔记/","text":"本片文章是我记录学习 Spring MVC 的学习笔记，作为初学者，对于这个框架的理解可能并不深刻，所以这篇文章主要讲述的是 Spring MVC 框架的使用，所以对于有些内容为什么要这么做，这么做有什么好处，由于才疏学浅，却不是我能解释的，所以本篇文章以代码偏多，文字解释偏少。 Hello Spring MVC先简单的的把 Spring MVC 用起来，然后在解释一下 Spring MVC 的用法。首先在 pom.xml 中导入需要的包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-webmvc 就是我们需要的包，而 junit 不用说，是用来测试用的。Java 底层对浏览器做出响应是基于 Servlet，所以 Spring MVC 也是基于 Servlet 的，所以我们还导入了 Servlet 的包，以及对 JSP 的支持和 JSTL 语言的支持的包。 由于我们建立的只是一个普通的 Maven 工程，我们要对项目添加支持，使其成为一个 Web 项目，单击项目右键选择 Add Framework Support...，如下 接着勾选 WebApplication，点击 OK 这时会在你的项目中为你生成一个 web 目录，如下 这时我们配置 web.xml 如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 我们知道 JavaWeb 的工作流程是根据浏览器的请求地址去找对应的 Servlet 去做处理，这里我们配置对所有的请求(/)都会使用 Spring 提供的 DispatchServlet 进行处理。具体的处理流程稍后会介绍，从上面的配置看出，DispatchServlet 还需要一个配置文件地址的参数，这里我们写为了 classpath:springmvc-config.xml，而这个文件还没有，所以我们在 src/main/resources 中新建 springmvc-config.xml，内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;context:component-scan base-package=\"com.controller\"/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 我们在这个配置文件中对 com.controller 中的类开启了 mvc 注解支持。还配置了一个 ServletHandler 和 ViewResolver，这两个东西与后面讲的 Spring MVC 执行流程有关，后面再说。 现在新建 com.controller.HandleRequest.java，内容如下 package com.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HandleRequest &#123; @RequestMapping(\"/hello\") public String sayHello() &#123; return \"Hello Spring MVC\"; &#125;&#125; 该类的作用是当浏览器访问 /hello 时，会返回浏览器一个字符串 &quot;Hello Spring MVC&quot;，现在使用 tomcat 服务器启动该项目，并且在地址栏后输入 /hello，这时我们会得到一个错误如下 这是因为我们没有在项目中加入所依赖的包，这时我们在 IDEA 中的左上角找到 File 并点击，选择 Project Structure，接着在 Project Structure 中选择 Artifacts 这时选择你的项目，比如我的是 mvc-hello，右键选择 Put into Output Root 接下来重新启动 Tomcat，然后在浏览器地址栏后输入 /hello 就可以看到 Hello Spring MVC 在浏览器上显示了出来。 Spring MVC的执行流程 上图演示了 Spring MVC 执行的流程，在这里稍作解释 用户发送请求至前端控制器 DispatcherServlet DispatcherServlet 收到请求调用处理器映射器 HandlerMapping 处理器映射器根据请求 url 找到具体的处理器，生成处理器执行链 HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给 DispatcherServlet。 DispatcherServlet 根据处理器 Handler 获取处理器适配器 HandlerAdapter，执行 HandlerAdapter 处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作 执行处理器 Handler(Controller，也叫页面控制器) Handler 执行完成返回 ModelAndView HandlerAdapter 将 Handler 执行结果 ModelAndView 返回到 DispatcherServlet DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器 ViewReslover 解析后返回具体 View DispatcherServlet 对 View 进行渲染视图(即将模型数据 model 填充至视图中) DispatcherServlet 响应用户 现在稍加解释上面牵涉到的组件： DispatcherServlet：前端控制器，用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性,系统扩展性提高 HandlerMapping：处理器映射器，HandlerMapping 负责根据用户请求的 url 找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml 配置方式，实现接口方式，注解方式等 Handler：处理器，Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler HandlAdapter：处理器适配器,通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行 ModelAndView 是 SpringMVC 的封装对象，将 Model 和 View 封装在一起。 ViewResolver：视图解析器，ViewResolver 负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 View：是 SpringMVC 的封装对象，是一个接口, SpringMVC 框架提供了很多的 View 视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 Spring MVC注解@Controller@Controller 注解表明了一个类是作为控制器的角色而存在的。Spring 不要求你去继承任何控制器基类，也不要求你去实现 Servlet 的那套 API。当然，如果你需要的话也可以去使用任何与 Servlet 相关的特性和设施。 @Controller 注解可以认为是被标注类的原型(stereotype)，表明了这个类所承担的角色。分派器(DispatcherServlet)会扫描所有注解了 @Controller 的类，检测其中通过 @RequestMapping 注解配置的方法(详见下一小节)。 当然，你也可以不使用 @Controller 注解而显式地去定义被注解的 bean，这点通过标准的 Spring bean 的定义方式，在 dispather 的上下文属性下配置即可做到。但是 @Controller 原型是可以被框架自动检测的，Spring 支持 classpath 路径下组件类的自动检测，以及对已定义 bean 的自动注册。 @RestController这里说的是与 @Controller，被 @Controller 注解的类，如果在方法中方法字符串，则会被视图解析器解析，即如下 package com.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HandleRequest &#123; @RequestMapping(\"/hello\") public String sayHello() &#123; return \"hello\"; &#125;&#125; 当访问 /hello 时，会执行 sayHello 方法，这时返回的 hello 会被视图解析器解析，视图解析器会根据在 springmvc-config.xml 中的配置进行拼接 &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 所以上面方法的 hello 会被拼接成 WEB-INF/jsp/hello.jsp，接着会返回该 jsp 页面。 而使用 @RestController 注解，则不会经过视图解析器，而是会将该结果直接返回，就像在前一节演示的例子一样。因为最近流行前后端分离，所以后端不需要写页面了，只需要将前端请求的数据返回，而前端负责渲染展示数据，所以 @RestController 类用的还是比较多的。 @RequestMapping你可以使用 @RequestMapping 注解来将请求 URL，如 /appointments 等，映射到整个类上或某个特定的处理器方法上。一般来说，类级别的注解负责将一个特定(或符合某种模式)的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的 HTTP 请求方法（&quot;GET&quot; &quot;POST&quot;方法等）、HTTP 请求中是否携带特定参数等条件，将请求映射到匹配的方法上。 现在来讲一下 @RequestMapping 中的属性，@RequestMapping 的源码如下 public @interface RequestMapping &#123; String name() default \"\"; @AliasFor(\"path\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] path() default &#123;&#125;; RequestMethod[] method() default &#123;&#125;; String[] params() default &#123;&#125;; String[] headers() default &#123;&#125;; String[] consumes() default &#123;&#125;; String[] produces() default &#123;&#125;;&#125; name, value, path：是用来设置匹配的 url 路径的 method：指定请求的 method 类型, GET、POST、PUT、DELETE 等 consumes：指定处理请求的提交内容类型(Content-Type)，例如 application/json, text/html produces：指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回 params：指定 request 中必须包含某些参数值时，才让该方法处理 headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求 给个例子： @RequestMapping(value=\"/hello\", method = RequestMethod.GET, params = \"myParam=myValue\", headers=\"Referer=www.baidu.com\", consumes=\"application/json\", produces=\"application/json\") 除了可以使用 method 属性指定请求办法外，还可以使用注解： @GetMapping(&quot;/hello&quot;) @PostMapping(&quot;/hello&quot;) ...... 这些注解与 RequestMapping 具有相同的属性，除了 method 属性。 @RequestParam该注解类型用于将指定的请求参数赋值给方法中的形参，那么 @RequestParam 注解有什么属性呢? 它有 4 种属性，下面将逐一介绍这四种属性： name 属性：该属性的类型是 String 类型，它可以指定请求头绑定的名称 value 属性：该属性的类型是 String 类型，它可以设置是 name 属性的别名 required 属性：该属性的类型是 boolean 类型，它可以设置指定参数是否必须绑定 defalutValue 属性：该属性的类型是 String 类型，它可以设置如果没有传递参数可以使用默认值 @RequestMapping(value=\"/hello\")public String hello( @RequestParam(\"loginname\") String loginname, @RequestParam(\"password\") String password) &#123; return \"hello\";&#125; @PathVaribale@PathVaribale 注解，该注解类型可以非常方便的获得请求 url 中的动态参数。@PathVaribale 注解只支持一个属性 value，类型 String，表示绑定的名称，如果省略则默认绑定同名参数 @RequestMapping(value=\"/pathVariableTest/&#123;userId&#125;\")public void pathVariableTest(@PathVaribale Integer userId) @CookieValue绑定 cookie 的值到 Controller 方法参数 @RequestMapping ( \"/hello\" )public String testCookieValue( @CookieValue(\"hello\") String cookieValue) &#123; return \"cookieValue\" ;&#125; @RequestHeader@RequestHeader 注解，该注解类型用于将请求的头的信息区域数据映射到功能处理方法的参数上。那么@RequestHeader 注解有什么属性呢? 它和 @RequestParam 注解一样，也有 4 种属性，分别如下 name 属性：该属性的类型是 String 类型，它可以指定请求头绑定的名称 value 属性：该属性的类型是 String 类型，它可以设置是 name 属性的别名 required 属性：该属性的类型是 boolean 类型，它可以设置指定参数是否必须绑定 defalutValue 属性：该属性的类型是 String 类型，它可以设置如果没有传递参数可以使用默认值 @RequestMapping(value=\"/requestHeaderTest\")public void requestHeaderTest( @RequestHeader(\"User-Agent\") String userAgent, @RequestHeader(value=\"Accept\") String[] accepts) &#123;&#125; @RequestBody@RequestBody 注解是将 HTTP 请求正文插入方法中 @RequestMapping(value = \"/login\")public String login(@RequestBody Person person) &#123; return \"...\"; &#125; @RequestBody 注解常用来处理 Content-type 不是默认的 application/x-www-form-urlcoded 编码的内容，比如说：application/json 或者是 application/xml 等。一般情况下来说常用其来处理 application/json 类型。 对于前端使用而言，form 表单的 enctype 属性为编码方式，常用有两种：application/x-www-form-urlencoded 和 multipart/form-data，默认为 application/x-www-form-urlencoded，所以在前端传输数据时，需要将 Content-type 显示指定为 application/json。 总结： ReuqestBody 主要是处理 json 串格式的请求参数，要求使用方指定 header Content-type:application/json RequestBody 通常要求调用方使用 post 请求 @ResponseBody@ResponseBody 注解的作用是将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 response 对象的 body 区，通常用来返回 JSON 数据或者是 XML 数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，它的效果等同于通过 response 对象输出指定格式的数据。 @RequestMapping(\"/login\")@ResponseBodypublic User login(User user)&#123; //User字段：userName pwd //那么在前台接收到的数据为：'&#123;\"userName\":\"xxx\",\"pwd\":\"xxx\"&#125;' return user;&#125;//效果等同于如下代码：@RequestMapping(\"/login\")public void login(User user, HttpServletResponse response)&#123; response.getWriter.write(JSONObject.fromObject(user).toString()); &#125;&#125; 参考资料 SpringMVC执行流程及工作原理 RequestMapping 属性解释 Spring之RequestBody的使用姿势小结 @responseBody注解的使用","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/SpringMVC/"}]},{"title":"Hexo中数学公式问题","date":"2020-02-29T04:23:42.000Z","path":"/hexo博客中的数学问题/","text":"起因之前我的 Hexo 主题使用的是 Next 主题，Next 主题因为对数学公式有进行处理，所以在用 Next 主题时写数学公式是十分的顺畅的，但是最近觉得Next主题颜色太淡了，所以就换了一个颜色比较鲜艳的 Hexo 主题，但是这一换，数学公式就有了麻烦。 首先我们要明白这个麻烦是怎么产生的，因为 markdown 的语法跟 mathjax 有重叠，比如 _ 在 mathjax 中表示下标，但是在 markdown 中，被两个下划线 _ 包裹起来的内容会被转为 &lt;em&gt; 标签，即其间的内容会被转为斜体，这就使得数学公式渲染不出来；另一个就是 \\\\ 在 mathjax 表示换行，但是在解析 markdown 时却会被转义。 解决这个时候我就去网上搜了解决办法，有好几种，比如第一种是修改 marked.js(node_modules/marked/lib/marked.js)，修改两个关键字为 excape 和 em 的正则表达式，这个方法我试了，但是没有用；第二个办法是卸载 hexo 默认的 markdown 解析 hexo-renderer-marked，然后安装 hexo-renderer-pandoc(好像 Next 就是这么干的)，前提是要安装 Pandoc，然后由于我的 npm 不知道出了什么原因，不能 uninstall，只能寻求它法。(不过你们可以尝试，解决办法链接在这) 不过功夫不负有心人，经过几个小时折腾，还是被我找到了解决办法，我在hexo的issue中看到，将有问题的数学公式如下处理： 这样数学公式就不会被 marked 解析，但是会被 mathjax 解析。 上面的做法可以解决大部分的问题，但是我们数学公式里面包含一对 &lt;&gt; 的话，又会出现问题，通过 F12 检查元素，发现被 &lt;&gt; 包裹的内容被误认为是标签了，导致渲染不出来，要解决这个办法，把公式中所有的 &lt; 使用 \\lt 替代，所有的 &gt; 使用 \\gt 替代，这样就可以了。 Hexo 的数学公式真的是折腾的我够呛，所以这次经历必须记录下来，为了下次遇到同样问题时能够迅速解决。 参考资料 关于数学公式的渲染问题 Hexo下mathjax转义问题","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Hexo/"}]},{"title":"Spring笔记","date":"2020-02-26T16:00:00.000Z","path":"/Spring笔记/","text":"概述Spring是一个什么东西? 简单的理解就是一个容器。既然是容器，那就是装东西的，装什么的呢? 里面装的都是对象。以前对象都是由我们自己管理，比如我们在User类中使用Student对象，那么我们会直接new，比如 // User.javaStudent student = new Student(); 那如果使用Spring的话，会将Student对象放在Spring容器中，如果在User类中使用Student对象，那么就向Spring容器要。我们把这个称之为IOC(控制反转)，即控制权由程序员交给了Spring容器。 所以接下来就要讲如何将对象交给Spring容器，或者说Spring容器如何创建对象，主要是在创建对象时如何为对象里面的成员变量注入值。 入门首先新建一个Maven工程，在pom.xml中导入依赖。说实话Spring框架是一个大家族，它有非常多的包，这里我们导入spring-webmvc，该包依赖了很多其他Spring的包，这样我们需要的包都会被导入，所以我们只要导入这一个包就可以，如下 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在src/main/java下新建pojo.Hello.java，如下 package pojo;public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Hello&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 现在我们要将这个Hello对象交给Spring，首先在resources下新建Spring的配置文件beans.xml(名字随便，官方名字是applicationContext.xml)，内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hello\" class=\"pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Hello\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 其中 &lt;bean id=\"hello\" class=\"pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Hello\"/&gt;&lt;/bean&gt; 就是在Spring容器中注册Hello，其中id是我们向Spring容器获取Hello对象用的，class是Hello类的全限定类名。在bean标签中的peoperty标签的作用是设置在创建Hello对象时其成员变量的值。上面设置为成员变量name注入值Hello。 现在在test/java下新建TestHello.java，内容如下 import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Hello;public class TestHello &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Hello hello = (Hello) applicationContext.getBean(\"hello\"); System.out.println(hello); &#125;&#125; 运行结果为 Hello&#123;name='Hello'&#125; 其中 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); 是根据配置文件beans.xml得到Spring容器，接着我们根据在beans,xml中配置的id获取Hello对象 Hello hello = (Hello) applicationContext.getBean(\"hello\"); 接着我们打印出Hello对象，发现这个对象的成员变量name已经有值Hello，这是我们在beans.xml中注入的。 IOC创建对象IOC创建对象的过程，其实关键就是向对象的成员变量注入值，我们把这个东西叫做装配，而接下来就是介绍如何为成员变量注入值。 构造器注入第一种方法就是通过构造函数注入(初始化)，上面那个例子IOC在创建对象时是调用的是无参构造函数，所以上面那个例子的装配不是通过构造函数装配的，为了演示构造函数装配，首先新建一个User类 package pojo;public class User &#123; private String userName; private int age; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 接着在beans.xml注册该类(就是将它交给Spring容器)，如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"奥特曼\"/&gt; &lt;constructor-arg index=\"1\" value=\"1\"/&gt;&lt;/bean&gt; 其中constructor-arg标签就是通过构造函数注入值，这里是通过参数的位置注入值的，比如为第一个参数即index = 0的位置注入”奥特曼”，为第二个参数即index = 1的位置注入1。 接着我们可以在test/java中新建TestUser类，内容如下 import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.User;public class TestUser &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); System.out.println(user); &#125;&#125; 上面的代码想必无需解释，上面的结果为 User&#123;userName='奥特曼', age=1&#125; 可见是注入成功了。 通过构造器注入，还有两种方法，比如通过类型注入，修改上面的constructor-arg标签如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"奥特曼\"/&gt; &lt;constructor-arg type=\"int\" value=\"1\"/&gt;&lt;/bean&gt; 上面的配置就是根据构造函数参数类型进行配置，再次运行代码，得到的结果还是一样的。 注意: 如果有多个成员变量的类型是相同的，那么此方法就不适用了。 最后一种就是根据成员变量的名字进行配置，如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg name=\"userName\" value=\"奥特曼\"/&gt; &lt;constructor-arg name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; set方法注入set方法注入就是指通过无参构造函数创建对象以后，通过set方法将值注入到成员变量中，所以使用该方法注入就需要为每个成员变量写set方法，修改上面的User类如下 package pojo;public class User &#123; private String userName; private int age; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 现在在beans.xml中进行配置如下 &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;property name=\"userName\" value=\"奥特曼\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; 我们通过property标签向对象注入值，这是通过成员变量的名字进行配置的。 其它配置方法p命名空间注入要使用p命名空间，就得导入约束，修改beans.xml的约束 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- ... ... --&gt;&lt;/beans&gt; 所谓p命名空间注入与set方法注入是相同的，只不过写法不同，写法如下 &lt;bean id=\"user\" class=\"pojo.User\" p:userName=\"奥特曼\" p:age=\"1\"/&gt; c命名空间注入要使用c命名空间同样要导入约束，再次修改beans.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- ... ... --&gt;&lt;/beans&gt; c命名空间注入与构造函数注入是相同的，写法同p命名空间注入，如下 &lt;bean id=\"user\" class=\"pojo.User\" c:userName=\"奥特曼\" c:age=\"1\"/&gt; 或者 &lt;bean id=\"user\" class=\"pojo.User\" c:_0=\"奥特曼\" c:_1=\"1\"/&gt; 上面的0和1代表的是构造函数中参数的位置。 各种类型成员变量的注入这里以set的方式讲解怎么注入各种类型成员变量，比如复杂类型，数组，List等集合，首先新建一个Student类如下 package pojo;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Student &#123; private String name; private Address address; private String[] hobbies; private List&lt;String&gt; games; private Set&lt;String&gt; toys; private Map&lt;String, Integer&gt; scores; private String wife; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getHobbies() &#123; return hobbies; &#125; public void setHobbies(String[] hobbies) &#123; this.hobbies = hobbies; &#125; public List&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(List&lt;String&gt; games) &#123; this.games = games; &#125; public Set&lt;String&gt; getToys() &#123; return toys; &#125; public void setToys(Set&lt;String&gt; toys) &#123; this.toys = toys; &#125; public Map&lt;String, Integer&gt; getScores() &#123; return scores; &#125; public void setScores(Map&lt;String, Integer&gt; scores) &#123; this.scores = scores; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address + \", hobbies=\" + Arrays.toString(hobbies) + \", games=\" + games + \", toys=\" + toys + \", scores=\" + scores + \", wife='\" + wife + '\\'' + '&#125;'; &#125;&#125; 上面的成员变量类型有String，复杂类型Address，数组，List, Map, Set集合，以及最后一个String类型的wife，我们将通过wife演示如果注入null。因为这里用到了复杂类型Address，所以新建类Address如下 package pojo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; 将Address注册到Spring容器中，在beans.xml中添加如下 &lt;bean id=\"address\" class=\"pojo.Address\"&gt; &lt;property name=\"address\" value=\"China\"/&gt;&lt;/bean&gt; 现在直接演示如果为Student中的成员变量注入 &lt;bean id=\"student\" class=\"pojo.Student\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"address\" ref=\"address\"/&gt; &lt;property name=\"hobbies\"&gt; &lt;array&gt; &lt;value&gt;打球&lt;/value&gt; &lt;value&gt;游泳&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;list&gt; &lt;value&gt;王者荣耀&lt;/value&gt; &lt;value&gt;吃鸡&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"toys\"&gt; &lt;set&gt; &lt;value&gt;飞机&lt;/value&gt; &lt;value&gt;大炮&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"scores\"&gt; &lt;map&gt; &lt;entry key=\"math\" value=\"20\"&gt;&lt;/entry&gt; &lt;entry key=\"english\" value=\"50\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt;&lt;/bean&gt; 对于Address复杂类型，我们使用ref属性引用已经在Spring中注册过的类，其值就是它注册时的id。剩下的应该很容易看懂，就不解释了。 Spring配置 标签 作用 alias 别名 bean 向Spring容器注册类 import 导入其它配置文件 Bean的作用域bean标签有一个scope属性，可以设置作用域，这里只介绍两种取值 singleton：单例模式，从Spring容器中得到的对象是同一对象，默认值 prototype：原型模式，从Spring容器中得到的对象是不同对象 &lt;bean id=\"user\" class=\"pojo.User\" c:userName=\"奥特曼\" c:age=\"1\" scope=\"singleton\"/&gt; 比如在TestUser中修改如下 import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.User;public class TestUser &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); // 第二个参数传了User.class就不用强转了 User user2 = applicationContext.getBean(\"user\", User.class); System.out.println(user == user2); // true &#125;&#125; 现在修改scope为prototype，再次运行打印出的结果就是false了。 自动装配Bean首先准备几个类，新建Man.java package com.pojo;public class Man &#123; private Dog dog; private Cat cat; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125;&#125; 其中Man有两个宠物，一个为Cat，一个为Dog，新建这两个类 package com.pojo;public class Cat &#123; public void shout() &#123; System.out.println(\"miao\"); &#125;&#125; package com.pojo;public class Dog &#123; public void shout() &#123; System.out.println(\"wang\"); &#125;&#125; 在beans.xml中注册Dog和Cat &lt;bean id=\"cat\" class=\"com.pojo.Cat\"/&gt;&lt;bean id=\"dog\" class=\"com.pojo.Dog\"/&gt; 现在考虑怎么向Man中注入Cat和Dog。 按名字自动注入在beans.xml添加如下 &lt;bean id=\"man\" class=\"com.pojo.Man\" autowire=\"byName\"/&gt; autowire就是用来设置自动注入的，这里设置为按名字自动注入(byName)。它会在Spring容器寻找到id与setXxx中Xxx名字相同的类注入，比如在Man中有setDog()方法，它会在Spring容器中找到id为dog的类(在Spring中注册的类，一般都称为bean)自动为它注入。 按类型注入修改Man的bean为 &lt;bean id=\"man\" class=\"com.pojo.Man\" autowire=\"byType\"/&gt; 这时会在Spring容器中寻找类型为Dog和Cat的bean为Man中的Dog和Cat自动注入，但是如果Spring容器中有多个类型相同的bean，那么就不能注入，比如我们向Spring容器中在注入一个Dog如下 &lt;bean id=\"dog2\" class=\"com.pojo.Dog\"/&gt; 这时我们发现在beans.xml中报错了 使用注解注入使用@AutoWired注解在成员变量上，会在Spring容器找到符合条件的，自动注入，首先在beans.xml中注册Man类 &lt;bean id=\"man\" class=\"com.pojo.Man\"/&gt; 在Man.java中为成员变量加上注解 @Autowiredprivate Dog dog;@Autowiredprivate Cat cat; 这时还是不行的，因为要在beans.xml中开启注解支持，首先导入约束，修改约束如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- ... ... --&gt;&lt;/beans&gt; 接着开启注解支持，在beans.xml中添加如下 &lt;context:annotation-config/&gt; @AutoWired注解首先通过byType即类型寻找符合条件的bean，如果找到多个类型相同的bean符合条件，那么接着在这些bean中byName寻找符合条件的。 我们可以给成员变量加上@Qualifier注解，这样就会按照@Qualifier规定的name取寻找符合条件的bean。 @Autowired@Qualifier(\"dog\")private Dog dog;@Autowired@Qualifier(\"cat\")private Cat cat; @AutoWired也可以在setXxx方法上使用，并且如果在成员变量上使用，则可以不写setter方法了。 除了使用@AutoWired注解，我们还可以使用@Resource注解，这个注解不是Spring的，是J2EE的，我们修改注解如下 @Resourceprivate Dog dog;@Resourceprivate Cat cat; @Resource是默认byName去寻找符合条件的bean的，如果找不到则byType。 Spring注解开发要使用注解，首先导入约束(在上面演示过了)，并且开启注解支持，最后设置要扫描的包(即哪些包下的类是使用注解的)，beans.xml的内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.pojo\"/&gt;&lt;/beans&gt; 在上面定义扫描com.pojo下的包，首先新建Student类和Address类 package com.pojo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;public class Student &#123; private String name; private Address address; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address + '&#125;'; &#125;&#125; package com.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;public class Address &#123; private String address; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; @Component接下来本应该是在beans.xml中注册，但是这次我们不使用xml配置了，而是使用注解，要向Spring容器中注册，我们只需要在类上面加入@Component注解，而注入则可以使用我们在上面介绍的@AutoWired，如下 package com.pojo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Student &#123; @Value(\"Alice\") private String name; @Autowired private Address address; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address + '&#125;'; &#125;&#125; package com.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Address &#123; @Value(\"American\") private String address; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; 其中@Value注解是向其中注入普通值的，如String，int等等，对于一些其他一些复杂类型，如数组，集合等，建议使用xml配置，更清晰。 接下来在test/java/TestStudent.java中进行测试 import com.pojo.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestStudent &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = applicationContext.getBean(\"student\", Student.class); System.out.println(student); &#125;&#125; 输出为 Student&#123;name='Alice', address=Address&#123;address='American'&#125;&#125; @Component衍生的注解:下面介绍@Component衍生的注解，这些注解的作用与@Component相同，只不过语义不同，如 @Controller：使用在Web层(servlet) @Service：使用在业务层(service) @Repository：使用在持久层(dao) 这些注解的功能相同，就是将类配置在Spring容器中。 @Scope@Scope是用来设置bean的范围的，上面我们介绍过两种取值，一种是singleton，另一种是prototype，如 @Component@Scope(\"singleton\") 通过JavaConfig实现配置新建工程并新建一个User类，如下 package com.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; @Value(\"biu\") private String name; @Value(\"1\") private int age; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 这其中的内容都不洗解释了。之前我们的配置都是通过xml文件配置的，这次我们将彻底不需要xml文件，而是通过Java类来进行配置，在com.config包下新建JavaConfig.java，内容如下 package com.config;import com.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.pojo\")public class JavaConfig &#123; @Bean public User getUser() &#123; return new User(); &#125;&#125; 在此类中我们使用了一个@Configuration注解，代表这是一个配置类。@ComponentScan定义了扫描包的范围。@Bean注解就是相当于bean标签，其方法名就相当于是id，返回值类型就是class。 接在我们在test/java/TestUser中进行使用如下 import com.config.JavaConfig;import com.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestUser &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class); User user = applicationContext.getBean(\"getUser\", User.class); System.out.println(user); &#125;&#125; 输出为 User&#123;name='biu', age=1&#125; 我们可以通过@Bean注解来设置id，比如上面JavaConfig中的@Bean修改如下 @Bean(\"user\") 那么我们就可以通过”user”去Spring容器中拿User对象 User user = applicationContext.getBean(\"user\", User.class); 注意: 这时不能通过方法名获得对象了。 AOP现在假设有这么一个需求，有下面这么一个dao类，如下 package com.dao;public class UserDao &#123; public void add() &#123; System.out.println(\"add\"); &#125; public void update() &#123; System.out.println(\"update\"); &#125; public void query() &#123; System.out.println(\"query\"); &#125; public void delete() &#123; System.out.println(\"delete\"); &#125;&#125; 我们希望每次在调用该类的方法的前后都打印出日志，我们当然不能在UserDao类中的每个方法中手动打印，如 public void add() &#123; System.out.println(\"add方法执行前\"); System.out.println(\"add\"); System.out.println(\"add方法执行后\");&#125; 这样将日志的代码与业务的代码揉在一起，不好；另一个对于每个方法都要写这样的代码，又累又low。 AOP概念Spring框架自诞生之日就拯救我等程序员于水火之中，它有两大法宝，一个是IoC控制反转，另一个便是AOP面向切面编程。AOP全名Aspect-oriented programming面向切面编程。 切面(Aspect)切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 目标对象(Target)目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。 连接点(JoinPoint)程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定： 方法(表示程序执行点，即在哪个目标方法) 相对点(表示方位，即目标方法的什么位置，比如调用前，后等) 简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。 切入点(PointCut)切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。 一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。 通知(Advice)通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。 织入(Weaving)织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。 增强器(Adviser)Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。 Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。 Spring AOP我们将使用AOP来实现上面的需求，要使用AOP，首先要导入一个包aspectj，如下 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 两个日志类分别表示在方法执行之前和执行之后 package com.log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class LogBefore implements MethodBeforeAdvice &#123; public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(\"在\" + method.getName() + \"之前执行\"); &#125;&#125; package com.log;import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class LogAfter implements AfterReturningAdvice &#123; public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123; System.out.println(\"在\" + method.getName() + \"执行后， 返回值为\" + o); &#125;&#125; 接着在beans.xml中注册这三个类，为了使用AOP，我们要导入约束，beans.xml全部内容如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.dao.UserDao\"/&gt; &lt;bean id=\"beforeLog\" class=\"com.log.LogBefore\"/&gt; &lt;bean id=\"afterLog\" class=\"com.log.LogAfter\"/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.dao.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"beforeLog\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 现在在TestUserDao中进行测试 import com.dao.UserDao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestUserDao &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserDao userDao = applicationContext.getBean(\"userDao\", UserDao.class); userDao.add(); &#125;&#125; 输出为 在add之前执行add在add执行后， 返回值为null 自定义类 AOP现在我们将使用另一种用法实现上面的效果，这次我们新建一个Log类，如下 package com.log;public class Log &#123; public void before() &#123; System.out.println(\"before\"); &#125; public void after() &#123; System.out.println(\"after\"); &#125;&#125; 修改beans.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.dao.UserDao\"/&gt; &lt;bean id=\"log\" class=\"com.log.Log\"/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"log\"&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.dao.*.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 再次运行TestUserDao类，输出为 beforeaddafter 注解 AOP修改beans.xml为 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com\"/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 修改Log.java为 package com.log;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Aspect@Componentpublic class Log &#123; @Before(\"execution(* com.dao.*.*(..))\") public void before() &#123; System.out.println(\"before\"); &#125; @After(\"execution(* com.dao.*.*(..))\") public void after() &#123; System.out.println(\"after\"); &#125;&#125; UserDao.java package com.dao;import org.springframework.stereotype.Component;@Componentpublic class UserDao &#123; public void add() &#123; System.out.println(\"add\"); &#125; public void update() &#123; System.out.println(\"update\"); &#125; public void query() &#123; System.out.println(\"query\"); &#125; public void delete() &#123; System.out.println(\"delete\"); &#125;&#125; 再次运行TestUserDao，输出如下 beforeaddafter","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Spring/"}]},{"title":"MyBatis学习笔记","date":"2020-02-13T16:00:00.000Z","path":"/MyBatis学习笔记/","text":"MyBatis入门新建Maven工程，在其中引入所需要的包，如mybatis, mysql-connector-java, junit。配置pom.xml如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;xt.mybatis&lt;/groupId&gt; &lt;artifactId&gt;simple&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在MySQL中新建一个mybatis的库 CREATE DATABASE mybatis; 然后使用该数据库并建一个book表 USE mybatis;CREATE TABLE BOOK(ID INT AUTO_INCREMENT PRIMARY KEY,NAME VARCHAR(20),NUMBER int );insert into BOOK(NAME,NUMBER) VALUES('Java程序设计',10),('数据结构',10),('设计模式',10); 如果出现由于中文不能插入的问题，输入以下语句然后插入数据 alter table mybatis change name name varchar(20) character set utf8; 在src/java中新建包com.xt.entity，新建Book实体类，实体类是用来保存数据库中查询到的结果，在这里实体类的属性要保持和数据库中的列名一致(后续会讲解不一致会出现什么以及解决办法) package com.xt.entity;public class Book &#123; private int id; private String name; private int number; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; @Override public String toString() &#123; return \"Book&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", number=\" + number + '&#125;'; &#125;&#125; 在src/java中新建包com.xt.dao，新建一个接口BookDao package com.xt.dao;import com.xt.entity.Book;import java.util.List;public interface BookDao &#123; public List&lt;Book&gt; findAll();&#125; 在src/resources下新建mybatis-config.xml文件配置如下 &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/xt/dao/bookDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis-config.xml是mybatis的配置文件，我们在其中配置数据源，连接数据库的驱动，连接哪个数据库，以及用户和密码。 在src/resources下新建目录结构com/xt/dao，在dao文件夹中新建BookDao.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xt.mapper.BookMapper\"&gt; &lt;select id=\"findAll\" resultType=\"com.xt.entity.Book\"&gt; select * from book &lt;/select&gt;&lt;/mapper&gt; 在test/java下新建类MyBatisTest import com.xt.mapper.BookDao;import com.xt.entity.Book;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.*;import java.util.List;public class BookMapperTest &#123; @Test public void testFindAll() &#123; SqlSession sqlSession = null; SqlSessionFactory sqlSessionFactory = null; InputStream is = null; try &#123; String resource = \"mybatis-config.xml\"; is = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); sqlSession = sqlSessionFactory.openSession(); BookMapper bookMapper = sqlSession.getMapper(BookMapper.class); List&lt;Book&gt; list = bookMapper.findAll(); System.out.println(list); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 输出为 [Book&#123;id=1, name='Java程序设计', number=10&#125;, Book&#123;id=2, name='数据结构', number=10&#125;, Book&#123;id=3, name='设计模式', number=10&#125;] 如果能够顺利输出以上数据，说明配置没有问题了。 MyBatis的CRUD保存操作在BookDao中添加方法saveBook(Book book) void saveBook(Book book); 然后在BookDao.xml中添加下面的语句 &lt;insert id=\"saveBook\" parameterType=\"com.xt.entity.Book\"&gt; insert into book(name, number) values (#&#123;Book.name&#125;, #&#123;Book.number&#125;);&lt;/insert&gt; 上面的parameterType说明该方法传入的参数类型，需要写全类名。我们在下面一行sql语句中使用了传入Book对象的属性 #&#123;Book.name&#125;, #&#123;Book.number&#125; 由于已经指定了传入的是Book类，所以Book.可以不写，即 &lt;insert id=\"saveBook\" parameterType=\"com.xt.entity.Book\"&gt; insert into book(name, number) values (#&#123;name&#125;, #&#123;number&#125;);&lt;/insert&gt; 接在在test/java下的测试类MybatisTest.java，加入下面的代码 private SqlSession sqlSession;private BookDao bookDao;@Beforepublic void init() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\"mybatis-config.xml\")); sqlSession = sqlSessionFactory.openSession(); bookDao = sqlSession.getMapper(BookDao.class);&#125;@Afterpublic void destroy() &#123; sqlSession.close();&#125;@Testpublic void testSaveBook() &#123; Book book = new Book(); book.setName(\"C++\"); book.setNumber(5); bookDao.saveBook(book);&#125; 对以上的程序做几点声明： init()添加了@Before注解，表示该方法会在被@Test注解的方法执行前执行；destroy()添加了@After注解，表示在被@Test注解的方法后执行 init()中是一些初始化的代码，因为SqlSession和BookDao对象会在@Test注解的方法中用到，为了不每次都初始化，我们把SqlSession和BookDao抽离出来作为成员变量，然后在init()方法中初始化；destroy()中是释放资源的代码 在执行前我们先看数据库中的数据，以观察该保存操作是否执行成功 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 |+----+--------------+--------+ 执行程序之后，数据库中的数据为 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 |+----+--------------+--------+ 发现数据库中的数据并没有发现改变，难道是程序写错了。其实是因为autocommit被设置为false了，所以进行回滚操作了，我们在destroy中加入下面的语句 @Afterpublic void destroy() &#123; sqlSession.commit(); sqlSession.close();&#125; 再次执行程序观察数据库中的数据 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 || 5 | C++ | 5 |+----+--------------+--------+ 我们保存对象时并没有设置id的值，因为id是自增长的。如果我们在保存数据后希望获得自增长的id值，我们可以修改BookDao.xml为 &lt;insert id=\"saveBook\" parameterType=\"com.xt.entity.Book\"&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into book(name, number) values (#&#123;name&#125;, #&#123;number&#125;);&lt;/insert&gt; 接着修改测试类中的方法 @Testpublic void testSaveBook() &#123; Book book = new Book(); book.setName(\"C++\"); book.setNumber(5); System.out.println(\"更新前的Book对象\"); System.out.println(book); bookDao.saveBook(book); System.out.println(\"更新后的Book对象\"); System.out.println(book);&#125; 运行结果为 更新前的Book对象Book&#123;id=null, name='C++', number=5&#125;更新后的Book对象Book&#123;id=6, name='C++', number=5&#125; 可见已经获得了自增长的id。 更新操作在BookDao中添加updateBook(Book book)方法 void updateBook(Book book); 然后在BookDao.xml中添加如下 &lt;update id=\"updateBook\" parameterType=\"com.xt.entity.Book\"&gt; update book set name = #&#123;name&#125;, number = #&#123;number&#125; where id = #&#123;id&#125;;&lt;/update&gt; 现在在测试类中添加测试方法 @Testpublic void testUpdateBook() &#123; Book book = new Book(); book.setId(5); book.setName(\"PHP\"); book.setNumber(20); bookDao.updateBook(book);&#125; 执行并观察数据库中的数据 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 || 5 | PHP | 20 |+----+--------------+--------+ 删除操作在BookDao中添加deleteBook(Integer id)方法 void deleteBook(Integer id); 在BookDao.xml中添加如下 &lt;delete id=\"deleteBook\" parameterType=\"int\"&gt; delete from book where id = #&#123;id&#125;;&lt;/delete&gt; 这里的parameterType写为了int，其实这里可以写为INT,integer,Integer均可，在sql语句中使用了#{id}，其实这里可以随便写，如#{uid},#{bookId}，因为只传入一个值，不管写什么都会被认为是这个传入的值。现在在测试类中添加测试方法 @Testpublic void testDeleteBook() &#123; bookDao.deleteBook(5);&#125; 执行并且查看数据库中的数据如下 +----+--------------+--------+| ID | name | NUMBER |+----+--------------+--------+| 1 | Java程序设计 | 10 || 2 | 数据结构 | 10 || 3 | 设计模式 | 10 |+----+--------------+--------+ 查询操作查询一个在BookDao中添加findById(Integer id)方法 Book findById(Integer id); 在BookDao.xml中添加如下 &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.xt.entity.Book\"&gt; select * from book where id = #&#123;id&#125;;&lt;/select&gt; 上面的resultType声明了返回的数据类型，接下来在测试了中添加测试方法 @Testpublic void testFindById() &#123; Book book = bookDao.findById(1); System.out.println(book);&#125; 输出结果为 Book&#123;id=1, name='Java程序设计', number=10&#125; 模糊查询在BookDao中添加findByName(String name)方法 List&lt;Book&gt; findByName(String name); 在BookDao.xml中添加如下 &lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.xt.entity.Book\"&gt; select * from book where name like #&#123;name&#125;&lt;/select&gt; 接下来在测试了中添加测试方法 @Testpublic void testFindByName() &#123; List&lt;Book&gt; list = bookDao.findByName(\"%设计%\"); for(Book book:list) &#123; System.out.println(book); &#125;&#125; 输出为 Book&#123;id=1, name='Java程序设计', number=10&#125;Book&#123;id=3, name='设计模式', number=10&#125; 当初我在使用中文模糊查询时查询不出来，使用英文可以，去网上查了一下，解决办法是是在my.ini文件的最后加上 character-set-server = utf8 collation-server = utf8_general_ci 然后重启mysql服务器。具体可以参考这个链接中文模糊查询。 查询一个值比如我想查询数据库中有多少条数据，在BookDao中添加findTotal()方法 int findTotal(); 在BookDao.xml中添加如下 &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from book;&lt;/select&gt; 接下来在测试了中添加测试方法 @Testpublic void testFindTotal() &#123; int numbers = bookDao.findTotal(); System.out.println(numbers);&#125; 输出为 3 resultMap上面我们要求实体类Book的属性要与数据库中类的列名相同，如果列名不同呢? 我们修改Book的实体类 package com.xt.entity;import java.io.Serializable;public class Book implements Serializable &#123; private Integer bookId; private String bookName; private int bookNumber; //省略getter和setter以及toString方法&#125; 现在修改测试类中的Setxxx方法，以及BookDao.xml中的#{Xxx}，如修改#{name}为#{bookName}，接着运行findAll的测试方法，得到 nullnullnullnull 可见数据没有封装。这个时候有两种解决办法 起别名 resultMap 先介绍起别名，我们修改findAll的sql语句为 &lt;select id=\"findAll\" resultType=\"com.xt.entity.Book\"&gt; select id bookId, name bookName, number bookNumber from book&lt;/select&gt; 接着运行findAll的测试方法，结果为 Book&#123;bookId=1, bookName='Java程序设计', bookNumber=10&#125;Book&#123;bookId=2, bookName='数据结构', bookNumber=10&#125;Book&#123;bookId=3, bookName='设计模式', bookNumber=10&#125;Book&#123;bookId=6, bookName='C++', bookNumber=5&#125; 可见数据封装好了。这种方法执行效率很高，但是所有的select语句都需要起别名，这里介绍resultMap，只要将实体类的属性名与数据库列名对应好，下面只需要引用即可，只需要写一次，在 &lt;mapper namespace=\"com.xt.dao.BookDao\"&gt; &lt;!--id是resultMap唯一标识，方便下面引用 type是要对应的实体类名称--&gt; &lt;resultMap id=\"bookMap\" type=\"com.xt.entity.Book\"&gt; &lt;!--主键的对应规则 property是实体类的属性名 column是数据库的列名--&gt; &lt;id property=\"bookId\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"bookName\" column=\"name\"&gt;&lt;/result&gt; &lt;result property=\"bookNumber\" column=\"number\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--这里就不需要些resultType了，直接引用上面写的resultMap 下面同理--&gt; &lt;select id=\"findAll\" resultMap=\"bookMap\"&gt; select * from book &lt;/select&gt; &lt;select id=\"findById\" parameterType=\"int\" resultMap=\"bookMap\"&gt; select * from book where id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=\"findByName\" parameterType=\"string\" resultMap=\"bookMap\"&gt; select * from book where name like #&#123;bookName&#125; &lt;/select&gt; ... ...&lt;/mapper&gt; 再次运行findAll的测试方法，输出为 Book&#123;bookId=1, bookName='Java程序设计', bookNumber=10&#125;Book&#123;bookId=2, bookName='数据结构', bookNumber=10&#125;Book&#123;bookId=3, bookName='设计模式', bookNumber=10&#125;Book&#123;bookId=6, bookName='C++', bookNumber=5&#125; 动态SQL所谓的动态SQL指的是SQL语句不是不变的，比如根据是否传入age以决定是否加入age验证项，下面介绍三种动态SQL。 加入有下面User表 +-----------+------+| user_name | age |+-----------+------+| 张三 | 18 || 李四 | 19 |+-----------+------+ 实体类以及UserDao接口就不演示了。 if首先在UserDao中创建下面的方法 List&lt;User&gt; findByCondition(User user); 该方法根据传入的User对象去查询，主要是根据该User对象所包含的userName和age去查询，但是这个User对象不一定设置了这两个属性，如 User user = new User();user.setAge(18);userDao.findByCondition(user); 上面的Java代码只设置了age的值，这意味着我们在userDao.xml中的select语句不能写成这样 select user_name userName, age from user where user_name = #&#123;userName&#125; and age = #&#123;age&#125; 假设如果userName没有设置的话，那么where后面的结果永远是false，意味着查不到结果，而我们希望的是，如果存在什么，则根据什么是查，比如如果不存在userName，存在age，则相应的SQL语句应该是 select user_name userName, age from user where age = #&#123;age&#125; 如果存在userName而不存在age，则只根据userName查，如果都不存在，则得到所有的User，即 select user_name userName, age from user 这个时候仅仅靠我们上面的手段是得不到的，因为这时的SQL语句是动态的。明显，我们需要对userName和age进行判断，以决定是否加入到SQL语句中，而判断使用的就是if。满足上面要求的SQL语句如下 &lt;select id=\"findByCondition\" parameterType=\"com.xt.domain.User\" resultType=\"com.xt.domain.User\"&gt; select user_name userName, age from user where 1 = 1 &lt;if test=\"userName != null\"&gt; and user_name = #&#123;userName&#125; &lt;/if&gt; &lt;if test=\"age != null\"&gt; and age = #&#123;age&#125; &lt;/if&gt;&lt;/select&gt; 上面的if标签就是对User对象中的属性进行判断，判断语句要写在if标签的test属性中，如果为真，则if标签包含的内容则会添加到SQL语句后，否则不会添加。 where大家注意上面的SQL语句中有 where 1 = 1 那么为什么要加上1 = 1呢? 假设如果不加1 = 1，并且传过来的User对象的userName和age都为null，那么最后的SQL语句是什么样子? select user_name userName, age from user where 这明显是一个错误的SQL语句，但是如果加上1 = 1，即使userName和age都为null，SQL也是正确的SQL语句 select user_name userName, age from user where 1 = 1 但是这样未免有点hack的意味，像是一种奇淫技巧，那mybatis有没有提供比较好的写法，答案就是where标签了，现在我们将上面的sql语句改为 select user_name userName, age from user&lt;where&gt; &lt;if test=\"userName != null\"&gt; and user_name = #&#123;userName&#125; &lt;/if&gt; &lt;if test=\"age != null\"&gt; and age = #&#123;age&#125; &lt;/if&gt;&lt;/where&gt; 我们将所有的if标签都放到了where标签里面，如果所有的if都不满足的话，那么在SQL语句中就不会出现where，如果if至少有一个成立的话，则会去掉第一个成立if标签中包含的and。假设该User对象包含userName不包含age，则最后的SQL语句是 select user_name userName, age from user where user_name = #&#123;userName&#125; forEach现在有一种的新的情况，如果传过来的参数是一个集合或者数组，那怎么处理呢? 在UserDao接口中添加下面的方法 List&lt;User&gt; findByAges(List&lt;Integer&gt; ages); 该方法会接收一个List集合，我们的要求是去查询用户年龄在ages集合中的用户，相应的SQL语句如下 &lt;select id=\"findByAges\" resultType=\"com.xt.domain.User\" parameterType=\"java.util.List\"&gt; select user_name userName, age from user &lt;where&gt; &lt;if test=\"list != null\"&gt; &lt;foreach collection=\"list\" item=\"age\" open=\"and age in(\" close=\")\" separator=\",\"&gt; #&#123;age&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 上面的where和if标签想必不用再解释了，重点是forEach标签。forEach的作用就是遍历集合创建一个SQL语句。forEach中的collection标签的值就是传过来的list集合，item就是集合中的元素，forEach会遍历该集合拿到这些item，open是指创建的SQL语句以什么开头，close是以什么结尾，而separator是指分隔符是什么，而forEach中包含的内容即是分隔符分隔的一个个元素。所以假设传来这么一个List List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.append(15);list.append(18); 那么上面的SQL语句最后会被生成为 select user_name userName, age from user where age in (15, 18) sql片段在上面，我们发现上面的SQL语句都包含这么一条SQL语句 select user_name userName, age from user 既然这是重复的内容，那我们就可以将其抽离出来成一个SQL片段，然后在SQL语句中引用该片段，在userDao.xml中的mapper标签下，我们加入以下内容 &lt;sql id=\"default\"&gt; select user_name userName, age from user&lt;/sql&gt; 上面的id名可以任意的取，这里的id是为了在后面引用该SQL片段。接下来将所有select中的 select user_name userName, age from user 替换为 &lt;include refid=\"default\"&gt;&lt;/include&gt; 如 &lt;select id=\"findByAges\" resultType=\"com.xt.domain.User\" parameterType=\"java.util.List\"&gt; &lt;include refid=\"selectAll\"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=\"list != null\"&gt; &lt;foreach collection=\"list\" item=\"age\" open=\"and age in(\" close=\")\" separator=\",\"&gt; #&#123;age&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 多表查询一对多与多对一假设有两张表，用户表和账户表，二者之间的关系为 一个用户可以有多个账户 一个账户对应一个用户 现在我们的需求的是当我们查询用户时，同时查询它所包含的所有账户，当我们查询账户时，同时查询它所对应的用户。 现在创建两张表user和account。 DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime default NULL COMMENT '生日', `sex` char(1) default NULL COMMENT '性别', `address` varchar(256) default NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'), (42,'小王','2018-03-02 15:09:37','女','北京金燕龙'), (45,'张三','2018-03-07 17:37:26','男','北京'),(46,'超级玛丽','2018-03-08 11:44:00','女','北京修正');DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT '编号', `UID` int(11) default NULL COMMENT '用户编号', `MONEY` double default NULL COMMENT '金额', PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `account`(`ID`,`UID`,`MONEY`) values (1,46,1000),(2,45,1000),(3,46,2000); 现在这两张表的内容为 # user+----+----------+---------------------+------+------------+| id | username | birthday | sex | address |+----+----------+---------------------+------+------------+| 41 | 老王 | 2018-02-27 17:47:08 | 男 | 北京 || 42 | 小王 | 2018-03-02 15:09:37 | 女 | 北京金燕龙 || 45 | 张三 | 2018-03-07 17:37:26 | 男 | 北京 || 46 | 超级玛丽 | 2018-03-08 11:44:00 | 女 | 北京修正 |+----+----------+---------------------+------+------------+# account+----+------+-------+| ID | UID | MONEY |+----+------+-------+| 1 | 46 | 1000 || 2 | 45 | 1000 || 3 | 46 | 2000 |+----+------+-------+ 现在创建对应的实体类以及对应的接口以及相应的xml文件。二者的实体类如下 package entity;import java.util.Date;import java.util.List;public class User &#123; private Integer id; private String name; private String sex; private Date birthday; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", birthday=\" + birthday + \", address='\" + address + '\\'' + \", accounts=\" + accounts + '&#125;'; &#125;&#125; package entity;public class Account &#123; private Integer id; private Integer uid; private Double money; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", uid=\" + uid + \", money=\" + money + \", user=\" + user + '&#125;'; &#125;&#125; 仔细注意这两个实体类，发现在User实体类中有一个Account的List列表，因为一个用户可以有多个账户。而在Account中有一个User对象，因为一个账户对应一个用户。 现在我们来实现第一个需求，当查询所有用户时，同时显示每个用户下的所有账户信息，在UserDao中加入下面的方法 List&lt;User&gt; findAllUsers(); 下面在userDao.xml中加入下面的查询语句 &lt;mapper namespace=\"dao.UserDao\"&gt; &lt;resultMap id=\"users\" type=\"entity.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"userName\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;collection property=\"accounts\" ofType=\"entity.Account\"&gt; &lt;id column=\"aid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUsers\" resultMap=\"users\"&gt; select user.*, account.id aid, account.uid, account.money from user, account where user.id = account.uid &lt;/select&gt;&lt;/mapper&gt; 由于User中包含一个Account类型的List，所以要设置这个List的对应规则，正是上面collection标签的部分，property是User中List对象的名称，ofType是List集合的类型。collection包含的部分就是List元素对应的规则。 现在实现第二个需求，当查询账户时，同时查询出对应的User信息，在AccountDao中添加下面的方法 List&lt;Account&gt; findAllAccounts(); 在accountDao.xml添加内容如下 &lt;mapper namespace=\"dao.AccountDao\"&gt; &lt;resultMap id=\"accounts\" type=\"entity.Account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"entity.User\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"userName\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findAllAccounts\" resultMap=\"accounts\"&gt; select user.*, account.id aid, account.uid, account.money from account left join user on user.id = account.uid &lt;/select&gt;&lt;/mapper&gt; 在Account中有一个User对象，我们要设置这个的对应规则，使用的就是association，property就是Account中User对象的名称，javaType是指对应的实体类。 多对多其实多对多查询与一对多的查询是一样的，上述我们在User类中添加了一个类型为Account的List集合，已表示一对多，在Account中有一个User对象，已表示一对一。 那要如果表示多对多，假设一个账户对应多个用户，那么只要在Account中将一个User对象改为一个类型为User的List列表。 延迟加载延迟加载又称为懒加载，又称按需加载，指的就是在需要的时候才加载，比如上面查询所有的User，但是这时不需要立即加载对应的账户信息，而是等我们使用账户信息时在进行加载，比如 user.getAccounts(); 这时再向数据库发起查询。 MyBatis根据对关联对象查询的select语句的执行时机，分为三种类型：直接加载、侵入式加载与深度延迟加载 直接加载：执行完对主加载对象的select语句，马上执行对关联对象的select查询。 侵入式延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的某个属性（该属性不是关联对象的属性）时，就会马上执行关联对象的select查询。 深度延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的select查询。只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。 Mybatis的延迟加载，需要通过resultMap标签中的association和collection子标签才能演示成功。 要设置延迟加载，需要在mybatis-config.xml中设置，如下 &lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;/settings&gt; ... ...&lt;/configuration&gt; lazyLoadingEnabled是设置是否深度延迟，当设置为true，就是设置为深度延迟，即当访问关联对象的详细信息时才会进行查询。aggressiveLazyLoading是用来设置侵入式延迟，默认为false，这里本应不用设置，只是为了演示。 一对一延时加载这里演示当查询账户时，同时查询对应的用户信息。首先我们看原先的查询语句 select user.*, account.id aid, account.uid, account.money from account left join user on user.id = account.uid 如果这么写的话，会立即查询相应User的信息，所以必须更改上面的sql语句 select * from account 同时修改resultMap如下 &lt;resultMap id=\"accounts\" type=\"entity.Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"entity.User\" select=\"dao.UserDao.findById\" column=\"uid\"&gt; &lt;/association&gt;&lt;/resultMap&gt; 注意到我们将association中的对应规则删除了，因为在上面的sql语句中我们只查询了account的内容。但是我们增加了两个属性，一个是select属性，这个是当我们使用account对象访问其中的User属性时会调用的sql语句，比如 account.getUser(); 这时因为会访问Account关联对象User的具体信息，会调用userDao的findbyId(Integer id)进行查询，从而得到相应的User信息。 第二个参数是column，其值是上面findById方法所需要的id。 这里向UserDao中增加下面的方法 User findById(Integer id); 并且在userDao.xml中增加select标签 &lt;select id=\"findById\" resultType=\"entity.User\" parameterType=\"Integer\"&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 此刻万事大吉，这里贴出accountDao.xml中的内容 &lt;resultMap id=\"accounts\" type=\"entity.Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"entity.User\" select=\"dao.UserDao.findById\" column=\"uid\"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAllAccounts\" resultMap=\"accounts\"&gt; select * from account&lt;/select&gt; 一对多延时加载一对多延时加载与一对一延时加载是一样，只不过association换成了collection。 这里我们以查询User信息时，同时查询该用户包含的所有账户，这里修改findAllUsers对应的sql语句为 &lt;select id=\"findAllUsers\" resultMap=\"users\"&gt; select * from user&lt;/select&gt; 修改对应的resultMap为 &lt;resultMap id=\"users\" type=\"entity.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"userName\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;collection column=\"id\" property=\"accounts\" ofType=\"entity.Account\" select=\"dao.AccountDao.findByUid\"&gt; &lt;/collection&gt;&lt;/resultMap&gt; 这时上面的代码已经不需要解释了，在AccountDao中添加findByUid的方法 List&lt;Account&gt; findByUid(Integer uid); 同时在accountDao.xml中添加对应的select标签 &lt;select id=\"findByUid\" resultType=\"entity.Account\" parameterType=\"Integer\"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; 缓存所谓缓存，指的就是当我们向数据库查询数据时，将数据保存在内存中，当第二次查询时，不再向数据库进行查询，而是直接从内存拿数据，这就是缓存。由于数据在内存中，从内存中拿数据比从数据库中拿数据快很多，并且也可以减少数据库的压力。 一级缓存MyBatis中的一级缓存的范围是sqlSession，即相当于在sqlSession中有一个localCache，当sqlSession查询数据时会将数据保存在这个cache中，当该sqlSession再次查询数据时，会先在这个cache中查询数据，如果有，则会直接拿内存中的数据，如果没有，则会去数据库查询。 那怎么保证拿到的数据不会错呢? 比如当更新数据后，如果继续从缓存中拿数据，这时拿到的数据就会是错的，所以当发生更新、删除、commit()等操作时，就会将一级缓存清空，这就意味着当更新数据后，就得直接去数据库中拿数据了。当SqlSession对象调用clearCache()，也会清除sqlSession的缓存。 那么怎么开启一级缓存呢? 在mybatis-config.xml中添加下面的setting &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; localCacheScope有两种取值，一种是SESSION，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存；一种是STATEMENT级别，可以理解为缓存只对当前执行的这一个Statement有效。默认是SESSION级别，这就意味着一级缓存默认是开启的，上面的设置不用写。 二级缓存想象有两个sqlSession，暂且称之为sqlSession1和sqlSession2，二者连接了同一个表，假设sqlSession1对表进行了更新，sqlSession2向数据库查询数据，但是由于一级缓存的存在，并且sqlSession2没有进行增加、删除等等操作，意味着sqlSession2没有清楚缓存，所以sqlSession2拿到的是缓存中的数据，这种数据称之为脏数据。 那怎么解决这个问题? 这个时候就要使用二级缓存。二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。 当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。 那怎么开启二级缓存呢? 首先在mybatis-config.xml加入下面的设置 &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 接着在xxxDao.xml中的namespace(mapper标签内中)加入 &lt;cache/&gt; 如果希望局部关闭二级缓存时，比如某查询标签关闭二级缓存，则在标签的属性useCache设置为false，如 &lt;select id=\"findAllUsers\" resultMap=\"users\" useCache=\"false\"&gt; select * from user&lt;/select&gt; 二级缓存对于不同的命名空间namespace的数据是互不干扰的，倘若多个namespace中对一个表进行操作的话，就会导致这不同的namespace中的数据不一致的情况。例如，在单表上使用二级缓存 在做关联关系查询时，就会发生多表的操作，此时有可能这些表存在于多个namespace中，这就会出现上面出现的问题了。 总结: MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。 MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。 使用注解开发使用注解开发，不需要对应的xxxDao.xml文件，因为我们将sql语句写在XxxDao接口的注解中。 简单使用新建一个工程，配置好pom.xml文件以及mybatis-config.xml的主配置文件，在entity包下新建User实体类，在dao包下新建UserDao接口，内容如下 package dao;import entity.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 在test/java/TestUser类中进行单元测试 import dao.UserDao;import entity.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;public class TestUser &#123; private UserDao userDao; private SqlSession sqlSession; private InputStream inputStream; @Before public void init() throws Exception&#123; String resource = \"mybatis-config.xml\"; inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); userDao = sqlSession.getMapper(UserDao.class); &#125; @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); System.out.println(users); &#125; @After public void destroy() throws Exception&#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125;&#125; 输出为 [User&#123;id=41, userName='老王', sex='男', birthday=Tue Feb 27 17:47:08 CST 2018, address='北京'&#125;, User&#123;id=42, userName='小王', sex='女', birthday=Fri Mar 02 15:09:37 CST 2018, address='北京金燕龙'&#125;, User&#123;id=45, userName='张三', sex='男', birthday=Wed Mar 07 17:37:26 CST 2018, address='北京'&#125;, User&#123;id=46, userName='超级玛丽', sex='女', birthday=Thu Mar 08 11:44:00 CST 2018, address='北京修正'&#125;] 其他CRUD这里简单的演示实验其他的CRUD操作。 更新操作在UserDao中添加如下方法 @Update(\"update user set username = #&#123;userName&#125; where id = #&#123;id&#125;\")void updateUser(User user); 在测试类中进行测试 @Testpublic void testUpdateUser() &#123; User user = new User(); user.setId(45); user.setUserName(\"李四\"); userDao.updateUser(user); System.out.println(userDao.findAll());&#125; 输出为 [User&#123;id=41, userName='老王', sex='男', birthday=Tue Feb 27 17:47:08 CST 2018, address='北京'&#125;, User&#123;id=42, userName='小王', sex='女', birthday=Fri Mar 02 15:09:37 CST 2018, address='北京金燕龙'&#125;, User&#123;id=45, userName='李四', sex='男', birthday=Wed Mar 07 17:37:26 CST 2018, address='北京'&#125;, User&#123;id=46, userName='超级玛丽', sex='女', birthday=Thu Mar 08 11:44:00 CST 2018, address='北京修正'&#125;] 如果发现不能插入中文，则修改mybatis-config.xml中的dataSource中的url为 &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; 插入操作在UserDao中添加下面的方法 @Insert(\"insert into user(username, sex, address, birthday) values(#&#123;userName&#125;, #&#123;sex&#125;, #&#123;address&#125;, #&#123;birthday&#125;)\")void insertUser(User user); 在测试类中进行测试 @Testpublic void testInsertUser() &#123; User user = new User(); user.setUserName(\"奥特曼\"); user.setSex(\"男\"); user.setAddress(\"M78\"); user.setBirthday(new Date()); userDao.insertUser(user); System.out.println(userDao.findAll());&#125; 删除操作在UserDao中添加下面的方法 @Delete(\"delete from user where id = #&#123;id&#125;\")void deleteUserById(Integer id); 在测试类中进行测试 @Testpublic void testDeleteUserById() &#123; userDao.deleteUserById(48); for (User user: userDao.findAll()) &#123; System.out.println(user); &#125;&#125; 在注解中配置resultMap如下 @Select(\"select * from user\")@Results(value = &#123; @Result(id=true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"sex\", property = \"sex\"), @Result(column = \"birthday\", property = \"birthday\"), @Result(column = \"address\", property = \"address\")&#125;)List&lt;User&gt; findAll(); 如果直接将Results写在方法上，那就意味则如果还有方法需要些resultMap，那么就还需要在写一遍，我们希望就是只写一遍resultMap，然后通过id引用即可，我们给上面的Results添加id @Results(id = \"users\", value = &#123; @Result(id=true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"sex\", property = \"sex\"), @Result(column = \"birthday\", property = \"birthday\"), @Result(column = \"address\", property = \"address\")&#125;) 然后在需要resultMap的方法上添加如下的注解 @Results(value = &#123;\"users\"&#125;) 或者简写为 @Results(\"users\") 多表查询一对一@Select(\"select * from account\")@Results(id = \"accounts\", value = &#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"uid\", property = \"uid\"), @Result(column = \"money\", property = \"money\"), @Result(column = \"uid\", property = \"entity.User\", one = @One(select = \"dao.UserDao.findById\", fetchType = FetchType.EAGER)),&#125;)List&lt;Account&gt; findAll(); Result中的one就是用来设置一对一查询的，其值是一个One注解，其中的select不用解释，与在xml中association设置的select相同功能 fetchType是用来设置是立即加载还是延迟加载的 FetchType.EAGER：立即加载 FetchType.LAZY：延迟加载 注意，如果要使用延迟加载，得先在mybatis-config.xml中开启延迟加载(方法同xml配置方式)。 一对多@Select(\"select * from user\")@Results(value = &#123; @Result(id=true, column = \"id\", property = \"id\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"sex\", property = \"sex\"), @Result(column = \"birthday\", property = \"birthday\"), @Result(column = \"address\", property = \"address\"), @Result(column = \"id\", property = \"accounts\", many = @Many(select = \"dao.AccountDao.findByUid\", fetchType = FetchType.LAZY))&#125;)List&lt;User&gt; findAll(); 将one换成了many，对应的Many注解里面的内容不用多加解释。 缓存如何在注解中使用缓存，对于一级缓存来说，与xml相同，不用设置，默认是SESSION。 对于二级缓存，首先在mybatis-config.xml开启缓存，与在xml中相同。 &lt;setting name=\"cacheEnabled\" value=\"true\"&gt;&lt;/setting&gt; 在xml中，我们是在namespace中设置 &lt;cache/&gt; 但是在注解中，我们在UserDao接口上添加@CacheNameSpace注解，设置其blocking属性为true，如下 @CacheNamespace(blocking = true)public interface UserDao &#123; ...&#125; 这样就开启二级缓存了。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/MyBatis/"}]},{"title":"使用React搭建一个基于富文本编辑器的博客系统","date":"2020-02-10T16:00:00.000Z","path":"/使用React搭建一个基于富文本编辑器的博客系统/","text":"本文将从0开始搭建一个基于富文本编辑器的博客系统，包括的内容有 React的基础知识 富文本编辑器组件BraftEditor的使用及扩展 React Hooks Redux + React-Redux antd表单的介绍及使用 登录权限控制 项目前的准备首先需要下载Node.js和npm(下载Node.js自带npm)，下载完Node.js后，由于npm的速度较慢，可以考虑使用下面的命令下载cnpm npm install cnpm -g npm是什么，为什么会需要npm： 想要知道npm是什么，那就要先从共享代码说起，程序员自古以来就有社区文化，加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。 前端是怎么共享代码的呢? 在 GitHub 还没有兴起的年代，前端是通过网址来共享代码，比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用，GItHub 兴起之后，社区中也有人使用 GitHub 的下载功能。 当一个网站依赖的代码越来越多，程序员发现这是一件很麻烦的事情，比如你要下载BootStrap，你就必须下载jQuery，因为BootStrap依赖jQuery，所以你需要一个网站一个网站的去下代码。如果遇到依赖比较多的情况，这个库依赖另一个库，另一个库又依赖另一个库，如此当依赖关系十分复杂时，你根本不知道要下哪些库，这对程序员来说简直就是个灾难。 有些程序员就受不了了，一个程序员叫 Isaac Z. Schlueter(以下简称Isaaz)给出一个解决方案：用一个工具把这些代码集中到一起来管理吧!这个工具就是他用 JavaScript(运行在Node.js上)写的 npm，全称是 Node Package Manager。 NPM 的思路大概是这样的： 买个服务器作为代码仓库(registry)，在里面放所有需要被共享的代码 发邮件通知 jQuery、Bootstrap、Underscore等作者使用npm publish 把代码提交到registry上，分别取名 jquery、bootstrap和underscore(注意大小写) 社区里的其他人如果想使用这些代码，就把jquery、bootstrap和underscore写到package.json里，然后运行 npm install，npm就会帮他们下载代码 下载完的代码出现在 node_modules 目录里，可以随意使用了。 这些可以被使用的代码被叫做「包」(package)，这就是 NPM名字的由来：Node Package(包) Manager(管理器)。 但是npm叫别人这么干，别人不一定会这么干啊，所以npm是怎么火的呢?npm的发展是跟Node.js的发展相辅相成的。Node.js是由一个在德国工作的美国程序员Ryan Dahl写的。他写了Node.js，但是Node.js缺少一个包管理器，于是他和 npm的作者一拍即合、抱团取暖，最终Node.js内置了npm。 后来的事情大家都知道，Node.js火了。随着Node.js的火爆，大家开始用 npm来共享JS代码了，于是jQuery作者也将 jQuery发布到npm了。所以现在，你可以使用npm install jquery来下载jQuery代码。 现在用npm来分享代码已经成了前端的标配。 接下来下载搭建React项目的脚手架create-react-app cnpm install create-react-app -g 什么是脚手架：随着前端工程化的概念越来越深入人心，脚手架的出现就是为减少重复性工作而引入的命令行工具，摆脱ctrl + c, ctrl + v，此话zenjiang? 现在新建一个前端项目，已经不是在html头部引入css，尾部引入js那么简单的事了，css都是采用Sass或则Less编写，在js中引入，然后动态构建注入到html中；除了学习基本的js，css语法和热门框架，还需要学习构建工具webpack，babel这些怎么配置，怎么起前端服务，怎么热更新；为了在编写过程中让编辑器帮我们查错以及更加规范，我们还需要引入ESlint；甚至，有些项目还需要引入单元测试(Jest)。对于一个刚入门的人来说，这无疑会让人望而却步。而前端脚手架的出现，就让事情简单化，一键命令，新建一个工程，再执行两个npm命令，跑起一个项目。在入门时，无需关注配置什么的，只需要开心的写代码；另外，对于很多系统，他们的页面相似度非常高，所以就可以基于一套模板来搭建，虽然是不同的人开发，但用脚手架来搭建，相同的项目结构与代码书写规范，是很利于项目的后期维护的；以上就是为什么脚手架存在的意义， 让项目从”搭建-开发-部署”更加快速以及规范。 接着使用create-react-app搭建一个React项目，这里的项目名称就命名为blog create-react-app blog 使用该命令会在本地生成一个文件夹blog，里面的内容如下 其中src就是我们开发的文件夹，其中index.js是入口文件，里面的内容为 import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import * as serviceWorker from './serviceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: https://bit.ly/CRA-PWAserviceWorker.unregister(); 现在我们将里面的内容改为 import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;div&gt;Hello React&lt;/div&gt;, document.getElementById('root')); 然后npm start就可以看到下面的页面 这时可以将src下除index.js的文件全部都删掉了，因为没有用到他们。 React基础JSX语法可能现在你对上面的代码不太了解，特别是怎么在JavaScrpt里面写HTML ReactDOM.render(&lt;div&gt;Hello React&lt;/div&gt;, document.getElementById('root')); 这里的HTML就是JSX，JSX的全称是JavaScript XML，指的就是JavaScript中的XML。 上面这行语句的作用是什么呢? React会解析这个JSX语句为一个虚拟DOM，而ReactDOM会将这个虚拟DOM转变为真正的DOM，然后塞到页面某个特定的元素上面，这里是塞到一个id为root(该DOM元素在public/index.html中)的DOM对象中,我们查看index.html中的内容 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;!-- 省略head中的内容和所有注释 --&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 经过ReactDOM渲染后的index.html的页面应该为为 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;!-- 省略head中的内容和所有注释 --&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=\"root\"&gt; &lt;div&gt;Hello React&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 为了验证这个想法，可以在刚才的页面中按下F12检查元素 所以页面显示出来的就是Hello React。 为什么需要虚拟DOM： 原因很简单，那就是DOM很慢，我们先来看一下浏览器的渲染流程 用HTML分析器，分析HTML元素，构建一颗DOM树 用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表 将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树 有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值 Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来 当你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。 即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。 虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。 我们知道React中的JSX会被解析为一个React对象(或者说JavaScript对象)，所以我们在写JSX的过程中，就可以把JSX看做是一个对象(记住JSX的本质就是对象，每当在JavaScript代码中看到这种JSX结构的时候，脑子里面就可以自动做转化，这样对你理解React.js的组件写法很有好处)。这就意味着JSX只能有一个根元素，如下面的写法是错误的 &lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 因为上面的代码并不能被解析为一个对象，正确的写法应该是 &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 这样的JSX才会被解析为一个对象。 现在我们在来说一下文件开头的两行语句 import React from 'react';import ReactDOM from 'react-dom'; 在React中，我们使用import来导入npm下载的包，这里我们引入了React和ReactDOM，这里你可能有疑问，我们并没有使用npm下载react和react-dom，为什么能够引入，这是因为create-react-app为我们做了这件事情，打开package.json我们可以发现已经帮我们添加了react和react-dom 那么引入的React是做什么事情的呢? 首先在JavaScript中是不能写JSX的，在React中的JSX会被解析为JavaScript对象，就是通过React来做到的，而ReactDOM是将React渲染的JSX对象(有时我们也称之为组件)转变为真正的DOM对象并塞到某个特定的元素里面。所以记住只要你写React.js组件，都必须要引入React。 组件这里十分推荐React.js 小书，里面将React的内容讲的十分的深入浅出，每读一遍都有新的收获。 组件是什么? 如果你搭过积木的话，那么里面的积木就是组件，我们使用积木搭建出一个东西，在React中我们使用组件来搭建一个页面。组件的作用就是复用，这里的复用指的不仅仅是页面的复用，还有逻辑和样式；除此以外，有的组件并不是用来展现页面的，而是用来加载数据的，然后将数据传给子组件，这样会使得处理数据的逻辑和展示数据的逻辑分开，职责分明，逻辑清晰，以及便于后期的维护。另外，有的组件是做权限的认证，以决定展示某些页面与否。总而言之，有许多不同的组件，组件根据功能或写法或有无状态等等可以进行分类，在后面将详细讨论。 按照组件的写法可以分为函数组件和类组件。 类组件我们写一个类组件HelloReact See the Pen React类组件使用 by LastKnightCoder (@lastknightcoder) on CodePen. 使用类组件，里面必须有一个render函数，该方法是用来返回JSX代码。我们创建了一个HelloWorld组件 ReactDOM.render(&lt;HelloReact /&gt;, document.getElementById(\"root\")) 并且我们通过&lt;HelloReact /&gt;的方式使用了组件，此时的&lt;HelloReact /&gt;就相当于render函数的返回值 &lt;div&gt;Hello React&lt;/div&gt; 但&lt;HelloReact /&gt;不仅仅是HTML，虽然在这个组件中，我们并没有加上JavaScript的逻辑和CSS样式，但是我们知道一个组件是包括这些的，下面我们为这个类添加样式和点击函数 See the Pen abOzEWb by LastKnightCoder (@lastknightcoder) on CodePen. 两点说明： 由于class在React中是关键字，所以类名要写成className onClick={()=&gt; console.log(“click me”)}为div标签添加了点击事件，onClick={}并不是说onClick是一个对象，{}是React的插值语法，使用插值语法可以将组件的属性与变量(表达式)绑定起来，这样就不会写死，而是会根据变量取不同的值。这里就是将onClick这个React事件与{}里面的箭头函数绑定起来。在{}中的内容只能是JavaScript的表达式，不能是if，while等语句 React事件： 使用原生的JS为DOM元素添加事件，主要有下面三种方法 在HTML中直接事件绑定 &lt;p onclick=\"console.log('click')\"&gt;&lt;/p&gt; 直接绑定 let divObj = document.getElementById(\"root\");divObj.onclick = function() &#123;&#125; 对DOM对象进行事件监听处理,事件委托监听方式 let divObj = document.getElementById(\"root\");divObj.addEventListener('click', function()&#123;&#125;); 至于这三种方法的优缺点与及什么时候使用，这里却不在讨论。那么React中的事件是如何绑定的呢? 在React中事件的绑定是直接写在JSX元素上的,不需要通过addEventListener事件委托的方式进行监听，写法上: 在JSX元素上添加事件,通过on*EventType这种内联方式添加,命名采用小驼峰式(camelCase)的形式,而不是纯小写(原生HTML中对DOM元素绑定事件,事件类型是小写的),无需调用addEventListener进行事件监听,也无需考虑兼容性,React已经封装好了一些的事件类型属性(ps:onClick,onMouseMove,onChange,onFocus)等 使用JSX语法时,需要传入一个函数作为事件处理函数,而不是一个字符串,也就是props值应该是一个函数类型数据,事件函数方法外面得用一个双大括号包裹起来(也就是上面提到的插值语法) on*EventType的事件类型属性,只能用作在普通的原生html标签上(例如:div,input,a,p等,例如:&lt;div onClick={ 事件处理函数 }&gt;&lt;/div&gt;),无法直接用在自定义组件标签上,也就是说下面这么写是没有作用的 &lt;HelloReact onClick=&#123;()=&gt; console.log(\"click me\")&#125;&gt; 不能通过返回false的方式阻止默认行为,必须显示使用preventDefault 具体React事件有哪些，可以参照事件系统|React。 props组件最常用的作用就是用来展示数据，那么作为可复用的组件，不同人拿到这个组件所展示的数据也不会相同，那么数据从哪里来? 使用组件的人怎么将数据传给组件，而组件又怎么拿到数据。这就要用到props了。 假如有下面的组件 class DisplayData extends React.Component &#123; render() &#123; return ( &lt;div&gt;假设这里是要展示的数据&lt;/div&gt; ) &#125;&#125; 这个组件的作用就是展示数据，现在我要用DisplayData组件，我怎么把数据传过去，如下 &lt;DisplayData data=\"数据\" /&gt; 我们通过给DisplayData组件加上一个data属性，值是”数据”，就可以将数据传给DisplayData，现在怎么拿到数据呢? 每一个组件都有props属性，它是一个对象，通过上面方法传递给组件的属性都会以键值对的形式添加到props对象中，所以在DisplayData组件中，我们就可以通过this.props.data拿到数据 class DisplayData extends React.Component &#123; render() &#123; return ( &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; ) &#125;&#125; See the Pen React props父组件给子组件传递数据 by LastKnightCoder (@lastknightcoder) on CodePen. 以上我们把DisplayData称之为子组件，而使用DisplayData的组件称之为父组件，上面演示了如何将数据从父组件传给子组件，现在我们考虑一下，如何将子组件的数据传递到父组件呢? 完全是有这个需要的，比如子组件是一个登录组件，我们需要将用户输入的用户名和密码交由父组件进行处理(为什么要交给父组件处理，在子组件中处理不可以吗?如果你在子组件里面处理了数据，那么这个组件就与具体的业务相关了，就不能够被复用了，所以数据处理的工作需要交由父组件来做)。 其实也很简单，我们给子组件传递一个回调函数，那么在子组件的某个时刻(比如子组件的值改变了或者说点击提交)时调用此回调函数并传入数据，这样我们就可以在父组件中拿到数据了 See the Pen React子组件向父组件传递数据 by LastKnightCoder (@lastknightcoder) on CodePen. 上面的逻辑代码为当SonComponent中的input发生改变时(输入内容或删减内容等等)，会触发子组件中的handleValue回调函数(该回调函数bind了this，后面会进行解释)，在子组件的handleValue中，我们根据浏览器传入的event获得了input输入框的值，并且调用ParentComponent传入的handleValue回调函数将此值传入，这样就将子组件的数据传给了父组件，在父组件中，我们定义了这个回调函数接收这个值，并在控制台打印，你可以在上面的input中输入值并在控制台观察结果。 JavaScript函数里面的this是什么： 要想知道JavaScript函数里面的this是什么，就要知道函数调用的4种方式： 定义在全局作用域中函数 定义在全局作用域中的函数，根据是否是严格模式下，this的取值也不同，如果是在严格模式下，里面的this是undefined，如果是在非严格模式下，里面的this是window \"use strict\"function test() &#123; console.log(this); &#125;test(); //undefined function test() &#123; console.log(this); &#125;test(); //window 对象方法 对象中方法中的this如果是对象.的形式调用的，那么对象方法中的this就是该对象 let obj = &#123; test: function() &#123; console.log(this); &#125;&#125;obj.test(); // obj 如果以某种角度看的话，第一种情况的非严格模式下是第二种情况的特例，我们知道在全局作用域下声明的变量和函数都会成为window对象的属性，当我们在全局作用域下声明一个test函数，就相当于在window对象中添加了一个test方法(在对象中的函数我们一般称为方法)，而调用test()方法就相当于window.test()，按照第二种情况，test中的this就是应该指向window 作为构造函数被调用 当我们new一个方法的时候，里面的this是一个空对象 function Dog() &#123; console.log(this)&#125;new Dog(); // &#123;&#125; 使用call, apply, bind方法改变函数的上下文(this) 上面三者都可以改变函数执行时内部this的指向，下面来看一个例子 funtion printName(firstName, lastName) &#123; console.log(this.fullName) console.log(`$&#123;firstName&#125; $&#123;lastName&#125;`)&#125; 如果直接执行这个函数的话，那么this.fullName的结果就是undefined，因为window对象没有这个属性，但是如果有以下对象 let obj = &#123; fullName: \"David\"&#125; 下面我们将printName函数执行时内部的this指向obj let firstName = \"firstName\"let lastName = \"lastName\"// 将printName内部this指向obj， 后面是printName需要的参数printName.apply(obj, firstName, lastName) // 将printName内部this指向obj， 后面是printName需要的参数printName.call(obj, [firstName, lastName]) 这时this.fullName就是obj中的fullName了，因为apply和call方法改变了printName内的this指向。这里我们发现apply和call方法是极其的相似，除了传递参数时格式不一样；事实上也是如此，apply和call的功能是一样的。 说完apply和call，接下来讲一讲bind，bind与上面两者不同，上面改变函数内部的this指向时是立即执行这个函数的，而使用bind改变函数内部的this指向时，这个函数不会立即的执行，如 printName = printName.bind(obj) printNAme函数内部的this指向已经改变，当printName执行时，打印出的this.fullName就是obj里面的David。 了解完JavaScript中的this是什么，接下来就要解释 &lt;input type=\"text\" placeholder=\"Please Input\" onChange=&#123;this.handleValue.bind(this)&#125; /&gt; 中onChange={this.handleValue.bind(this)}，首先我们来看handleValue中的代码 handleValue(event) &#123; this.props.handleValue(event.target.value)&#125; 当input发生改变时便会执行这个函数，但是是谁执行这个函数呢? 是window，而React是运行在严格模式下的，所以这时的this就是undefined，所以我们拿不到我们想要的this，要使得我能拿到的使我们想拿到的this，就是改变函数执行时内部的this指向，考虑到这个函数是作为回调函数而不是立即执行，我们使用bind来绑定this。 机智的你已经发现，ParentComponent中的handleValue没有bind(this)，这是因为它在函数里面没有用到this啊，所以什么时候bind(this)是不是已经很清楚了呢! 到这里你有没有发现我们使用组件都是这样 &lt;HelloReact /&gt; 居然不是一开一闭的格式，那想必你有疑问，可不可以这样使用 &lt;HelloReact&gt;&lt;/HelloReact&gt; 答案是可以，那么问题来了? 二者又有什么不同? 使用后面的写法意味着可以在标签里面写子元素，如 &lt;HelloReact&gt; &lt;div&gt;inner&lt;/div&gt;&lt;/HelloReact&gt; 其实这也可以看做是一种传递数据的方式，标签里面的子元素会传给这个组件，传过去的数据会保存在props.children中，在HelloReact中可以通过this.props.children获得数据。 这两种写法都很常见，在写布局，路由，认证等组件时经常使用后面的写法，而在一些展示的组件中，通常只需要父组件传下来的数据，会使用前一种写法，当然这种情况下也可以使用第二种写法。 为了理解children的应用，我们来写简单的Layout组件。所谓的Layout，就是布局 我们简单的把页面上面三个部分，这就是一种布局，一个头部，一个侧边栏，一个内容区。很多时候我们发现一个网站的多个网页之间的布局是一样的，并且很有可能头部和侧边栏是相同，仅仅是内容区不同，作为一名优秀的程序员，当然要尽可能的抽离出这些重复的代码，我们把这个布局抽离为一个组件 See the Pen 尝试Layout by LastKnightCoder (@lastknightcoder) on CodePen. 首先希望不要关注样式，因为那不是重点，关注Layout的结构。注意我们将{this.props.children}放在了类名为content的div中，所以如果我们将Content内容区组件放到Layout里面，Content组件就会被放在Layout的内容区，放置不同的Content组件，就会得到多个布局一样，内容不同的页面，这就做到了复用。 整个网站当然不可能只会有一种布局，很多时候我们会写多个布局的组件，明白了布局组件的作用，这些对你来说应当不难。 stateReact中一个比较重要的思想就数据驱动视图，例如子组件根据props的内容进行展示，根据不同的props展示不同的内容，不同的props会展现不同的UI，所以可以认为是props决定了视图，每当props变化时，都会引起子组件的渲染，展现不同的视图，视图的改变完全在于数据，所以现在我们操作的重点不再是DOM，而是数据，我们通过操作数据来达到不同的UI效果。 但是仅仅靠props似乎是够的，因为props是只读的，它不能够更改。这意味着什么? 假设父组件传给子组件的props没有发生变化，那么子组件的视图就不会改变，因为数据没有改变。这意味着我们如何与这样一个组件进行交互呢? 这意味组件的内部需要数据来管理UI的变化，我们将组件内部的数据称之为state，state就是状态的意思。比如使用visible这个状态来控制某个对话框是否可见，用户通过改变visible这个状态从而影响组件UI的变化，每次state的变化都会引起组件UI的刷新，从而达到数据驱动视图的目的。从此，我们关心的再也不是DOM操作，而是props, state这些数据，我们操作这些数据来控制视图的更新。 定义一个合适的state，是正确创建组件的第一步。state必须能代表一个组件UI呈现的完整状态集，即组件的任何UI改变，都可以从state的变化中反映出来；同时，state还必须是代表一个组件UI呈现的最小状态集，即state中的所有状态都是用于反映组件UI的变化，没有任何多余的状态，也不需要通过其他状态计算而来的中间状态。 组件中用到的一个变量是不是应该作为组件state，可以通过下面的4条依据进行判断： 这个变量是否是通过props从父组件中获取? 如果是，那么它不是一个状态。 这个变量是否在组件的整个生命周期(后面讲到)中都保持不变? 如果是，那么它不是一个状态。 这个变量是否可以通过其他状态(state)或者属性(props)计算得到?如果是，那么它不是一个状态。 这个变量是否在组件的render方法中使用? 如果不是，那么它不是一个状态(因为state是用来驱动视图的，如果这个变量没有在render方法中使用，意味着该状态的改变并不能使得视图发生变化)。这种情况下，这个变量更适合定义为组件的一个普通属性，例如组件中用到的定时器，就应该直接定义为this.timer，而不是this.state.timer。 现在来写一个计数器，当点击按钮时页面上显示的数字+1，页面上的数字发生改变正是UI的改变，这个时候我们就要用state来管理页面上要展示的数据 See the Pen Counter演示state by LastKnightCoder (@lastknightcoder) on CodePen. 我们在constructor构造函数中初始化state为 this.state = &#123; number: 0&#125; state为一个对象，其中的number属性正是我们要展现的数据，我们将它初始化为0。当我们点击按钮时，触发状态的改变 increment() &#123; this.setState(&#123; number: ++this.state.number &#125;)&#125; 注意，状态的改变不能使用this.state.number = ++this.state.number使状态发生改变，要使得状态发生改变，必须使用setState()方法使状态发生改变。 上面的例子进一步验证了数据驱动视图的思想，在计数器的例子中，我们没有手动的更改视图(操作DOM)，而是通过改变state来使得视图得到刷新，因为每次state的改变都会引起render()方法的调用，从而使得视图得以刷新。 请务必牢记，并不是组件中用到的所有变量都是组件的状态! 当存在多个组件共同依赖一个状态时，一般的做法是状态上移，将这个状态放到这几个组件的公共父组件中。 所谓状态上移是怎么回事呢? 考虑下面这么一个评论组件 CommentInput用来输入评论，当提交之后会在CommentList中新增一个CommentItem来显示新增的评论，很明显我们需要一个comments数组，当CommentInput提交评论时，将comment添加到comments数组中，CommentList拿到comments数组，comments中的元素会交给其中的CommentItem显示。而作为关键的comments数组，它是多个组件都会用到的，所以它应该作为state保存在公共的父组件中，即Comment组件中。这就是状态上移，将多个组件都会用到的数据上移到共同父组件的state中，当更新父组件的state的时，会使得传到子组件的props相应的更新，从而达到视图 更新的目的 生命周期函数一个人从出生到死亡会经历一些人生节点，孩童、青年、中年、老年。而一个组件从创建到销毁也要经历特殊的节点，在这些节点中，我们可以做一些操作，每一个节点都对应一个函数，我们将它们称为生命周期函数。 那React有哪些生命周期函数，这些生命周期函数对应的节点是什么呢? 或者说这些生命周期函数在React从创建到销毁的哪一个过程会被执行呢? 这里我们将生命周期分为三个阶段： 创建阶段 更新阶段 卸载阶段 在每一个阶段都包含数个生命周期函数。 创建阶段constructor(props)我们一般在构造函数中干两件事情： 初始化状态 为事件处理函数绑定this 注意： ES6子类的构造函数必须执行一次super()。React如果构造函数中要使用this.props，必须先执行super(props)。 static getDerivedStateFromProps(nextProps, prevState)当创建时、接收新的 props 时、setState时、forceUpdate时会执行这个方法。这是一个静态方法，参数nextProps是新接收的props，prevState是当前的state。返回值(对象)将用于更新state，如果不需要更新则需要返回null。 这个方法在建议尽量少用，只在必要的场景中使用，一般使用场景如下： 无条件的根据props更新state 当props和state的不匹配情况更新state componentWillMount()这个方法已经不推荐使用。因为在未来异步渲染机制下，该方法可能会多次调用。它所行使的功能也可以由 componentDidMount() 和 constructor() 代替： 之前有些人会把异步请求放在这个生命周期，其实大部分情况下都推荐把异步数据请求放在 componentDidMount() 中。 在服务端渲染时，通常使用 componentWillMount() 获取必要的同步数据，但是可以使用 constructor() 代替它。 有定义getDerivedStateFromProps时，会忽略componentWillMount() render()每个类组件中，render() 唯一必须的方法。render() 正如其名，作为渲染用，可以返回下面几种类型： React 元素（React elements） 数组（Arrays） 片段（fragments） 插槽（Portals） 字符串或数字（String and numbers） 布尔值或 null（Booleans or null） 里面不应该包含副作用，应该作为纯函数。不能使用 setState。 componentDidMount()组件完成装载（已经插入 DOM 树）时，触发该方法。这个阶段已经获取到真实的 DOM。一般用于下面的场景： 异步请求 ajax 添加事件绑定(注意在componentWillUnmount中取消，以免造成内存泄漏) 更新阶段componentWillReceiveProps()这个方法在接收新的 props 时触发，即使 props 没有变化也会触发。一般用这个方法来判断 props 的前后变化来更新 state，如下面的例子： class ExampleComponent extends React.Component &#123; state = &#123; isScrollingDown: false, &#125;; componentWillReceiveProps(nextProps) &#123; if (this.props.currentRow !== nextProps.currentRow) &#123; this.setState(&#123; isScrollingDown: nextProps.currentRow &gt; this.props.currentRow, &#125;); &#125; &#125;&#125; 这个方法将被弃用，推荐使用 getDerivedStateFromProps 代替。 static getDerivedStateFromProps()见创建阶段的描述 shouldComponentUpdate()在接收新的 props 或新的 state 时，在渲染前会触发该方法。该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。返回 false， 则不会触发后续的 componentWillUpdate()、render() 和 componentDidUpdate()（但是 state 变化还是可能引起子组件重新渲染）。 所以通常通过这个方法对 props 和 state 做比较，从而避免一些不必要的渲染。 componentWillUpdate()当接收到新的 props 或 state 时，在渲染前执行该方法。在以后异步渲染时，可能会出现某些组件暂缓更新，导致 componentWillUpdate 和 componentDidUpdate 之间的时间变长，这个过程中可能发生一些变化，比如用户行为导致 DOM 发生了新的变化，这时在 componentWillUpdate 获取的信息可能就不可靠了。这个方法将要弃用。 render()见创建阶段的描述 getSnapshotBeforeUpdate()这个方法在 render() 之后，componentDidUpdate() 之前调用。两个参数 prevProps 表示更新前的 props，prevState 表示更新前的 state。返回值称为一个快照（snapshot），如果不需要 snapshot，则必须显示的返回 null —— 因为返回值将作为 componentDidUpdate() 的第三个参数使用。所以这个函数必须要配合 componentDidUpdate() 一起使用。 这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如：在 getSnapShotBeforeUpdate 中获取滚动位置，然后作为参数传给 componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。 下面是官方文档给出的例子： class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // If we have a snapshot value, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; componentDidUpdate()这个方法是在更新完成之后调用，第三个参数 snapshot 就是 getSnapshotBeforeUpdate 的返回值。 正如前面所说，有 getSnapshotBeforeUpdate 时，必须要有 componentDidUpdate。所以这个方法的一个应用场景就是上面看到的例子，配合 getSnapshotBeforeUpdate 使用。 卸载阶段componentWillUnmount() 在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如： 取消定时器 取消事件绑定 取消网络请求 上面三个阶段是正常的生命周期，但是如果发生了异常，就需要进行错误处理，所以React也提供了发生异常时的函数 发生异常componentDidCatch(err, info) 任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。 错误边界不会捕获下面的错误： 事件处理(Event handlers)(因为事件处理不发生在 React 渲染时，报错不影响渲染) 异步代码(Asynchronous code)(e.g. setTimeout or requestAnimationFrame callbacks) 服务端渲染(Server side rendering) 错误边界本身(而不是子组件)抛出的错误 下面我们来看一张生命周期函数图来加深对上面描述的生命周期函数的理解 虽然React有做向下兼容，但是推荐尽量避免使用废弃的生命周期，而是拥抱未来，用新的生命周期替换它们。 函数式组件现在我们用函数式组件写一个HelloReact组件 See the Pen 函数式组件示例 by LastKnightCoder (@lastknightcoder) on CodePen. 其中函数式组件接收一个参数props，通我们在类组件中介绍的props相同。函数式组件与类组件不同的是，函数式组件没有state和生命周期函数，所以函数式组件又被称为无状态组件，从某种意义上说类组件具有更加强大的功能。 为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。其官方指出：在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。 无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点： 组件不会被实例化，整体渲染性能得到提升 因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。 组件不能访问this对象 无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件 组件无法访问生命周期的方法 因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用 无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。 组件分类组件按写法分可以分为类组件和函数式组件，在上面已经详细介绍过。按照组件有无状态又可以将组价分为有状态组件和无状态组件。按照组件的功能分又可以将组件分为容器组件和展示组件，又或者称为Smart组件和Dumb组件。这里主要介绍容器组件和展示组件。 展示组件： 只关注看起来怎么样 内部可能包含有展示组件或容器组件，并且通常有DOM标签和样式 不用指明数据是如何加载或者变化的 只通过props接收数据和回调函数 一般写为函数式组件，除非它们需要状态、生命周期函数或者性能优化 容器组件： 只关注如何工作的 内部也许包含展示组件或容器组件，但一般不会有DOM标签除非一个包装的div，不可能会有样式 为展示组件或其他容器组件提供数据和回调函数 一般是有状态的，被认为是数据源 一般是从高阶组件生成的 通过将组件分为这两种，可以有以下优点： 关注点更好的分离 更好的复用性 高阶组件高阶组件指的不是组件，而是一个函数，它可以增强组件，它接收一个组件，返回一个新组件，这个新组件是接收组件的加强版。假设有这样三个组件 class App1 extends React.Component &#123; state = &#123; data: null &#125;; componnetDidMount() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;; &#125;&#125;class App2 extends React.Component &#123; state = &#123; data: null &#125;; componnetDidMount() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;; &#125;&#125;class App3 extends React.Component &#123; state = &#123; data: null &#125;; componnetDidMount() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;; &#125;&#125; 观察这三个组件，它们都有一个共同的特点，那就是它们在挂载后都要从localStorage中获取数据，可见这样的代码是重复了的，我们如果每次要从localStorage获取数据，都要写一遍这样的代码，那怎么可以让这样的逻辑复用呢? 这就是高阶组件的作用，考虑下面这样的一个函数 function getDataFromLocalStorage(WrapComponent) &#123; class NewComponent extends React.Component &#123; state = &#123; data: null &#125;; componentDidComponent() &#123; const data = localStorage.getItem(\"data\"); this.setState(&#123; data &#125;); &#125; render() &#123; return &lt;WrapComponent data=&#123;this.state.data&#125; /&gt; &#125; &#125; return NewComponent&#125; 该函数接收一个组件，返回一个新组件。这个新组件在挂载后会用localStorage读取数据，并注入到传入的组件的props.data中。而这个传入的组件会作为新组件render函数的返回值，所以当我们使用这个新组件时，与使用传入的组件一致，不过此时新组件的props中已经有了从localStorage读取的数据。我们可以将上面的三个组件都可以改造为 class App1 extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125; App1 = getDataFromLocalStorage(App1)&#125; class App2 extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125; App2 = getDataFromLocalStorage(App2)&#125;class App3 extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125; App3 = getDataFromLocalStorage(App3)&#125; 我们使用高阶函数为三个组件的props.data中注入了数据，这样三个组件只要调用这个方法，就可以自动可以在props中获取到数据，从而达到了代码的复用。可能读到这里你还不能理解，没关系，多读几遍好好消化，或者写个几遍就习惯了。 render propsrender props的目的同样也是进行代码的复用。再次考虑上面代码的复用，不过这次使用render props实现代码的复用 class GetDataFromLocalStorage extends React.Component &#123; state = &#123;data: null&#125; componentDidMount() &#123; this.setState(localStorage.getItem(\"data\")) &#125; render() &#123; return &#123;this.props.render(this.state)&#125; &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;GetDataFromLocalStorage render = &#123;(&#123;data&#125;) =&gt; &#123; return &lt;div&gt;data&lt;/div&gt; &#125;&#125; /&gt; ) &#125;&#125; 仔细阅读上面的代码，想必还是比较容易读懂的。Render Props的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件。 React Redux假设有这么一棵组件树 Com4从App中获取数据，需要一层一层的传下来，有的中间组件可能只是用来传递数据用，同理，Com4向App传递数据，也要通过回调函数一层层往上传，再这样的情况下，代码实在是比较臃肿，不仅写出了很多不必要的代码，而且使得数据也比较难以理解。 假设有这么一个中央仓库，任何组件都可以直接存储和更改数据，而不需要一层层的传递 不管组件处于多深的层次，都可以从store中直接拿取数据。所以这个想法怎么做到呢? Context首先来介绍React中你可能永远不会用到的特性context。我们在父组件中它下面的子组件通过context的方式提供数据，其中的任意子组件均可以通过context访问数据，这就使得context相当于中央仓库，那怎么用呢(为了演示方便，就写父子两层)? See the Pen Context的使用 by LastKnightCoder (@lastknightcoder) on CodePen. 在上面用到了PropTypes，所以需要下载prop-types，使用npm下载 cnpm install prop-types --save 首先父组件提供context要声明提供的数据名称以及对应的类型 static childContextTypes = &#123; data: PropTypes.string&#125; 然后在getChildContext中返回数据 getChildContext () &#123; return &#123; data: \"data\" &#125;&#125; 而子组件要使用父组件提供的数据，首先要声明要使用的数据是什么以及类型 static contextTypes = &#123; data: PropTypes.string&#125; 只有这样才可以通过this.context获取想要的数据 &lt;div&gt;Child中获取Context：&#123;this.context.data&#125;&lt;/div&gt; context 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。 但是这种机制对于前端应用状态管理来说是很有帮助的，因为毕竟很多状态都会在组件之间进行共享，context 会给我们带来很大的方便。一些第三方的前端应用状态管理的库（例如 Redux）就是充分地利用了这种机制给我们提供便利的状态管理服务。但我们一般不需要手动写 context，也不要用它，只需要用好这些第三方的应用状态管理库就行了。 Redux + React Redux本来还想继续写Redux，React-Redux的，但是我发现React.js 小书写的实在是太好了，推荐仔细阅读其中的Redux和React-Redux的部分。 React Hooks使用React Hooks，使得在函数式组件可以有状态，也可以仿照生命周期函数，甚至可以替代React Redux。所谓的Hooks，就是指一些函数，通过这些函数可以在函数式组建中实现类组件的功能。 钩子函数一般是useXxx的形式，所有的钩子函数都只能写在函数式组件中。 useState我们来看一下如何在函数式组件中使用state See the Pen useState的使用 by LastKnightCoder (@lastknightcoder) on CodePen. 通过useState来创建一个状态，接收一个参数，这个参数就是状态的初始值，返回一个数组，数组包含两个元素，第一个元素就是状态，第二个元素是一个方法，该方法用来设置状态的，如上面 const [number, setNumber] = useState(0) 其中number就是状态，初始值为0，而setNumber是用来设置number的(二者的名字可以随便起，什么changeNumber随意)，每当我们点击+1按钮，都会将当前的number加一。 useEffectuseEffect主要是用来执行一些副作用的代码，比如拿数据 See the Pen useEffect by LastKnightCoder (@lastknightcoder) on CodePen. useEffect接收两个参数，第一个参数是回调函数，第二个参数是一个数组，它会监视数组中的元素，当数组中的元素发生改变时，就会执行回调函数，所以当我们点击按钮改变data时，由于data发生改变，useEffect中的回调函数会被执行。如果希望是componentDidMount生命周期函数的特点，即只在组件挂载是执行一次，那么可以为第二个参数传入一个空数组。 useContextuseContext的作用正如在React Redux中介绍的Context中一样，可以使得子组件无论在什么深度都可以直接访问父组件提供的Context，这个给个例子大家就可以明白 See the Pen useContext的使用 by LastKnightCoder (@lastknightcoder) on CodePen. ## useReducer 如何仔细阅读过React.js小书，那么想必你已经理解了reducer的作用，useReducer接收一个reducer和初始状态initState，返回state和dispatch，如下 See the Pen useReducer by LastKnightCoder (@lastknightcoder) on CodePen. 结合useContext和useReducer我们可以将useContext和useReducer结合，来达到React-Redux的效果，具体就是将useReducer产生的state和dispatch作为Context传下去，如下 See the Pen useContext与useReducer结合 by LastKnightCoder (@lastknightcoder) on CodePen. 富文本编辑器既然是搭建一个基于富文本编辑器的博客系统，那么就要用到富文本编辑器组件，这里我们选择BraftEditor。 使用npm安装到你的项目 cnpm install braft-editor --save 新建pages文件夹，并且在pages中新建文件夹RichText，在RichText中新建index.jsx，内容如下 import React, &#123;useState&#125; from 'react'import BraftEditor from 'braft-editor'import 'braft-editor/dist/index.css'function RichText(props) &#123; const [editorState, setEditorState] = useState(BraftEditor.createEditorState(\"&lt;p&gt;123&lt;/p&gt;\")) const handleEditorChange = (editorState) =&gt; &#123; &#125; const handleEditorSave = (editorState) =&gt; &#123; &#125; return ( &lt;BraftEditor value=&#123;editorState&#125; onChange=&#123;handleEditorChange&#125; onSave=&#123;handleEditorSave&#125; /&gt; )&#125;export default RichText 我们在src下的index.js中引入该组件，并渲染到dom中 import React from 'react';import ReactDOM from 'react-dom';import RichText from './pages/RichText';ReactDOM.render(&lt;RichText /&gt;, document.getElementById(\"root\")); 这时你使用yarn start或者npm start启动项目，在端口3000看到的页面应该是这样的 现在我们来看BraftEditor组件接收的三个props，分别是 value onChange onSave 我们一个个来看。 首先看value，它是BraftEditor组件要显示的内容，它的值是一个editorState对象，我们可以通过BraftEditor.createEditorState()创建editorState对象，它接收html字符串或者一个raw对象(raw对象是它自定义的对象，一般我们保存富文本的内容就是保存raw对象)，也可以通过editorState实例转化为html字符串或者raw对象，如 // 创建edirorState对象const editorState = BraftEditor.createEditor(\"&lt;p&gt;123&lt;/p&gt;\");const htmlContent = editorState.toHTML();const rawContent = editorState.toRAW(); 再者来看onChange，它是当BraftEditor发生改变时调用的回调函数，它会传入一个editorState对象，这个editorState对象代表的就是当前的文本内容。 最后看onSave，它是当按下Ctrl + S保存时会调用的方法，也会将代表当前文本内容的editorState传入。 我们来做一个简单的案例，当按下Ctrl + S时，将数据以raw对象的格式保存在localStorage中，当富文本加载时，从localStorage中读取数据 import React, &#123;useState, useEffect&#125; from 'react'import BraftEditor from 'braft-editor'import 'braft-editor/dist/index.css'function RichText(props) &#123; const [editorState, setEditorState] = useState(BraftEditor.createEditorState(null)) useEffect(() =&gt; &#123; const rawContent = localStorage.getItem(\"rawContent\") || null; setEditorState(BraftEditor.createEditorState(rawContent)) &#125;, []) const handleEditorChange = (editorState) =&gt; &#123; &#125; const handleEditorSave = (editorState) =&gt; &#123; const rawContent = editorState.toRAW(); localStorage.setItem(\"rawContent\", rawContent) &#125; return ( &lt;BraftEditor value=&#123;editorState&#125; onChange=&#123;handleEditorChange&#125; onSave=&#123;handleEditorSave&#125; /&gt; )&#125;export default RichText 这里就增加了两个地方，第一个是增加了useEffect，作用是当组件挂载后从localStorage中读取数据(既然从localStorage初始化，那么原来的”&lt;p&gt;123&lt;/p&gt;“就换为了null)，第二个是更改了handleEditorSave，当保存时将数据保存在localStorage中，上面的代码都很容易理解，不再解释。如果成功了的话，在富文本编辑器中输入并按Ctrl + S保存，然后刷新，数据会原样的重现。 页面布局我们来看一下项目的每个页面的布局 Home Edit Display Login 其中Home, Display, Edit都是下面这样的布局 而Login的布局是 所以我们抽离出布局组件，Home，Edit,Display三者的布局抽离为BasicLayout，而Login的布局抽离为LoginLayout组件，注意到他们的Heder都是相同的，所以我们把Header抽离为一个公共的组件。 Header在src下新建components目录，在其中新建Header文件夹，在其中新建index.jsx和index.module.css。index.jsx的内容如下 import React from 'react'import styles from './index.module.css'function Header(props) &#123; const toEdit = (e) =&gt; &#123; e.preventDefault() &#125; const toHome = (e) =&gt; &#123; e.preventDefault() &#125; return ( &lt;div className=&#123;styles.header&#125;&gt; &lt;div className=&#123;styles.nav&#125;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/home\" onClick=&#123;toHome&#125;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/edit\" onClick=&#123;toEdit&#125;&gt;写博客&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div className=&#123;styles.desc&#125;&gt; Coder &lt;/div&gt; &lt;/div&gt; )&#125;export default Header index.module.css中的内容为 .nav &#123; width: 100%; height: 100px; position: relative;&#125;.nav ul &#123; position: absolute; top: 0; right: 0; padding: 0; margin: 0;&#125;.nav ul li &#123; list-style: none; float: left; width: 80px; height: 30px; line-height: 30px; text-align: center; padding-top: 5px;&#125;.nav ul li a &#123; text-decoration: none; color: white; font-family: Consolas, \"楷体\";&#125;.nav ul li:hover &#123; border-bottom: 1px solid #FFF; box-shadow: 0 0 10px #FFF inset;&#125;.desc &#123; width: 100%; height: 100px; font-size: 40px; line-height: 100px; color: white; font-family: Consolas, \"楷体\";&#125; 上面的内容想必还是很容易理解的，其中Header中的两个a标签的点击事件均没有处理，这两个a标签是用于做路由跳转用的，等用到在回过头来补充。 BasicLayout在src下新建layouts文件夹，在其中新建文件夹BasicLayout，在BasicLayout中新建index.jsx和index.module.css，其中index.jsx的内容为 import React from 'react'import styles from './index.module.css'import Header from './../../components/Header'function BasicLayout(props) &#123; const &#123; children &#125; = props; return ( &lt;div className=&#123;styles.box&#125;&gt; &lt;div className=&#123;styles.container&#125;&gt; &lt;Header /&gt; &lt;div className=&#123;styles.main&#125;&gt; &lt;div className=&#123;styles.content&#125;&gt; &#123;children&#125; &lt;/div&gt; &lt;div className=&#123;styles.aside&#125;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default BasicLayout 其中index.module.css中的内容为 .box &#123; width: 100%; background: #d8e2eb url(./../../assets/img/bg.jpg) no-repeat top center; min-height: 100vh;&#125;.container &#123; max-width: 1200px; margin: 0 auto; padding: 0 50px;&#125;.main &#123; display: flex;&#125;.content &#123; flex: 3; margin-right: 20px;&#125;.aside &#123; flex: 1;&#125; 这里要用到背景图片，我们在src下新建assets文件夹，然后新建img，在其中放入背景图片，背景图片在这里 接在src下新建common.css，以消除内外边距，设置字体 * &#123; margin: 0; padding: 0;&#125;div &#123; font-family: Consolas, \"楷体\"; box-sizing: border-box;&#125; 现在我们在src/index.js中引用该布局看看效果 import React from 'react';import ReactDOM from 'react-dom';import RichText from './pages/RichText';import BasicLayout from './layouts/BasicLayout'import './common.css'ReactDOM.render(&lt;BasicLayout&gt; &lt;RichText /&gt; &lt;/BasicLayout&gt;, document.getElementById(\"root\")); 如下： LoginLayout在layouts下新建LoginLayout文件夹，在LoginLayout中新建index.jsx和index.module.css。有了BasicLayout的经验，代码的内容不必解释，直接上代码。index.jsx import React from 'react'import styles from './index.module.css'import Header from './../../components/Header'function LoginLayout(props) &#123; const &#123; children &#125; = props; return ( &lt;div className=&#123;styles.box&#125;&gt; &lt;div className=&#123;styles.container&#125;&gt; &lt;Header /&gt; &lt;div className=&#123;styles.main&#125;&gt; &#123;children&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default LoginLayout index.module.css .box &#123; width: 100%; background: #d8e2eb url(./../../assets/img/bg.jpg) no-repeat top center; min-height: 100vh;&#125;.container &#123; max-width: 1200px; margin: 0 auto; padding: 0 50px;&#125;.main &#123; width : 300px; margin: 0 auto;&#125; 页面路由为了使用路由，先下好react-router-dom cnpm install react-router-dom --save 该blog项目总共有四个页面 Home：页面主页 Display：阅读文章的页面 Edit：编辑文章的页面 Login：登录页面 为了演示路由，在pages中分别新建Home, Display, Edit, Login四个文件夹，并在每个文件夹中新建index.jsx，同时在Edit文件夹了新建components文件夹，将RichText文件夹全部移入到这个文件夹中(因为RichText富文本编辑器属于编辑文章页面的一部分)，简单的在每个文件的index.jsx写下一些内容，具体的内容在后面添加。 // Home/index.jsximport React from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'function Home(props) &#123; return ( &lt;BasicLayout&gt; Home &lt;/BasicLayout&gt; )&#125;export default withRouter(Home) // Display/index.jsximport React from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'function Display(props) &#123; return ( &lt;BasicLayout&gt; Display &lt;/BasicLayout&gt; )&#125;export default withRouter(Display) // Edit/index.jsximport React from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'import RichText from './components/RichText'function Edit() &#123; return ( &lt;BasicLayout&gt; &lt;RichText /&gt; &lt;/BasicLayout&gt; )&#125;export default withRouter(Edit) // Login/index.jsximport React from 'react'import &#123;withRouter&#125; from 'react-router-dom'import LoginLayout from './../../layouts/LoginLayout'function Login(props) &#123; return ( &lt;LoginLayout&gt; login &lt;/LoginLayout&gt; )&#125;export default withRouter(Login) 设计页面路由如下 path component redirect /home Home /display/:id Display /edit Edit /edit:id Edit /login Login / /home 注意到Edit组件对应两个路径，因为编辑文章有两种情况，第一种是添加文章，这时是/edit路径，第二种是编辑文章，这时需要传入文章的id，所以这时是/edit/:id路径。 在src下新建文件夹config，在config新建routes.js，里面设置路由信息，如下 import Home from './../pages/Home/index'import Display from './../pages/Display/index'import Edit from './../pages/Edit/index'import Login from './../pages/Login/index'export default [ &#123; path: \"/login\", component: Login &#125;, &#123; path: \"/home\", component: Home &#125;, &#123; path: \"/display/:id\", component: Display &#125;, &#123; path: \"/edit\", component: Edit &#125;, &#123; path: \"/edit/:id\", component: Edit &#125;, &#123; path: \"/\", redirect: \"/home\", exact: true &#125;,] 在src下新建router.js，用来渲染路由，内容如下 import React from 'react'import routes from './config/routes'import &#123;Switch, BrowserRouter as Router, Route, Redirect &#125; from 'react-router-dom'import &#123; createBrowserHistory &#125; from 'history';const history = createBrowserHistory();// 返回可能是Redirect 也可能是Route 所以使用RouteItem封装const RouteItem = (props) =&gt; &#123; const &#123; path, component: Component, redirect, key, exact &#125; = props; if (redirect) &#123; return &lt;Redirect from=&#123;path&#125; to=&#123;redirect&#125; key=&#123;key&#125; /&gt; &#125; return ( &lt;Route key=&#123;key&#125; exact=&#123;exact&#125; path=&#123;path&#125; render=&#123;componentProps =&gt; &#123; return ( &lt;Component &#123;...componentProps&#125; /&gt; ) &#125;&#125; /&gt; );&#125;;const router = () =&gt; &#123; return ( &lt;Router&gt; &#123;/* Switch 唯一匹配 */&#125; &lt;Switch&gt; &#123;routes.map((item, id) =&gt; &#123; return RouteItem(&#123; key: id, ...item &#125;) &#125;)&#125; &lt;/Switch&gt; &lt;/Router&gt; );&#125;;export default router; 接着在src/index.js中渲染出来 import ReactDOM from 'react-dom';import router from './router'import './common.css';ReactDOM.render(router(), document.getElementById(\"root\")); 接着启动项目(npm start或yarn start)，改变浏览的url(如localhost:3000/display)看看页面是否能成功跳转(我这里是没有问题的，如果你不能的话，回过头仔细看看吧)。 页面编写antd表单的使用要使用antd，先下载antd cnpm install antd --save 首先看一个表单的例子，在src下新建一个test文件夹，新建TextAntdForm.jsx，内容如下(先不管看得懂看不懂，后面解释) import React from 'react'import &#123;Form, Input, Button&#125; from 'antd'function TextAntdForm(props) &#123; const &#123;getFieldDecorator, validateFields&#125; = props.form const handleSubmit = (event) =&gt; &#123; event.preventDefault(); validateFields((error, values) =&gt; &#123; if (!error) &#123; console.log(values); &#125; &#125;) &#125; return( &lt;div style=&#123;&#123;width: \"300px\", margin: \"100px auto\", fontFamily: \"Consolas, '楷体'\"&#125;&#125;&gt; &lt;Form onSubmit=&#123;handleSubmit&#125;&gt; &lt;Form.Item label=\"用户名\"&gt; &#123;getFieldDecorator('title', &#123; rules: [&#123; required: true, message: '请输入用户名', &#125;], &#125;)( &lt;Input size=\"large\" placeholder=\"请输入用户名\"/&gt; )&#125; &lt;/Form.Item&gt; &lt;Form.Item label=\"密码\"&gt; &#123;getFieldDecorator('password', &#123; rules: [&#123; required: true, message: '请输入密码', &#125;], &#125;)( &lt;Input.Password size=\"large\" placeholder=\"请输入密码\"/&gt; )&#125; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button size=\"large\" type=\"primary\" htmlType=\"submit\"&gt;提交&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/div&gt; )&#125;export default Form.create()(TextAntdForm) 修改src/index.js渲染该组件(记得引入antd/dits/antd.css，否则antd组件没有样式) import React from 'react'import ReactDOM from 'react-dom';// import router from './router'import TestAntdForm from './test/TestAntdForm'import 'antd/dist/antd.css'import './common.css';// ReactDOM.render(router(), document.getElementById(\"root\"));ReactDOM.render(&lt;TestAntdForm /&gt;, document.getElementById(\"root\")); 现在来解释上面的代码，首先看最后一行 Form.create()(TextAntdForm) 还记得高阶组件吗，Form.create()就是一个高阶组件，他会向组件的props中注入form，form提供了一些API，这里使用了两个： getFieldDecorator：用于和表单进行双向绑定 getFieldDecorator('title', &#123; rules: [&#123; required: true, message: '请输入用户名', &#125;],&#125;)( &lt;Input size=\"large\" placeholder=\"请输入用户名\"/&gt;) 上面将Input与表单项进行了绑定，getFieldDecorator接收两个参数，第一个参数是id，根据它可以获取输入控件的值或者设置输入控件的值，是必填项；第二个参数是options，里面可以有很多属性，这里使用了rules，定义了校验的规则，required表示是否必填，message表示未填时显示的消息文字。 validateFields：校验 里面接受一个回调函数，回调函数接收两个参数，第一个参数为error，当不满足校验规则时error的值非空，第二个参数是values，会将绑定表单的值以对象的形式传给values，键就是在getFieldDecorator传入的id。 上面在提交表单后，会调用Form的onSubmit回调函数，在回调函数，我们对数据进行了校验，如果没有问题的话，我们可以将输入表单的键值对以对象的形式获取到values，并打印出来 页面数据我们将数据设置为一个数组datas，它的格式如下 datas = [ &#123;title: , brief: , isTop: , content: &#125; &#123;title: , brief: , isTop: , content: &#125;] Home组件根据datas展示数据，Edit和Display组件根据id和datas获取要展示的数据，由于多个组件都要用到数据，所以这里使用useContext和useReducer来分发数据。 在src下新建Provider.jsx，用来提供state和dispatch，内容如下 import React, &#123;useReducer&#125; from 'react'export const Context = React.createContext();const reducer = (state, action) =&gt; &#123; const tempDatas = state.datas // 按道理case后面跟的都是常量，我这里为了简单 switch(action.type) &#123; case 'insertData': tempDatas[tempDatas.length] = action.data; return &#123;...state, datas: tempDatas&#125; case 'updateData': tempDatas[action.id] = action.data return &#123;...state, datas: tempDatas&#125; case 'deleteData': tempDatas.splice(action.id, 1) return &#123;...state, datas: tempDatas&#125; case 'changeOperation': return &#123;...state, operation: action.operation&#125; default: return state &#125;&#125;const initState = &#123; // 随便写的数据用来实验 随后会删掉 datas: [&#123;title: 'aaa', isTop: true, brief: 'hahah'&#125;, content: '&lt;p&gt;123&lt;/p&gt;'], // 用来判断是添加文章还是编辑文章 operation: 'ADD'&#125;function Provider(props) &#123; const [state, dispatch] = useReducer(reducer, initState) const &#123;children&#125; = props return ( &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt; &#123;children&#125; &lt;/Context.Provider&gt; )&#125;export default Provider 更改router.js，在最上面加上Provider import Provider from './Provider'// 上面没有变化，除了import Provider，故此省略const router = () =&gt; &#123; return ( &lt;Provider&gt; &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &#123;routes.map((item, id) =&gt; &#123; return RouteItem(&#123; key: id, ...item, history: history &#125;) &#125;)&#125; &lt;/Switch&gt; &lt;/Router&gt; &lt;/Provider&gt; );&#125;;export default router Home观察Home页面 发现Home是由这一个个Item组成，Item中的数据正是datas数组中每一个元素的内容，在Home中新建文件夹Item，并在Item中新建index.jsx和index.module.css。index.jsx: import React from 'react'import styles from './index.module.css'import &#123;Modal&#125; from 'antd'const &#123;confirm&#125; = Modalfunction Item(props) &#123; const &#123; data, login, handleDelete, index, handleToEdit, handleToDisplay &#125; = props; const toDisplay = (event) =&gt; &#123; event.preventDefault(); handleToDisplay(index) &#125; const toEdit = (event) =&gt; &#123; event.preventDefault(); handleToEdit(index) &#125; const toDelete = (event) =&gt; &#123; event.preventDefault(); confirm(&#123; title: `你确定要删除$&#123;data.title&#125;`, content: '删除后内容不可恢复', onOk() &#123; handleDelete(index) &#125;, onCancel() &#123; &#125;, &#125;); &#125; return ( &lt;div className=&#123;styles.item&#125;&gt; &lt;h2&gt;&lt;a href=&#123;`/display/$&#123;data.id&#125;`&#125; onClick=&#123;toDisplay&#125;&gt;&#123;data.title&#125;&lt;/a&gt;&lt;/h2&gt; &lt;hr /&gt; &lt;div className=&#123;styles.abstract&#125;&gt; &#123;data.brief&#125; &lt;/div&gt; &lt;div className=&#123;styles.readmore&#125;&gt; &lt;a href=&#123;`/display/$&#123;data.id&#125;`&#125; onClick=&#123;toDisplay&#125;&gt;阅读更多&lt;/a&gt; &lt;/div&gt; &#123;/* 当登录失显示编辑本文和删除本文 */&#125; &#123;login ? &lt;div className=&#123;styles.edit&#125;&gt; &lt;a href=&#123;`/edit/$&#123;data.id&#125;`&#125; onClick=&#123;toEdit&#125;&gt;编辑本文&lt;/a&gt; &lt;/div&gt; : \"\"&#125; &#123;login ? &lt;div className=&#123;styles.delete&#125;&gt; &lt;a href=\"/delete\" onClick=&#123;toDelete&#125;&gt;删除本文&lt;/a&gt; &lt;/div&gt;: \"\"&#125; &#123;/* 当isTop为1时显示置顶图标 */&#125; &#123;data.isTop ? &lt;div className=&#123;styles.isTop&#125;&gt; &lt;svg viewBox=\"0 0 1024 1024\"&gt; &lt;path d=\"M0 0h1024v1024z\" fill=\"#7ED321\"&gt;&lt;/path&gt; &lt;path d=\"M571.733333 157.866667l17.066667-12.8-83.2-83.2L552.533333 14.933333l183.466667 183.466667-46.933333 46.933333-81.066667-81.066666-17.066667 12.8 100.266667 100.266666-14.933333 14.933334-102.4-102.4c-6.4 4.266667-10.666667 8.533333-17.066667 10.666666l72.533333 72.533334-110.933333 110.933333 36.266667 36.266667-14.933334 14.933333L313.6 209.066667l14.933333-14.933334 36.266667 36.266667 110.933333-110.933333 61.866667 61.866666c6.4-4.266667 10.666667-8.533333 17.066667-10.666666l-96-96 14.933333-14.933334 98.133333 98.133334z m-72.533333 209.066666l17.066667-17.066666-117.333334-117.333334-17.066666 17.066667 117.333333 117.333333z m27.733333-29.866666l14.933334-14.933334L426.666667 204.8l-14.933334 14.933333 115.2 117.333334z m27.733334-27.733334l17.066666-14.933333-117.333333-117.333333-17.066667 14.933333 117.333334 117.333333z m27.733333-25.6l14.933333-14.933333L482.133333 149.333333l-14.933333 14.933334 115.2 119.466666z m10.666667-202.666666L554.666667 44.8l-21.333334 21.333333 38.4 38.4 21.333334-23.466666z m57.6 57.6l-40.533334-40.533334-21.333333 21.333334 40.533333 40.533333 21.333334-21.333333zM704 192l-38.4-38.4-21.333333 21.333333L682.666667 213.333333l21.333333-21.333333zM571.733333 471.466667l12.8-21.333334c8.533333 10.666667 17.066667 19.2 25.6 27.733334 6.4 6.4 12.8 6.4 21.333334-2.133334l172.8-172.8-38.4-38.4 17.066666-17.066666 87.466667 87.466666-17.066667 17.066667-29.866666-29.866667-177.066667 177.066667c-14.933333 14.933333-29.866667 14.933333-44.8 0l-29.866667-27.733333z m302.933334 21.333333l-44.8 44.8c-27.733333 25.6-55.466667 40.533333-83.2 44.8-27.733333 2.133333-59.733333-6.4-96-25.6l6.4-25.6c34.133333 19.2 64 27.733333 87.466666 25.6 23.466667-4.266667 46.933333-14.933333 68.266667-36.266667l44.8-44.8 17.066667 17.066667z m132.266666-21.333333l-17.066666 19.2-55.466667-55.466667c-10.666667 8.533333-19.2 17.066667-29.866667 23.466667l51.2 51.2-119.466666 119.466666-17.066667-17.066666 102.4-102.4-76.8-76.8-104.533333 100.266666-17.066667-17.066666 121.6-121.6 42.666667 42.666666c10.666667-6.4 19.2-14.933333 29.866666-23.466666L861.866667 362.666667l17.066666-17.066667 128 125.866667zM802.133333 682.666667h-25.6c2.133333-25.6 2.133333-55.466667-2.133333-89.6h23.466667c4.266667 34.133333 4.266667 64 4.266666 89.6z\" fill=\"#FFFFFF\"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/div&gt; : \"\"&#125; &lt;/div&gt; )&#125;export default Item 注意到Item为展示组件，只负责数据的展示，而不负责数据的处理、获取，Item的数据、数据的操作都是从props中获取的，这些操作都由Item的容器组件Home来完成。 我们会将login保存在sessionStorage，login是一个布尔值，保存了是否登录的信息，true表示登录，false表示未登录，根据是否登录，决定是否将删除和编辑的操作暴露出来。同时我们也将根据data的isTop是否为true来显示是否置顶的svg图样(该图样来自CSDN的置顶图样)。 index.module.css .item &#123; width: 100%; height: 150px; background-color: white; margin-bottom: 40px; border-radius: 4px; padding-left: 25px; padding-right: 20px; padding-top: 20px; position: relative; box-shadow:0px 0px 6px 6px #FFF;&#125;.item a &#123; text-decoration: none; color: #40759b;&#125;.item a:hover &#123; text-decoration: underline;&#125;.abstract &#123; width: 100%; padding-top: 30px;&#125;.readmore &#123; position: absolute; font-size: 14px; bottom: 10px; right: 10px;&#125;.edit &#123; position: absolute; font-size: 14px; bottom: 10px; right: 75px;&#125;.delete &#123; position: absolute; font-size: 14px; bottom: 10px; right: 140px;&#125;.isTop &#123; position: absolute; width: 50px; top: 0; right: 0;&#125; 现在进入Home组件，修改Home/index.jsx如下 import React, &#123; useContext &#125; from 'react'import BasicLayout from './../../layouts/BasicLayout'import Item from './components/Item'import &#123;withRouter&#125; from 'react-router-dom'import &#123;Context&#125; from './../../router'import &#123; message &#125; from 'antd'function Home(props) &#123; const &#123;history&#125; = props // 使用useContext获取Provider提供的数据 const &#123;state, dispatch&#125; = useContext(Context); const login = sessionStorage.getItem(\"login\"); const datas = state.datas; const handleDelete = (id) =&gt; &#123; dispatch(&#123;type: \"deleteData\", id&#125;); message.success('删除成功'); &#125; const handleToEdit = (id) =&gt; &#123; dispatch(&#123;type: \"changeOperation\", operation: \"EDIT\"&#125;) history.push(`/edit/$&#123;id&#125;`); &#125; const handleToDisplay = (id) =&gt; &#123; history.push(`display/$&#123;id&#125;`); &#125; return ( &lt;div&gt; &lt;BasicLayout&gt; &#123;datas.map((data, index) =&gt; &#123; return &lt;Item index=&#123;index&#125; data=&#123;data&#125; key=&#123;index&#125; login=&#123;login&#125; handleDelete=&#123;handleDelete&#125; handleToEdit=&#123;handleToEdit&#125; handleToDisplay=&#123;handleToDisplay&#125; /&gt; &#125;)&#125; &lt;/BasicLayout&gt; &lt;/div&gt; )&#125;export default withRouter(Home) 现在启动项目(npm start)，观察到页面如下 说明Home页面已经成功了(由于在sessionStorage中没有login，所以删除本文和编辑本文均显示不出来，当点击阅读更多时，会跳转到Display的页面)。 Display我们来观察Display的页面 发现Display页面有一个背景为白色的内容区和一个按钮，这个按钮根据是否有登录来决定是否暴露出来，所以我们在Display中新建一个components文件夹，在里面新建一个Content文件夹，在Content文件夹中新建index.jsx和index.module.css。首先Content是一个展示组件，所以它的数据全部都由Display提供，所有的数据操作也由Display传入回调函数进行处理。 index.jsx如下 import React from 'react'import &#123; Button &#125; from 'antd'import styles from './index.module.css'function Content(props) &#123; const &#123;login, htmlContent, handleToEdit&#125; = props const toEdit = () =&gt; &#123; handleToEdit(); &#125; return( &lt;div className=&#123;styles.display&#125;&gt; &lt;div className=\"braft-output-content\" style=&#123;&#123;minHeight: \"425px\", backgroundColor: \"#FFF\", padding: \"50px 25px\", fontSize: \"16px\", maxWidth: \"850px\"&#125;&#125; dangerouslySetInnerHTML=&#123;&#123;__html: htmlContent&#125;&#125; &gt; &lt;/div&gt; &#123;login &amp;&amp; &lt;div className=&#123;styles.edit&#125;&gt; &lt;Button type=\"primary\" onClick=&#123;toEdit&#125;&gt;编辑文章&lt;/Button&gt; &lt;/div&gt; &#125; &lt;/div&gt; )&#125;export default Content 想必上面的代码还是比较容易理解的，index.module.css的内容如下 .display &#123; position: relative;&#125;.display ul, .display ol &#123; padding-left: 30px;&#125;.edit &#123; position: absolute; top: 10px; right: 10px;&#125; 所以Display中的内容如下 import React, &#123;useContext&#125; from 'react'import BasicLayout from './../../layouts/BasicLayout'import &#123;withRouter&#125; from 'react-router-dom'import Content from './components/Content'import &#123;Context&#125; from './../../Provider'import BraftEditor from 'braft-editor'function Display(props) &#123; const &#123;history&#125; = props // 获取传过来的id const index = Number(history.location.pathname.split(\"/\")[2]) const &#123;state, dispatch&#125; = useContext(Context) const htmlContent = BraftEditor.createEditorState(state.datas[index].content).toHTML() const login = sessionStorage.getItem(\"login\") const handleToEdit = () =&gt; &#123; dispatch(&#123;type: \"changeOperation\", operation: \"EDIT\"&#125;); history.push(`/edit/$&#123;index&#125;`); &#125; return ( &lt;BasicLayout&gt; &lt;Content htmlContent=&#123;htmlContent&#125; login = &#123;login&#125; handleToEdit = &#123;handleToEdit&#125; /&gt; &lt;/BasicLayout&gt; )&#125;export default withRouter(Display) 至此Display页面设计完毕。 Edit在写Edit页面之前，来改造一下RichText组件，我们要将RichText做成展示组件，所有的数据都由Edit提供，所有的数据处理也由Edit处理，修改如下 import React from 'react'import BraftEditor from 'braft-editor'import 'braft-editor/dist/index.css'function RichText(props) &#123; const &#123;value, onChange&#125; = props const handleEditorChange = (editorState) =&gt; &#123; onChange(editorState) &#125; return ( &lt;BraftEditor value=&#123;value&#125; onChange=&#123;handleEditorChange&#125; /&gt; )&#125;export default RichText 现在我们来看一下Edit页面的结构 我们使用antd的表单来做成这件事情，在前面已经介绍过antd表单的使用，所以这里不多加介绍，直接上代码 import React, &#123;useEffect, useContext&#125; from 'react'import RichText from './components/RichText'import &#123; withRouter &#125; from 'react-router-dom'import &#123; Form, Input, Button, message, Checkbox &#125; from 'antd'import BasicLayout from './../../layouts/BasicLayout'import BraftEditor from 'braft-editor'import &#123;Context&#125; from './../../Provider'function Edit(props) &#123; const &#123;history&#125; = props const FormItem = Form.Item; const &#123; getFieldDecorator, validateFieldsAndScroll &#125; = props.form; const &#123;state, dispatch&#125; = useContext(Context) useEffect(() =&gt; &#123; // 当组件加载后 如果是编辑文章 根据id获取数据 然后显示 // 如果是添加操作，则不加载数据 直接显示空白内容 if(state.operation === 'EDIT') &#123; const index = Number(history.location.pathname.split(\"/\")[2]) const data = state.datas[index] // setFieldsValue为表单设置内容 props.form.setFieldsValue(&#123; ...data, content: BraftEditor.createEditorState(data.content) &#125;) &#125; &#125;, []) const handleSubmit = (event) =&gt; &#123; event.preventDefault(); validateFieldsAndScroll((err, values) =&gt; &#123; if(!err) &#123; // 如果是通过添加按钮进来的 那么拿到数据保存 然后跳转到home页面 if(state.operation === 'ADD') &#123; dispatch(&#123;type: 'insertData', data: &#123; ...values, content: values.content.toRAW() &#125;&#125;); message.success(\"添加成功\"); history.push(\"/home\"); //如果是编辑文章进来的，更新数据 然后跳转到home &#125; else if (state.operation === \"EDIT\") &#123; const id = Number(history.location.pathname.split(\"/\")[2]); dispatch(&#123;type: \"updateData\", id, data: &#123; ...values, content: values.content.toRAW(), &#125;&#125;); message.success(\"更新成功\"); history.push(\"/home\"); &#125; &#125; &#125;) &#125; return ( &lt;BasicLayout&gt; &lt;div&gt; &lt;Form onSubmit=&#123;handleSubmit&#125;&gt; &lt;FormItem labelAlign=\"left\" label=\"文章标题\"&gt; &#123;getFieldDecorator('title', &#123; rules: [&#123; required: true, message: '请输入标题', &#125;], &#125;)( &lt;Input size=\"large\" placeholder=\"请输入标题\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem size=\"large\" label=\"文章摘要\"&gt; &#123;getFieldDecorator('brief', &#123; rules: [&#123; required: true, message: '请输入摘要', &#125;], &#125;)( &lt;Input.TextArea style=&#123;&#123;fontSize: \"16px\"&#125;&#125; placeholder=\"请输入摘要\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem&gt; &#123;getFieldDecorator('isTop', &#123; valuePropName: 'checked', &#125;)( &lt;Checkbox&gt; 是否置顶 &lt;/Checkbox&gt;, )&#125; &lt;/FormItem&gt; &lt;FormItem label=\"文章正文\"&gt; &#123;getFieldDecorator('content', &#123; validateTrigger: 'onBlur', rules: [&#123; required: true, message: \"请输入正文\" &#125;], &#125;)( &lt;RichText /&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button size=\"large\" type=\"primary\" htmlType=\"submit\"&gt;提交&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/div&gt; &lt;/BasicLayout&gt; )&#125;// 为Edit注入formexport default withRouter(Form.create()(Edit)) 上面的代码虽然有点长，但是都是比较容易理解的。注意，虽然我们没有为RichText传入value和onChange，但是由于RichText和表单项进行了双向绑定，所以表单会注入value和onChange。 LoginLogin页面应该是最简单的，只要用我们在前面antd表单示例里面的表单就可以完成，所以直接上代码如下 import React from 'react'import &#123;withRouter&#125; from 'react-router-dom'import &#123;Form, Button, Input, message &#125; from 'antd'import LoginLayout from './../../layouts/LoginLayout'function Login(props) &#123; const &#123; form, history &#125; = props; const FormItem = Form.Item; const &#123;getFieldDecorator, validateFields&#125; = form const handleSubmit = (event) =&gt; &#123; event.preventDefault(); validateFields((err, values) =&gt; &#123; if (!err) &#123; if (values.adminId === \"123\" &amp;&amp; values.password === \"123\") &#123; sessionStorage.setItem(\"login\", true); message.success(\"登录成功\"); history.push(\"/home\") &#125; else &#123; message.error(\"用户名或密码错误\") &#125; &#125; &#125;) &#125; return ( &lt;LoginLayout&gt; &lt;Form onSubmit=&#123;handleSubmit&#125;&gt; &lt;FormItem labelAlign=\"left\" label=\"用户名\"&gt; &#123;getFieldDecorator('adminId', &#123; rules: [&#123; required: true, message: '请输入用户名', &#125;], &#125;)( &lt;Input size=\"large\" placeholder=\"请输入用户名\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem size=\"large\" label=\"密码\"&gt; &#123;getFieldDecorator('password', &#123; rules: [&#123; required: true, message: '请输入密码', &#125;], &#125;)( &lt;Input.Password size=\"large\" placeholder=\"请输入密码\"/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button size=\"large\" type=\"primary\" htmlType=\"submit\"&gt;提交&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/LoginLayout&gt; )&#125;export default withRouter(Form.create()(Login)) 收尾在这里还有一个小地方没有处理，那就是Header，里面的a标签的点击事件没有处理，并且我们希望在登录的情况下显示”写博客”，以及在登录的情况下显示”退出登录”，在未登录的情况下显示”登录”，所以修改Header如下(由于要用到history，所以要在Layout里给Header传入history，但是Layout也没有history，所以要在Home, Edit, Display, Login中给用到的Layout传入history，这里的代码就不贴出了，想必这样的事情对现在的你应该已经很简单了) import React, &#123;useContext&#125; from 'react'import styles from './index.module.css'import &#123;Context&#125; from './../../Provider'function Header(props) &#123; const &#123;history&#125; = props; const &#123;dispatch&#125; = useContext(Context); const login = sessionStorage.getItem(\"login\"); const toEdit = (e) =&gt; &#123; e.preventDefault(); dispatch(&#123;type: \"changeOperation\", operation: \"ADD\"&#125;); history.push(\"/edit\"); &#125; const toHome = (e) =&gt; &#123; e.preventDefault() history.push(\"/home\") &#125; const logout = (e) =&gt; &#123; e.preventDefault() sessionStorage.removeItem(\"login\"); history.push(\"/login\"); &#125; const login_ = (e) =&gt; &#123; e.preventDefault() history.push(\"/login\"); &#125; return ( &lt;div className=&#123;styles.header&#125;&gt; &lt;div className=&#123;styles.nav&#125;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/home\" onClick=&#123;toHome&#125;&gt;首页&lt;/a&gt;&lt;/li&gt; &#123;login &amp;&amp; &lt;li&gt;&lt;a href=\"/edit\" onClick=&#123;toEdit&#125;&gt;写博客&lt;/a&gt;&lt;/li&gt;&#125; &#123;login ? &lt;li&gt;&lt;a href=\"/login\" onClick=&#123;logout&#125;&gt;退出登录&lt;/a&gt;&lt;/li&gt; : &lt;li&gt;&lt;a href=\"/login\" onClick=&#123;login_&#125;&gt;登录&lt;/a&gt;&lt;/li&gt;&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div className=&#123;styles.desc&#125;&gt; Coder &lt;/div&gt; &lt;/div&gt; )&#125;export default Header 接下来就是数据的持久化，我们希望将数据能够保存到localStorage，这样当页面刷新，关闭页面、浏览器,关机数据都能够保存。修改Provider.jsx import React, &#123;useReducer&#125; from 'react'export const Context = React.createContext();const saveData = (datas) =&gt; &#123; localStorage.setItem(\"datas\",JSON.stringify(datas) || [])&#125;const loadData = () =&gt; &#123; // 如果datas没有内容，则为空数组，因为后面用到datas.map，放止报错 return JSON.parse(localStorage.getItem(\"datas\")) || []&#125;const reducer = (state, action) =&gt; &#123; const tempDatas = state.datas // 每次对数据进行操作后都保存数据 switch(action.type) &#123; case 'insertData': tempDatas[tempDatas.length] = action.data; saveData(tempDatas) return &#123;...state, datas: tempDatas&#125; case 'updateData': tempDatas[action.id] = action.data saveData(tempDatas) return &#123;...state, datas: tempDatas&#125; case 'deleteData': tempDatas.splice(action.id, 1) saveData(tempDatas) return &#123;...state, datas: tempDatas&#125; case 'changeOperation': return &#123;...state, operation: action.operation&#125; default: return state &#125;&#125;const initState = &#123; // 初始化从localStorage中读取数据 datas: loadData(), operation: 'ADD'&#125;function Provider(props) &#123; const [state, dispatch] = useReducer(reducer, initState) const &#123;children&#125; = props return ( &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt; &#123;children&#125; &lt;/Context.Provider&gt; )&#125;export default Provider 登录权限控制如果用户没有登录的话，是没有权利访问某些页面的，比如编辑页面，它不能够添加文章，也不能够编辑文章(虽然我们在未登录的情况下没有暴露这样的途径，如Display页面未登录没有编辑文章的按钮，Header未登录没有写文章的连接，但是可以通过url直接访问)，所以我们要做一些权限控制。 所以在访问路由时，我们要做权限的检查，修改router.js中的RouteItem方法，不能直接的返回Route，而是要给Route加一层验证，以决定是否返回，如下 import Auth from './components/Auth'// ...const RouteItem = (props) =&gt; &#123; const &#123; path, component: Component, redirect, key, exact &#125; = props; if (redirect) &#123; return &lt;Redirect from=&#123;path&#125; to=&#123;redirect&#125; key=&#123;key&#125; /&gt; &#125; return ( &lt;Route key=&#123;key&#125; exact=&#123;exact&#125; path=&#123;path&#125; render=&#123;componentProps =&gt; &#123; return ( // 对Component加以验证 &lt;Auth history=&#123;history&#125;&gt; &lt;Component &#123;...componentProps&#125; /&gt; &lt;/Auth&gt; ) &#125;&#125; /&gt; );&#125;;// ... Auth组件正是用来做权限控制的，在src/components下新建Auth文件夹，并在其中新建index.jsx，如下 function Auth(props) &#123; const &#123;children, history&#125; = props const login = sessionStorage.getItem(\"login\") // Edit页面不能直接访问 需要登录 if (children.type.WrappedComponent.name !== \"Edit\") &#123; return children &#125; else &#123; if (login) &#123; return children &#125; history.replace(\"/login\") return null &#125;&#125;export default Auth 验证的逻辑也是十分的简单，如果不是Edit组件，则可以访问直接返回，如果是，则进一步判断是否登录，如果登录，则可以访问，否则来到登录页面。 至此，整个项目的工作已经大致完成了，可能有的地方还需要美化，比如富文本编辑器的代码美化，或者将数据保存在后台服务器等等。这一路走来可能你会感到有点不轻松，那么恭喜你，你获得了进步，如果你十分的轻松，那么这个项目对你来说还是有点容易。不过不管怎么样，希望你能够完全靠自己做一遍，也许你跟着我一路走来十分的顺利，这是因为一些坑我给你跳过去了，说实话，在我第一次做时，遇到到许许多多的坑，有很多不明白的点，有的地方明明十分的简单，可是我能卡几个小时甚至一两天，虽然辛苦，但是收获十分的巨大。所以我希望你能够独立的完成，去遇到一些坑，然后去找解决办法，在这个过程你会收获巨大，索性你已经完成了这个项目，所以对于这个项目要做出什么样的效果以及功能已经有了把握，所以在做一遍会简单很多，总之，加油。 参考资料 npm是干什么的? 前端脚手架，听起来玄乎，实际呢? 虚拟DOM介绍 React.js 小书 React中的事件处理 深入理解React组件状态(State) 重新认识生命周期函数 React中类组件和函数式组件 Presentational and Container Components 使用Render Props吧 Hook BraftEditor","tags":[{"name":"React","slug":"React","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/React/"},{"name":"antd","slug":"antd","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/antd/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/React-Hooks/"}]},{"title":"CSS3 新特性","date":"2019-12-24T16:00:00.000Z","path":"/CSS3/","text":"CSS3新特性样式背景background-origin我们知道盒子的大小有三部分组成：border, padding, content，当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的，它有三个可选值 border-box padding-box content-box 其中意思不必解释就可以明白。如果不进行设置的话，默认是padding-box，即以padding的左上角为原点。 background-clip该属性是用来设置背景(背景图片、背景颜色)延伸的范围，有4个值可选 border-box：背景延伸至边框外沿(但是在边框下层) padding-box：背景延伸至内边距(padding)外沿,不会绘制到边框处 content-box：背景被裁剪至内容区(content box)外沿 text：背景被裁剪成文字的前景色 具体可以参考网站background-clip，这里演示一下上面的效果 background-sizebackground-size用以设置背景图片大小。单张图片的背景大小可以使用以下三种方法中的一种来规定： 使用关键词 contain 使用关键词 cover 设定宽度和高度值 设定指定的宽度和高度值想必不用多加介绍。contain和cover会等比例的缩放图片，以使得图片能够最大的被完整包含或者最小的覆盖背景区。 如果背景区(由background-origin决定)的宽高比和图片的宽高比是一样的，那么cover和contain的结果是一样的，会完全的覆盖背景区并完整的显示。 边框边框圆角使用border-radius可以设置边框为圆角的，border-radius的值就是圆角边框的半径。 width: 100px;height: 100px;margin: 0 auto;border-radius: 20px;background-color: pink; 与padding一样，取不同个数的值，代表设置不同地方的圆角半径，如 取值个数 设置 1个，如border-radius: 20px 设置四个角的圆角半径都为20px 2个，如border-radius: 10px 20px 设置左上角和右下角这条对角线为10px,另一条对角线为20px 3个，如border-radius: 10px 20px 30px 设置左上角为10px,右上角和左下角这条对角线为20px,右下角为30px 4个，如border-radius: 5px 10px 15px 20px 从左上角开始设置，按顺时针来，即左上角为5px,右上角为10px, … 由第一张图，我们发现半径也分为水平半径和垂直半径，这两个也可以分别设置，用/分开当做两组，第一个用来设置水平半径，第二个设置垂直半径，如 width: 100px;height: 120px;margin: 0 auto;border-radius: 50px / 60px; background-color: pink; 我们设置四个角的水平半径为50px,四个角的水平半径为60px,得到效果如下 如果不分开设置，则默认水平半径和垂直半径是相同的。 如果想要更加详细的了解，这里推荐一篇阮一峰的网络日志CSS3圆角边框。 边框图片找到一篇写的很好的博文border-image的正确用法，所以这里就不自己写了。 阴影盒子阴影为了知道什么是盒子阴影，观看如下效果 这里选取了小米的做法，由于设置阴影的颜色比较淡，所以可能比较难看出来。 用以设置盒子阴影的属性是box-shadow,它的值比较多，需要设置的值如下， 水平阴影 垂直阴影 模糊距离(虚实) 阴影尺寸(影子大小) 阴影颜色 内/外阴影(这个我也不懂，不做介绍) 其中水平阴影h-shadow和垂直阴影v-shadow是必须设置的。 为了观看设置这些值的效果，我们首先创建一个盒子 width: 200px;height: 200px;border: 1px solid #CCC;margin: 100px auto; 为盒子添加阴影 box-shadow: 1px 1px 1px 1px red; 水平阴影大小的影响(正值，阴影向右移动，负值，阴影向左移动) 垂直阴影大小的影响(正值，阴影向下移动，负值，阴影向上移动) 模糊距离大小的影响 阴影尺寸大小的影响 文本阴影使用text-shadow来设置文本阴影。使用与box-shadow差不多，具体可以参照text-shadow。 CSS3选择器CSS3新增了许多的选择器，为我们选择元素提供了更加灵活的选择。 属性选择器 [attr]：选择包含attr属性的标签 [attr=value]：选择attr属性值为value的标签 [attr^=value]：选择attr属性值以value开头的标签 [attr*=value]：选择attr属性值包含value的标签 [attr$=value]：选择attr属性值以value的标签 如 div[class] &#123; /* 会选择包含class属性的div标签 */&#125;div[class=\"active\"] &#123; /* 会选择class属性值为active的div标签 */&#125;div[class^=\"header\"] &#123; /* 会选择class属性以header开头的div标签 */&#125;... ... 结构伪类选择器 E:first-child E:last-child E:nth-child(n) E:nth-last-child(n) E:first-of-type E:last-of-type E:nth-of-type(n) E:nth-last-of-type(n) 上面的选择器是比较常见的结构伪类选择器，下面具体讲解其表达的意思。 E:first-child指的是，选择E，这个E满足的条件是：它是其父元素第一个子元素。听起来有点绕，来看一个例子 &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; span:first-child &#123; /* 它会选择span，条件是这个span必须是它父元素的第一个子元素 */&#125; 由于第一个div里面的span是其父元素(第一个div)的第一个子元素，所以第一个div里面的span会被选中。而第二个div里面的span不是其父元素(第二个div)的第一个子元素，所以这个span不会被选中。 E:last-child的与E:first-child相似，不过第一个改为最后一个。 E:nth-child(n)指的是选择E，E需要满足条件，是其父元素的第n个元素(n是从1开始的)，E:first-child就相当于是E:nth-child(1)。E:nth-child(n)中这个”n”除了可以是具体的数字以外，还可以是odd和even，表示选择所有的E，这些E是其父元素的第奇数或第偶数个。除此之外”n”还可以是表达式，如2n+1, 3n(n从1开始)。 而E:nth-last-child(n)则是倒着数的，用法同E:nth-child(n)相似，这里不多介绍。 E:first-of-type与E:first-child不同，其意思是选择器父元素下的第一个E元素。还是以上面两个div为例 &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;&lt;/span&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; span:first-of-type &#123; /* 选择span父元素下的第一个span元素 */&#125; 这个时候两个span都可以被选择到，first-of-type相当于只是将E的父元素所包含的E全部抽离出来，然后进行选择。现在我们将div包含的span全部抽离出来，相当于 &lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 然后选择第一个span，所以这两个span都可以被选择到。其余的first-last-type, nth-of-type(n), nth-last-of-type同上面介绍的last-child, …相似，其不同之处在fitst-child与first-of-type处已详细阐述。 CSS3颜色渐变颜色渐变是指在两个颜色之间平稳的过渡。以往我们如果希望有颜色渐变的效果，会在绘图工具(如PS)设计出希望的效果，然后作为图片来实现这种效果。现在通过浏览器可以渲染而成，这样可以减少下载的时间和带宽的使用，以及在放大时看起来效果更好，因为这是浏览器自动生成的。 线性渐变线性渐变指的是颜色在一条线上平稳的变化，为了实现线性渐变，我们要规定线的方向，起点颜色和终止颜色。它的语法为 background-image: linear-gradient(direction, color-stop1, color-stop2, ...); 如 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box &#123; width:100%; height:100px; background-image: linear-gradient(to right, red, green); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果为 其中 linear-gradient(to right, red, green); 其中第一个参数to right是用来设置方向的，设置方向的值有 to right：从左往右 to left：从右往左 to top：从下往上 to bottom：从上往下，默认值 to right bottom：从左上角往右下角 … … 除了可以设置这些值之外，还可以设置角度，如 linear-gradient(0deg, red, green); 其中角度所代表的的方向如下所示 即0deg代表的方向是从下往上。 除此之外，除了设置起点颜色和终点颜色之外，还可以在之间设置多个颜色节点，如下面设置了一个彩虹渐变色 background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); 除此之外，还可以在颜色后面加上数值或者百分比，如 background-image: linear-gradient(to right, red, blue 10%, violet); blue 10%表示blue颜色节点在该线性方向10%的位置，所以从0%-10%是红色到蓝色的渐变，10%-100%是蓝色到紫色的渐变。 接下来介绍渐变的最后一个特性：渐变重复。看下面一个例子 /* 设置为23%而没有设置为能被100%整除的数 就是想看一下这种情况是怎么处理的 */repeating-linear-gradient(to right, red,yellow 23%); 上面的意思是从0%-23%实现红色到黄色的渐变，然后重复直至100%。 径向渐变径向渐变是指以某点为圆心，向外进行颜色渐变。所以为了实现径向渐变，我们要规定圆心的位置和起点颜色和终点颜色。径向渐变的语法为 background-image: radial-gradient(shape size at position, start-color, ..., last-color); 其中shape为渐变的形状，有两种取值 circle(圆形) ellipse(椭圆, 默认值) size是指100%所代表的的长度，有四种取值 closest-side(离最近的边的距离) farthest-side(离最远的边的距离) cloest-corner(离最近的角的距离) farthest-corber(离最远的角的距离，默认值) position是指圆心的位置，默认为center，即中心位置，也可以通过at 100px 100px形式进行设置，左上角的坐标的为(0px, 0px)。 .box &#123; width:400px; height:200px; /* 设置size大小为离最近的边的距离 */ background-image: repeating-radial-gradient(circle closest-side at 200px 100px, red, red 10%,green 12.5%, green 25%)&#125; 可见离最近的边有4个完整的重复。 /* 设置size大小为离最远的边的距离 */background-image: repeating-radial-gradient(circle farthest-side at 200px 100px, red, red 10%,green 12.5%, green 25%) 可见离最远的边有4个完整的重复。 /*为了使最远的角和最近的角的距离不同 position不能设置在中心 *//* 设置size大小为离最近的角的距离 */background-image: repeating-radial-gradient(circle closest-corner at 100px 100px, red, red 10%,green 12.5%, green 25%) 可见离最近的角有4个完整的重复。 /* 设置size大小为离最远的角的距离 */background-image: repeating-radial-gradient(circle farthest-corner at 100px 100px, red, red 10%,green 12.5%, green 25%) 可见离最远的角有4个完整的重复。 CSS3 2D变换CSS3 2D变换包括对元素进行移动、缩放、转动、拉长或拉伸。 translate()：对元素进行进行移动 translate(100px)：对元素向x正方向移动100px(负值向负方向移动) translate(100px, 100px)：对元素向x, y正方向方向移动100px scale()：对元素进行缩放 scale(n)：对元素进行缩放，传入的参数大于1，进行放大，小于1，进行缩小 scale(x, y)：第一个参数对宽度进行缩放，第二个值对高度进行缩放 rotate()：围绕中心旋转，正值顺时针，负值逆时针 transform-origin：可以改变旋转的中心，如 /* 围绕左上角进行旋转 */transform-origin: left top; /* 围绕中心旋转 为默认值 */transform-origin: 50% 50%; skew()：对元素进行倾斜 skew(angle)：向x轴负方向倾斜angle(负值沿正方向) skew(anglex, angley)：第一个参数对x方向，第二个参数对y方向 除了可以使用上述属性进行设置，还可以使用translateX(), translateY()等进行设置。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; &#125; /* 为每个div设置颜色 */ .box1 &#123; background-color: red; &#125; .box2 &#123; background-color: aqua; &#125; .box3 &#123; background-color: chocolate; &#125; .box4 &#123; background-color: darkcyan; &#125; /* 为每个盒子设置不同的2D变换效果 */ .box1:hover &#123; transform: translateX(100px); &#125; .box2:hover &#123; transform: scale(0.5); &#125; .box3:hover &#123; transform: rotate(-30deg); &#125; .box4:hover &#123; transform: skew(30deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt; &lt;div class=\"box4\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS3 3D3D变换的操作同2D相同，只是多了一个对Z轴的操作，如translateZ()，而rotate也分为rotateX(), rotateY(), rotateZ()，分别表示绕着X轴，Y轴，Z轴旋转。2D变换的rotate()其实就相当于rotateZ()。 CSS3动画transition首先我们来看一个例子 .box &#123; height: 100px; width: 100px; background-color: black;&#125;.box:hover &#123; transform: translateX(600px);&#125; 当我们把鼠标放在盒子上时，盒子向右移动了600px，但是这个过程是在瞬间完成的，十分的突兀，我们希望是缓慢由一个转态转变到另一个状态的，这种效果又叫做过渡，这时就需要用到transition属性了。 为某个元素添加过渡效果，必须规定两项内容： transition-property：指定要添加效果的CSS属性 例如上面就要为transform添加过渡效果，所以就可以写为 /* 值可以为all 表示为所有的属性添加过渡效果 默认值为all*/transition-property: transform; transition-duration：添加过渡的总时间 /* 默认值为0s */transition-duration: 1s; /* 单位可以为s */transition-duration: 100ms; /* 单位也可以为ms */ 除了上面必须设置的两个属性，还可以设置下面的属性 transition-timing-function：时间函数，设置过渡的变化速度 ease：开始和结束慢，中间快，默认值。 linear：匀速。 ease-in：开始慢。 ease-out：结束慢。 ease-in-out：和ease类似，但比ease幅度大。 除了可以设置以上关键字，还可以设置steps()函数，语法如下： steps(&lt;integer&gt;[,start | end]?) 第一个参数传入一个整数值，steps步进函数将过渡时间划分成大小相等的时间时隔来运行，这个整数值就是分成的份数。第二个值是可选的，默认值为end。如果是start，则不保留开始值，如果是end，则保留开始值。 这里给出一个利用steps()函数做动画效果的例子。 transition-delay：延时时间，默认值为0s animation与transition一样，animation也有很多的属性 animation-name：动画名称 animation-duration：动画持续时间 animation-timing-function：动画时间函数 animation-delay：动画延迟时间 animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环 animation-direction：动画执行方向 animation-paly-state：动画播放状态 animation-fill-mode：动画填充模式 过渡是指在两个状态之间，而动画则是指在多个状态之间变化，这些状态我们称之为关键帧，因此动画又称之为关键帧动画。使用动画首先要创建关键帧，然后使用animation-name去调用该动画，如 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; background-color: aqua; &#125; .box:hover &#123; animation-name: move; animation-duration: 1s; &#125; /* 创建一个关键帧动画 动画名为move */ /* 调用时使用animation-name: move调用 */ @keyframes move &#123; /* 第一个状态 0% 时的状态 可以使用from代替 */ /* 这里的百分比是指 总时间 * 百分比 得到的某个时刻的状态*/ 0% &#123; transform: translateX(0px); &#125; 50% &#123; transform: translateX(100px); &#125; /* 100% 可以使用 to 代替 */ 100% &#123; transform: translateY(100px); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们还可以设置动画的执行次数，修改上面的样式为 .box &#123; width: 100px; height: 100px; background-color: aqua; animation-name: move; animation-duration: 1s; /* 播放次数默认值为 1 */ animation-iteration-count: infinite;&#125; 我们发现动画执行完毕后，盒子突然就回到了原位置，这个过程有点突兀，我们希望这个过程也是慢慢过渡的，那么我们可以设置animation-direction，animation-direction有四种取值 normal：默认值，正常播放 reverse：反向播放 alternate：如果动画次数在两次或两次以上，那么第偶数次为反向播放，就可以达到回到原位置时也有过渡的效果。若动画只播放一次，则和正向播放一样。 alternate-reverse：若动画只播放一次，则和反向播放一样。若播放两次以上，偶数次效果为正向播放 .box:hover &#123; animation-name: move; animation-duration: 1s; animation-iteration-count: 2; animation-direction: alternate;&#125; animation-play-state用来设置动画的播放状态，有两种取值 running：默认值，动画运行 paused：动画暂停 将样式修改为 .box &#123; width: 100px; height: 100px; background-color: aqua; animation-name: move; animation-duration: 1s; animation-iteration-count: infinite; animation-direction: alternate;&#125; .box:hover &#123; /* 当鼠标放上去时 动画暂停 */ animation-play-state: paused;&#125; animation-fill-mode用来定义动画开始帧之前和结束帧之后的动作，有以下四种取值 none：默认值。动画结束后，元素移动到初始状态(不一定0%的状态，是元素自身的属性值) forwards：元素停在动画结束时的位置(不一定是100%的位置，有可能反向运动) backwards：在animation-delay的时间内，元素立刻移动到动画开始时(不一定是0%，有可能反向运动)的位置。若元素无animation-delay时，与none的效果相同 both：同时具有forwards和backwards 修改样式如下 .box &#123; width: 100px; height: 100px; background-color: aqua;&#125; .box:hover &#123; animation-name: move; animation-duration: 1s; /* 动画结束后，停留在动画结束的位置 */ animation-fill-mode: forwards;&#125; CSS3 flex布局当一个父元素被设置为display:flex时，它就是弹性布局，子元素的float、clear和vertical-align属性将失效。此时我们把父元素称之为container(容器)，把子元素称之为item(项目)。当父元素被设置为弹性布局后，对子元素有什么影响? 先来感受一下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .container &#123; display: flex; width: 500px; height: 400px; background-color: crimson; &#125; .item &#123; width: 100px; height: 100px; background-color: aqua; position: relative; &#125; /* 这个是为了演示方便 样式不重要 不必细看 */ .item div&#123; width: 50%; height: 50%; position: absolute; /* 下面三行语句是为了设置居中对齐 */ top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: brown; /* 圆角边框 */ border-radius: 50%; /* 下面两行设置文字居中对齐 */ text-align: center; line-height: 50px; /* 设置字体样式 */ font-size: 30px; font-weight: 700; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;3&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当父元素设置为flex布局后，其子元素item会在父元素container的主轴上排列。 这里又牵涉到新的概念，主轴(main axis)，flex容器的主轴默认为X轴，即从左向右，既然有主轴，那么就会有侧轴(cross axis)，默认的侧轴为Y轴，即从上往下。 container上的属性直观的感受了一下flex的效果，现在我们来看看flex要设置哪些属性，首先设置在container的flex属性有 flex-direction flex-wrap flex-flow justify-content align-items align-content 下面来一一介绍。 flex-direction是用来设置主轴的，它有以下四个值可选 row：默认值，主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 现在我们分别修改container里面的样式 flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; 为了演示flex-wrap，我们添加9个item(此时flex-direction为默认值row，除非特别声明，否则我们在演示其一个flex属性时，会将其他flex属性设置为默认值) &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;3&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;4&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;5&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;6&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;7&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;8&lt;/div&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;div&gt;9&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 效果为 我们发现9个item排成了一排，没有换行。为了使得item能够换行，我们需要设置flex-wrap，它有三个值可选 nowrap：默认值，不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-wrap: wrap; flex-wrap: wrap-reverse; flex-flow是flex-direction和flex-wrap两个属性的简写，默认值为row wrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content是用来设置item在container在主轴上的对齐方式的，具体对齐方式与轴的方向有关,下面假设主轴为从左到右(row)。有下面几种值可选 flex-start：左对齐 flex-end：右对齐 center：居中对齐 space-between：两端对齐，项目之间间隔相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 这里演示一下space-between和space-around justify-content: space-between; justify-content: space-around; align-items定义了在侧轴上的对齐方式(以从上往下的侧轴为例) first-start：往上对齐 first-end：往下对齐 center：居中对齐 baseline：item的第一行文字的基线对齐。 stretch：默认值，如果没有设置height或者height设置为auto，将占满整个容器的高度 这里演示一下stretch，不设置height .container &#123; display: flex; width: 500px; height: 400px; background-color: crimson; align-items: stretch;&#125;.item &#123; width: 100px; /* height: 100px; */ background-color: aqua; position: relative;&#125;.item div &#123; /* 修改line-height为200px使文字居中 */&#125; align-content，当我们设置flex-wrap为wrap或者wrap-reverse时，item会占据多行，这个属性是用来设置占据多行item在侧轴上的对齐方式，如果没有多行，这个属性无效。有下列值可选(以侧轴为从上往下为例) first-start：往上对齐 first-end：往下对齐 center：居中对齐 stretch：默认值，轴线占据整个侧轴 space-between：两端对齐，轴线之间平均分布 space-around item上的属性下面6个属性是设置在item上的 order flex-grow flex-shrink flex-basis flex self-align order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0，现在设置第2个item的order为1 .item:nth-child(2)&#123; order: 1;&#125; 如果存在剩余空间，那么flex-grow可以用来设置item占据剩余空间的份数(这会导致item增大)，默认值为0，意味着即使有剩余空间，也不增大，现在设置各自的flex-grow .item:first-child &#123; /* 第一个item占 1 / (1 + 2 + 1) = 1/4 的剩余间 */ flex-grow: 1;&#125;.item:nth-child(2) &#123; /* 第二个item占 2/4 的剩余空间*/ flex-grow: 2;&#125;.item:last-child &#123; /* 第三个item占 1/4 的剩余空间 */ flex-grow: 1;&#125; flex-shrink与flex-grow相反，当空间不足时，item缩小的以使得所有item被包含在container中。默认值是1，即每个item会等比例缩小 .item:first-child &#123; flex-shrink: 2;&#125;.item:nth-child(2) &#123; flex-shrink: 2;&#125;.item:last-child &#123; flex-shrink: 2;&#125; 可见第一个、第二个和最后一个缩小的更多。 flex-basis的含义是item在被放进container之前的大小。也就是item理想或假设的大小。默认值为auto，如果不设置这个值，并且主轴是row的话，那么flex-basis就是width的大小，如果主轴是column的话，那么flex-basis就是height的大小，如果width或height也没有设置的话，flex-basis是content的大小。item的宽度是最终的flex-basis，最佳的方法是只使用flex-basis而不是width或height属性。 但是flex-basis不能保证其大小! 一旦将items放入flex容器中，flex-basis的值就无法保证了。这是因为有flex-grow和flex-shrink，可能会被放大或者缩小item的大小。 除此之外，flex-basis还受到min-width, max-width, min-height, max-height的约束。具体见The Difference Between Width and Flex Basis这篇文章，有着十分详细的阐述，绝对让你物超所值。 slef-align属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .container &#123; ... ... align-items: center; flex-wrap: wrap;&#125;.item:first-child &#123; align-self: flex-start;&#125;","tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/CSS3/"}]},{"title":"HTML5超详细了解","date":"2019-12-22T16:00:00.000Z","path":"/HTML5入门/","text":"HTML5属于上一代HTML的新迭代语言，设计HTML5最主要的目的是为了在移动设备上支持多媒体，例如：video标签和audio及canvas标记。 HTML5中语义化标签在HTML5中新增了很多的语义标签，如 header footer nav article aside section … … 比如以前我们使用以下方式来布局 &lt;div class=\"header\"&gt;&lt;/div&gt; 现在可以替换为 &lt;header&gt;&lt;/header&gt; HTML5可以让很多更语义化的结构化代码标签代替大量无意义的div标签 这种语义化的特性提升了网页的质量和语义 减少了以前用于CSS 调用的class和id属性 并且对搜索引擎的友好，新的结构标签带来的是网页布局的改变及提升对搜索引擎的友好。 但是现在碰到一个问题，由于这些具有语义的标签是HTML5新增的，这就意味着在IE8及以下版本的IE浏览器中不支持，如下面的样式在IE8中就不能够正常的显示 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; header &#123; background-color: red; height: 400px; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 解决办法： 在script中创建语义标签header，并且将header的display设置为block &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; header &#123; background-color: red; height: 400px; width: 100%; display: block; &#125; &lt;/style&gt; &lt;script&gt; document.createElement(\"header\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 使用1的方法，意味着对每个语义标签都要创建元素，这样未免比较麻烦，更好的办法是使用插件，引入html5shiv.js文件，该插件的实质还是创建了语义元素 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; header &#123; background-color: red; height: 400px; width: 100%; &#125; &lt;/style&gt; &lt;script src=\"html5shiv.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 上面的方法还有需要改进的地方，比如在谷歌浏览器中完全支持HTML5，这就意味着在渲染HTML网页时不需要下载html5shiv.js文件，但是上面的方法是在任何的浏览器中都会下载的，所以再次改进如下 &lt;!--[if lte IE 8]&gt; &lt;script src=\"html5shiv.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上面的代码只有IE浏览器才会识别，意思是如果IE浏览器的版本是IE8及以下的版本，才会下载这个js文件，在其他浏览器中会认为这时注释，自动忽略。 video和audio在浏览器中插入视频和音频文件，以往是使用flash来实现，但是在移动端使用flash就会比较慢，HTML5给了两个新的标签，用来插入视频和音频文件。二者的使用相似，现以video为例介绍该标签的属性 属性 作用 src 值为视频文件的路径 controls 显示控制台 autoplay 自动播放 loop 循环播放 … … … … 还有一些属性没有介绍，以上是较为常用的，剩余的请参考网站HTML5视频。这里给出一个实例 &lt;video src=\"resources/video.mp4\" controls autoplay loop&gt;&lt;/video&gt; 另一个需要注意的是，目前只支持三种格式的视频 Ogg MPEG 4(mp4) WebM 并且不同的浏览器支持的程度也不一样，具体的可以参考上面的链接。那么这个时候怎么办? 我们不能这么写 &lt;video src=\"test.mp4\"&gt;&lt;/video&gt;&lt;video src=\"test.ogg\"&gt;&lt;/video&gt;&lt;video src=\"test.WebM\"&gt;&lt;/video&gt; 虽然我们的本意是：如果支持.mp4，那么就使用.mp4，否则如果支持.ogg，则用.ogg，以此类推。但是上面的效果是出现3个video，而不是一个，这个时候的解决办法是使用source标签，如下 &lt;video&gt; &lt;source src=\"test.mp4\"&gt; &lt;source src=\"test.ogg\"&gt; &lt;source src=\"test.WebM\"&gt;&lt;/video&gt; 这个时候达到的效果就是我们想要的。 表单HTML5在表单这里也做了很多的改进，比如新增了一些属性以进行表单验证(以往这些工作我们都是使用JavaScript进行正则表达式的验证)，以及新的标签和方法。 智能表单控件 emial url number range color date month week time 首先用法如下 &lt;form action=\"test\" method=\"get\"&gt; email: &lt;input type=\"email\"&gt; &lt;br&gt; url: &lt;input type=\"url\"&gt; &lt;br&gt; number: &lt;input type=\"number\"&gt; &lt;br&gt; range: &lt;input type=\"range\"&gt; &lt;br&gt; color: &lt;input type=\"color\"&gt; &lt;br&gt; date: &lt;input type=\"date\"&gt; &lt;br&gt; week: &lt;input type=\"week\"&gt; &lt;br&gt; time: &lt;input type=\"time\"&gt; &lt;br&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; 当type设置为emial时，如果输入的不是电子邮箱，当点击提交按钮时，不能提交成功，并给出提示信息 当type设置为url时，如果输入的不是url地址，那么当点击提交按钮时，也不能提交成功，并给出提示信息 正确的url地址应该以http或者https开头，如http://www.baidu.com。 当type设置为number时，这时在控件里面只能输入数字，当你按其他键时没有反应，可以自行实验看看效果。 当type设置为color时，点击color后的颜色，会出现拾色器，可以选择颜色，如下 设置type设置为date, week, time时，显示的是各种格式的时间，这里不多加解释想必可以明白。 表单属性form表单的属性 autocomplete 直译过来就是自动完成，当我们提交表单后，表单会记录我们提交的内容，当我们再次填写时，它会给出我们已经提交过的内容作为提示信息。有时这种情况下可能会造成信息的泄漏，不安全，我们可以将autocomplete设置为off，这时就不会出现上面的情况。默认情况下autocomplete为on &lt;form action=\"test\" method=\"get\" autocomplete=\"off\"&gt; ... ...&lt;/form&gt; novadilate 上面我们提到，当我们使用智能表单控件时，如果不能满足格式的要求，如email，则不能提交成功，当表单添加novadilate属性时，那么这时即使所填写的格式不满足要求，那么也可以提交成功。 &lt;form action=\"test\" method=\"get\" autocomplete=\"off\" novalidate&gt; ... ...&lt;/form&gt; input的属性 autofocus 自动获得焦点，我们先来看一个淘宝的案例 当我们进入淘宝，搜索框会自动的获得焦点，用户可以直接输入，不需要用鼠标先点击搜索框获得焦点才能输入。input添加autofocus的属性即可有这种效果。 form 先来看这么一个结构 &lt;form action=\"test\" method=\"get\"&gt; &lt;input type=\"text\" name=\"one\"&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;input type=\"text\" name=\"two\"&gt; 我们可以知道当提交form表单时，只会提交表单域里面的表单，表单域外的表单不会提交，所以当我们提交时，只会有one的数据才会提交 但是如果希望当提交时，two的数据也能进行提交(别奇怪，真的有这种需求)，这个时候就需要用到form属性了 &lt;form id=\"data\" action=\"test\" method=\"get\"&gt; &lt;input type=\"text\" name=\"one\"&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;input type=\"text\" name=\"two\" form=\"data\"&gt; form属性的值为form表单的id值。这时再次进行提交 这时two的数据也得到了提交。 list list属性要配合HTML5新添加的表单标签&lt;datalist&gt;使用，如下 &lt;input type=\"text\" list=\"list\"&gt;&lt;datalist id=\"list\"&gt; &lt;option value=\"One\"&gt;&lt;/option&gt; &lt;option value=\"Two\"&gt;&lt;/option&gt; &lt;option value=\"Three\"&gt;&lt;/option&gt;&lt;/datalist&gt; list属性的值为datalist标签的id值。当我们在text中输入时，会有datalist中option值的提示 multiple multiple可以实现多选的效果，比如选择多个文件，假设有下面的input标签 &lt;input type=\"file\"&gt; 这时只能选择一个文件，为了选择多个文件，我们为input标签添加multiple属性 &lt;input type=\"file\" multiple&gt; 这时就可以选择多个文件了。 placeholder 使用placeholder作为提示信息，假设有如下标签 &lt;input type=\"text\" placeholder=\"请输入信息\"&gt; 当我们输入文字时，提示信息会消失，当我们将文字消失时，文字又会出现。 required 当input使用该属性时，表示该input控件是必填项，否则无法提交，具体可以自己试验一下，这里就不演示了。 HTML5 API获取DOM元素假设有如下的html结构 &lt;ul&gt; &lt;li&gt; &lt;span&gt;span1&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;span&gt;span2&lt;/span&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 如果我们要改变span的样式(通过JS)，我们我们一般要为span标签添加id属性或者class属性，这样才能获取要对应的DOM元素，HTML5新增了两个方法 querySelector()：只能选择一个元素 querySelectorAll()：可以选择所有符合条件的元素 可以向其中传入选择器(任何CSS支持的选择器)，从而来选择DOM元素，如 //使用子代选择器选择span元素document.querySelector(\"li&gt;span\").style.color = \"red\"; 类名操作有时候我们需要为某个标签添加或者移除类样式，HTML5为我们提供了API接口 classList.add()：为DOM元素添加指定的类样式 classList.remove()：为DOM元素移除指定的类样式 classList.toggle()：切换，意思即如果DOM元素有这个类样式，则移除这个类样式，如果没有这个类样式，这添加这个类样式 classList.contains()：判断该DOM元素是否包含这个类样式，包含则返回true，否则返回false。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active &#123; width: 100%; height: 100px; background-color: darkred; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;button class=\"add\"&gt;添加类名&lt;/button&gt; &lt;button class=\"remove\"&gt;移除类名&lt;/button&gt; &lt;button class=\"toggle\"&gt;切换类名&lt;/button&gt; &lt;button class=\"contains\"&gt;是否包含类名&lt;/button&gt; &lt;script&gt; document.querySelector(\".add\").onclick = function () &#123; document.querySelector(\"div\").classList.add(\"active\"); &#125; document.querySelector(\".remove\").onclick = function () &#123; document.querySelector(\"div\").classList.remove(\"active\"); &#125; document.querySelector(\".toggle\").onclick = function () &#123; document.querySelector(\"div\").classList.toggle(\"active\"); &#125; document.querySelector(\".contains\").onclick = function () &#123; console.log(document.querySelector(\"div\").classList.contains(\"active\")); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义属性HTML5规定自定义属性需要以data-开头，如 &lt;div data-test=\"one\"&gt;&lt;/div&gt; 上面自定义了一个叫test的属性，我们可以通过DOM元素的dataset来访问或者修改自定义属性的值，有两种方式 dataset.属性名 dataset[“属性名”] &lt;div data-test=\"one\"&gt;&lt;/div&gt;&lt;script&gt; console.log(document.querySelector(\"div\").dataset.test); document.querySelector(\"div\").dataset[\"test\"] = \"two\";&lt;/script&gt; 如果属性名之间使用-之间连接，如下 &lt;div data-test-name=\"one\"&gt;&lt;/div&gt; 那么使用dataset访问或修改时要使用驼峰命名法获取，如下 console.log(document.querySelector(\"div\").dataset.testName);document.querySelector(\"div\").dataset[\"testName\"] = \"two\"; 文件读取FileReader是用来读取上传的文件的，它有3个读取的方法 readAsText()：读取文本文件，返回文本字符串(utf-8) readAsBinaryString()：读取任意文件，返回二进制文件 readAsDataURL()：读取任意文件，得到包含一个data:URL格式的字符串(base64编码)，以表示所读取文件的内容 上面三个方法读取的内容都会放在FileReader对象的result属性中。 现在演示一个案例，选择上传的图片，在上传之后希望有预览的效果 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\"&gt;&lt;br&gt; &lt;br&gt; &lt;img src=\"\" width=\"800\"&gt;&lt;/img&gt; &lt;script&gt; //获得input DOM元素 let input = document.querySelector(\"input\"); //获得img DOM元素 let image = document.querySelector(\"img\"); //当input发生改变时即有文件上传时触发该事件 input.onchange = function () &#123; //获得上传的文件对象 let file = input.files[0]; //获得FileReader对象 let reader = new FileReader(); //使用FileReader读取该图片，得到一个base64格式的编码 reader.readAsDataURL(file); //reader读取完毕后触发该事件 reader.onload = function() &#123; //将读取到的base64编码格式的URL赋值给img标签的src属性 image.src = reader.result; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，我们用到了FileReader对象的onload事件，这里列出FileReader提供的事件 onabort：中断时触发 onerror：出错时触发 onload：文件读取成功完成时触发 onloadend：读取完成触发，无论成功或失败 onloadstart：读取开始时触发 onprogress：在读取过程中持续触发 获取网络状态HTML5提供了有关网络状态的API，使用window.navigator.onLine可以获取当前的网络状态，返回一个布尔值。除此之外，还提供了两个网络事件 ononline()：连上网络的时候触发 onoffline()：断开网络的时候触发 window.ononline = function () &#123; console.log(\"online\");&#125;window.onoffline = function () &#123; console.log(\"offline\");&#125; 本地存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案，使用sessionStorage和localStorage存储数据。 sessionStorage的大小大约为5M左右，它的生命周期为当前页面，即当关闭当前页面时，存储在本地的数据会被清除。并且不同页面之间的sessionStorage是独立的，不能互相访问。sessionStorage的方法有 setItem(key, value)：存储键值对 getItem(key)：根据key获取对应的value removeItem(key)：删除key所对应的键值对 clear()：清除sessionStorage本地缓存 localStorage的大小为20M左右，它的生命周期为当前浏览器。关闭浏览器不会清除数据，数据存储在硬盘上，只能手动清除。localStorage的方法同sessionStorage。","tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTML5","slug":"HTML5","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/HTML5/"}]},{"title":"史纲","date":"2019-10-21T16:00:00.000Z","path":"/史纲/","text":"反侵略斗争鸦片战争 中英–南京条约 中英–虎门条约 中美–望厦条约 中法–黄埔条约 丧失了很多的主权(领土，领海，司法，关税)，社会性质发生变化，逐步成为半殖民半封建社会。(辛丑条约，正式沦为两半社会) 两半社会 原因 已经丧失了独立的地位(殖民地)，仍然维持着独立国家和政府的名义(半) 中国卷入世界资本主义经济体系，西方列强不愿中国成为独立的资本主义国家(半封建) 特征 帝国主义成为决定性力量 中国封建势力成为统治工具 封建土地所有制还保留着 民族资本主义发展缓慢，力量软弱 政治、经济和文化发展极不平衡(高度概括，单选就选这个) 广大人民水深火热 阶级关系变化 地主 农民 工人阶级(新兴阶级)：最早出现的新阶级 资产阶级 官僚买办：跟封建势力勾结(官僚)，跟帝国主义勾结(买办) 民族资本：本土成长起来的 (小资产阶级)：不是资产阶级，是劳动人民，虽然小有资产，但是不剥削别人 主要矛盾 帝国主义和中华民族的矛盾(主要中的主要) 封建主义和人民大众的矛盾 近代以来历史任务 争取民族独立、人民解放(反帝反封建) 实现国家富强、人民富裕 时间 国情 矛盾 任务 道路 1840-1949 半殖民地半封建 帝国主义和中华民族的矛盾，封建主义和人民大众的矛盾 反帝反封建 农村包围城市，武装夺取政权 现代 社会主义初级阶段 日益增长的生活需要与发展不平衡不充分的矛盾 解放发展力 中国特色社会主义道路 斗争历程 人民群众 三元里人民的抗英斗争，第一次中国人民第一次大规模反侵略 爱国官兵 鸦片战争时期：关天培，陈化成，海岭 中日甲午：邓世昌 粉碎瓜分中国的阴谋中日甲午战争爆发后达到瓜分高潮，马关条约 台湾、澎湖列岛割给日本 俄、德、法干涉还辽 破产的原因 列强之间的矛盾，相互制约(重要原因) 中华民族进行不屈不挠的反侵略斗争(根本原因) 义和团的局限性 笼统的排外(只要跟外国人有关的就杀) 受到封建统治者的欺骗 存在迷信、落后的倾向 义和团的作用 在粉碎列强瓜分中国的斗争中，发挥了重大的历史作用 反侵略失败原因 制度腐败(根本原因) 经济技术落后(重要原因) 民族意识的觉醒 鸦片战争：先进的中国人睁眼看世界 中日甲午战争：民族意识普遍觉醒 林则徐：近代中国睁眼看世界的第一人 魏源：《海国图志》—— 师夷长技以制夷 严复：《救亡决论》，翻译了《天演论》(物竞天择) 孙中山：振兴中华 各阶层的探索 农民阶级 封建阶级 资产阶级 维新派 革命派 无产阶级 太平天国原因 赋税增加，农民负担加重 自然经济解体(社会不稳定) 评价：反对清政府腐朽统治和地主阶级压迫、剥削的正义战争 结局：天京事变，天平天国由盛转衰 《天朝田亩制度》内容 体现太平天国的纲领性文件 确立了平均分配土地的方案，耕者有其田 实际上是起义农民提出的一个以解决土地问题为中心比较完整的社会改革方案 评价 进步性：主张上否定了封建社会的基础即封建地主的土地所有制(实际上没有否定) 局限性： 没有超出农民小生产者的狭隘思想 具有不切实际的空想性质 未付诸实施 《资政新篇》内容 开始提倡资本主义的雇佣劳动制 评价 进步性：具有资本主义色彩 局限性：未能付诸实施 天平天国运动的意义及局限意义 沉重打击了封建统治 中国旧式农民战争的最高峰 冲击了孔子和儒家经典的正统权威 有力打击了外国侵略势力 19世纪中叶亚洲民族解放运动中，时间最久、规模最大、影响最深的战争 失败的原因(重要) 阶级局限性(根本原因) 无法从根本上提出完整的、正确的政治纲领和社会改革方案 无法制止领导集团腐败现象的滋长 无法长期保持领导集团的团结 没有科学理论的指导 未能正确地对待儒学 对西方资本主义侵略者还缺乏理性的认识 教训：农民不能为中国找到出路。 洋务运动(封建地主阶级)原因 首先是为了购买洋枪洋炮镇压农民起义 同时也加强海防、边防 指导思想(纲领)：中体西用 中国的制度，西方的技术 洋务事业 兴办近代企业 军用企业 民用企业(官督商办) 建立新式海陆军：北洋水师 创办新式学堂，派遣留学生(推荐央视纪录片《幼童》) 翻译学堂 工艺学堂 军事学堂 历史作用 对中国早期工业发展有促进作用 给中国带来了新知识，打开了眼界 工商业者的地位上升(古代商人的政治地位极低) 失败的原因(重要)甲午战争北洋海军全军覆没，标志着洋务运动失败。失败的原因是 封建性(根本原因) 对外国具有依赖性 洋务企业的管理具有腐朽性 教训：地主不能为中国找到出路 总结：甲午战争的失败标志着 民族意识普遍觉醒 列强瓜分中国达到高潮 洋务运动失败 戊戌维新原因 中国民族资本有了初步发展 人民形成共识：要救国，只有维新，要维新，只有学外国(主要是日本) 活动 公车上书 著书立说 介绍外国变法的经验教训 办学会 设学堂 办报纸 维新派与守旧派(洋务派)的论战三个问题 要不要变法 要不要实行君主立宪 要不要废八股、改科举(清末新政废科举)和兴西学 意义 资产阶级思想与封建主义思想的正面交锋 进一步开阔了新型知识分子的眼界 使西方资产阶级社会政治学说在中国得到进一步的传播 百日维新 政治方面：改革行政机构，裁撤闲散、重叠机构 经济方面：保护、奖励农工商业 军事方面：裁剪旧式绿营军，改练新式陆军 文化教育：京师大学堂(后来的北大)，废八股 进步性：是资产阶级性质的改良运动 局限性：未触动封建制度的根本，是十分温和的改良方案(要暴力革命) 结果： 戊戌六君子被杀 除京师大学堂被保留，其余全部被废除 意义和教训意义 爱国救亡运动 资产阶级性质的政治改良运动 思想启蒙运动，京师大学堂成为中国近代国立高等教育的发端 失败的原因 民族资产阶级力量弱小(客观原因，力量弱小不属于阶级局限性) 唯新派的局限性(主观原因) 不敢否定封建主义 对帝国主义抱有幻想 惧怕人民群众(没有发动群众，是精英运动) 教训：资产阶级维新派不能为中国找到出路。 辛亥革命历史条件 民族危机加深 辛丑条约：标志着中国正式沦为两半社会 清末“新政”破产 废除科举 预备仿行宪政(君主立宪) 颁布《钦定宪法大纲》(近代中国的第一部宪法) 资产阶级革命派的阶级基础和骨干力量开始成熟 资产阶级、小资产阶级知识分子(精英运动，没有发动群众) 准备工作 孙中山组建第一个革命团体兴中会 … … 在日本成立中国同盟会(第一个全国性政党) 革命的纲领：三民主义学说同盟会的政治纲领：“驱除鞑虏，恢复中华，创立民国，平均地权”。孙中山概括为三大主义：民族主义，民权主义，民生主义 民族主义，即民族革命 推翻清朝政府 追求独立 局限性(不反帝，反封不彻底)： 没有明确的反帝纲领 放松了汉族封建势力，结果就保留了封建势力，导致辛亥革命后封建势力的反扑(袁世凯) 民权主义，即政治革命 创立民国，推翻封建君主专制制度 建立资产阶级民主共和国 局限性： 归根到底建立资产阶级专政国家，广大人民群众的民主权利很难得到保证 民生主义(考的多)，即社会革命，指的是平均地权 现有地价归原主 增价归国家，为国民共享 局限性：并非将土地所有权给农民，没有真正触及封建土地所有制，不能满足广大农民的土地要求，革命中难以成为发动广大工农群众的理论武器。(没地的还是没地，不是耕者有其田) 与改良派(维新派)的辩论舆论阵地 《民报》 《新民丛报》 主要问题有三个 要不要以革命的手段推翻清王朝(论战的焦点) 要不要推翻帝制，实行共和 要不要进行社会革命 意义 划清了革命与改良的界限 传播了民主革命思想，促进了革命形势的发展 但也暴露了革命派在思想理论方面的弱点 走精英路线 不反帝，反封不彻底 不分地 总结： 洋务派：君主专制 维新派：君主立宪 革命派：实行共和 武昌起义与封建帝制的覆灭 第一次武装起义是萍、浏、醴起义(同盟会) 黄花岗起义(也称广州起义) 共进会和文学社在武昌举行武装起义(辛亥革命) 中华民国的建立1912年1月1日，孙中山在南京就职改国号为中华民国，成立中华民国临时政府。南京临时政府是一个资产阶级共和国性质的革命政权 政权组成人员上看，资产阶级革命派占主体地位 从南京临时政府制定的政策看，反映了中国民族资产阶级的愿望和利益 临时参议院颁布《中华民国临时约法》(第二部宪法) 中国历史上第一部具有资产阶级共和国宪法性质的法典 规定：中华民国之主权属于国民全体 评价 进步性 是革命的产物，具有革命性，民主性 不仅具有现实的进步意义，在中国宪政史上也占有重要地位 局限性 企图承认清政府签订的条约 没有提出满足农民要求的政策，反而维护封建土地制度 历史意义 推翻了清王朝的统治，打击了中外反动势力 建立了中国历史上第一个资产阶级共和政府，使民主共和观念深入人心 带来了思想上的解放 促使社会经济、思想习惯和社会风俗发生了积极变化(剪辫) 不仅在一定程度上打击了帝国主义的侵略，而且推动了亚洲各国民族解放运动的高涨 封建军阀专制统治的形成 在政治上：北洋政府实行军阀官僚的专制统治 在经济上：北洋政府竭力维护帝国主义(日本)、地主阶级和买办资产阶级的利益 在文化思想：尊孔复古思想猖獗一时(因为袁世凯想当皇帝) 袁世凯死后，中国陷入军阀割据，原因是 中国是地方性农业经济，没有形成统一的资本主义市场 帝国主义国家在中国采取划分势力范围的分裂剥削政策 失败的原因及教训宋教仁被暗杀 &lt;– 二次革命(孙中山针对宋教仁被杀发动的) 袁世凯复辟 &lt;– 护国运动(孙中山针对袁世凯复辟发动的) 段祺瑞拒绝恢复临时约法 &lt;– 护法运动(国民党要求段祺瑞恢复临时约法，孙中山发动)，护法运动的失败也标志着整个中国民族资产阶级领导的旧民主主义革命的终结。 教训：中国民族资本阶级再也不能领导中国革命前进了。 失败的原因 客观上，在帝国主义时代，在两半的中国，资本主义建国的方案行不通 主观上，领导者资产阶级革命派本身存在许多弱点和错误(阶级局限性) 没有提出彻底的反帝反封建的革命纲领 不能发动群众 不能建立坚强的革命政党 总结: 中共 成功：懂得将马克思主义与中国的实际相结合 失败：不能将马克思主义与中国的实际相结合 非中共 成功：不可能 失败：阶级局限性(主观) 资产阶级革命派的这些弱点、错误，根源于中国民族资产阶级的软弱性和妥协性 中国共产党是孙中山先生开创的革命事业最坚定的支持者、最亲密的合作者、最忠实的继承者 总结： 民资的两面性 妥协性 革命性 马克思主义的传播新文化运动与思想解放的潮流 1915年9月陈独秀在上海创办《青年》杂志开始的(后改为《新青年》) 蔡元培出任北京大学校长，聘请陈独秀为北大文科学长 《新青年》杂志和北京大学成为了新文化运动的主要阵地 初期新文化运动的基本内容 提倡民主和科学 提倡个性解放 提倡新文学 新文化提出的基本口号：民主和科学，即德先生(Democracy)和赛先生(Science) 五四以前新文化运动的历史意义 中国历史上前所未有的启蒙运动和思想解放运动 为马克思主义在中国传播准备了条件 五四以前新文化运动的局限性 并不能为人们提供一种思想武器去认识中国 仅仅依靠少数人的呐喊(精英路线) 许多领导人物，还没有马克思主义的批判精神(辩证法)，一般还是资本阶级的方法(形而上) 十月革命对中国的影响 经济文化落后的国家也可以用社会主义思想指引自己走向解放之路 有力的推动了社会主义思想在中国的传播 给予中国先进分子以新的革命方法(群众路线) 李大钊《我的马克思主义观》：李大钊是中国第一个马克思主义者。 在五四运动前，信仰马克思主义的，只是李大钊这样的个别人物。 五四运动的发生和发展社会历史条件： 新的社会力量的成长、壮大 新文化掀起思想解放的潮流 俄国十月革命对中国的影响 五四运动的直接导火线，是巴黎和会上中国外交的失败。 巴黎和会(一战战胜国对战败国的审判会) 中国是战胜国，日本也是战胜国(日本在中国山东青岛打了德国)，国际社会要求将山东交给日本 消息传回国内，爆发五四运动。可以参考电影《我的1919》(外交官顾维钧) 新民主主义革命的开端(超级重要)五四运动的新特点： 表现了反帝反封建的彻底性 是一次真正的群众运动 促进了马克思主义在中国的传播与中国工人运动的结合 发生在俄国十月革命之后，发生在无产阶级社会主义革命的新时代 结论：中国的民族民主革命，在十月革命后就属于世界无产阶级社会主义革命的一部分了。 革命的所属范围(中国革命与世界革命的关系) 旧民主主义革命：世界资产阶级革命 新民主主义革命(自己是资产阶级革命)：属于世界无产阶级社会主义革命的一部分 领导阶级 对象(任务) 性质 所属范围 旧民主主义革命 资产阶级 反帝反封建 资产阶级革命 世界资产阶级革命的一部分 新民主主义革命 无产阶级 反帝反封建 资产阶级革命 世界无产阶级革命的一部分 社会主义革命 无产阶级 反资 无产阶级革命 世界无产阶级革命的一部分 五四运动成为了新民主主义革命的开端。 中国共产党的诞生 早期“马克思主义”队伍 党小组 中国共产党 早期马克思主义运动队伍： 五四以前新文化的精神领袖：李大钊，陈独秀 五四爱国运动的左翼骨干：毛泽东，周恩来 原中国同盟会会员：董必武 … 特点： 重视马克思主义基本理论的学习(强调暴力革命)，与第二国际(强调改良，修正主义，被阉割过的马克思主义)的社会民主主义划清界限 注意从中国的实际出发 开始提出知识分子与劳动群众相结合 与中国工人的结合 1920年8月，第一个共产党组织在上海建立 主要工作 加强对马克思主义的研究和宣传 在工人中进行宣传和组织工作 建立社会主义青年团(后面也叫共青团) 进行有关建党问题的研究和讨论 中国共产党诞生(背)中国共产党诞生的历史必然性(为什么历史选择了党)： 近代以来，为改变中华民族的命运，中国人民和无数仁人志土进行了干辛万苦的探索和不屈不挠的斗争。然而不触动封建根基的自强运动和改良主义，旧式的农民战争，资产阶级革命派领导的革命，照搬西方资本主义的其他种种方案，都不能完成中华民族救亡图存的民族使命和反帝反封建的历史任务。中国的发展进步，客观上要求有能够指导中国人民进行反帝反封建革命的先进理论，有能够领导中国社会变革的先进社会力量。中国共产党的诞生成为历史发展的必然。(中国很惨，他们不行，需要我来) 1921年7月23日，中国共产党第一次全国代表大会于在上海举行。大会确定党的名称为中国共产党。 成立时的历史特点： 十月革命后，第二国际主义、修正主义遭到破产后 中国工人受三重压迫，具有坚定的革命性 当时中国共产党要加强自身建设的原因： 工人阶级的人数不多，出身小资产阶级的党员占有相当大的数量，新生中国共产党受到严重影响 幅员辽阔、人口众多、情况复杂 伟大意义： 有了党，中国革命有了坚强的领导力量 使中国有了科学的指导思想 有了崭新的奋斗目标和纲领 有了新的革命方法(群众路线) 制定革命纲领，发动工农运动分清敌友是革命的首要问题。 中共二大： 反帝反封建的民主革命的纲领 开始采取民族资产阶级、小资产阶级的政党和政治派别。采取群众路线 发动工农群众开展革命斗争： 工人罢工 … … 国共合作第一次合作 “打倒列强，除军阀”成为人民的强烈愿望 中共三大决定全体共产党以个人民义加入国民党(党内合作)，同国民党建立统一战线 新三民主义： 在民族主义中突出反帝的内容 在民权主义中强调民主权利应“为一般平民所共有” 在民生主义概括为“平均地权”和“节制主张”两大原则(后来又提出了“耕者有其田”) 结论：因为新三民主义同中国共产党在民主革命阶段的纲领一致，因此新三民主义是国共合作的共同纲领，国共一大的召开标志着第一次国共合作的正式形成。 时期 标志性事件 统一战线 1925-1927 大革命时期(北伐) 五卅(sa)运动 国民革命统一战线(国共合作统一战线) 1927-1937 土地革命战争时期 八七会议 工农民主统一战线 1937-1945 抗日战争时期 西安事变 抗日民族统一战线 1945-1949 解放战争时期 国民党进攻中原解放区 人民民主统一战线 毛泽东发表《国民革命与农民问题》：农民问题是国民革命的中心问题。 国民合作全面破裂，四一二反革命政变和七一五反革命成为大革命失败的标志。 大革命的意义： 基本推翻了北洋军阀 教育和锻炼了各革命阶级 提高了中国共产党在全国人民的政治威望 失败的原因： 客观：反革命力量强大 主观： 犯了以陈独秀为代表的右倾机会主义错误，放弃了领导权(特别是武装) 不善于将马列主义的基本原理和中国革命的实践相结合(根本原因) 共产国际不了解中国实际情况，瞎指挥(遵义会议以前只要失败了就会有这个原因) 经验教训： 必须建立工、农、小资和民资在内的革命统一战线(朋友还得要) 无产阶级领导权的中心问题是农民问题 必须要有军队(国共第一次合作时没有军队) 加强思想、政治、组织建设，将马列主义同中国实际情况结合 大革命的失败与土地革命的兴起国民党统治全国 张学良改易旗帜，服从国民党的领导 国民党实行清党分共政策 国民党退化了，同北洋军阀没有本质区别 国情没变，革命对象没变，革命性质也没有变 土地革命兴起八七会议： 彻底清算陈独秀右倾机会主义错误 提出土地革命是中国资产阶级民主革命的中心问题 毛泽东：政权是由枪杆子中取得的 评价：挽救党和革命 总结：特别重要的会议 八七会议 遵义会议 十一届三中全会 南昌起义是中国共产党领导革命战争、创建人民军队和武装夺取政权的开端。(南昌起义开始有了自己的军队) 南昌起义 秋收起义 广州起义 农村包围城市、武装夺取政权的道路 《中国的红色政权为什么能够存在?》和《井冈山的斗争》：论证了红色政权能够长期存在并发展的主客观条件 《星星之火，可以燎原》：农村包围城市、武装夺取政权的道路 《反对本本主义》： 没有调查，没有发言权 中国革命斗争的胜利要靠中国同志了解中国情况 结论：农村包围城市、武装夺取政权的道路理论的提出，标志着毛泽东思想的初步形成。 土地政策： 消灭封建地主的土地私有制，实现农民的土地私有制 井冈山土地法(第一个土地法)，可以抢地 兴国土地法(第二个土地法)，没收公共的地和地主的地 依靠贫农、雇农，联合中农，限制富农，保护中小工商业者，消灭地主 按人口平分土地(耕者有其田) 第一个可以付诸实施的比较完整的土地革命纲领和路线。 农村革命根据地的建设： 第一次全国工农代表大会在江西省瑞金县叶坪村举行(从此有了自己的政权) 通过了《中华苏维埃共和国宪法大纲》(第三部宪法)，成立xxx中央政府，毛泽东任主席 实现工农兵代表大会制度 土地革命的严重错误： 第一次是左倾盲动错误 第二吃是左倾冒险错误 第三次是以王明为代表的左倾教条主义(导致第五次反围剿战争失败) 混淆了民主革命与社会主义革命的界限(反资了) 坚持以城市为中心 提出坚决打击富农 实行进攻中的冒险主义、防御中的保守主义、退却中的逃跑主义 拉帮结派，排除异己(毛泽东这时很惨) 为什么会犯错： 八七会议后一直存在着浓厚的左倾情绪 共产国际瞎指挥 不懂得将马列同中国实际情况相结合(根本原因) 遵义会议遵义会议解决了军事问题和组织问题 政治问题：瓦窑堡(bu)会议 思想问题：延安整风运动 遵义会议：挽救党的命运，中国共产党在政治上走向成熟。(不听共产国际的了) 总结历史经验 《论反对日本帝国主义的策略》：系统解决了党的政治路线问题 《中国革命战争的战略问题》：系统说明了中国革命战争战略方面的诸问题 《矛盾论》《实践论》：揭露了党内的主观主义尤其是教条主义的错误，马列原理要与实际相结合，阐明了党的马克思主义思想路线 抗日战争日本灭亡中国的计划 占东北 1931年9月18日，日本发动九一八事变(抗日战争的起点) 图华北 全面抗战 1937年7月7日爆发卢沟桥事变，日本全面侵华 中国共产党举起武装抗日的旗帜 1931年九一八事变是中国抗日战争的起点，局部抗战揭开了反法西斯战争的序幕 八一宣言，呼吁停止内战，一致抗日 一二九运动，标志着中国人抗日救亡运动新高潮的到来 瓦窑堡会议(核心词：抗日民族统一战线) 西安事变 西安事变：十年内战由此结束 抗日民族统一战线的形成瓦窑堡会议(抗日民族统一战线)： 阐明了抗日民族统一战线的可能性 工人、农民、小资是抗日的 民资的两面性，是可能抗日的 地主有的是可以联合的 批判了左倾关门主义错误，强调中国共产党的领导作用 “人民共和国”代替“工农共和国” 全面性抗战的开始国民党《中国共产党为公布国共合作宣言》，蒋介石实际承认共产党合法地位的谈话标志着国共第二次合作： 不仅包括工人、农民、小资、民资，还包括以蒋介石为代表的亲英美派大地主大资产阶级 有政权有军队的合作(第一次没有) 没有共同纲领(第一次合作有共同纲领：新三民主义) 战略防御阶段和相持阶段的正面战场广州、武汉失守，标志着进入了战略相持阶段 战略防御(敌进我退) 战略相持(退无可退) 战略反攻(估计就那么) 正面战场：台儿庄战役大捷，其他全部都是失败 客观原因：敌我力量悬殊 主观原因：国民党战略指导方针的失误 实行片面抗战 不敢放手发动群众，只寄存与正规军 日本对国民党：政治诱降为主，军事打击为辅 国民党对中国共产党态度：防共、反共 全面抗战的路线和持久战的方针 实行全面抗战(洛川会议) 人民战争路线，发动人民群众 必须坚持无产阶级的领导权 采取持久战的战略方针(《论持久战》) 日本是强国，中国是弱国，只能持久战 日本是小国，发动战争，国际上失道寡助，中国是大国，进行反侵略战争，国际上得道多助 敌后战场 平型关大捷是中国军队取得的第一次重大胜利，粉碎了日军不可战胜的神话 游击战被提到了战略的地位，具有全局性的意义 在战略防御阶段，正面战场是主要的 在战略相持阶段，敌后游击战成为主要的抗日作战方式 游击战为人民军队进行战略反攻准备了条件 坚持抗战、团结、进步的方针 统一战线中的独立自主原则(领导权) 坚持抗战、团结、进步 巩固抗日民族统一战线的策略总方针 发展进步势力，争取中间势力，孤立顽固势力 进步势力：工农小资 中间势力：民资，条件： 中国共产党有充足的力量 尊重它们的利益 同顽固势力斗争，并能取得胜利 顽固势力：大地主、大资产阶级的抗日派(蒋介石的国民党)，原则：有理、有利、有节 抗日民主根据地建设 政治：三三制的民主政权建设 共产党1/3，非党的左派进步分子和不左不右的中间派各占1/3 经济：减租减息，发展生产 地主要减租减息改善农民生活 农民要交租交息照顾地主富农的利益 文化 抗日军事政治大学、鲁迅艺术学院、延安自然科学院 大后方的抗日民主运动各界人士要求国民党实行抗战民主 宪政运动 《光明报》 提出废除国民党一党专政 新民主主义理论的系统阐明中共六届六中全会，毛泽东明确提出“马克思主义中国化”这个命题，毛泽东撰写了《&lt;共产党人&gt;发刊词》《中国革命和中国共产党》《新民主主义理论》 揭示了两半的国情，近代中国社会的主要矛盾和中国革命发生和发展的原因 中国革命运动：民主主义革命和社会主义革命两个阶段在内的全部革命运动 阐明了中国共产党在新民主主义革命阶段的基本纲领 总结了中国共产党以来的历史经验，指出统一战线、武装斗争、党的建设是三大法宝 新民主主义理论的系统阐明，标志着毛泽东思想达到成熟 延安整风解决思想问题： 《改造我们的学习》：反对主观主义整学风(党的高级干部) 《整顿党的作风》：反对宗派主义整党风(全党党员) 《反对党八股》：反对党八股整文风(全党党员) 学风问题： 是思想方法问题 是对待马列主义的态度问题 是工作态度问题 结论：学风问题是第一个重要的问题 主观主义： 实质是理论脱离实际，是实际工作中的唯心主义 表现形式是教条主义和经验主义，尤其是教条主义是整风的重点 整风运动是一场伟大的思想解放运动。一切从实际出发、理论联系实际、实事求是的马克思主义思想路线，在全党范围确立起来 中共七大完成了马克思主义中国化的第一次历史性飞跃，其成果就是毛泽东思想。(第一次结合的开始：六届六中全会《论新阶段》) 抗日战争的胜利 9月3日，成为中国人民抗日战争胜利纪念日 波茨坦公告，台湾、澎湖列岛由中国收回，这是抗日战争取得完全胜利的重要标志 在反法西斯战争中的地位 是世界反法西斯战争的重要组成，是东方主战场 世界反法西斯力量对中国的援助 抗日战争胜利的意义、原因主要原因： 以爱国主义为核心的民族精神是决定因素 中国共产党的中流砥柱作用是关键 全民族抗战是重要法宝 世界人民 … 为什么中国共产党是抗战中的中流砥柱： 建立抗日民族统一战线 坚持全面抗战路线 坚持抗战，反对投降 … 意义： 彻底粉碎了日本军国主义殖民奴役中国的图谋 促进了中华民族的大团结 对世界反法西斯战争的胜利、维护世界和平的事业产生了巨大影响 开辟了中华民族伟大复兴的光明前景 解放战争与建立新中国抗战胜利后国际国内形势 美苏争霸 美国取代了日本的地位，采取扶蒋反共的政策 争取和平民主的斗争 重庆谈判 签署了双十协定，确认和平建国的基本方针 政协会议在重庆开幕 出席会议的有国民党，共产党，民主党派 五项协议 土地革命与农民的广泛发动《五四指示》 使地主阶级剥削农民而占有的土地转移到农民手中 用一切方法吸收中农参加运动，绝不可侵犯中农土地 一般不变动富农土地(征收富农多余土地)，对富农和地主有所区别 不可将农村中反对封建地主阶级的方法运用与城市中反对工商业资产阶级的斗争 有耕者有其田，不再是削弱封建性剥削土地制度，而是废除。 第二条战线的形成在国统区，学生运动等等也发展起来了，原因 官员腐败 反人民内战 征收苛税 恶性通货膨胀，物价飞涨 民族工商业走向破产 农村经济急剧衰弱 中国共产党与民主党派的合作民主党派： 民族资产阶级 城市小资产阶级 知识分子和其他爱国分子 民主党派参政，在中共的领导了，和共产党一道担任管理国家和建设国家的重任 第三条道路的幻灭民族党派提出走资本主义道路： 在政治上，实现英美式民主政治，但不准地主官僚资本家操纵 在经济上，应当实行改良的资本主义，但不容官僚资本横行 资产阶级建国的方案在中国行不通： 民资没有勇气去领导人民进行反帝反封的革命斗争(资产阶级两面性：革命性和软弱性) 帝国主义不会使中国成为一个独立、富强的资本主义国家 从中国革命形势来看，国民党当局不允许任何阻止其一党专政的力量存在 人民政协与《共同纲领》七届二中全会： 提出迅速夺取全国胜利的方针 工作重心必须由乡村转移到城市 由农业国转变为工业国、由新民主主义社会转变为社会主义社会(反资) 两个务必：不骄不躁，艰苦奋斗 《论人民民主专政》： 团结民资 新政协： 《中国人民政治协商协会组织法》 《中华人民共和国中央人民政府组织法》 中国人民政治协商会议共同纲领 中国革命胜利的原因： 中国革命的发生，有着深刻的社会根源和雄厚的群众基础 之所以能胜利，有共产党的领导 国际无产阶级的支持 经验(三大法宝)： 统一战线 武装斗争 党的建设 实现领导权的条件： 对敌人作坚决斗争并取得胜利 对被领导者给予物质福利，至少不损害其利益 对夺取领导权的资产阶级采取又联合、又斗争的政策 新中国的成立：反帝反封的任务基本完成 社会主义改造中华人民共和国的成立及其伟大意义 反帝成功了 反封成功了 军阀割据结束 改变了中国社会的发展方向 中国共产党称为了执政党 中华人民共和国的成立：标志着新民主主义起得了基本的胜利，两半的国情改变，而是新民主主义社会的全国范围内建立 完成近代以来的第一项历史任务(民族独立和人民解放)，为实现第二项历史任务创造了前提 标志着新民主主义革命基本结束，标志着社会主义革命刚刚开始 新民主主义社会 政治：各革命阶级联合专政 经济：五种经济成分并存 国营经济(社会主义性质 –&gt; 工人) 合作社经济(过渡，很快消失) 个体经济(农，小资) 私人资本主义经济(资本主义性质 –&gt; 民资) 国家资本注意经济(过渡) 文化：马克思 矛盾：无产阶级与资产阶级的矛盾，社会主义与资本主义的矛盾 七届二中全会提出中国还存在着两种基本的矛盾 国际上新中国同帝国主义的矛盾(封锁中国) 国内是工人阶级和资产阶级的反蹲 完成民主革命的遗留任务，恢复国民经济 1949-1953： 完成民主革命的遗留任务(西藏、海南岛. . .还没有解放) 恢复国民经济 1953-1956： 实现社会主义的工业化 社会主义改造 新中国成立初期面临的问题： 解放全中国的任务还没有结束 经济十分落后 以美国为首的西方资本主义阵营试图搞垮新中国 中国共产党能不能经受起考研 重点工作： 完成民主革命的遗留任务 在新解放区进行土改，废除地主阶级剥削土地所有制，实行农民土地所有制，保存富农经济 公布《中华人民共和国婚姻法》，废除封建婚姻制度 恢复和发展国民经济 维护国家主权和安全(抗美院草) 另起炉灶 打扫干净屋子再请客(不承认之前签订的跳跃) 一边倒(导向苏联，社会主义阵营) 加强党的建设 三反：反贪污、反浪费、反官僚主义 五反：打击不法资本家行贿、偷税漏税、盗窃国家财产、偷工减料、盗窃经济情报 开始向社会主义过渡 没收官僚资本 具有双重性质 反帝国主义的附属中国的买办资产阶级，具有民主革命的性质 反大资产阶级，具有社会主义革命的性质 将资本主义纳入国家资本主义轨道 引导个体农民在土地改革后逐步走上互助合作的道路 工业化的任务和发展道路建国之初：先化后改 –&gt; 后来：边化边改，原因： 主要矛盾发生了深刻的变化 经济成分发生了重要变化 过渡时期的总路线：一化三改。 实行社会主义改造的必要性和条件之所以进行社会主义改造，是因为具备了以下条件： 国营经济相对比较强大 资本主义经济弱小，不可能成为中国工业起飞的基础 进行社会主义改造，是保证工业发展、实现国家工业化的一个必要条件 国际环境也促使中国选择社会主义(背靠苏联) 一五期间： 鞍山、包头、武汉三大钢铁基地 武汉长江大桥通车 青藏、康藏、新藏公路建成通车 农业、手工业合作化运动的发展农业： 互助组(社会主义萌芽) 初级社(半社会主义性质) 高级社(社会主义性质) 先合作化、后机械化。 坚持自愿和互利的原则，采取典型示范、逐步推广的方法，发展一批，巩固一批 在实现农业合作化以后，国家用先进的技术和装备发展农业经济 1956年底，农业改造完成 手工业： 合作小组(社会主义萌芽) 供销合作社(半社会主义性质) 生产合作社(社会主义性质) 1956年底，手工业改造完成 对资本主义工商业赎买政策的实施 赎买政策 初级形式：加工订货、统销包销、经销代销(社会主义萌芽) 高级形式：公私合营，企业利润采用“四马分肥” 起初，个别企业公私合营(半社会主义性质) 1956年底，全行业公私合营(社会主义性质) 特点： 赎买，有偿而不是无偿 改造的同时，给予工作安排 不剥夺资产阶级的选举权 社会主义建设成就与改革开放全面建设社会主义的开端面临两大问题： 如何处理社会主义条件下的阶级斗争问题 如何处理好社会主义建设中的规模和速度问题 毛泽东提出第二次马克思主义同中国实际结合(未完成) 中共八大路线的制定 主要矛盾：经济文化不能满足人民需要 主要任务：集中力量发展社会生产力 陈云三个主体、三个补充 国营经济和集体经济是主体，一定数量的个体经济为补充 计划生产是主体，一定范围的自由生产为补充 国家市场是主体，一定的自由市场为补充 中共八大后，毛泽东提出，可以消灭了资产主义，又搞资本主义，称作“新经济政策” 探索社会主义建设道路的初步成果《论十大关系》 基本方针：调动国内外一切积极因素，为社会主义服务 是开始探索中国自己的社会主义建设道路的标志 《关于正确处理人民内部矛盾的问题》 正确处理人民内部矛盾作为国家政治生活的主体，如何处理： 政治思想：团结–批评–团结 物质分配：统筹兼顾，适当安排 科学文化：百花齐放，百家争鸣 共产党和民主党：长期共存，互相监督 社会主义社会的基本矛盾 生产关系和生产力之间的矛盾 上层建筑和经济基础的矛盾 《一九五七年夏季的形势》 六又政治局面：又有集中又有民主，又有纪律又有自由，又有意志又有个人心情舒畅、生动活泼 改革开放与现代化建设新时期 真理标准问题是又一场思想解放运动 《解放思想，实事求是，团结一致向前看》：开创中国特色社会主义新理论的宣言书 十一届三中全会：进行改革开放和社会主义现代化建设的历史新时期 南方谈话： 计划和市场都是经济手段 阐明了社会主义的本质 发展才是硬道理 三个有利于 强调加强党的建设 关于社会主义初级阶段的长期性和前途 改革开放前和改革开放后都是中国共产党领导人民进行社会主义建设的实践探索","tags":[{"name":"考研","slug":"考研","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E8%80%83%E7%A0%94/"}]},{"title":"思修","date":"2019-10-21T16:00:00.000Z","path":"/思修/","text":"人生的青春之问时代新人 有崇高的理想信念 有高强的本领 有天下兴亡、匹夫有责的担当精神 有信念、有梦想 思想道德和法律的关系在调节领域、调节方式、调节目标等方面不同，但二者都是上层建筑的重要组成部分，共同服务于一定的经济基础 思想道德为法律提供思想指引和价值基础 法律为思想提供制度保障 人的本质一切社会关系的总和。 人的社会属性：是人的本质属性 人生观人生目的：为什么活着 人生态度：应当如何活着 人生价值：什么样的人生才有价值 人生目的 人生目的决定人生道路 人生目的决定人生态度 人生目的决定人生价值选择 人生态度：稳定的心理倾向和精神转态 人生价值(分析题考点)： 自我价值：从社会索取了什么 社会价值：为社会做了什么，奉献了什么 自我价值的实现是为社会创造更大价值的前提，社会价值是个体自我完善、全面发展的保障。 人生观与世界观世界观：人们对生活在其中的世界以及人与世界的关系的总体看法和根本观点。 关系： 世界观决定人生观，人生观对世界观的巩固、发展和变化起着重要作用。 个人与社会的辩证关系对立统一的关系： 社会需要是个人需要的集中体现，个人利益的满足是在一定的社会条件下，通过一定的社会方式来实现 在社会主义社会中，个人利益和社会利益在根本上是一致的 科学高尚的人生追求什么是科学高尚的人生追求：服务人民、奉献社会 为什么： … … … 人生价值的评价与实现 正确评价人生价值 衡量人生价值的标准，最重要的就是看一个人是否用自己的劳动和聪明才智为国家和社会真诚奉献，为人民群众尽心尽力服务。 评价人生价值的方法： 坚持能力有大小与贡献尽力相统一 坚持物质贡献与精神贡献相统一 坚持完善自身和贡献社会相统一 人生价值的实现条件 从社会客观条件出发 从个体自身条件出发 不断增强实现人生价值的能力和本领 人生理想理想信念理想内涵：是世界观、人生观和价值观在奋斗目标上的集中体现 理想的分类： 个人和社会 近期和远期 生活和职业 道德和政治 特征： 超越性：源于现实且超越现实 实践性：在实践中产生、发展，且只能在实践中实现 时代性：一定时代的产物 信念内涵：在一定的认识基础上确立的对某种思想或事物坚信不疑并身体力行的精神状态。 特征： 执着性：一旦形成，就不会轻易改变 多样性： 不同人有不同的信念 同一个人在不同阶段信念不同 信仰是最高层次的信念 理性和信念的关系理想和相互依存。理想是信念所指的对象，信念则是理性实现的保障。没有理想，信念无从产生，没有信念，理想村部难行 理想信念是精神之钙理想信念的作用： 理想指引方向，信念决定成败 理想信念昭示奋斗目标 理想信念提供前进动力 理想信念提高精神境界 理想和现实的关系 理想和现实存在着对立的一面 理想和现实又是统一的：理想受现实的规定和制约 现实中包含着理想的因素，孕育着理想的发展 理想中也包含着现实，既包含着现实必然发展的因素，又包含着由理想转化为现实的条件，在一定的条件下，理想就可以转化为未来的现实 实现理想的过程具有：长期性、艰巨性和曲折性 个人理想与社会理想的统一 概念： 个人理想：个体对未来的物质生活、精神生活所产生的种种向往和追求 社会理想：社会集体乃至社会全体成员的共同理想 关系：相互联系、相互影响、相互制约 个人理想以社会理想为指引；个人理想的实现，必须以社会理想的实现为前提和基础 社会理想是对个人理想的凝华和升华 中国精神重精神是中华民族的优秀传统 对物质生活与精神相互关系的独到理解上 中国古人对理想的不懈追求 表对到的修养和到的教化的重视上 对理想人格的追崇 中国共产党是中华民族优秀传统的忠实继承者和坚定弘扬者 中国精神是民族精神和时代精神的统一民族精神：为本民族大多数成员所认同的价值取向、思维方式、道德规范、精神气质的总和。 民族精神的内涵(四个伟大)： 伟大创造精神 伟大奋斗精神 伟大团结精神 伟大梦想精神 时代精神：是体现民族特质并顺应时代潮流的思想观念、价值取向、精神风貌和社会风尚的总和 时代精神的核心：改革创新 时代楷模 精神脊梁 关系： 民族精神是古代的时代精神，现在的时代精神会成为未来的民族精神 民族精神和时代精神共同构成了我们当今时代的中国精神 民族精神是中华民族的精神独立性得以保持的重要保证 时代精神赋予中国精神以时代内涵 实现中国梦必须弘扬中国精神中国精神的作用： 凝聚中国力量的精神纽带 激发创新创造的精神动力 推进复兴伟业的精神定力 爱国主义的基本内涵、要求和特点爱国主义： 体现了人们对自己祖国的深厚感情 它是调节个人与祖国之前关系的道德要求、政治原则和法律规范 也是中华民族精神的核心 要求： “热爱祖国的大好河山”：维护祖国的领土完整是每一个人的使命和责任 “爱自己的骨肉同胞”：检验一个人对祖国忠诚的试金石 “爱祖国的灿烂文化”：民族群体意识的载体、民族的胎记、精神基因、摇篮 “爱自己的国家”：心系国家的前途和命运 基本特征： 爱国主义是历史的、具体的，在不同的历史时代和文化背景下产生的爱国主义，具有不同的内涵 爱国主义随着国家的产生而产生，随着国家的发展而发展 在阶级社会中，爱国主义具有阶级性，既有一致的一面，也有差异的一面，甚至有对立的一面 新时代的爱国主义基本要求： 坚持爱国主义和社会主义相统一 维护祖国统一和民族团结 尊重和传承中华民族历史的文化 必须坚持立足民族又面向世界 如何坚持立足民族又面向世界(分析题)： 必须坚持立足民族，维持国家发展主体性 必须面向世界，构建人类命运共同体 做忠实的爱国者 推进祖国统一 促进民族团结 增强国家安全意识 以人民安全为宗旨 以政治安全为根本 以经济安全为基础 以军事、文化、社会安全为保障 以促进国际安全为依托 改革创新是时代要求意义(作用)： 创新始终是推动人类社会发展的第一动力 创新能力是当今国际竞争新优势的集中体现 改革创新是我国赢得未来的必然要求。 必须把创新作为引领发展的第一动力 把人才作为支撑发展的第一资源 把创新摆在国家发展全局的核心位置 把创新驱动发展战略作为国家重大战略 实施创新驱动发展战略 最根本的是要增强自主创新能力 最紧迫的是要破除体质机制障碍 践行社会主义核心价值观社会主义核心价值观的基本内容 核心价值观 概念：是一定社会形态社会性质的集中体现 意义：生动展现了中国共产党和中华民族高度的价值自信与价值自觉 社会主义核心价值观 富强、民主、文明、和谐(国家) 自由、平等、公正、法治(社会) 爱国、敬业、诚信、友善(公民) 社会主义核心价值观和社会主义核心价值体系的关系 社会主义核心价值观是社会主义核心价值体系的精神内涵，是社会主义核心价值体系的高度凝练和集中表达 都体现了社会主义意识形态的本质要求 当代中国发展进步的精神指引培育和践行社会主义核心价值观的重要性(必要性)： 有效整合我国社会意识 凝聚社会价值共识 解决和化解社会矛盾 聚合磅礴之力的重大举措 保证我国经济社会沿着正确的方向发展、实现中国民族伟大复兴的价值支撑 社会主义核心价值观的作用： 坚持和发展中国特色社会主义的价值遵循 提高国家文化软实力的迫切要求 增进社会团结和谐的最大公约数 社会主义核心价值观的历史底蕴、现实基础、道义力量历史底蕴：中华优秀传统文化 现实基础：中国特色社会主义建设实践 道义力量：具有先进性、人民性和真实性，具有强大的道义力量 做社会主义核心价值观的积极践行者 扣好人生的扣子 勤学修德明辨笃实 勤学：知识的树立社会主义核心价值观的重要基础 修德：做人做事第一位的是崇德修身 明辨：辨别什么是真善美、什么是假丑恶 笃实：道不可坐论，德不能空谈 道德传承与实践什么是道德 道德的起源 劳动是道德起源的首要前提 社会关系是道德赖以产生的客观条件 人的自我意识是道德产生的主观条件 道德的本质 道德是反映社会经济关系的特殊意识形态 有什么样的社会经济关系，相应地就有什么样的道德(经济基础决定上层建筑) 道德随着社会经济关系的变化而变化 道德作为一种社会意识，在阶级社会里反映着一定阶级的利益，因而不可避免具有阶级性；同时不同的阶级道德有共同之处，反映着道德普遍性 道德一经产生，便具有相对独立性，既表现为道德的历史继承性，也表现为道德对社会发展具有能动的反作用 道德是社会利益关系特殊调节方式 与法律规范、政治规范的不同之处在于它是用善恶标准去评价，依靠社会舆论、传统习俗、内心信念来维持的，因此是一种非制度化的、柔性的规范 道德是一种实践精神(不但这样想，还要这样做) 道德的功能和作用主要功能： 认识功能：道德反映社会现实特别是反映社会经济关系的功效和能力(行为前) 规范功能：在正确善恶观的指引下，规范社会成员在各个领域的行为(行为中) 调节功能：通过评价等方式，指导和纠正人们的行为和实践活动(行为后)，这是道德最突出也是最重要的功能 作用： 为经济基础的形成、巩固和发展服务，是一种重要的精神力量 对其他社会意识形态(如法律思想)的存在有着重大的影响 通过调整人们之间的关系维护社会秩序和稳定 是提高人的精神境界、促进人的自我完善、推动人的全面发展的内在动力 在阶级社会中，道德是阶级斗争的重要工具 两种错误的观点： 道德万能论 道德无用论 传承中华传统美德 传统美德的基本精神 注重整体利益，强调责任奉献 推崇仁爱原则，注重以和为贵 提倡人伦价值，重视道德义务 追求精神境界，向往理想人格 强调道德修养，注重道德践履 中华传统美德的创造性转化和创新性发展 传统道德既有好的(精华)也有不好的(糟粕) 传统美德是传统道德的精华部分 加强对中华传统美德的挖掘和阐发 同中华传统美德滋养社会主义道德建设 在对待传统道德的问题上，反对两种错误的思潮 复古论 虚无论(全盘否定) 发展中国革命精神 中国革命道德形成与发展 中国共产党始终高度重视继承和发扬革命道德传统 中国革命道德作为一种精神力量，从它形成的时候起，就对中国的革命、建设、改革事业发挥着极其重要的作用 弘扬中国革命道德，要同弘扬中华传统美德相结合 中国革命道德主要内容 为实现社会主义和共产主义理想而奋斗 全心全意为人民服务 始终把革命利益放在首位 树立社会新风，建立新型人际关系 修身自律，保持节操 中国革命道德的当代价值 有利于加强和巩固社会主义和共产主义的理性和信念 有利于培育和践行社会主义核心价值观 有利于引导人们树立正确的道德观 有利于培育良好的社会道德风尚 借鉴人类文明优秀道德成果 每一个民族或国家都有自己优良的道德传统，都对促进道德发展做出过不同程度的贡献 必须秉承正确的态度和科学的方法 坚持以我为主、为我所用，批判继承其他国家的道德成果 社会主义道德的核心和原则 社会主义道德建设的核心：为人民服务 社会主义道德建设的原则：集体主义 社会主义道德建设的重点：诚实守信 社会主义道德建设的基本要求：社会主义荣辱观 为什么要以为人民服务为核心? 为人民服务是经济基础和人际关系的客观要求 是社会主义市场经济健康发展的要求 体现着社会主义道德建设的先进性要求和广泛性要求的统一 如何理解集体主义原则? 社会主义集体主义强调集体利益和个人利益相统一 强调国家利益、社会整体利益高于个人利益 强调重视和保障个人的正当利益 集体主义三个层次的道德要求： 无心奉献、一心为公(最高层次) 先公后私、先人后己 顾全大局、遵纪守法、热爱祖国、诚实劳动(最基本的道德要求) 社会公德公共生活的特征： 活动范围的广泛性 活动内容的公开性 交往对象的复杂性 活动方式的多样性 社会公德： 文明礼貌：社会交往必然的道德要求 助人为乐：社会主义人道主义的基本要求 爱护公物：社会文明程度的重要标志 保护环境：当今时代社会公德的重要内容 遵纪守法：社会公德最基本的要求 公民生活的最低要求的爱国守法 网络生活中的道德要求： 正确使用网络工具 健康进行网络交往 自觉避免沉迷网络 养成网络自律精神 职业道德 爱岗敬业：职业道德最基本的要求 诚实守信：公民道德建设的重点 办事公道 服务群众 奉献社会：职业道德最高层次的要求 个人品德概念：通过社会道德教育和个人自觉的道德修养所形成的稳定的心理状态和行为习惯 作用： 对道德和法律作用的发挥具有重要的推动作用 是个体人格完善的重要标志 是经济社会发展进程中重要的主体精神力量 掌握道德修养的正确方法： 学思并重 省察克治 慎独自律 知行合一 积善成德 锤炼高尚道德品格： 形成正确的道德认识和道德判断 激发正向的道德认同和道德情感 强化坚定的道德意志和道德信念 中国特色社会主义法律体系和法治体系法律及其历史发展 法律的含义 国家创制和实施的行为规范，方式主要有两种 国家机关在法定的职权范围内依照法律程序，制定、修改、废止规范性法律文件的活动 国家机关赋予某些既存社会规范以法律效力，或者赋予先前的判例以法律效力的活动 法律由一定的社会物质生活条件所决定，物质资料的生产方式(生产力和生产关系)既是决定社会面貌、性质和发展的根本因素，也是决定法律本质、内容和发展方向的根本因素 法律是统治阶级意志的体现 不是统治阶级内部个别人的意志，也不是统治者个人意志的简单相加 统治阶级也要遵守法律 法律体现的不是统治者的全部意志 法律的定义：法律是由国家制定和认可并以国家强制力保证实施的，反映由特定社会物质生活条件所决定的统治阶级意志的规范体系 法律的历史发展 我国社会主义法律的本质特征特征： 体现了党的主张和人民意志的统一，具有鲜明的阶级性 具有科学性和先进性 是中国特色社会主义建设的重要保障 我国社会主义法律的运行 制定 属性：关键关节 环节： 法律案的提出 法律案的审议 法律案的表决 原则：科学立法、民主立法 执行 属性：最大量、最经常的工作 执法主体： 中央与地方各级政府 各级政府中享有执法权的下属机构 法律授权的社会组织、行政机关依法委托的社会组织 原则： 合法性 合理性 信赖保护(今天给了判决结果，后面不能轻易更改) 效率 适用 司法机关：检查机关、审判机关 基本要求：正确、合法、合理、及时 原则： 司法公正 公民在法律面前一律平等 以事实为依据，以法律为准绳 司法机关依法独立公正行使司法权 遵守 属性：是法律实施和实现的基本途径 含义： 依法享有并行使权力 依法承担并履行义务 守法主体：一切组织和个人 立法： 人大 全国：宪法，法律 地方性：法规 政府 国务院：行政法规 地方性：地方规章 部委：部门规章 宪法是国家的根本法回顾党领导的宪法建设史，可以得出几点结论： 制定和实施宪法，是 … 必然要求 宪法是在实践的基础形成的，有必然性 党的领导很重要，这样才能制定出好的宪法 党重视宪法，这是宪法保持生机活力的根本原因所在 我国宪法的地位： 党的主张和人民意志的高度统一 是国家的根本法 宪法在中特体系中具有统帅地位 规定了国家的根本制度 宪法的生命在于实施，宪法的权威在于实施 我国宪法的基本原则： 党的领导原则 人民主权原则 尊重和保障人权原则 社会主义法治原则 民主集中制原则 我国的实体法律部分实体法律部分包括：宪法相关法、民法商法、行政法、经济法、社会法、刑法 民法的原则：遵循民事主体地位平等、自愿、公平、诚信、公序良俗，有利于阶跃自愿和保护生态环境等基本原则 商法的原则：商法遵循民法的基本原则，商事交易自由、等价有偿、便捷安全 刑法的原则：罪刑法定、法定面前人人平等、罪刑相适应 规定了犯罪的概念，明确了犯罪及其要件 规定了正当防卫、紧急避险等排除社会危害性的行为 规定了刑罚的种类，包括管制、拘役、有期徒刑、无期徒刑、死刑五种主刑以及罚金、剥夺政治权利、没收财产三种附加刑 我国的程序法律部门包括诉讼法和非诉讼程序法： 诉讼法：规范国家司法机关解决社会纠纷 刑事诉讼法 民事诉讼法 行政诉讼法 非诉讼程序法：仲裁机构或调解组织解决社会纠纷 仲裁法：一裁终局 人民调解法 建设中国特色社会主义法治体系的重大意义 中国特色社会主义法治体系是中特的本质要求和重要保障 推进国家治理体系和治理能力现代化的重要举措 全面依法治国的总抓手 建设中国特色社会主义法治体系的主要内容 完备的法律规范体系 是中特法治体系的前提，是基础 高效的法治实施体系 是建设中特法治体系的重点 严密的法治监督体系 是宪法法律有效实施的重要保障，是迫切要求 有力的法治保障体系 是全面依法治国的重要依托 完善的党内法规体系 是中特法治体系的本质要求和重要内容 全面依法治国的基本格局 科学立法 龙头环节 严格执法 法律的生命力、权威在于实施 公正执法 生命线，最后一道防线 全民守法 法治道路与思维、法律权利和义务坚持中国共产党的领导为什么要坚持中国共产党的领导： 党的领导是中特的最本质的特征，是社会主义法治的根本保证，党的领导和依法治国是高度统一的 坚持党的领导，是社会主义法治的根本要求，是全面依法治国的题中应有之义 怎样坚持中国共产党的领导： 党领导立法 保证执法 支持司法 带头守法 坚持人民的主体地位重要性：在社会主义法治国家，人民是依法治国的主体和力量源泉 如何坚持：… … 坚持法律面前人人平等平等是社会主义法律的基本属性，是法治的基本要求 坚持依法治国和以德治国相结合 正确认识法治和德治的地位 法治的地位：治国理政的基本方式，依法治国的基本方略 德治的地位：治国理政的重要方式 正确认识法治和德治的作用 法治的作用：发挥作用以国家强制力为后盾，对违法行为追究法律责任 德治的作用：：通过人们的内心信念、传统习俗、社会舆论等进行道德教化，对违背道德的行为进行道德谴责 正确认识法治和德治的实现途径 法治的实现途径：制定和实施法律规范的形式来推进和实施 德治的实现途径：培育和弘扬道德等途径来推进和实施 推动法治和德治的相互促进 强调道德对法治的支撑作用，发挥道德对法治的滋养作用 把道德要求贯彻到法治建设中，以法治承载道德理念 运用法治手段解决道德领域突出问题。法律是道德的底线，也是道德的保障 坚持从中国实际出发 坚持从实际出发，就是要突出法治道路的中国特色、实践特色、时代特色 从我国实际出发，不等于关起门来高法治，学习世界上优秀的文明成果 法治思维及其内涵法治思维的含义： 法治思维以法治价值和法治精神为指导 法治思维以法律原则为依据来指导人们的社会行为 法治思维以法律手段和法律方法为依托分析问题、处理问题、解决纠纷 法治思维是一种符合规律、尊重事实的科学思维 法治思维的特征： 在依据上，以事实为依据，以法律为准绳 在方式上，坚持法律面前人人平等，具有稳定性和一贯性 在价值上，强调集中社会大众的意志来进行决策和判断 在标准上，法治与人治的分水岭为最高的权威是法还是人，法治思维以法律为最高权威 法治思维的基本内容 法律至上：法律的普遍适用性、优先适用性(多种方式判断，法律优先)和不可违抗性 权利制约：权利由法定、有权必有责、用权受监督、违法受追究 公平正义：权利公平、机会公平、规则公平和救济公平 权利保障：宪法保障是前提和基础，立法保障是重要条件，行政保护是关键环节，司法保障是最后防线 正当程序：程序的合法性、中立性、参与性、公开性、时限性 尊重和维护法律权威 法律权威的含义 法律占主导地位 法律科学 法律受到严格实施 法律反映人民共同意愿且为人民真诚信仰 意义 社会主义法治观念的核心要求和建设社会主义法治国家的前提条件 国家治理基础和关键 实现人民意志、维护人民毅力、保障人民权利的基本途径 维护个人合法权益的根本保障 要求 信仰法律 遵守法律 服从法律 维护法律 法律权利和法律义务法律权利： 权利的产生、发展和实现，都必须要以一定的社会经济条件为基础。 法律权利的特征： 受物质生活条件的制约 不同制度和不同国家法律下存在差异 受法律保护，具有不可侵犯性 必须依法行使 法律义务的履行： 作为：义务人实施积极的行为(如看望父母) 不作为：义务人不得实施某种行为(如私闯民宅) 法律义务的特征： 是历史的 源于现实需要 必须依法设定 可能发生变化 法律义务和法律权利的关系： 不可分割，相互依存 法律权利的实现必须以相应法律义务履行为条件 法律义务的设定和履行页必须以法律权利的行使为依据 法律权利与法律义务是目的与手段的关系 有些法律权利和义务具有复合性的关系。一个行为可以同时是权利行为和义务行为(劳动，教育) 法律权利和法律义务平等 法律面前人人平等被确立为基本原则 在法律权利和法律义务的具体设定上要平等 权利与义务的实现要体现平等 依法行使法律权利我国宪法法律规定的基本权利 政治权利 选举权 表达 民主管理 监督权 人身权利 生命健康权 人身自由权 人格尊严权 住宅安全权 通信自由权 财产权利 私有财产权 继承权 社会经济权利 劳动权 休息权 社会保障权 物质帮助权 宗教信仰及文化权利 行使法律权利的界限 权利行使的目的 权利行使的限度 权利行使的方式 权利行使的程序 依法履行义务法律义务： 维护国家统一和民族团结 遵守宪法与法律 维护祖国安全、荣誉和利益 依法服兵役 依法纳税 违反法定义务应当承担法律责任： 民事责任 行政责任(针对行政机关和行政人员) 刑事责任","tags":[{"name":"考研","slug":"考研","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E8%80%83%E7%A0%94/"}]},{"title":"常见排序算法","date":"2019-10-01T16:00:00.000Z","path":"/排序算法/","text":"由于近期在学习排序算法，决定将自己的学习过程记录下来，一是为了自己能够方便的复习，另一个是将这个知识分享给大家。我将使用 Java 语言实现下列排序算法 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 准备工作为了对实现的算法进行测试，我们准备一个工具类 Helper，里面包括我们由于测试算法正确与否的方法以及性能测试的代码，包括交换数组中的两个元素(这个操作在排序时经常用到，所以抽象出一个方法)，还有产生一个指定容量和范围的随机数组，还有判断数组是否有序的函数以及性能测试的函数 import java.util.Arrays;import java.util.Random;public class Helper &#123; //交换arr[i]和arr[j] public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //产生一个范围在rangeL-rangeR，容量为n的数组 public static int[] generateArray(int n, int rangeL, int rangeR) &#123; Random random = new Random(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = random.nextInt(rangeR - rangeL + 1) + rangeL; &#125; return arr; &#125; //判断数组是否有序(从小到大) public static boolean isSorted(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; return false; &#125; &#125; return true; &#125; //测试排序需要的时间 需要传入一个函数接口Sort public static double testTime(int[] arr, Sort sort) &#123; long startTime = System.nanoTime(); sort.sort(arr); long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; &#125;&#125; 其中 testTime 需要传入一个函数式接口 Sort，该接口定义如下 public interface Sort &#123; public void sort(int[] arr);&#125; 我们在调用该方法时，只要将我们的排序算法的方法引用传入即可。 选择排序为了描述的精确性，我们把数组分为两部分，一部分是已经排好序的区域，一部分是未排序的区域 选择排序的策略就是在未排序的区域找出最小元素的位置，然后将它交换到未排序区域的最前方，然后已排序区域向前扩大一位，然后接着上面策略，直至未排序的区域为空，排序结束。下面以一个例子进行说明，我们默认蓝色区域代表已排序区域，白色区域代表未排序区域 代码如下 public class SelectionSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; Helper.swap(arr,minIndex,i); minIndex = i + 1; &#125; &#125; public static void main(String[] args) &#123; //对100000个数进行排序 int n = 100000; //产生随机数组 int[] arr = Helper.generateArray(n, 0, n); //传入排序算法的引用，得到排序所需时间 double time = Helper.testTime(arr,SelectionSort::sort); //确定算法是否排好序 System.out.println(\"isSorted: \" + Helper.isSorted(arr)); //打印排序所需时间 System.out.println(time + \"s\"); &#125;&#125; 输出为 isSorted: true7.319637673s 可见算法已经排好序，并且选择排序对 100000 个数据排序所需的时间为 7.32s 左右。 插入排序插入排序就像是你在打斗地主，当你摸牌时你对牌的排序。向上面一样，我们将数组分为已排序的部分和未排序的部分，以排序的部分就是你已经排好序的牌，现在你又摸到了一张牌，那么你是不是会将这张牌与排好序的牌进行比较，插入到合适的位置，然后继续摸下一张牌，然后又进行插入排序，直到牌已经摸完了(未排序的部分为空)，那么你就已经拍好序了，下面看一个例子 代码为 public class InsertSort &#123; public static void sort(int[] arr) &#123; //i = 1开始，因为默认第一张牌是排好序的 for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; //如果后面比前面小，进行交换 if (arr[j - 1] &gt; arr[j]) &#123; Helper.swap(arr,j - 1, j); &#125; else &#123; //如果后面比前面大，结束交换 break; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int n = 100000; int[] arr = Helper.generateArray(n, 0, n); double time = Helper.testTime(arr,InsertSort::sort); System.out.println(\"isSorted: \" + Helper.isSorted(arr)); System.out.println(time + \"s\"); &#125;&#125; 输出为 isSorted: true8.863959818s 这表明插入排序对 100000 个数据排序所需的时间为 8.86s 左右。它的速度比选择排序还要慢一些，这时因为插入排序中含有大量的交换操作，如果我们将上面的交换操作替换为赋值操作 public static void sort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int e = arr[i]; //保存要插入的元素 int j; //记录要插入的位置 for (j = i; j &gt; 0; j--) &#123; if (arr[j - 1] &gt; e) &#123; //向后移动 arr[j] = arr[j - 1]; &#125; else &#123; break; &#125; &#125; arr[j] = e; &#125;&#125; 这时需要的时间为 isSorted: true2.293106947s 并且对于近乎有序的数组，插入排序的速度非常的快，甚至比后面要介绍的 $O(N \\log N)$ 的速度还要快。 希尔排序希尔排序是对插入排序的改进。既然是改进，那么我们就要知道插入排序有什么问题：如果有一个很小的数在数组的后方，那么这个数就会进行很长时间的交换才能插入到合适的位置，这明显是一个比较慢的过程 而希尔排序将解决这一个问题，希尔排序首先将数组分组，比如 上面的示例中，我们从每隔 3 个一组到每隔 2 个一组最后每隔 1 个一组，我们把上面的 &quot;3,2,1&quot; 称之为增幅序列 h，不同的递增序列对算法的性能也有影响，有很多的论文研究了不同的递增序列，但都无法证明某个递增序列是最好的，下面的程序考虑使用 &quot;1, 4, 13, ...&quot; 这个递增序列(h = 1, h = 3 \\* h + 1)，代码如下 public class ShellSort &#123; public static void sort(int[] arr) &#123; int N = arr.length; int h = 1; while (h &lt; N / 3) &#123; h = 3*h + 1; // 1 4 13 40 121 ... &#125; // h = 1的时候就是对整个数组进行插入排序 while (h &gt;= 1) &#123; //每隔h个元素(将数组分成了h组)进行插入排序 for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j - h] &gt; arr[j]) &#123; Helper.swap(arr, j, j-h); &#125; else &#123; break; &#125; &#125; &#125; h = h/3; &#125; &#125; public static void main(String[] args) &#123; int n = 100000; int m = 10; double time = 0; for (int i = 0; i &lt; m; i++) &#123; int[] arr = Helper.generateArray(n, 0, n); time += Helper.testTime(arr, ShellSort::sort); System.out.println(\"isSorted: \" + Helper.isSorted(arr)); &#125; time = time / m; System.out.println(time + \"s\"); &#125;&#125; 输出为 isSorted: true0.0292856418s 希尔排序 10 次平均所需的时间只有 0.03s，与选择排序和插入排序不是一个等级上的。 归并排序自顶向下的归并排序归并排序的思想是将数组一分为二，然后对左、右两边的数组进行排序，然后将左右两边的已经有序数组进行融合成一个有序的数组，而左右两边的排序问题也可以按照上面的思想进行，直到数组只剩下一个元素，我们认为已经是有序的了，然后向上进行融合 下面的代码简要的简述了上面的过程 import java.util.Arrays;public class MergeSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return ; &#125; mergeSort(arr,0, arr.length-1); &#125; private static void mergeSort(int[] arr, int left, int right) &#123; //如果只有一个元素，可认为是有序的了 if (left == right) &#123; return ; &#125; int mid = left + (right - left) / 2; //对左右两边进行排序 mergeSort(arr,left,mid); mergeSort(arr,mid + 1, right); //融合左右两边的数组 merge(arr,left,right); &#125;&#125; 现在的关键是如何融合左右两个有序的数组为一个有序的数组，来看下面这个例子 private static void merge(int[] arr, int left, int right) &#123; //要融合的数组 int[] help = new int[right - left + 1]; int mid = left + (right - left) / 2; //左右数组的首部 int p1 = left; int p2 = mid + 1; //要融合数组的首部 int i = 0; //如果两个数组都没有遍历完毕 while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; if (arr[p1] &lt;= arr[p2]) &#123; help[i++] = arr[p1++]; &#125; else &#123; help[i++] = arr[p2++]; &#125; &#125; //如果p2遍历完毕了，将p1中剩下的元素复制到融合的数组中 while (p1 &lt;= mid) &#123; help[i++] = arr[p1++]; &#125; //同上 while (p2 &lt;= right) &#123; help[i++] = arr[p2++]; &#125; //将融合的数组按序赋值给我们要排序的数组 for (int j = left; j &lt;= right; j++) &#123; arr[j] = help[j - left]; &#125;&#125; 我们来测试一下 10 次平均所需时间为 isSorted: true0.0334043239s 归并排序是 $O(N \\log N)$ 级别的算法，比选择排序和插入排序要快很多。 优化上面我们在对左右两个数组排好序之后，直接进行了 merge 操作 mergeSort(arr,left,mid);mergeSort(arr,mid + 1, right);merge(arr,left,right); 但是如果考虑到如下情况 mergeSort(arr,left,mid);mergeSort(arr,mid + 1, right);if (arr[mid] &gt; arr[mid + 1]) merge(arr,left,right); 我们还可以进行优化，在上面我们提到，插入排序在数组近乎有序的情况下排序的速度非常的快，所以我们可以考虑当数组被划分到小于一定的规模(当数组小于一定规模时，近乎有序的概率很大)时我们不在向下划分，而是转而用插入排序，所以我们在 Helper 中添加一个方法 public static void insertSort(int[] arr, int l, int r) &#123; for (int i = l + 1; i &lt;= r; i++) &#123; int e = arr[i]; //保存要插入的元素 int j; //记录要插入的位置 for (j = i; j &gt; l; j--) &#123; if (arr[j - 1] &gt; e) &#123; arr[j] = arr[j - 1]; &#125; else &#123; break; &#125; &#125; arr[j] = e; &#125;&#125; 这个方法与插入排序的算法很相似，不过规定了对什么范围的数组进行排序，所以归并排序的算法可以修改如下 private static void mergeSort(int[] arr, int left, int right) &#123; //当数组小于15时，使用插入排序 if (right - left &lt; 15) &#123; Helper.insertSort(arr, left, right); return; &#125; int mid = left + (right - left) / 2; mergeSort(arr,left,mid); mergeSort(arr,mid + 1, right); if (arr[mid] &gt; arr[mid + 1]) merge(arr,left,right);&#125; 再次测试 10 次平均所需时间 isSorted: true0.028484280499999997s 自底向上的归并排序我们在上面使用的归并排序是自顶向下使用递归来完成的，但是我们不一定要自顶向下的完成这个排序过程，而是可以自底向上进行排序，首先将底层的序拍好，然后进行 merge 一路向上完成排序 public static void sortBU(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return ; &#125; //每轮2*sz个元素，为什么不直接sz = 2, 因为我们后面传入mid是要/2，所以这里的粒度就为sz for (int sz = 1; sz &lt;= arr.length; sz += sz) &#123; //mid &lt;= arr.length - 1 for (int i = 0; i + sz &lt; arr.length; i += (sz + sz)) &#123; //小数组使用插入排序 if (2 * sz &lt; 15) &#123; Helper.insertSort(arr,i, i + sz + sz - 1); continue; &#125; //只有当右边最小比左边最大还大时才需要merge if (arr[i + sz -1] &gt; arr[Math.min(i + sz, arr.length - 1)]) //防止越界 merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, arr.length - 1)); //防止越界 &#125; &#125;&#125;private static void merge(int[] arr, int left, int mid, int right) &#123; int[] help = new int[right - left + 1]; int p1 = left; int p2 = mid + 1; int i = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; if (arr[p1] &lt;= arr[p2]) &#123; help[i++] = arr[p1++]; &#125; else &#123; help[i++] = arr[p2++]; &#125; &#125; while (p1 &lt;= mid) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= right) &#123; help[i++] = arr[p2++]; &#125; for (int j = left; j &lt;= right; j++) &#123; arr[j] = help[j - left]; &#125;&#125; 你可能发现这次的 merge 需要自己传入 mid 值，而不是自己计算。可以思考一下为什么? 现在我们测试一下自底向上排序所需要的时间 isSorted: true0.031012182500000006s 自底向上的排序会比自顶向下的排序慢，但是自底向上的排序有一个非常重要的特点，它没有利用数组随机访问的特点，即数组通过下标对元素访问(插入排序中有，但是你可以不优化这里)，这意味着我们可以对链表使用自底向上的排序。 快速排序基本算法在看快速排序算法前我们先来看一个问题，给定一个数，要求数组左边的数都小于等于这个数，数组右边的数都大于这个数，请问这个算法怎么写。首先我们将数组标记为小于等于区和大于区，并用 less 和 more 标记区域的范围，所有 index &lt;= less 的元素都小于指定数，所有 index &gt;= more 的都大于指定数，下图将讲解具体的算法 上面的过程我们称为 partition，对应的代码如下 int e = 6;public static int partition(int[] arr, int L, int R) &#123; int less = L - 1; int more = R + 1; int cur = L; while (cur &lt; more) &#123; if (arr[cur] &lt;= e) &#123; //如果当前元素小于指定元素 less和cur向前移动 less++; cur++; &#125; else if (arr[cur] &gt; e) &#123; Helper.swap(arr,--more,cur); &#125; else &#123; cur++; &#125; &#125; //返回两个数组的分界处 return less;&#125; 那么快速排序的思想就是选定一个数(一般我们选择要排序范围内的最后一个数 arr[R])，要求左边的数比这个数小(或等于)，右边的数比这个数大。然后又接着对左右两边的数进行上述的分割(partition)，直至分割后的数组只剩下一个元素，可认为是有序的，这时数组就是有序的了 public class QuickSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr,0,arr.length-1); &#125; public static void quickSort(int[] arr, int l, int r) &#123; //当数组较小时，使用插入排序 if (r - l &lt; 15) &#123; Helper.insertSort(arr, l, r); return; &#125; if (l &lt; r) &#123; int p = partition(arr, l, r); quickSort(arr, l, p); quickSort(arr, p + 1, r); &#125; &#125; public static int partition(int[] arr, int L, int R) &#123; int less = L - 1; int more = R + 1; int cur = L; while (cur &lt; more) &#123; if (arr[cur] &lt;= arr[R]) &#123; less++; cur++; &#125; else if (arr[cur] &gt; arr[R]) &#123; Helper.swap(arr,--more,cur); &#125; &#125; return less; &#125;&#125; 测试此时 10 次平均所需的时间 isSorted: true0.023240137399999996s 随机快排但是此时有一个问题，如果此时数组是近乎有序的，那么我们根据最后一个元素划分元素会划分出左右两边的数组失衡 所以我们不能选择最后一个元素，而是选择一个随机的元素，我们只要在上面的程序中加入下面的一行代码即可 if (l &lt; r) &#123; //随机一个下标和最后一个元素交换 Helper.swap(arr, (int)Math.random() * (r - l + 1) + l, r); // 随机快排 int p = partition(arr, l, r); quickSort(arr, l, p); quickSort(arr, p + 1, r);&#125; 三路快排这时需要考虑这么一种情况，如果数组中有十分多的重复元素，那么就会有元素重复的子数组，这时应该就不应该排序了，但是我们的算法还是会把数组继续切分为更小的数组进行排序，这就有很大的改进潜力。所以我们考虑我们的 partition 算法不再划分为两部分，而是划分为三部分，小于，等于和大于三个区域 所以我们修改上面的排序算法如下 public static void quickSort(int[] arr, int l, int r) &#123; if (r - l &lt; 15) &#123; Helper.insertSort(arr, l, r); return; &#125; if (l &lt; r) &#123; Helper.swap(arr, (int)Math.random() * (r - l + 1) + l, r); // 随机快排 //p得到的是等于区的范围 int[] p = partition(arr,l,r); //对等于区不用排序 quickSort(arr,l,p[0] - 1); quickSort(arr,p[1] + 1, r); &#125;&#125;public static int[] partition(int[] arr, int L, int R) &#123; int less = L - 1; int more = R; int cur = L; while (cur &lt; more) &#123; if (arr[cur] &lt; arr[R]) &#123; //与less的前一个元素进行交换 并且less和cur向前移动 Helper.swap(arr,++less,cur++); &#125; else if (arr[cur] &gt; arr[R]) &#123; //与more的后一个元素进行交换 并且more向后移动，并且cur和less都不移动 Helper.swap(arr,--more,cur); &#125; else &#123; //如果等于，将cur向前移动即可 cur++; &#125; &#125; //最后将最后一个元素与more位置的元素进行交换 Helper.swap(arr,R,more); //返回等于区的左右下标 return new int[]&#123;less+1,more&#125;;&#125; 堆排序堆的有关知识可以参考数据结构–Java描述中优先队列与堆的内容，如果你已经仔细的阅读了话，相比你已经熟悉了堆的性质了，那么下面就直接上代码了 import java.util.Arrays;public class HeapSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; //将数组变成堆结构 for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr,i); &#125; int heapSize = arr.length; while (heapSize &gt; 0) &#123; Helper.swap(arr,0,--heapSize); heapify(arr,0,heapSize); &#125; &#125; public static void heapInsert(int[] arr, int index) &#123; while (arr[index] &gt; arr[(index-1)/2]) &#123; Helper.swap(arr,index,(index-1)/2); index = (index - 1)/2; &#125; &#125; public static void heapify(int[] arr, int index, int heapSize) &#123; int left = 2 * index + 1; while (left &lt; heapSize) &#123; int right = left + 1; //假设左更大 int larger = left; //如果右比左大 改变larger为右 if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[left]) &#123; larger = right; &#125; //如果父比左右子节点都大，说明还是堆，直接退出循环 if (arr[larger] &lt; arr[index]) &#123; break; &#125; //如果不是，那么就和比较大的交换交换 Helper.swap(arr,larger,index); index = larger; left = index * 2 + 1; &#125; &#125; public static void main(String[] args) &#123; int n = 100000; int m = 10; double time = 0; for (int i = 0; i &lt; m; i++) &#123; int[] arr = Helper.generateArray(n, 0, n); time += Helper.testTime(arr, HeapSort::sort); System.out.println(\"isSorted: \" + Helper.isSorted(arr)); &#125; time = time / m; System.out.println(time + \"s\"); &#125;&#125; 测试 10 次平均所需时间为 isSorted: true0.060118443099999995s","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"排序","slug":"排序","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"数据结构--Java描述","date":"2019-09-23T16:00:00.000Z","path":"/数据结构--Java描述/","text":"本篇文章是为了记录自己在学习数据结构时的笔记，会对常见的数据结构做基本的介绍以及使用Java语言进行实现。包括 动态数组 栈 队列 链表 二分搜索树 优先队列和堆 线段树 Trie 并查集 AVL 树 红黑树 哈希表 动态数组API介绍数组是一种根据下标操作的数据结构，它的查询速度很快，但是它有缺点，那就是数组的容量一旦在创建时确定，就不能进行更改，所以为了克服这一缺点，我们实现一个自己的数组，并除此以外，还会实现一些方法，包括以下 add(int index, E e) 向指定 index 添加元素 e get(int index) 获得指定 index 的元素 remove(int index) 删除指定 index 的元素并返回该元素 set(int index, E e) 更改 index 处的元素为 e getSize() 返回数组中元素的个数 contains(E e) 查询数组是否包含元素 e isEmpty() 查看数组是否为空(是否有元素) find(E e) 返回数组中元素 e 第一次出现的 index，若没有元素 e，则返回 -1 新建一个 Array 类，它含有两个私有成员变量 E[] data 用以保存数据 int size 用以记录数组中元素的个数 除此以外还有两个构造方法 Array(int capacity) 设定数组的容量 Array() 容量默认为 10 public class Array&lt;E&gt; &#123; private E[] data; private int size; public Array(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; &#125; public Array() &#123; this(10); &#125;&#125; 现在我们来实现上面提到的方法。 方法实现首先来实现 getSize() 方法，这个是返回数组元素的个数的，我们直接返回 size 即可 public int getSize() &#123; return size;&#125; isEmpty() 是为了查看数组中是否还有元素，如果 size 为 0 的话说明数组为空，所以我们返回 size == 0 即可 public boolean isEmpty() &#123; return size == 0;&#125; 现在来实现 add(int index, E e) 方法，该方法的实现是将 index 后面的元素都向后移动一位，然后在 index 处插入元素 e public void add(int index, E e) &#123; //对inex进行验证 如果不符合规范则抛出异常 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //将元素向后移动 for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; //在index处插入元素e data[index] = e; //数组中元素个数+1 size++;&#125; 根据这个方法，我们可以很快的实现 addFirst(E e) 和 addLast(E e) 方法，这两个方法一个是在数组头添加元素，一个是在数组的末尾添加一个元素 public void addLast(E e) &#123; //在index = size处添加元素 即在数组末尾添加一个元素 add(size,e);&#125;public void addFirst(E e) &#123; //在index = 0处添加一个元素 即在数组头添加一个元素 add(0,e);&#125; 下面来实现 remove(int index) 方法，该方法是删除 index 处的元素，并将该元素返回，以添加的操作相反，删除是将后面的元素向前移动，覆盖掉 index 处的元素即可删除 public E remove(int index) &#123; //参数检查 if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //获得index处的元素用以返回 E e = data[index]; //将元素从后向前移一个 for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i+1]; &#125; //数组中元素个数-1 size --; //返回删除的元素 return e;&#125; 同理，根据这个方法我们可以快速的实现 removeLast() 和 removeFirst() 方法 public E removeLast() &#123; return remove(size -1);&#125;public E removeFirst() &#123; return remove(0);&#125; 我们可以添加一个删除指定元素的方法 removeElement(E e)，我们会遍历数组，如果发现有元素等于该元素，那么删除该元素并退出方法，所以这个方法只删除第一个元素 e，并不是数组所有的元素 e public void removeElement(E e) &#123; //遍历数组 for (int i = 0; i &lt; size; i++) &#123; //如果找到等于该元素的元素 if (e.equals(data[i])) &#123; //删除该元素 remove(i); //退出方法 return; &#125; &#125;&#125; 下面实现 contains(E e) 方法，这个方法的思路同删除指定元素相似，遍历数组，如果找到元素与指定元素相同，那么返回 true，如果遍历完数组还没有找到与之相等的元素，那么返回 false public boolean contains(E e) &#123; //遍历数组 for (int i = 0; i &lt; size; i++) &#123; //如果找到元素，那么返回true if (data[i].equals(e)) &#123; return true; &#125; &#125; //如果遍历完所有数组没有找到，那么返回false return false;&#125; find(E e) 方法的实现也是遍历数组，如果找到了元素，那么返回下标，如果遍历完数组都没有找到，那么返回 -1 public int find(E e) &#123; //遍历数组 for (int i = 0; i &lt; size; i++) &#123; //找到元素则返回下标 if (data[i].equals(e)) &#123; return i; &#125; &#125; //如果遍历完数组都没有找到，返回-1 return -1;&#125; 下面实现 get(int index) 和 set(int index, E e)，这两个方法的实现及其简单，直接上代码 public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index];&#125;public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; data[index] = e;&#125; 我们可以根据 get 方法实现 getLast()和 getFirst() 方法 public E getFirst() &#123; return get(0);&#125;public E getLast() &#123; return get(size - 1);&#125; 现在我们已经实现了 API 中提到的所有的方法，但是我们还是没有解决数组容量固定的问题，为了解决这个问题，我们需要实现一个 resize(int newCapacity)，它的作用是改变数组的容量大小，这样当数组的容量不足时，我们调用该方法就可以将数组进行扩容，或者当数组中有大量空间空闲时，我们可以缩小数组的容量，代码如下 private void resize(int newCapacity) &#123; //创建一个新容量的数组 E[] temp = (E[]) new Object[newCapacity]; //将数组中的数据全部放入新数组中 for (int i =0; i &lt; size; i++) &#123; temp[i] = data[i]; &#125; //改变数组指针指向 data = temp;&#125; 现在我们改变 add(int index, E e)和remove(int index) 方法，我们会在添加元素和删除元素时检查数组的容量，以便对数组进行扩容或者缩容 public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //如果数组容量满了 那么将数组的容量扩为原来的两倍 if (size == data.length) &#123; resize(data.length * 2); &#125; for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; data[index] = e; size++;&#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E e = data[index]; for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i+1]; &#125; size --; //如果数组中的元素个数为数组容量的1/4，那么容量变为原来的1/2 //思考一下为什么是1/4 提示：复杂度震荡 if (size == data.length/4) &#123; resize(data.length/2); &#125; return e;&#125; 为了方便的打印 Array 类，我们重写 toString() 方法如下 public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(\"size \" + size); str.append(\" capacity \" + data.length); str.append(\"\\n[\"); for (int i = 0; i &lt; size; i++) &#123; if (i == size - 1) &#123; str.append(data[i].toString()); &#125; else &#123; str.append(data[i].toString() + \", \"); &#125; &#125; str.append(\"]\"); return str.toString();&#125; 至此，我们已经完全实现了 Array，它的容量没有限制，并且提供了很多的方法供用户调用，我们将使用该类来实现其它的基本的数据结构。下面贴出完整的代码 public class Array&lt;E&gt; &#123; private E[] data; private int size; public Array(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; &#125; public Array() &#123; this(10); &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void addLast(E e) &#123; add(size,e); &#125; public void addFirst(E e) &#123; add(0,e); &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; if (size == data.length) &#123; resize(data.length * 2); &#125; for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; data[index] = e; size++; &#125; public E removeLast() &#123; return remove(size -1); &#125; public E removeFirst() &#123; return remove(0); &#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E e = data[index]; for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i+1]; &#125; size --; if (size == data.length/4) &#123; resize(data.length/2); &#125; return e; &#125; public void removeElement(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(data[i])) &#123; remove(i); return; &#125; &#125; &#125; public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; public int find(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; private void resize(int newCapacity) &#123; E[] temp = (E[]) new Object[newCapacity]; for (int i =0; i &lt; size; i++) &#123; temp[i] = data[i]; &#125; data = temp; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index]; &#125; public E getFirst() &#123; return get(0); &#125; public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; data[index] = e; &#125; public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(\"size \" + size); str.append(\" capacity \" + data.length); str.append(\"\\n[\"); for (int i = 0; i &lt; size; i++) &#123; if (i == size - 1) &#123; str.append(data[i].toString()); &#125; else &#123; str.append(data[i].toString() + \", \"); &#125; &#125; str.append(\"]\"); return str.toString(); &#125;&#125; 栈栈是一种先进后出的结构，比如你放书会把书放在最上面，最先放的书在最下面，而你拿书却是从最上面拿，最后放的最先拿到，栈正是怎么一种结构，我们规定最上面的位置叫做栈顶，我们向栈中添加元素是添加到栈顶，向栈中取出元素是从栈顶取出的，我们先来定义一个 Stack 接口，里面规定了一个栈包含的操作 public interface Stack&lt;E&gt; &#123; //向栈中压入一个元素 void push(E e); //将栈顶元素弹出 E pop(); //栈是否为空 boolean isEmpty(); //获得栈中元素的个数 int getSize(); //获得栈顶元素 E peek();&#125; 下面我们将使用上面实现的 Array 来实现一个 ArrayStack，我们把数组的最后位置定义为栈顶 public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private Array&lt;E&gt; data; public ArrayStack(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public ArrayStack() &#123; data = new Array&lt;&gt;(); &#125; @Override public void push(E e) &#123; data.addLast(e); &#125; @Override public E pop() &#123; return data.removeLast(); &#125; @Override public boolean isEmpty() &#123; return data.isEmpty(); &#125; @Override public int getSize() &#123; return data.getSize(); &#125; @Override public E peek() &#123; return data.getLast(); &#125; public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Stack: \"); res.append(\"[\"); for (int i = 0; i &lt; data.getSize(); i++) &#123; res.append(data.get(i)); if (i != data.getSize()-1) &#123; res.append(\", \"); &#125; &#125; res.append(\"] top\"); return res.toString(); &#125;&#125; 上面的代码极其的简单，只要仔细的阅读就可以完全的理解，这里不多做解释。 下面介绍一个有关于栈的题目，此题来自于LeetCode第20题 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 这道题的解题思路是，如果遇到左括号&#39;(&#39;, &#39;[&#39;, &#39;{&#39;，那么将左括号压入栈中，如果遇到右括号，那么将栈顶的左括号弹出，判断两个括号是否匹配，如果不匹配返回 fasle，如果匹配进行下一轮，最后如果字符串遍历完毕，如果栈为空说明匹配成功，如果栈不为空，所以左边的括号多匹配失败，代码如下 import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; //创建一个空栈 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //遍历字符串 for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); //如果是左括号，则压入栈中 if (c == '(' || c == '[' || c == '&#123;') &#123; stack.push(c); &#125; else &#123; //如果是右括号 先判断栈是否为空 if (stack.isEmpty()) &#123; return false; &#125; //获得栈顶的左括号 char charTop = stack.pop(); //下面三种皆为不匹配的情况 if (c == ')' &amp;&amp; charTop != '(') &#123; return false; &#125; if (c == ']' &amp;&amp; charTop != '[') &#123; return false; &#125; if (c == '&#125;' &amp;&amp; charTop != '&#123;') &#123; return false; &#125; &#125; &#125; //这里不能直接返回true 要根据栈是否为空决定返回值 return stack.isEmpty(); &#125;&#125; 队列队列是一种先进先出的结构，假设你在排队，那么最先排队的人最先得到服务。我们只能从队尾添加元素，从队首取出元素。老规矩，我们首先规定一下队列 Queue 的 API public interface Queue&lt;E&gt; &#123; //向队列中添加一个元素 void enqueue(E e); //从队列中取出一个元素 E dequeue(); //获得队首的元素 E getFront(); //获取队列中元素的个数 int getSize(); //判断队列是否为空 boolean isEmpty();&#125; 数组队列 现在我们将使用动态数组 Array 类来实现队列，实现的逻辑也十分的简单，如下 public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayQueue() &#123; array = new Array&lt;&gt;(); &#125; public ArrayQueue(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public E getFront() &#123; return array.getFirst(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Queue: \"); res.append(\"front [\"); for (int i = 0; i &lt; array.getSize(); i++) &#123; res.append(array.get(i)); if (i != array.getSize()-1) &#123; res.append(\", \"); &#125; &#125; res.append(\"] tail\"); return res.toString(); &#125;&#125; 注意上面我们的 dequeue 操作是调用了动态数组的 removeFirst 操作，这个操作需要遍历整个数组将元素向前移动，所以该操作是 O(n) 的。 循环队列上面队列的 dequeue 操作是 O(n) 级别的，这是因为上面会将数组整体向前移一位，但是如果我们不这么做，而是增加一个变量 front 来记录队首的位置，这样我们只要将 front 向前移一位即可，这样的操作就是 O(1) 级别的 这样做的同时，我们发现，如果当 tail 来到数组的末尾，按道理应该将数组进行扩容，但是 front 前面还有空间 这个时候我们应当将 tail 移动到数组头去 这时 tail 的计算公式不再是简单的 tail = tail + 1，而是 tail = (tail + 1) % data.length，如果不理解这个式子，就想象一下时钟，11 点向前一步就是 12 点，也可以称为是 0 点，这个时候时钟的计算公式为 (11 + 1) % 12。因为这种循环的特性，我们把这种实现方式称为循环队列。这次我们实现队列不在使用上面的动态数组，有了上面实现栈和队列的经验，想必可以容易理解下面的代码(在关键的步骤给予注释) public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private int front; private int tail; //队列中元素的个数 private int size; //底层实现的数组 private E[] data; //构造方法初始化 public LoopQueue(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; front = 0; tail = 0; &#125; //默认容量为10 public LoopQueue() &#123; this(10); &#125; @Override public void enqueue(E e) &#123; //首先判断数组是不是满了，如果是那么就进行扩容 if (size == data.length) &#123; resize(2 * data.length); &#125; //向队尾添加元素 data[tail] = e; //tail向后移动 不是简单的+1 上面已有解释 tail = (tail +1) % data.length; size++; &#125; //数组伸缩操作，已接触过 private void resize(int newCapacity) &#123; E[] temp = (E[]) new Object[newCapacity]; for (int i =0; i &lt; size; i++) &#123; //这里我们将队列的头对应到新数组的开头 temp[i] = data[(front + i)%data.length]; &#125; //重新记录front和tail的位置 front = 0; tail = size; data = temp; &#125; @Override public E dequeue() &#123; //如果队列为空，抛出异常 if (size == 0) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; //获得出队的元素 E e = data[front]; data[front] = null; //front向前移动(带循环) front = (front + 1) % data.length; size--; //缩容操作，不做解释 if (size == data.length / 4) &#123; resize(data.length / 2); &#125; return e; &#125; @Override public E getFront() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; return data[front]; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(\"Queue: size \" + size); str.append(\" capacity \" + data.length); str.append(\"\\nfront [\"); for (int i = 0; i &lt; size; i++) &#123; if (i == size - 1) &#123; str.append(data[(front + i) % data.length].toString()); &#125; else &#123; str.append(data[(front + i) % data.length].toString() + \", \"); &#125; &#125; str.append(\"] tail\"); return str.toString(); &#125;&#125; 这次我们得到的 dequeue 操作就是 O(1) 的了(严格的讲均摊复杂度为 O(1)，因为里面 resize() 复杂度是 O(n) 的)。 链表链表是一种非常重要的线性数据结构，我们在实现栈和队列时使用的是动态数组实现的，这个动态数组是针对用户而言是动态的，实际上底层是静态的，是通过 resize() 操作去解决容量问题的。而链表则是一种真正的动态数据结构，它是这么一种数据结构，我们把数据存储在一个节点(Node)中，一个节点一般包含两部分的内容，一个是存储的数据，一个是它要指向的下一个节点 class Node &#123; private E e; private Node next;&#125; 一个节点指向一个节点，所以最后看起来就像是一个链，我们把这种数据结构称为链表 最后一个节点的下一个节点为 `NULL`，表示后面没有节点了。它是一个真正的动态的数据结构，不需要处理容量的问题。但是它也有缺点，它没有数组那样快的查询能力，它要查询某个节点的数据，只能通过头结点一直寻找下来(后面我们将看到)，所以它的查询速度比数组慢。 链表实现现在我们将实现这么一个结构，首先设计好节点类 public class LinkedList&lt;E&gt; &#123; //我们将Node设置为LinkedList的私有内部类 private class Node&lt;E&gt; &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125;&#125; 我们要想向链表中添加(或其他操作)元素，不可避免的要遍历链表(因为链表不能通过索引访问，只能通过前面的节点找到后面的节点)，而要遍历链表，我们就要将链表的头存储起来，这样才能遍历链表，我们将链表的头称为 head 同时我们使用变量 `size` 来记录链表中元素的个数 public class LinkedList&lt;E&gt; &#123; //为了节省篇幅，Node类不再展示，下同 //头结点 private Node head; //链表中元素的个数 private int size; public LinkedList() &#123; head = null; size = 0; &#125;&#125; 现在我们实现两个简单的方法 getSize() 和 isEmpty() public int getSize() &#123; return size;&#125;public boolean isEmpty() &#123; return size == 0;&#125; 添加元素向链表头添加元素 首先将要插入的新节点指向 `head`，然后将 `head` 设置为新节点，实现如下 public void addFirst(E e) &#123; //体会一下这条语句的意思 head = new Node(e,head); size++;&#125; 在链表的中间添加一个元素 比如现在往节点 `1` 后面插入一个元素，首先将新节点指向节点 `2`，然后节点 `1` 指向新节点，实现如下 public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //如果是头结点需要单独处理 if (index == 0) &#123; addFirst(e); &#125; //prev代表要插入位置的前一个节点 Node prev = head; for (int i = 0; i &lt; index - 1; i++) &#123; prev = prev.next; &#125; prev.next = new Node(e, prev.next); size++;&#125; 向链表的尾部添加一个元素直接复用上面的代码 public void addLast(E e) &#123; add(size, e);&#125; 虚拟头结点我们在向链表中添加元素时，因为 head 前面没有节点，所以我们在添加元素时会对 head 进行单独的处理，为了不使 head 具有特殊性，我们在链表的最头部添加一个虚拟头结点，里面不存储元素，它的存在是为了使得操作链表方便 现在我们修改上面的 `head` 为 `dummyHead` public class LinkedList&lt;E&gt; &#123; //虚拟结点 private Node dummyHead; private int size; public LinkedList() &#123; //这里修改了 dummyHead = new Node(null, null); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; //直接调用add方法 public void addFirst(E e) &#123; add(0,e); &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //不需要对head进行单独的处理了 //index - 1修改为了index Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; prev.next = new Node(e, prev.next); size++; &#125; public void addLast(E e) &#123; add(size, e); &#125;&#125; 获得某个索引的值实现的思路同 add 很像，不过这里我们找的不是前一个节点，而是当前的节点 public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //cur代表当前节点 Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return (E) cur.e;&#125; 基于这个方法，我们可以很快的实现 getFirst() 和 getLast() public E getFirst() &#123; return get(0);&#125;public E getLast() &#123; return get(size - 1);&#125; 更新某个索引的值实现的思路完全是同 get() 方法，直接上代码 public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.e = e;&#125; 查找链表是否存在元素epublic boolean contains(E e) &#123; //从当前节点开始，一直遍历到最后一个节点 for (Node cur = dummyHead.next; cur != null; cur = cur.next) &#123; if (cur.e.equals(e)) &#123; return true; &#125; &#125; return false;&#125; 删除链表中的元素 上图已详细说明了操作的步骤，这里直接贴上代码实现 public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //获得要删除节点的前一个节点 Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; //图示的操作 Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size--; return (E) delNode.e;&#125; 根据上面的方法，可以很快的实现 removeFirst() 和 removeLast() 方法 public E removeFirst() &#123; return remove(0);&#125;public E removeLast() &#123; return remove(size - 1);&#125; toString()@Overridepublic String toString() &#123; StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; //你可以使用上面的for循环 while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"NULL\"); return res.toString();&#125; 全部代码public class LinkedList&lt;E&gt; &#123; private class Node&lt;E&gt; &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedList() &#123; dummyHead = new Node(null, null); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void addFirst(E e) &#123; add(0,e); &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; prev.next = new Node(e, prev.next); size++; &#125; public void addLast(E e) &#123; add(size, e); &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return (E) cur.e; &#125; public E getFirst() &#123; return get(0); &#125; public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.e = e; &#125; public boolean contains(E e) &#123; for (Node cur = dummyHead.next; cur != null; cur = cur.next) &#123; if (cur.e.equals(e)) &#123; return true; &#125; &#125; return false; &#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; Node prev = dummyHead; for (int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size--; return (E) delNode.e; &#125; public E removeFirst() &#123; return remove(0); &#125; public E removeLast() &#123; return remove(size - 1); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"NULL\"); return res.toString(); &#125;&#125; 使用链表实现栈由于链表的 addFirst() 和 removeFirst() 的操作都是 O(1)，所以我们使用链表头作为栈顶，具体的实现逻辑如下 public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListStack() &#123; linkedList = new LinkedList&lt;&gt;(); &#125; @Override public void push(E e) &#123; linkedList.addFirst(e); &#125; @Override public E pop() &#123; return linkedList.removeFirst(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public E peek() &#123; return linkedList.getFirst(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Stack: top \"); res.append(linkedList); return res.toString(); &#125;&#125; 使用链表实现队列我们之前使用数组实现队列，由于它的 dequeue 操作是 O(n) 级别的，所以我们使用 front 来标记队首，使用循环队列设计，同样的在链表中从链表尾部删除或增加元素都是 O(n) 级别的，为了解决这一个问题，我们决定在链表的尾部增加一个 tail 变量来标记，从而使得在尾部增加元素是 O(1) 级别的。 另外考虑在尾部删除一个元素是 O(1) 的吗? 答案是不是。因为我们删除一个节点需要知道该节点的前一个节点，而知道 tail 节点是无法知道 tail 的前一个节点的，我们还是要遍历。所以我们在 head 端删除元素，在 tail 端添加元素，并且由于只涉及到头部和尾部的操作，所以我们也不需要添加虚拟头结点了 下面就是实现的代码 public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&lt;E&gt; &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node head; private Node tail; private int size; public LinkedListQueue() &#123; head = null; tail = null; size = 0; &#125; @Override public void enqueue(E e) &#123; //队列为空时，tail和head都为null 添加元素后二者都指向第一个元素 if (size == 0) &#123; tail = new Node(e); head = tail; &#125; else &#123; tail.next = new Node(e); tail = tail.next; &#125; size++; &#125; @Override public E dequeue() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; Node delNode = head; head = head.next; delNode.next = null; size--; //如果队列为空了，此时tail指向的是delNode，此时应该让tail为null if (size == 0) &#123; tail = null; &#125; return (E) delNode.e; &#125; @Override public E getFront() &#123; if (head == null) &#123; throw new IllegalArgumentException(\"队列为空\"); &#125; return (E) head.e; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Queue: front \"); Node cur = head; while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"NULL tail\"); return res.toString(); &#125;&#125; 二分搜索树什么是树结构 当你把上面的图倒过来看，就像是一棵树，所以我们把这种结构称为是树结构。那为什么要使用树结构，因为树结构在生活中很常见，如文件夹的组织方式，又或者如公司职能的组织方式，这些都是树结构的例子。为什么会使用树结构呢? 原因就是因为高效。 概念同链表一样，它也是一种动态的数据结构，链表中的节点是指向一个节点，而二叉树是指向两个节点，我们把这两个节点称为左子树和右子树，又或者称为左孩子和右孩子。如下图表示的就是二叉树 class Node &#123; E e; Node left; Node right;&#125; 根节点 最顶部的那个节点，如上图中 28 就是根节点 二叉树具有唯一的一个根节点 叶子节点 没有孩子的节点，如上图的最后一行都是叶子节点 二叉树的每个节点最多有两个孩子，最多有一个父亲 那是什么是二分搜索树，首先二分搜索树是二叉树，它满足这样的特点，对于每个节点 大于左子树所有节点的值 小于右子树所有节点的值 可以验算，上面的这棵树满足二分搜索树的性质，所以这棵树是二分搜索树。下面我们来实现二分搜索树中节点有关代码 public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left; public Node right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; //根节点 private Node root; //树中元素的个数 private int size; public BST() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; 实现添加元素 上图想必已经将添加元素的规则说的很详细了，所以这里直接上代码 public void add(E e) &#123; if (root == null) &#123; root = new Node(e); size++; &#125; else &#123; add(root, e); &#125;&#125;private void add(Node node, E e) &#123; //递归终止条件 if (e.equals(node.e)) &#123; return; &#125; else if (e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null) &#123; node.left = new Node(e); size++; return; &#125; else if (e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null) &#123; node.right = new Node(e); size++; return; &#125; if (e.compareTo(node.e) &lt; 0) &#123; add(node.left, e); &#125; if (e.compareTo(node.e) &gt; 0) &#123; add(node.right, e); &#125;&#125; 其实上面的代码还可以改进，因为我们在 add(E e) 中对 root 为根节点进行了单独的考虑，其实可以不再这里考虑，因为通过上面的规则知道，当一个节点为 null 时，不管它是根节点还是左右孩子，新加入的节点都将取代这个 null 节点 所以我们优化上面的代码如下 public void add(E e) &#123; root = add(root, e);&#125;private Node add(Node node, E e) &#123; //这里返回的Node所指的语义是node所代表的根节点 if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; //如果比根节点小，对左子树进行更新 node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; //如果比根节点大，对右子树进行更新 node.right = add(node.right,e); &#125; //等于的话什么都不做 return node;&#125; 查询操作public boolean contains(E e) &#123; return contains(root, e);&#125;private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125;&#125; 二叉树的遍历对于某个数据结构的遍历就是将该数据结构中所有的元素都访问一遍，分为三类 前序遍历 父节点在访问左子树之前访问 中序遍历 父节点在访问左子树之后，在访问右子树之前访问 后序遍历 父节点在访问右子树之后访问 前序遍历public void preOrder() &#123; preOrder(root);&#125;private void preOrder(Node node) &#123; if (node == null) &#123; return; &#125; //先访问父节点 System.out.println(node); preOrder(node.left); preOrder(node.right);&#125; 中序遍历public void inOrder() &#123; inOrder(root);&#125;private void inOrder(Node node) &#123; if (node == null) &#123; return; &#125; inOrder(node.left); System.out.println(node); inOrder(node.right);&#125; 中序遍历的结果是元素从小到大排序。 后序遍历public void postOrder() &#123; postOrder(root);&#125;private void postOrder(Node node) &#123; if (node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node);&#125; 后序遍历的一个应用是内存释放，我们必须先把左右孩子的内存释放完才能释放该节点的内存。 前序遍历的非递归实现 代码实现 public void preOrderNR() &#123; //非递归写法 if (root == null) &#123; return; &#125; //这里的Stack是上面自己写的Stack Stack&lt;Node&gt; stack = new ArrayStack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node top = stack.pop(); System.out.println(top); if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125;&#125; 层序遍历 代码实现 public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LoopQueue&lt;&gt;(); queue.enqueue(root); while (!queue.isEmpty()) &#123; Node front = queue.dequeue(); System.out.println(front); if (front.left != null) &#123; queue.enqueue(front.left); &#125; if (front.right != null) &#123; queue.enqueue(front.right); &#125; &#125;&#125; 删除元素在二分搜索树中删除一个节点是比较复杂的，我们首先从最简单的情况开始，删除二分搜索树中的最小值和最大值，首先是如何找到最大值和最小值 public E minimum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return minimum(root).e;&#125;private Node minimum(Node node) &#123; if (node.left == null) &#123; return node; &#125; return minimum(node.left);&#125;public E maximum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return maximum(root).e;&#125;private Node maximum(Node node) &#123; if (node.right == null) &#123; return node; &#125; return maximum(node.right);&#125; 找到了之后如何删除呢 public E removeMin() &#123; E ret = minimum(); root = removeMin(root); return ret;&#125;private Node removeMin(Node node) &#123; if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125; public E removeMax() &#123; E ret = maximum(); root = removeMax(root); return ret;&#125;private Node removeMax(Node node) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 现在讲解如何删除二分搜搜数中的任意一个节点 public void remove(E e) &#123; root = remove(root, e);&#125;private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; else &#123; Node successor = minimum(node.right); successor.right = removeMin(node.right);//为什么这条语句必须在前面??? successor.left = node.left; node.left = node.right = null; //size--; 在removeMin中已经维护size了 return successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); &#125; else &#123; node.right = remove(node.right, e); &#125; return node;&#125; 上面说的是取右子树中的最小值，你也可以考虑取左子树中的最大值，道理都是一样的。 完整代码public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left; public Node right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; //根节点 private Node root; //树中元素的个数 private int size; public BST() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(E e) &#123; root = add(root, e); &#125; private Node add(Node node, E e) &#123; //这里返回语义指的的是node所代表的根节点 if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; //如果比根节点小，对左子树进行更新 node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; //如果比根节点大，对右子树进行更新 node.right = add(node.right,e); &#125; //等于的话什么都不做 return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125; //前序遍历 public void preOrder() &#123; preOrder(root); &#125; private void preOrder(Node node) &#123; if (node == null) &#123; return; &#125; System.out.println(node); preOrder(node.left); preOrder(node.right); &#125; public void preOrderNR() &#123; //非递归写法 if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new ArrayStack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node top = stack.pop(); System.out.println(top); if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125; //中序遍历 public void inOrder() &#123; inOrder(root); &#125; private void inOrder(Node node) &#123; if (node == null) &#123; return; &#125; inOrder(node.left); System.out.println(node); inOrder(node.right); &#125; //后序遍历 public void postOrder() &#123; postOrder(root); &#125; private void postOrder(Node node) &#123; if (node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node); &#125; public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LoopQueue&lt;&gt;(); queue.enqueue(root); while (!queue.isEmpty()) &#123; Node front = queue.dequeue(); System.out.println(front); if (front.left != null) &#123; queue.enqueue(front.left); &#125; if (front.right != null) &#123; queue.enqueue(front.right); &#125; &#125; &#125; public E minimum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return minimum(root).e; &#125; private Node minimum(Node node) &#123; if (node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; public E maximum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return maximum(root).e; &#125; private Node maximum(Node node) &#123; if (node.right == null) &#123; return node; &#125; return maximum(node.right); &#125; public E removeMin() &#123; E ret = minimum(); root = removeMin(root); return ret; &#125; private Node removeMin(Node node) &#123; if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; public E removeMax() &#123; E ret = maximum(); root = removeMax(root); return ret; &#125; private Node removeMax(Node node) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; node.right = removeMax(node.right); return node; &#125; public void remove(E e) &#123; root = remove(root, e); &#125; private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; else &#123; Node successor = minimum(node.right); successor.right = removeMin(node.right);//为什么这条语句必须在前面??? successor.left = node.left; node.left = node.right = null; //size--; 在removeMin中已经维护size了 return successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); &#125; else &#123; node.right = remove(node.right, e); &#125; return node; &#125;&#125; 优先队列和堆普通队列：先进先出，就像是我们在银行办业务或者是在超市买东西，但是考虑在医院，有病人有突发情况，这个时候容不得他去排队挂号了，这时他的优先级是比较高的，所以他需要得到优先的处理，像这种队列中的元素具有优先级的队列，我们把它称之为优先队列。在游戏中我们也会设置优先攻击血量最低的怪或者距离最近的怪，这时候血量和距离就成为了判断优先级的标准；在操作系统的任务调度，我们为程序分配 CPU，内存等等资源，并不是先到先得的，也是根据程序的优先级来进行分配的。 ### 堆的结构 这里的堆指的是二叉堆，它满足以下的性质 二叉堆是一棵完全二叉树 把元素顺序排列成树的形状 - 堆中某个节点的值总是不大于其父亲节点的值(最大堆，相应也可以定义最小堆) 如果我们使用数组去实现堆 上面的序号表示的是在数组中的下标，我们发现如果父节点的下标为 `i`，那么左孩子的下标就为 `2i + 1`，右孩子的下标为 `2i + 2`，所以可以很快的根据父节点的下标得到左右孩子的下标，如果知道左右孩子的下标 `i`，那么 `(i - 1)/2` 就可以得到父节点的下标(整数除法，小数部分会被舍去)。这个结论可以使用数学归纳法进行证明，但不是这里的重点，所以不多做阐述。 public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap() &#123; data = new Array&lt;&gt;(); &#125; public int size() &#123; return data.getSize(); &#125; public boolean isEmpty() &#123; return data.isEmpty(); &#125; //根据左右孩子的下标获得父亲节点的下标 private int parent(int index) &#123; return (index - 1) / 2; &#125; //根据父节点的下标获得左孩子的下标 private int leftChild(int index) &#123; return 2 * index + 1; &#125; //根据父节点的下标获得右孩子的下标 private int rightChild(int index) &#123; return 2 * index + 2; &#125;&#125; 堆的实现向堆中添加元素 public void swap(int i, int j) &#123; if (i &lt; 0 || i &gt;= size() || j &lt; 0 || j &gt;= size()) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E temp = data.get(i); data.set(i, data.get(j)); data.set(j, temp);&#125;public void add(E e) &#123; data.addLast(e); siftUp(data.getSize() - 1);&#125;private void siftUp(int index) &#123; //index不是根节点(根节点不要上浮了) 并且孩子比父亲大 while (index != 0 &amp;&amp; data.get(index).compareTo(data.get(parent(index))) &gt; 0) &#123; swap(index, parent(index)); index = parent(index); &#125;&#125; 向堆中取出最大元素 public E findMax() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(\"堆为空\"); &#125; return data.get(0);&#125;public E extractMax() &#123; E ret = findMax(); swap(0,data.getSize() - 1); data.removeLast(); siftDown(0); return ret;&#125;private void siftDown(int index) &#123; //没有孩子时，下沉结束 while (leftChild(index) &lt; size()) &#123; int max = leftChild(index); int rightIndex = rightChild(index); if (rightIndex &lt; size()) &#123; max = data.get(max).compareTo(data.get(rightIndex)) &gt; 0 ? max : rightIndex; &#125; //最大孩子比父节点小时，下沉结束 if (data.get(max).compareTo(data.get(index)) &lt;= 0) &#123; break; &#125; swap(max,index); index = max; &#125;&#125; replacereplace 操作指的是从堆中取出元素，并向堆中添加一个元素，实现的方法为 //取出堆中的最大元素，并添加一个新元素epublic E replace(E e) &#123; E ret = findMax(); data.set(0,e); siftDown(0); return ret;&#125; heapifyheapify 是指将任意一个数组整理成堆的形状， 我们把这个方法做成一个构造函数 public MaxHeap(E[] arr) &#123; data = new Array&lt;&gt;(arr.length); for (int i = 0; i &lt; arr.length; i++) &#123; data.addLast(arr[i]); &#125; for (int i = parent(data.getSize() -1); i &gt;=0; i--) &#123; siftDown(i); &#125;&#125; 完整代码public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap() &#123; data = new Array&lt;&gt;(); &#125; public MaxHeap(E[] arr) &#123; data = new Array&lt;&gt;(arr.length); for (int i = 0; i &lt; arr.length; i++) &#123; data.addLast(arr[i]); &#125; for (int i = parent(data.getSize() -1); i &gt;=0; i--) &#123; siftDown(i); &#125; &#125; public int size() &#123; return data.getSize(); &#125; public boolean isEmpty() &#123; return data.isEmpty(); &#125; //根据左右孩子的下标获得父亲节点的下标 private int parent(int index) &#123; return (index - 1) / 2; &#125; //根据父节点的下标获得左孩子的下标 private int leftChild(int index) &#123; return 2 * index + 1; &#125; //根据父节点的下标获得右孩子的下标 private int rightChild(int index) &#123; return 2 * index + 2; &#125; public void swap(int i, int j) &#123; if (i &lt; 0 || i &gt;= size() || j &lt; 0 || j &gt;= size()) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; E temp = data.get(i); data.set(i, data.get(j)); data.set(j, temp); &#125; public void add(E e) &#123; data.addLast(e); siftUp(data.getSize() - 1); &#125; private void siftUp(int index) &#123; //index不是根节点(根节点不要上浮了) 并且孩子比父亲大 while (index != 0 &amp;&amp; data.get(index).compareTo(data.get(parent(index))) &gt; 0) &#123; swap(index, parent(index)); index = parent(index); &#125; &#125; public E findMax() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(\"堆为空\"); &#125; return data.get(0); &#125; public E extractMax() &#123; E ret = findMax(); swap(0,data.getSize() - 1); data.removeLast(); siftDown(0); return ret; &#125; private void siftDown(int index) &#123; //没有孩子时，下沉结束 while (leftChild(index) &lt; size()) &#123; int max = leftChild(index); int rightIndex = rightChild(index); if (rightIndex &lt; size()) &#123; max = data.get(max).compareTo(data.get(rightIndex)) &gt; 0 ? max : rightIndex; &#125; //最大孩子比父节点小时，下沉结束 if (data.get(max).compareTo(data.get(index)) &lt;= 0) &#123; break; &#125; swap(max,index); index = max; &#125; &#125; //取出堆中的最大元素，并添加一个新元素e public E replace(E e) &#123; E ret = findMax(); data.set(0,e); siftDown(0); return ret; &#125;&#125; 基于堆的优先队列public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue() &#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public void enqueue(E e) &#123; maxHeap.add(e); &#125; @Override public E dequeue() &#123; return maxHeap.extractMax(); &#125; @Override public E getFront() &#123; return maxHeap.findMax(); &#125; @Override public int getSize() &#123; return maxHeap.size(); &#125; @Override public boolean isEmpty() &#123; return maxHeap.isEmpty(); &#125;&#125; 线段树对于有一类的问题，我们主要关心的是线段(区间)，比如说查询一个区间 [i, j] 内的最大值，最小值等等。假设你有一个网站，你想查询某年(或某年以后)的用户访问量，消费最多的用户等等，这些都是在某个区间内进行查询，一般线段树的区间是固定的，不包含删除和添加的操作，只有查询和更新的操作 ### 线段树的表示 现在如果假设有n个元素，用数组存储的话，需要多少空间呢 public class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; public SegmentTree(E[] arr) &#123; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * data.length]; &#125; public int getSize() &#123; return data.length; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index]; &#125; private int leftChild(int index) &#123; return 2 * index + 1; &#125; private int rightChild(int index) &#123; return 2 * index + 2; &#125;&#125; 实现创建线段树下面就要根据数组来创建一棵线段树，我们的方法先创建下面的子线段树，然后由这些子线段树合并成大的线段树，以此类推 在合并左右子树的过程中，我们不能写死合并的过程，具体怎么合并应该由业务决定，由用户去决定如何合并，所以合并的过程我们写一个接口，具体的实现由用户去实现 public interface Merger&lt;E&gt; &#123; public E merge(E a, E b);&#125; 然后我们在构造方法中添加创建线段树的过程(为了创建线段树，增加了一个辅助方法) private Merger&lt;E&gt; merger;//merger由用户传入 用户决定如何合并public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * data.length]; //构造线段树 创建根节点为0，范围为[0,data.length - 1]的线段树 buildSegmentTree(0, 0, data.length - 1);&#125;//在treeIndex创建一棵[l,r]的线段树private void buildSegmentTree(int treeIndex, int l, int r) &#123; if (l == r) &#123; tree[treeIndex] = data[l]; return; &#125; //l != r 那么就要创建子树的线段树 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; //(l +r) / 2中l + r可能会大于int表示的范围从而溢出 buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); //融合的方法由用户传入 tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);&#125; 为了方便我们打印出线段树，我们实现一个 toString() 方法 @Overridepublic String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"[\"); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append(\"null\"); &#125; if (i != tree.length - 1) &#123; res.append(\", \"); &#125; &#125; res.append(\"]\"); return res.toString();&#125; 查询 实现代码 public E query(int queryL, int queryR) &#123; if (queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return query(0, 0, data.length - 1, queryL, queryR);&#125;private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if (l == queryL &amp;&amp; r == queryR) &#123; return tree[treeIndex]; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (queryL &gt;= mid + 1) &#123; return query(rightChildIndex, mid+1, r, queryL, queryR); &#125; else if (queryR &lt;= mid) &#123; return query(leftChildIndex, l, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex, l, mid, queryL, mid); E rightResult = query(rightChildIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult);&#125; 更新public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; set(0, 0, data.length - 1, index, e);&#125;private void set(int treeIndex, int l, int r, int index, E e) &#123; if (l == r) &#123; tree[treeIndex] = e; return; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (index &gt;= mid + 1) &#123; set(rightChildIndex, mid+1, r, index, e); &#125; else &#123; set(leftChildIndex, l, mid, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftChildIndex], tree[rightChildIndex]);&#125; 完整代码public class SegmentTree&lt;E&gt;&#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * data.length]; buildSegmentTree(0, 0, data.length - 1); &#125; //在treeIndex创建一棵[l,r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r) &#123; if (l == r) &#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; //(l +r) / 2中l + r可能会大于int表示的范围从而溢出 buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]); &#125; public E query(int queryL, int queryR) &#123; if (queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return query(0, 0, data.length - 1, queryL, queryR); &#125; private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if (l == queryL &amp;&amp; r == queryR) &#123; return tree[treeIndex]; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (queryL &gt;= mid + 1) &#123; return query(rightChildIndex, mid+1, r, queryL, queryR); &#125; else if (queryR &lt;= mid) &#123; return query(leftChildIndex, l, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex, l, mid, queryL, mid); E rightResult = query(rightChildIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; set(0, 0, data.length - 1, index, e); &#125; private void set(int treeIndex, int l, int r, int index, E e) &#123; if (l == r) &#123; tree[treeIndex] = e; return; &#125; int leftChildIndex = leftChild(treeIndex); int rightChildIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; if (index &gt;= mid + 1) &#123; set(rightChildIndex, mid+1, r, index, e); &#125; else &#123; set(leftChildIndex, l, mid, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftChildIndex], tree[rightChildIndex]); &#125; public int getSize() &#123; return data.length; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return data[index]; &#125; private int leftChild(int index) &#123; return 2 * index + 1; &#125; private int rightChild(int index) &#123; return 2 * index + 2; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"[\"); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append(\"null\"); &#125; if (i != tree.length - 1) &#123; res.append(\", \"); &#125; &#125; res.append(\"]\"); return res.toString(); &#125;&#125; TrieTrie 树又称为字典树、前缀树。如果我们使用一般树结构去查询一个数据集里的单词，它的复杂度是 O(log n)，但是如果我们使用 Trie 去查询单词的话，查询的复杂度只与单词的长度有关，与数据的规模无关。比如对于一个 $2^{20}$ 规模的数据集，我们去查一个单词 &quot;word&quot;，一般树的复杂度为 O(20)，而 Trie 树的复杂度为 O(4)，其中 4 是单词的长度，所以 Trie 树是一种很高效的查询字符串的树结构。 class Node &#123; char c; Node next[26];&#125; 但是这样考虑忽略了大小写，并且没有考虑一些特殊的字符，如 @ 等符号或标点符号。所以我们每个节点不再是静态的指向 26 个节点，而是动态的指向若干个节点 class Node &#123; char c; Map&lt;Character,Node&gt; next;&#125; 另外我们通过某个字符来到一个节点，可以通过 Map已经知道了，所以我们不必存储这个字符 class Node &#123; Map&lt;Character,Node&gt; next;&#125; 另外通过叶子节点是无法区别单词的结尾的，因为有的单词可能为某个单词的前缀，如 `\"pan\"` 为 `\"panda\"` 的前缀，所以我们要增加一个变量 `isWord` 来表示是否是单词的结尾 import java.util.TreeMap;public class Trie &#123; private class Node &#123; public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125; public int getSize() &#123; return size; &#125;&#125; 实现添加单词 public void add(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); //判断是否有指向这个字符的节点 if (cur.next.get(c) == null) &#123; //没有则新建一个节点 cur.next.put(c, new Node()); &#125; //移动到这个节点 cur = cur.next.get(c); &#125; //遍历完毕，判断这个节点是否被标记为单词的结尾 如果没有则标记并且维护size++ if (!cur.isWord) &#123; cur.isWord = true; size++; &#125;&#125; 查询单词查询单词的逻辑与添加单词的逻辑高度重复，如果在查询过程中遇到没有指向该字符的节点，则直接返回 false，如果遍历完毕都没有发生上面的情况，则判断该节点是否被标记为单词的结尾，如果没有则返回 false，否则返回 true。 public boolean contains(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return cur.isWord;&#125; 前缀搜索查询是否包含某个前缀，与 contains() 方法几乎一样，不过最后不用判断是否是单词结尾，直接返回 true public boolean isPrefix(String prefix) &#123; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return true;&#125; 简单字符匹配对于字符串中的字符 . 规定它可以匹配任意的字符，那么这样的一个匹配算法如何写，如果我们遇到的字符不是 . 的话，逻辑和上面一样，如果遇到的是.的话，我们就要去搜索该节点中所有的分叉(子树) public boolean match(String word) &#123; return match(root, word, 0);&#125;private boolean match(Node node, String word, int index) &#123; //递归终止条件 if (index == word.length()) &#123; return node.isWord; &#125; char c = word.charAt(index); //如果不是. if (c != '.') &#123; //没有指向该字符的节点 返回false if (node.next.get(c) == null) &#123; return false; &#125; else &#123; //否则继续匹配 return match(node.next.get(c), word, index + 1); &#125; &#125; else &#123; //如果是. 去该节点的所有分叉中搜索 for (char nextChar : node.next.keySet()) &#123; //如果有任一个分叉匹配到了，则返回true if (match(node.next.get(nextChar), word, index + 1)) &#123; return true; &#125; &#125; //说明上面的没有一个匹配成功了，返回fasle return false; &#125;&#125; 全部代码import java.util.TreeMap;public class Trie &#123; private class Node &#123; public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125; public int getSize() &#123; return size; &#125; public void add(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (cur.next.get(c) == null) &#123; cur.next.put(c, new Node()); &#125; cur = cur.next.get(c); &#125; if (!cur.isWord) &#123; cur.isWord = true; size++; &#125; &#125; public boolean contains(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return cur.isWord; &#125; public boolean isPrefix(String prefix) &#123; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return true; &#125; public boolean match(String word) &#123; return match(root, word, 0); &#125; private boolean match(Node node, String word, int index) &#123; //递归终止条件 if (index == word.length()) &#123; return node.isWord; &#125; char c = word.charAt(index); if (c != '.') &#123; if (node.next.get(c) == null) &#123; return false; &#125; else &#123; return match(node.next.get(c), word, index + 1); &#125; &#125; else &#123; for (char nextChar : node.next.keySet()) &#123; if (match(node.next.get(nextChar), word, index + 1)) &#123; return true; &#125; &#125; //说明上面的没有一个匹配成功了 return false; &#125; &#125;&#125; 并查集我们之前遇到的树结构都是由父亲指向孩子，但是并查集不一样，它是由孩子指向父亲的一种结构，并查集结构可以非常高效的回答连接问题(Connectivity Problem)，它可以很快的判断网络中节点的连接状态。并查集主要支持两个动作 union(p, q) 将元素 p, q 连接起来 isConnected(p, q) 判断元素 p, q 是否是连接的，即是否所属一个集合 这里先给出并查集的接口，后面我们将实现多个版本的并查集 public interface UF &#123; public int getSize(); public boolean isConnected(int p, int q); public void unionElements(int p, int q);&#125; Quick Find //第一版的并查集public class UnionFind1 implements UF&#123; private int[] id; public UnionFind1(int size) &#123; id = new int[size]; //这时id全部为0，相当于在一个集合中 一开始应该全部不在一个集合中 for (int i = 0; i &lt; id.length; i++) &#123; id[i] = i; &#125; &#125; @Override public int getSize() &#123; return id.length; &#125; //找到元素p所属的集合 private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; return id[p]; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; if (find(p) == find(q)) &#123; return; &#125; for (int i = 0; i &lt; id.length; i++) &#123; if (id[i] == find(p)) &#123; id[i] = find(q); &#125; &#125; &#125;&#125; Quick Union //第二版的并查集public class UnionFind2 implements UF&#123; private int[] parent; public UnionFind2(int size) &#123; parent = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; index = parent[index]; &#125; return index; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; else &#123; parent[pRoot] = parent[qRoot]; &#125; &#125;&#125; 基于rank的优化 //第三版的并查集public class UnionFind3 implements UF&#123; private int[] parent; //记录根节点的高度 private int[] rank; public UnionFind3(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; index = parent[index]; &#125; return index; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; //只要在两个数的高度相等的时候 树的高度才会增加 if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; 路径压缩 //第四版的并查集public class UnionFind4 implements UF&#123; private int[] parent; private int[] rank; public UnionFind4(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; while (index != parent[index]) &#123; //只添加了这一行代码 parent[index] = parent[parent[index]]; index = parent[index]; &#125; return index; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; //这时rank不代表高度 因为在路径压缩时没有维护rank //但是整体上rank还是能够表示大小关系的 if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; //第五版的并查集public class UnionFind5 implements UF&#123; private int[] parent; private int[] rank; public UnionFind5(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; parent.length; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; private int find(int index) &#123; if (index &lt; 0 || index &gt;= parent.length) &#123; throw new IllegalArgumentException(\"参数错误\"); &#125; //修改了这里 if (index != parent[index]) &#123; parent[index] = find(parent[index]); &#125; return parent[index]; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &lt;= rank[qRoot])&#123; parent[pRoot] = parent[qRoot]; if (rank[pRoot] == rank[qRoot]) &#123; rank[qRoot]++; &#125; &#125; else &#123; parent[qRoot] = parent[pRoot]; &#125; &#125;&#125; 第五版的效率不一定比第四版的好，因为第四版最后也可能做到”扁平化”，并且第五版的递归操作比较耗时。 AVL树概念及实现我们在研究二分搜索树时发现，如果我们将数据顺序添加进树中时，它有会退化成一棵链表，即所有的元素都添加到一个孩子上，这样树结构的优势就体现不出来，为了不使左右孩子的高度相差太大，我们需要对树进行调整，使树达到平衡，成为一棵平衡二叉树，AVL 就是一种经典的平衡二叉树 在 `AVL` 中，我们定义的平衡二叉树为，对于任意一个节点，左子树和右子树的高度相差不能超过 `1`。 我们为每一个节点标注好高度值，计算方法为取左右子树高度较高的高度，然后 +1 然后我们还有记录节点左右子树的高度差，我们称之为平衡因子(规定用左子树的高度-右子树的高度) 由于我们只是在添加元素和删除元素时对树进行调整，其余的代码同二分搜索树是相同的，所以就不贴出所有的代码，只给出不同的代码，首先我们需要在 `Node` 类中添加一个 `height` 变量来记录高度 private class Node &#123; public E e; public Node left; public Node right; //高度 public int height; public Node(E e) &#123; this.e = e; left = null; right = null; //高度初始为1 height = 1; &#125; @Override public String toString() &#123; return e.toString(); &#125;&#125; 新增加一个获得某节点高度的函数和平衡因子的函数 private int getHeight(Node node) &#123; if (node == null) &#123; return 0; &#125; return node.height;&#125;private int getBalanceFactor(Node node) &#123; if (node == null) &#123; return 0; &#125; return getHeight(node.left) - getHeight(node.right);&#125; 有了这些因素，我们一般需要在添加元素时进行维护，重新计算高度和平衡因子，从而进行调整 private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; //更新高度 node.height = Math.max(getHeight(node.left),getHeight(node.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(node); if (Math.abs(balanceFactor) &gt; 1) &#123; //进行调整 &#125; return node;&#125; 我们后面的内容主要是如何调整，后面所以只给出如何调整的代码，在学如何调整之前，我们来写两个辅助函数来判断这棵树是不是二分搜索树和 AVL 树，因为如果我们的代码有问题的话，有可能破坏二分搜索树的性质，这样有利于我们检查，那怎么检查一棵树是不是二分搜索树，我们根据二分搜索树的性质，它的中序遍历的结果是从小到大的特性，我们重写中序遍历为 public boolean isBST() &#123; ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;(); inOrder(root, arrayList); for (int i = 1; i &lt; arrayList.size(); i++) &#123; if (arrayList.get(i-1).compareTo(arrayList.get(i)) &gt; 0) return false; &#125; &#125; return true;&#125;private void inOrder(Node node, ArrayList&lt;E&gt; arrayList) &#123; if (node == null) &#123; return; &#125; inOrder(node.left, arrayList); arrayList.add(node.e); inOrder(node.right, arrayList);&#125; 现在我们判断这棵树是不是平衡二叉树 public boolean isBalanced() &#123; return isBalanced(root);&#125;//判断某个节点是不是平衡private boolean isBalanced(Node node) &#123; if (node == null) &#123; return true; &#125; int balanceFactor = getBalanceFactor(node); if (Math.abs(balanceFactor) &gt; 1) &#123; return false; &#125; return isBalanced(node.left) &amp;&amp; isBalanced(node.right);&#125; 下面对不平衡的四种情形进行讨论，并给出调整方法 // 对节点y进行向右旋转操作，返回旋转后新的根节点x// y x// / \\ / \\// x T4 向右旋转 (y) z y// / \\ - - - - - - - -&gt; / \\ / \\// z T3 T1 T2 T3 T4// / \\// T1 T2private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; x.right = y; y.left = T3; //更新x和y的高度值 先更新y的，因为y是x的右孩子，x的更新取决于y y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x;&#125;// 对节点y进行向左旋转操作，返回旋转后新的根节点x// y x// / \\ / \\// T4 x 向左旋转 (y) y z// / \\ - - - - - - - -&gt; / \\ / \\// T3 z T4 T3 T1 T2// / \\// T1 T2private Node leftRotate(Node y) &#123; Node x = y.right; Node T3 = x.left; x.left = y; y.right = T3; y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x;&#125;public void add(E e) &#123; root = add(root, e);&#125;private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; //更新高度 node.height = Math.max(getHeight(node.left),getHeight(node.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(node); //调整 if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) &#123; return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) &#123; return leftRotate(node); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node;&#125;public void remove(E e) &#123; root = remove(root, e);&#125;private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; Node retNode; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; retNode = leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; retNode = rightNode; &#125; else &#123; Node successor = minimum(node.right); ////由于removeMin没有维持balance，所以我们复用remove successor.right = remove(node.right,successor.e); successor.left = node.left; node.left = node.right = null; retNode = successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); retNode = node; &#125; else &#123; node.right = remove(node.right, e); retNode = node; &#125; //否则retNode.height会有空指针异常 if (retNode == null) &#123; return null; &#125; //更新高度 retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(retNode); if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) &#123; return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) &#123; return leftRotate(retNode); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode;&#125; 完整代码import java.util.ArrayList;public class AVLTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left; public Node right; public int height; public Node(E e) &#123; this.e = e; left = null; right = null; height = 1; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; //根节点 private Node root; //树中元素的个数 private int size; public AVLTree() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private int getHeight(Node node) &#123; if (node == null) &#123; return 0; &#125; return node.height; &#125; private int getBalanceFactor(Node node) &#123; if (node == null) &#123; return 0; &#125; return getHeight(node.left) - getHeight(node.right); &#125; public boolean isBST() &#123; ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;(); inOrder(root, arrayList); for (int i = 1; i &lt; arrayList.size(); i++) &#123; if (arrayList.get(i-1).compareTo(arrayList.get(i)) &gt; 0) &#123; return false; &#125; &#125; return true; &#125; private void inOrder(Node node, ArrayList&lt;E&gt; arrayList) &#123; if (node == null) &#123; return; &#125; inOrder(node.left, arrayList); arrayList.add(node.e); inOrder(node.right, arrayList); &#125; public boolean isBalanced() &#123; return isBalanced(root); &#125; //判断某个节点是不是平衡 private boolean isBalanced(Node node) &#123; if (node == null) &#123; return true; &#125; int balanceFactor = getBalanceFactor(node); if (Math.abs(balanceFactor) &gt; 1) &#123; return false; &#125; return isBalanced(node.left) &amp;&amp; isBalanced(node.right); &#125; private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; x.right = y; y.left = T3; //更新x和y的高度值 先更新y的，因为y是x的右孩子，x的更新取决于y y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; private Node leftRotate(Node y) &#123; Node x = y.right; Node T3 = x.left; x.left = y; y.right = T3; y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; public void add(E e) &#123; root = add(root, e); &#125; private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; //更新高度 node.height = Math.max(getHeight(node.left),getHeight(node.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(node); if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) &#123; return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) &#123; return leftRotate(node); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125; public E minimum() &#123; if (size == 0) &#123; throw new IllegalArgumentException(\"树为空\"); &#125; return minimum(root).e; &#125; private Node minimum(Node node) &#123; if (node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; public void remove(E e) &#123; root = remove(root, e); &#125; private Node remove(Node node, E e) &#123; if (node == null) &#123; return null; &#125; Node retNode; if (e.equals(node.e)) &#123; if (node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; retNode = leftNode; &#125; else if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; retNode = rightNode; &#125; else &#123; Node successor = minimum(node.right); successor.right = remove(node.right,successor.e);//由于removeMin没有维持balance，所以我们用remove successor.left = node.left; node.left = node.right = null; //size--; 在removeMin中已经维护size了 retNode = successor; &#125; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); retNode = node; &#125; else &#123; node.right = remove(node.right, e); retNode = node; &#125; //否则retNode.height会有空指针异常 if (retNode == null) &#123; return null; &#125; //更新高度 retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right)) + 1; //计算平衡因子 int balanceFactor = getBalanceFactor(retNode); if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) &#123; return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) &#123; return leftRotate(retNode); &#125; if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode; &#125;&#125; 红黑树2-3树2-3 树的节点它可以有一个元素，也可以有两个元素，它也满足二分搜索树的性质 我们把含有两个孩子的节点称为 `2` 节点，含有 `3` 个孩子的节点称为 `3` 节点 `2-3` 树是一种绝对平衡的树，所谓绝对平衡的树指的是从根节点到任意一个叶子节点，所经过的节点是都是相同的。那么 `2-3` 树是怎么做到的呢? ### 红黑树与2-3树的等价性 由于我们一般每个节点都是表示一个数据的，2-3 树有点难以实现，所以有人发明一种树叫做红黑树，它可以说是 2-3 树的等价，那么它树如何等价的呢? 上图想必很清楚的描述了等价的过程 现在我们来实现一下上面描述的红黑树，大部分的代码都是和二分搜索树是重合的，只是在添加时有调整，另外这里我们不牵涉到从红黑树中删除元素，因为太复杂了(其实是我不会) public class RedBlackTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; //规定红色为true 黑色为false private static final boolean RED = true; private static final boolean BLACK = false; private class Node &#123; public E e; public Node left; public Node right; public boolean color; public Node(E e) &#123; this.e = e; left = null; right = null; //我们在2-3树中添加节点时 永远是和别的节点融合 所以默认为红色 color = RED; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node root; private int size; public RedBlackTree() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(E e) &#123; root = add(root, e); &#125; // 判断节点node的颜色 private boolean isRed(Node node)&#123; if(node == null) return BLACK; return node.color; &#125; private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125;&#125; 红黑树的性质在了解了红黑树与 2-3 等价以后，我们来看红黑树满足哪些性质 每个节点或者是红色的，或者的是黑色的 根节点是黑色的 - 每一个叶子节点(最后的空节点是黑色的) - 因为红色节点只存在于 3 节点中，而所有的叶子节点都是 2 节点 - 如果一个节点是红色的，那么它的所有孩子节点都是黑色的 - 从任意一个节点到黑色节点，经过的黑色节点是一样的 - 因为 `2-3` 树到所有叶子节点的距离都是一样的，而经过的节点，不管是 `2` 节点还是 `3` 节点，都包括一个黑色节点，所以经过的黑色节点是一样的 向红黑树中添加元素因为根节点是黑色的，所以我们在添加完元素后需要将根节点变为黑色 public void add(E e) &#123; root = add(root, e); root.color = BLACK;&#125; 在添加元素到红黑树中时，可能会破坏红黑树的规则，这时就需要红黑树进行自我调整，我们就来看一下添加过程会碰到的所有情形，以及处理方法 // node x// / \\ 左旋转 / \\// T1 x ---------&gt; node T3// / \\ / \\// T2 T3 T1 T2private Node leftRotate(Node node)&#123; Node x = node.right; // 左旋转 node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x;&#125; // 颜色翻转private void flipColors(Node node)&#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK;&#125; // node x// / \\ 右旋转 / \\// x T2 -------&gt; y node// / \\ / \\// y T1 T1 T2private Node rightRotate(Node node)&#123; Node x = node.left; // 右旋转 node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x;&#125; 对上面的情况进行总结 private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; if (isRed(node.right) &amp;&amp; !isRed(node.left)) node = leftRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rightRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node); return node;&#125; 完整代码public class RedBlackTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; //规定红色为true 黑色为false private static final boolean RED = true; private static final boolean BLACK = false; private class Node &#123; public E e; public Node left; public Node right; public boolean color; public Node(E e) &#123; this.e = e; left = null; right = null; //我们在2-3树中添加节点时 永远是和别的节点融合 所以默认为红色 color = RED; &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node root; private int size; public RedBlackTree() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private boolean isRed(Node node) &#123; if (node == null) &#123; return BLACK; &#125; return node.color; &#125; // node x // / \\ 左旋转 / \\ // T1 x ---------&gt; node T3 // / \\ / \\ // T2 T3 T1 T2 private Node leftRotate(Node node) &#123; Node x = node.right; node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x; &#125; // node x // / \\ 右旋转 / \\ // x T2 -------&gt; y node // / \\ / \\ // y T1 T1 T2 private Node rightRotate(Node node) &#123; Node x = node.left; node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x; &#125; private void flipColors(Node node) &#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK; &#125; public void add(E e) &#123; root = add(root, e); root.color = BLACK; &#125; private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; else if (e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right,e); &#125; if (isRed(node.right) &amp;&amp; !isRed(node.left)) node = leftRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rightRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node); return node; &#125; public boolean contains(E e) &#123; return contains(root, e); &#125; private boolean contains(Node node, E e) &#123; if (node == null) &#123; return false; &#125; if (e.equals(node.e)) &#123; return true; &#125; else if (e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else &#123; return contains(node.right,e); &#125; &#125;&#125; 哈希表我们通过将我们要查找的某种数据类型转化为一个索引 index，然后通过索引去数组中查找，这时它的复杂度就是 O(1) 级别的。而将某个数据类型转化为索引的函数我们就称为是哈希函数，比如说将 26 个小写字母转化为索引，我们可以这么写 index = ch - 'a'; 这样就建立起了一一对应的关系，但是并不是所有的对应关系都是一一对应的，因为数组的容量是有限的，而输入的范围可能是无穷的，所以很有可能不同的键对应着同一个索引，比如说键是字符串，因为字符串的组合方式是非常的多，可以看做是无穷的，我们不可能去开辟一个无穷的空间去与这些字符串一一对应，所以不同的字符串生成的索引很有可能会有冲突，我们称这种情况为哈希冲突。由于上面讲到的哈希冲突，所以我们要设计好哈希函数(hashCode())使得发生哈希冲突的可能性小，即使哈希函数产生的哈希值均匀的分布在数组中。 哈希函数的设计哈希函数应该满足上面提到的：哈希函数产生的哈希值均匀的分布在数组中。数据的类型五花八门，对于特殊的领域有特殊领域的哈希函数的设计方式，甚至还有专门的论文，说这么多就是想说哈希函数的设计十分的复杂，在这里我们只提最简单的一种，哈希函数的设计应该满足 一致性 如果 a == b，那么 hashCode(a) == hashCode(b) 高效性 计算迅速 均匀性 输出尽可能均匀 由于 `Java` 中基本数据类型和字符串类型有默认的 `hashCode()` 计算，所以我们就用 `Java` 自带的 `hashCode` 计算基本数据类型和字符串的哈希值，而对于引用类型 `Java` 是根据地址计算的哈希值，所以可能会出现问题，需要我们自己自定义规则，比如对于一个 `Student` 类，我们规定学号以及姓名相同(不区分大小写)就是同一个学生，所以根据一致性原则，它们应该产生相同的哈希值，但是由于 `Java` 默认是根据地址产生哈希值，由于二者的地址是不同的，所以产生的哈希值有极大的概率是不同的，所以我们需要自己创建哈希函数。 链地址法现在我们来演示往哈希表中添加元素的步骤 import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable(int M) &#123; this.M = M; size = 0; hashTable = new TreeMap[M]; for (int i = 0; i &lt; hashTable.length; i++) &#123; hashTable[i] = new TreeMap&lt;&gt;(); &#125; &#125; public HashTable() &#123; this(97); &#125; public int getSize() &#123; return size; &#125; //得到在数组中的索引 private int hash(K key) &#123; //与0x7fffffff是为了消除负数 return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public void add(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //先查看已经是否有这个键了 if (map.containsKey(key)) &#123; //有则更新 map.put(key, value); &#125; else &#123; //没有则进行添加，并维护size map.put(key, value); size++; &#125; &#125; public V remove(K key, V value) &#123; V ret = null; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //如果包含键则删除，没有返回null if (map.containsKey(key)) &#123; ret = map.remove(key); size--; &#125; return ret; &#125; public void set(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //没有该键抛出异常 if (!map.containsKey(key)) &#123; throw new IllegalArgumentException(\"键不存在\"); &#125; map.put(key,value); &#125; //直接得到相应的TreeMap，然后去查，TreeMap有检查步骤 public V get(K key) &#123; return hashTable[hash(key)].get(key); &#125;&#125; import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private static final int upperTol = 10; private static final int lowerTol = 2; private static final int initCapacity = 7; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable(int M) &#123; //只显示改变的内容 //... hashTable = new TreeMap[initCapacity]; &#125; public void add(K key, V value) &#123; //... if (size &gt;= upperTol * M) &#123; resize(2 * M); &#125; &#125; public V remove(K key, V value) &#123; //... if (size &lt; M * lowerTol &amp;&amp; M / 2 &gt;= initCapacity) &#123; resize(M / 2); &#125; return ret; &#125; private void resize(int newM) &#123; TreeMap&lt;K,V&gt;[] newHashTable = new TreeMap[newM]; //后面要更新M，但是还需要旧M遍历数组 int oldM = M; //由于后面要重新计算下标，所以这里要更新M M = newM; for (int i = 0; i &lt; oldM; i++) &#123; TreeMap&lt;K, V&gt; map = hashTable[i]; for (K key: map.keySet()) &#123; //重新计算下标并赋值 newHashTable[hash(key)].put(key, map.get(key)); &#125; &#125; hashTable = newHashTable; &#125;&#125; 但是我们发现每次我们都扩容为 2 \\* M，这时 M 就不是一个素数了，为了解决这一个问题，我们准备一个素数表，让 M 取素数表中的值，每次扩容 M 在素数表中的索引 +1，缩容 -1 import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; //素数表 private static final int[] capacity = &#123;&#125;; private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable() &#123; this.M = capacity[capacityIndex]; size = 0; hashTable = new TreeMap[M]; for (int i = 0; i &lt; hashTable.length; i++) &#123; hashTable[i] = new TreeMap&lt;&gt;(); &#125; &#125; public void add(K key, V value) &#123; //... if (size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; size) &#123; capacityIndex++; resize(capacity[capacityIndex]); &#125; &#125; public V remove(K key, V value) &#123; //... if (size &lt; M * lowerTol &amp;&amp; capacityIndex - 1 &gt;= 0) &#123; capacityIndex--; resize(capacity[capacityIndex]); &#125; return ret; &#125;&#125; 完整代码import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private static final int[] capacity = &#123;&#125;; private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; //数组中存储的是TreeMap这种查找表 private TreeMap&lt;K, V&gt;[] hashTable; private int M; private int size; public HashTable() &#123; this.M = capacity[capacityIndex]; size = 0; hashTable = new TreeMap[M]; for (int i = 0; i &lt; hashTable.length; i++) &#123; hashTable[i] = new TreeMap&lt;&gt;(); &#125; &#125; public int getSize() &#123; return size; &#125; //得到在数组中的索引 private int hash(K key) &#123; //与0x7fffffff是为了消除负数 return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public void add(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //先查看已经是否有这个键了 if (map.containsKey(key)) &#123; //有则更新 map.put(key, value); &#125; else &#123; //没有则进行添加，并维护size map.put(key, value); size++; &#125; if (size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; capacity.length) &#123; capacityIndex++; resize(capacity[capacityIndex]); &#125; &#125; public V remove(K key, V value) &#123; V ret = null; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //如果包含键则删除，没有返回null if (map.containsKey(key)) &#123; ret = map.remove(key); size--; &#125; if (size &lt; M * lowerTol &amp;&amp; capacityIndex - 1 &gt;= 0) &#123; capacityIndex--; resize(capacity[capacityIndex]); &#125; return ret; &#125; public void set(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashTable[hash(key)]; //没有该键抛出异常 if (!map.containsKey(key)) &#123; throw new IllegalArgumentException(\"键不存在\"); &#125; map.put(key,value); &#125; //直接得到相应的TreeMap，然后去查，TreeMap有检查步骤 public V get(K key) &#123; return hashTable[hash(key)].get(key); &#125; private void resize(int newM) &#123; TreeMap&lt;K,V&gt;[] newHashTable = new TreeMap[newM]; //后面要更新M，但是还需要旧M遍历数组 int oldM = M; //由于后面要重新计算下标，所以这里要更新M M = newM; for (int i = 0; i &lt; oldM; i++) &#123; TreeMap&lt;K, V&gt; map = hashTable[i]; for (K key: map.keySet()) &#123; //重新计算下标并赋值 newHashTable[hash(key)].put(key, map.get(key)); &#125; &#125; hashTable = newHashTable; &#125;&#125; 参考链接 玩转数据结构","tags":[{"name":"算法","slug":"算法","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"MySQL学习笔记","date":"2019-09-13T16:00:00.000Z","path":"/MySQL学习笔记/","text":"这篇文章是记录我学习 MySQL 时的一些笔记，不成体系，仅为以后快速学习准备，由于记录的是从零学习 MySQL 的笔记，所以笔记的内容是十分的基础的，基本上是以用为主，不牵涉到具体的原理性问题。 MySQL基本概念我们使用Java编写程序，一般数据都是存储在内存中的，一旦程序终止或断电，那么数据就会丢失，所以我们需要将数据存储到本地文件中，我们一般存储到数据库中，而 MySQL 正是这么一款数据库。 安装 MySQL 很简单，直接使用搜索引擎搜索 MySQL，进入官网进行安装，MySQL 是开源的软件。目前企业使用的是5.5-5.7的版本，选择进行下载即可。若要卸载 MySQL，在手动卸载 MySQL 后，还要删除 C:\\ProgramData\\MySQL 这个文件夹，否则重新安装时不能成功。 连接MySQL在命令行中输入 mysql -uroot -p 然后会提示你输入密码 输入的密码以密文的形式显示，以保证安全。当然你也可以直接在 -p 后面输入密码，不过这样并不安全。 SQL语句分类SQL 语句按功能分为 DDL：操作数据库，表 DML：增、删、改数据 DQL：查询数据 DLL：与授权有关 在 MySQL 中不区分大小写，不过关键字一般会大写，而数据库名和表名一般小写，SQL语句需要以;结尾，否则会一直等待输入。 注释MySQL 的注释为 -- 后面需要接一个空格，否则会报错，另一种注释为 #，这是 MySQL 独有的，后面不需要加空格 show databases; -- 显示所有的数据库show databases; #显示所有的数据库 DDL这里来介绍操作数据库和表的 SQL 语句，这些操作一般就是 C(Create), R(Retrieve), U(Update), D(Delete)。 操作数据库查询首先介绍查询数据库的语句，连接上 MySQL 后，在命令行中输入(这里关键字没有大写) show databases; 这个语句的作用是显示出所有的数据库 +--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || sys || world |+--------------------+6 rows in set (0.31 sec) 下面这条语句的作用是显示出某数据库所用的字符集 show create database 数据库名; 比如 show create database world; 输出为 +----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| world | CREATE DATABASE `world` /*!40100 DEFAULT CHARACTER SET latin1 */ |+----------+------------------------------------------------------------------+1 row in set (0.05 sec) 可见 world 数据库所用的字符集为 latin1。 创建创建数据库的语句为 create database 数据库名; 如 create database db1; -- 创建一个名为db1的数据库 如果数据库已经存在，那么会发生错误，例如再次执行上面的命令 create database db1; 会发生如下错误 ERROR 1007 (HY000): Can't create database 'db1'; database exists 这个时候我们可以使用 create database if not exists db1; -- 如果db1不存在，那么创建db1，否则什么也不做 我们还可以在创建数据库时指定字符集，如 create database db2 character set gbk; 使用 show create database db2; 查看字符集 +----------+-------------------------------------------------------------+| Database | Create Database |+----------+-------------------------------------------------------------+| db2 | CREATE DATABASE `db2` /*!40100 DEFAULT CHARACTER SET gbk */ |+----------+-------------------------------------------------------------+1 row in set (0.03 sec) 修改我们可以通过下面的命令修改数据库的字符集 alter database 数据库名 character set 字符集; 例如修改 db2 数据库为 utf8 编码 alter database db2 character set utf8; 删除我们可以使用 drop 命令删除数据库，例如 drop database db2; 使用 show databases; 查看数据库，发现 db2 已经被删除了 +--------------------+| Database |+--------------------+| information_schema || db1 || mysql || performance_schema || sakila || sys || world |+--------------------+ 如果数据库不存在，那么会报错，比如在删除一次 db2 ERROR 1008 (HY000): Can't drop database 'db2'; database doesn't exist 这个时候我们可以使用下面的语句 drop database if exists db2; -- 如果db2存在则删除db2，否则什么也不做 使用数据库通过 select database(); 命令可以查看我们正在使用哪一个数据库 +------------+| database() |+------------+| NULL |+------------+1 row in set (0.00 sec) 因为我们没有使用数据库，所以这里显示的是 NULL，可以通过 use 数据库名;来使用数据库，比如使用 db1 数据库 use db1; 再次执行 select database(); 输出为 +------------+| database() |+------------+| db1 |+------------+1 row in set (0.00 sec) 操作表查询可以使用 show tables 查询某数据库中所有的表，例如现在我们使用 world 数据库，然后查询其中所有的表 use world;show tables; 结果为 +-----------------+| Tables_in_world |+-----------------+| city || country || countrylanguage |+-----------------+3 rows in set (0.09 sec) 我们还可以使用 desc 表名; 来查询某表的结构，我们来查询 city 表的结构 desc city; +-------------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------------+----------+------+-----+---------+----------------+| ID | int(11) | NO | PRI | NULL | auto_increment || Name | char(35) | NO | | | || CountryCode | char(3) | NO | MUL | | || District | char(20) | NO | | | || Population | int(11) | NO | | 0 | |+-------------+----------+------+-----+---------+----------------+5 rows in set (0.65 sec) 使用 show create table 表名; 查看表的字符集。 创建创建表的语法为 create table 表名(列名1 数据类型1, ..., 列名n 数据类型n); MySQL 中常用的数据类型有 int 整数类型 double 浮点数类型，接收两个参数，如 double(5,2)，5 代表数字的总长度，2 代表小数点后的位数 date 日期类型，格式为 yy-MM-dd datetime 日期类型，格式为yy-MM-dd HH:mm:ss timestamp 时间戳，格式为yy-MM-dd HH:mm:ss，当不赋值或赋值为NULL时，自动使用当前的时间作为值 varchar 字符串类型，接收一个参数表示字符串的最大长度，如 varchar(20) 现在我们在 db1 中创建一个 student 表 use db1; -- 使用数据库db1create table student(name varchar(10), age int, score double(4,1), insert_time timestamp); -- 创建表student 里面包括name age score insert_time 等列desc student; -- 查看student表的结构 +-------------+-------------+------+-----+-------------------+-----------------------------+| Field | Type | Null | Key | Default | Extra |+-------------+-------------+------+-----+-------------------+-----------------------------+| name | varchar(10) | YES | | NULL | || age | int(11) | YES | | NULL | || score | double(4,1) | YES | | NULL | || insert_time | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |+-------------+-------------+------+-----+-------------------+-----------------------------+4 rows in set (0.07 sec) 删除同删除数据库一样，有两种用法 drop table 表名;drop table if exists 表名; 这里不多做解释。 修改 重命名表名 alter table 表名 rename to 新表名; 修改表的字符集 alter table 表名 character set 字符集; 添加一列 alter table 表名 add 列名 数据类型; 修改列名及其类型 alter table 表名 change 列名 新列名 新数据类型; 修改列的数据类型 alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; DMLDML 是与修改数据有关的 sql 语句。修改数据主要包括的是增删改数据。为了查看修改数据的效果，这里介绍一个查询数据的命令 select * from 表名; 现在创建一个 student 的表 CREATE TABLE student ( name varchar(10), -- 名字长度最大10个字符 age int, -- 年龄 math_score double(3,1), -- 数学成绩 english_score double(3,1), -- 英语成绩 insert_time timestamp -- 数据加入的时间); DESC student; -- 查看表的结构 添加数据向表中添加数据的写法为 insert into 表名(列名1, 列名2, ..., 列名n) values(值1, 值2, ..., 值n); -- 列名和值要一一对应 例如向表中添加数据 INSERT INTO student (name, age, math_score, english_score) VALUES ('dilireba', 27, 60, 70);INSERT INTO student (name, age, math_score, english_score) VALUES ('gulinazha', 28, 62, 68); 使用 SELECT * FROM student; 得到数据为 注意： 列名和值名要一一对应 如果表名后不定义列名，则默认为给所有列添加，如 INSERT INTO student VALUES (&#39;dilireba&#39;, 27, 60, 70); 除了数字类型，其他类型要用引号(&#39;)括起来 删除数据删除数据的格式为 delete from 表名 [where 条件]; -- 删除满足条件的行 其中 [] 代表的是里面的内容可省略，如果不加条件的话，默认为删除表中的所有数据，现在我们删除上例中 age &gt; 27 的行，如下 DELETE FROM student WHERE age &gt; 27; 得到的结果为 如果要删除表中的所有数据的话，不推荐使用 delete from 表名; 因为它会将表中的数据一行一行的删除，效率较慢，推荐使用 truncate table 表名; 它会直接删除这个表，然后创建一个空表，这个表的名字和结构与删除的表相同，从效果上就相当于是删除了表中所有的数据，但是它的效率比 delete from 表名; 快。 更新数据更新数据的语法为 update 表名 set 列名1 = 值1, ..., 列名n = 值n [where 条件]; -- 当符合条件时，更新值 如何省略条件，那么会修改所有的行，如现在我要更新，如何符合条件 age = 27，那么将 age 修改为 28，如下 UPDATE student set age = 28 WHERE age = 27; DQL查询数据的基本语法为 SELECT 字段列表FROM 表名列表WHERE 条件列表GROUP BY 分组字段HAVING 分组后的条件限定ORDER BY 排序LIMIT 分页限定 下面会详细的讲解其中各个关键字的意思。创建一个 student 表如下 CREATE TABLE student ( id int, -- 编号 name varchar(20), -- 姓名 age int, -- 年龄 sex varchar(5), -- 性别 address varchar(100), -- 地址 math int, -- 数学 english int -- 英语); 向其中插入以下数据 INSERT INTO student(id,name,age,sex,address,math,english) VALUES (1,'马云',55,'男', '杭州 ',66,78), (2,'马化腾 ',45,'女 ','深圳 ',98,87), (3,'马景涛 ',55,'男 ','香港 ',56,77), (4,'柳岩',20,'女 ','湖南 ',76,65), (5,'柳青 ',20,'男 ','湖南 ',86,NULL), (6,'刘德华 ',57,'男 ','香港',99, 99), (7,'马德',22,'女','香港',99,99), (8,'德玛西亚',18,'男','南京',56,65); 如果提示 Incorrect string value: '\\xE9\\xA9\\xAC\\xE4\\xBA\\x91' for column 'name' at row 1 那么就是因为字符编码的问题，这时可以修改 name,address,sex 的字符集为 utf8 alter table student change name name char(20) character set utf8;alter table student change address address char(100) character set utf8;alter table student change sex sex char(5) character set utf8; 基础查询查询多个字段SELECT name, age FROM student; -- 查询name和age字段 去重查询 address 字段时，发现有相同的，如”香港” SELECT address FROM student; 如果希望重复出现的只出现一次，那么可以使用 DISTINCT SELECT DISTINCT address FROM student; 计算列现在要计算它们的数学成绩和英语成绩的和 SELECT name, math, english, math+english FROM student; -- 为了看出是谁的总分，这里加上一个name字段 我们发现第 5 行的结果为 null，这是因为 null+ 其它数得到的结果都是 null，但是这里我们应该把 null 当做 0 处理 ，这样加出来的就是总分，而不是 null SELECT name, math, english, math+ifnull(english,0) FROM student; 这里使用了 ifnull(english,0)，如果 english 的值是 null，那么就替换为 0，所以我们得到的结果为 起别名我们注意到上面的最后一列的列名为 math+ifnull(english,0)，这个列名没有什么意义，我们应该为它起个别名，如 score SELECT name, math, english, math+ifnull(english,0) AS score FROM student; 其中 AS 作为一个起别名的作用，AS 其实可以省略，使用空格替代即可，如 SELECT name, math, english, math+ifnull(english,0) score FROM student; 该句得到的结果与上面的相同 条件查询我们使用 WHERE 来指明条件查询，比如我要查询年龄在 20 岁以上的 SELECT name,age FROM student WHERE age &gt; 20; 可见 WHERE 后面跟的是一个逻辑值，既然是逻辑值就可以使用与或非运算 AND OR NOT SELECT name,age FROM student WHERE age &gt; 20 AND age &lt; 50; -- 年龄在20-50之间的 我们可以使用 BETWEEN ... AND ... 来简化上面的操作 SELECT name,age FROM student WHERE age BETWEEN 20 AND 50; -- 在20-50之间，包括20和50 SELECT name,age FROM student WHERE age = 18 OR age = 20 OR age = 25; -- 查询年龄为18或20或25的 我们可以使用 IN 达到相同的效果 SELECT name,age FROM student WHERE age IN (18,20,25); -- 查询年龄为18或20或25的 排序查询使用 ORDER BY 来对查询结果进行排序，后面跟要排序的字段，默认对字段进行升序排序。 ASC：升序 DESC：降序 SELECT name,math FROM student ORDER BY math; -- 默认为升序 SELECT name,math FROM student ORDER BY math DESC; -- 降序 ORDER BY 可以对多个字段进行排序，先对前面的字段进行排序，如果前面的字段相同，在根据后面的字段排序，比如按照数学和英语成绩排名，优先按数学成绩来，如果数学成绩相同则按英语成绩来 SELECT name,math,english FROM student ORDER BY math DESC, english DESC; 模糊查询使用 LIKE 进行模糊查询，比如记不住全称，这时可以使用模糊查询，比如想查询姓马的，在查询之前要介绍占位符 _：表示单个任意字符 %：表示多个任意字符 SELECT name FROM student WHERE name LIKE '马%'; 如果我想查询名字中带有”德”字的 SELECT name FROM student WHERE name LIKE '%德%'; 聚合函数聚合函数将一列作为整体，进行纵向计算。聚合函数有 count：统计个数，不包括 NULL。 max：计算最大值 min：计算最小值 sum：计算总和 avg：计算平均值 SELECT count(math) FROM student;SELECT max(math) FROM student;SELECT min(math) FROM student;SELECT sum(math) FROM student;SELECT avg(math) FROM student; 分组查询使用 GROUP BY 进行分组查询，比如我想男生和女生的数学平均分，那么可以使用 SELECT sex,avg(math) avg -- avg是别名FROM student GROUP BY sex; 如果我想对分数在 70 以上的人计算平均分，并且统计人数，可以这么写 SELECT sex,avg(math) avg, count(id) count -- avg和count是别名FROM student WHERE math &gt; 70 GROUP BY sex; 如果分组后的还要进行筛选，那么可以使用 HAVING，比如这里我要筛选分组后人数大于 2 的才进行统计 SELECT sex,avg(math) avg, count(id) countFROM studentWHERE math &gt; 70GROUP BY sexHAVING count(id) &gt; 2; 分页查询当我们查询数据时，如果我们一页只能显示几行数据，我们就要进行分页查询，使用 LIMIT，后面跟两个数，第一个数代表查询的起始位置，从 0 开始，第二个代表一页显示的行数，如 SELECT *FROM studentLIMIT 0,3; -- 查询中0开始的3行数据 如果我们要查询第二页，可以怎么写 SELECT *FROM studentLIMIT 3,3; 约束所谓约束就是对数据产生限制，比如说某列不能为空(NULL)，有或者说某列的数据不能重复。约束一般包括下面四种约束 非空约束(not null) 唯一约束(unique) 主键约束(primary key) 外键约束(foreign key) 非空约束所谓的非空约束指的就是该列不能有 NULL 值，下面介绍如何创建非空约束，分为两种情况，一种是在创建表示添加非空约束，一种是在创建表之后添加非空约束 创建表示添加非空约束 CREATE TABLE emp( id int, name varchar(10) not null); -- 为name添加非空约束 name不能为NULL 如果此时为 name 赋值为 NULL，那么这条语句将会报错 INSERT INTO emp(id,name) VALUES (0,NULL); -- 为name赋值为NULL 将会报错 Column 'name' cannot be null 在创建表后添加非空约束 如现在给 id 也添加非空约束，应当这么写 ALTER TABLE emp MODIFY id int not null; -- 为id添加非空约束 删除非空约束 删除的办法与添加的语法差不多，如现在我又要删除 id 的非空约束，应当这么写 ALTER TABLE emp MODIFY id int; -- 删除id的非空约束 唯一约束唯一约束指的是该列的值不能相同，关键字为 unique。 创建表时如何添加唯一约束 CREATE TABLE emp( id int UNIQUE, name varchar(10)); -- 为name添加非空约束 name不能为NULL 创建表后添加唯一约束 ALTER TABLE emp MODIFY id int UNIQUE; 删除唯一约束 删除唯一约束的语法与删除非空约束的语法不同，如下 ALTER TABLE emp DROP INDEX id; 主键约束主键约束(primary key)是上面两个的总和，即该列既不能为 NULL，也不能相同。一张表只能有一个字段为主键。 创建表时添加主键 CREATE TABLE emp( id int PRIMARY KEY, name varchar(10)); 创建表后添加主键 ALTER TABLE emp MODIFY id int PRIMARY KEY; 删除主键 ALTER TABLE emp DROP PRIMARY KEY ; -- 因为主键只有一个，不必指明是哪个字段 下面介绍一个小知识点，主键自动增长，当我们添加数据时，如果我们设置了主键增长并且没有为主键赋值，那么主键的值会相较于上一条数据主键的值增长，设置主键自动增长的语法为(假设设置(了) id 为主键) CREATE TABLE emp( id int PRIMARY KEY AUTO_INCREMENT, -- 创建表时添加 name varchar(10) ); ALTER TABLE emp MODIFY id int AUTO_INCREMENT; -- 创建表后添加 id已经设置为主键了 删除主键增长的方法为 ALTER TABLE emp MODIFY id int; -- 这样是不会删除主键的，只会删除主键自动增长 外键约束假设有这么一张表 观察研发部门和部门地点，发现数据冗余很严重，并且在后续添加数据中添加的也是这么一对一对的，很麻烦并且有在添加数据可能会出错，所以我们可以把这张表拆成两张表，如下 现在问题是怎么将这两张表联系起来，答案就是外键约束。那么什么是外键，从表(被别人约束的表)中与主表(用来约束别人的表)主键对应的那一列，如：员工表中的 dep_id。 新建表时增加外键 [CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名) 创建表后添加外键 ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名); 比如我在创建 employee 表时添加外键 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20), age INT, dep_id INT, -- 外键对应主表的主键 CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id)); employee 表已经存在的情况下添加外键 ALTER TABLE employee ADD CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id); 删除外键 -- 删除 employee 表的 emp_depid_fk 外键ALTER TABLE employee DROP FOREIGN KEY emp_depid_fk; 这个时候又会出现新的问题，比如我改变主表中 id=1 为 id=5，但是这时是不会成功的，因为如果改了，从表中的 dep_id 便没有对应的值，这个时候就需要级联操作(在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作)。 ON UPDATE CASCADE 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新 ON DELETE CASCADE 级联删除 create table employee( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 -- 创建外键约束 constraint emp_depid_fk foreign key (dep_id) references department(id) on update cascade on delete cascade); 三大范式设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式 ： 第一范式(1NF) 、第二范式(2NF) 、第三范式(3NF) 、巴斯-科德范式(BCNF) 、第四范式(4NF)和第五范式(5NF，又称完美范式) 。满足最低要求的范式是第一范式(1NF) 。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF) ，其余范式以次类推。一般说来，数据库只需满足第三范式(3NF)就行了。 为了理解三大范式，我们首先来看这么一张表 我们首先来看第一范式的概念：数据库表的每一列都是不可分割的原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。上面的那个表不满足第一范式，因为系的那一列被拆成了两列，我们将它拆分成不同的列 它现在满足第一范式的要求了，接下来看第二范式的概念：在1NF的基础上，非码属性必须完全依赖于码。为了理解这句话的意思，先看下面几个概念： 函数依赖：A=&gt;B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值。则称 B 依赖于 A 例如：学号=&gt;姓名。(学号，课程名称) --&gt; 分数 完全函数依赖：A=&gt;B， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。 例如：(学号，课程名称) =&gt; 分数 部分函数依赖：A=&gt;B， 如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可。 例如：(学号，课程名称) --&gt; 姓名，只依靠学号 传递函数依赖：A=&gt;B, B=&gt;C . 如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A 例如：学号 =&gt; 系名，系名 =&gt; 系主任 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：(学号，课程名称) 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 其实 2NF 就是在 1NF 基础上消除非主属性对主码的部分函数依赖，上表中的码为(学号，课程名称)，只有分数完全依赖该码组，所以我们拆分表如下 第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖)，在学生表中存在学号 =&gt; 系名 =&gt; 系主任的传递依赖，所以再次拆分表 三大范式小结 1NF: 原子性，表中每列不可再拆分。 2NF: 不产生局部依赖，一张表只描述一件事情 3NF: 不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其它列间接依赖于主键。 多表查询多表查询顾名思义就是同时查询多张表，假设有下面这么两张表(第一张是职员(emp)表，第二张是部门(dept)表) 现在我们同时查询这两张表 SELECT *FROM emp, dept; 我们将得到下面这么一张表 这张表的结果是两张表一一组合得到的，得到的结果也叫做笛卡尔积，我们可以看到很有的信息都是错误的，我们的目的就是去除这些无用的信息。 内连接用左边表的记录去匹配右边表的记录，如果符合条件的则显示。内连接分为 隐式内连接 使用 WHERE 条件指定 显示内连接 使用 INNER JOIN ... ON 语句 比如现在我要在上面的笛卡尔积中筛选出 emp 表外键 dept_id 等于主表主键 id 的，那么分别使用隐式内连接和显式外连接的写法为 #隐式写法SELECT *FROM emp, deptWHERE emp.dept_id = dept.id; #显式写法SELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id; 外连接为了演示外连接，在上面的部门表中新加入一个销售部 外连接分为 左外连接 右外连接 两者只要掌握一种即可，因为用另一种时，将二表的顺序交换即可。那什么是左外连接，就是在内连接的基础上，以左表为基准，显示左表的所有内容，如果右表没有对应的内容，那么显示为 NULL，现在我们进行一次内连接查询 SELECT * FROM dept INNER JOIN emp e ON e.dept_id = dept.id; # e是emp的别名 现在我们进行一次左外连接查询 SELECT * FROM dept LEFT JOIN emp e ON dept.id = e.dept_id; 因为左外连接查询是以左表(dept)为基准，左表的内容会全部显示出来，即销售部会被查询出来，而对应的员工表没有对应的元素，所以会显示空 而右外连接与左外连接相反，是以右表为基准，现在如果我们将二表的位置交换，并且使用右外连接查询，得到的结果与上面的会是相同的 SELECT * FROM emp e RIGHT JOIN dept d ON e.dept_id = d.id; 子查询所谓的子查询是指将查询得到的结果作为另一个查询语句的条件，比如我想查出薪资最高员工的信息，那么思路如下 查出最高的薪资是多少 匹配谁的薪资为最高薪资 那么第一步查出的最高薪资就作为了第二步进行匹配的条件 SELECT * FROM emp t1 WHERE t1.salary = (SELECT max(salary) FROM emp); 子查询得到的结果有多种，例如 单行单列 单列多行 多行多列的值(表) 当结果是单个列的值的时候，肯定在 WHERE 后面作为条件，父查询使用比较运算符，如：&gt; 、&lt;、&lt;&gt;、 = 等。现在我要查询小于平均薪资的人有哪些，那么可以这么写 SELECT * FROM emp t1 WHERE t1.salary &lt; (SELECT avg(salary) FROM emp); 子查询结果是单列多行，结果集类似于一个数组，父查询使用 IN 运算符。查询工资大于5000的员工，来自于哪些部门 SELECT t1.nameFROM dept t1WHERE t1.id IN (SELECT emp.dept_id FROM emp WHERE emp.salary &gt; 5000); 子查询结果只要是多列，肯定在FROM后面作为表 SELECT 查询字段 FROM （子查询）表别名 WHERE 条件; 子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段。查询出2011年以后入职的员工信息，包括部门名称 SELECT *FROM (SELECT * FROM db1.emp t1 WHERE t1.join_date &gt; \"2011-1-1\") t3, dept dWHERE d.id = t3.dept_id; 事务所谓事务是指一系列的操作，这些操作要么同时成功，要么同时失败。比如转账，不能我这里转账成功，你那么收不到钱，那么钱就这么消失了? 如果事务执行成功了，那么就提交，如果有一条失败了，那么就需要进行回滚(即回到之前的状态)。与事务有关的三条语句为 start transaction 开启事务 commit 提交事务 可手动提交，也可设置为自动提交 roll back 回滚事务 当事务执行失败时自动自动，也可手动执行 假设有这么一张表，里面存储的是用户名和余额信息 现在张三要向李四转账 500 块，如下 -- 张三账号-500 update account set balance = balance - 500 where name='张三'; -- 李四账号+500 update account set balance = balance + 500 where name='李四'; 如果我们不开启事务的话，那么当张三转了 500 块时，这时服务器崩溃了，李四没有收到钱，但是钱还是少了，这种情况是不能发生的，我们应当开启一个事务，这两个操作要么同时成功，要么同时失败。 START TRANSACTION; -- 开启一个事务-- 张三账号-500update account set balance = balance - 500 where name='张三';-- 李四账号+500update account set balance = balance + 500 where name='李四';COMMIT; -- 提交事务 开启事务后，所有的操作都在临时日志文件中，commit 操作是将临时日志中的内容写到数据库的存储引擎中，所以在提交事务之前，是不会对数据库中的内容进行修改的。而 rollback 则是清空临时日志文件，之前没有进行提交的内容全部清除。 事务的步骤可以简述为下面几步 客户端连接数据库服务器，创建连接时创建此用户临时日志文件 开启事务以后，所有的操作都会先写入到临时日志文件中 所有的查询操作从表中查询，但会经过日志文件加工后才返回 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件 事务的提交分为自动提交和手动提交，在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 事务的特性事务的四大特性 ACID 原子性(Atomicity) 每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都失败。 一致性(Consistency) 事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前 2 个人的 总金额是 2000，转账后 2 个人总金额也是 2000 隔离性(Isolation) 事务与事务之间不应该相互影响，执行时保持隔离的状态。 持久性(Durability) 一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 这篇文章MySQL事务：ACID特性的实现原理总结分析详细讲解了 MySQL 的事务，所以在这里我不多做介绍，因为讲的没人家好。 事务的隔离级别事务在操作时的理想状态是所有的事务之间保持隔离，互不影响。但是因为并发操作，多个用户同时访问同一个数据时，可能引发并发访问的问题，如 脏读 一个事务读取到了另一个事务中尚未提交的数据 比如李四向张三转了 500 块，但是没有提交，这时张三读取数据，发现已经到账 500 块，跟李四说到账了，这时李四进行 roll back 不可重复读 一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这是事务 update 时引发的问题 两次查询输出的结果不同，到底哪次是对的? 不知道以哪次为准。 有的时候这不是一个问题，当然是后面的为准。但是我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和发短信给客 户，结果在一个事务中针对不同的输出目的地进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作 人员就不知道以哪个为准了。 脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据 幻读 一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致的，这是 insert 或 delete 时引发的问题 幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从 “1” 修改为 “2” 的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 “1” 并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体(比如数据的个数)。 MySQL数据库有四种隔离级别 read uncommitted 上面三种问题都有可能发生 read committed 不可能发生脏读，因为只有读到已提交的数据 repeatable read 可能发生幻读 这时 MySQL 的默认隔离级别 serializable 所有的问题都不会发生 上面的级别最低，下面的级别最高，隔离级别越高，性能越差，安全性越高。在 MySQL 数据库中设置事务的隔离级别 set [glogal | session] transaction isolation level 隔离级别名称;set tx_isolation='隔离级别名称'; 权限管理我们现在默认使用的都是 root 用户：超级管理员，拥有全部的权限。但是一个公司里面的数据库服务器上面可能同时运行着很多个项目的数据库。所以我们应该可以根据不同的项目建立不同的用户，分配不同的权限来管理和维护数据库。 创建用户CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; ‘用户名’ 将创建的用户名 ‘主机名’ 指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以 从任意远程主机登陆，可以使用通配符% 该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 #创建 user1 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123 create user 'user1'@'localhost' identified by '123'; #创建 user2 用户可以在任何电脑上登录 mysql 服务器，密码为 123 create user 'user2'@'%' identified by '123'; 创建的用户名都在 mysql 数据库中的 user 表中可以查看到，密码经过了加密。 授予权限GRANT 权限 1, 权限 2... ON 数据库名.表名 TO '用户名'@'主机名'; GRANT…ON…TO 授权关键字 权限 授予用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等。如果要授 予所有的权限则使用 ALL 数据库名.表名 该用户可以操作哪个数据库的哪些表。如果要授予该用户对所有数据库和表的相应操作 权限则可用 * 表示，如 *.* ‘用户名‘@’主机名’ 给哪个用户授权 #给 user1 用户分配对 test 这个数据库操作的权限：创建表，修改表，插入记录，更新记录，查询 grant create,alter,insert,update,select on test.* to 'user1'@'localhost'; #给 user2 用户分配所有权限，对所有数据库的所有表 grant all on *.* to 'user2'@'%'; 撤销权限REVOKE 权限 1, 权限 2... ON 数据库.表名 from '用户名'@'主机名'; REVOKE…ON…FROM 撤销授权的关键字 权限 用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等，所有的权限则使用 ALL 数据库名.表名 对哪些数据库的哪些表，如果要取消该用户对所有数据库和表的操作权限则可用*表 示，如*.* ‘用户名‘@’主机名’ 给哪个用户撤销 #撤销 user1 用户对 test 数据库所有表的操作的权限 revoke all on test.* from 'user1'@'localhost'; 查看权限SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'root'@'localhost'; 删除用户DROP USER '用户名'@'主机名'; 修改管理员密码如果忘了原来的管理员密码 cmd --&gt; net stop mysql 停止 mysql 服务 需要管理员运行该 cmd 使用无验证方式启动 mysql 服务：mysqld --skip-grant-tables 打开新的 cmd 窗口,直接输入 mysql 命令，敲回车。就可以登录成功 use mysql; update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;; 关闭两个窗口 打开任务管理器，手动结束 mysqld.exe 的进程 启动 mysql 服务 使用新密码登录。 如果记得原来的密码 mysqladmin -uroot -p password 新密码 #需要在未登陆 MySQL 的情况下操作，新密码不需要加上引号。 修改普通用户密码set password for '用户名'@'主机名' = password('新密码'); 参考链接 数据库隔离级别，每个级别会引发什么问题 MySQL事务：ACID特性的实现原理总结分析 MySQL数据查询之多表查询 MySQL插入中文错误","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/MySQL/"}]},{"title":"Java Web笔记","date":"2019-08-19T16:00:00.000Z","path":"/JavaWeb/","text":"TomcatWeb服务器软件 服务器：安装了服务器软件的计算机 服务器软件：接收用户请求，处理请求，做出响应 Web服务器软件：用户通过浏览器进行访问我们部署的项目 webLogic：oracle公司，大型JavaEE服务器，收费，支持所有的JavaEE规范 webSphere：IBM公司，大型JavaEE服务器，收费，支持所有的JavaEE规范 JBOSS：JBOSS公司，大型JavaEE服务器，收费，支持所有的JavaEE规范 Tomcat：Apache基金组织，中小型JavaEE服务器，仅仅支持少量的JavaEE规范，开源的，免费的 下载、安装、卸载下载：tomcat.apache.org(Tomcat 8) 安装：解压压缩包即可(路径不要含中文) 卸载：删除文件夹 bin 可执行文件conf 配置文件lib 依赖jar包logs 日志文件temp 临时文件webapps 存放web项目的work 运行时数据LICENSENOTICERELEASE-NOTESRUNNING.txt 启动 双击bin/startup.bat 访问：127.0.0.1:8080，有页面说明访问成功(127.0.0.1可写为localhost) 启动遇到的问题 黑窗口一闪而过 原因：没有配置JAVA_HOME 在环境变量中新建JAVA_HOME，值为jdk的路径，不包括bin目录 然后将PATH中的…/bin(jdk的路径)改为%JAVA_HOME%/bin 启动报错 原因：端口被占用，两种方法 找到占用8080端口的进程杀死 修改自身的端口号 conf/server.xml文件 修改port 一般会将tomcat的默认端口号修改为80(浏览器默认端口号) 关闭 正常关闭 shutdown.bat Ctrl + C 强制关闭 部署项目 直接将项目(这里假设为hello)放到webapps文件夹中即可 */hello：项目的访问路径，虚拟路径 简化部署：打包为war包，将war包复制到webapps下，war包会自动解压缩 缺点：必须拷贝到webapps中 config/server.xml &lt;Host ...&gt; ... &lt;Context docBase=\"项目路径\" path=\"虚拟路径\" /&gt;&lt;/Host&gt; 缺点：不安全，弄坏配置文件 /conf/Catalina/localhost 创建一个文件xxx.xml(任意名称) 编写&lt;Context docBase=”项目路径” /&gt; 虚拟目录就是xml文件的名称 Java动态项目的目录结构 根目录 WEB-INF web.xml：web项目的核心配置文件 classes：放置字节码文件的目录 lib：放置依赖的jar包 Tomcat集成到IDEA中Run –&gt; Edit Configurations -&gt; Defaults -&gt; Tomcat Server -&gt; Local -&gt; Configure -&gt; Tomcat安装目录 Servlet(server applet)概念Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat)识别的规则。 快速入门 创建JavaEE项目 定义一个类实现Servlet接口 实现接口中的抽象方法 配置Servlet package web;import javax.servlet.*;import java.io.IOException;public class ServletDemo01 implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //只写了这一行 System.out.println(\"Hello Servlet\"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 配置Servlet(web.xml) &lt;!--Servlet配置--&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;servlet-class&gt;web.ServletDemo01&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet执行原理 解析URL请求路径，获取Servlet的资源路径 查找web.xml中是否有对应的&lt;url-pattern&gt;标签内容 查找&lt;servlet-class&gt;全类名 tomcat将字节码文件加载进内存，并且创建其名称 调用其方法 Servlet生命周期方法init 在Servlet创建时执行，只会执行一次 默认情况第一次被访问时创建Servlet 配置&lt;servlet&gt;下的&lt;load-on-startup&gt;可修改Servlet创建时机 负数，第一次被访问时创建 0或正数，服务器启动时创建 Servlet是单例的 多个用户同时访问时，可能存在线程安全问题 解决：尽量不要在Servlet中定义成员变量，定义了成员变量，也不要进行赋值 service 提供服务的方法，每一次Servlet访问时执行 destroy Servlet被杀死时被执行(服务器被正常关闭时) 在Servlet被销毁之前执行 getServletConfig(了解) 获取Servlet的配置对象 getServletInfo(了解) 获取Servlet的信息(版本、作者…) Servlet3.0注解配置Servlet3.0 支持注解配置 创建JavaEE项目，勾选servlet3.0以上版本，可以不勾选web.xml 定义类实现Servlet接口，实现方法 在类上使用@WebServlet注解 @WebServlet(“资源路径”) Servlet体系结构Servlet –&gt; GenericServlet –&gt; HttpServlet GenericServlet：将Servlet接口除service()外进行了空实现，只对service()进行了抽象 HttpServlet：对http协议封装，简化操作 doGet() doPost() Servlet url_pattern配置可以定义多个访问路径：@WebServlet({“/d4”,”/dd4”,”/ddd4”}) /xxx /xxx/xxx(目录结构) /xxx/*(*是通配符，优先级较低) *.do(*表示任意，.do代表后缀名，如/demo4.do) HTTP规定请求消息和响应消息的格式。 特点： 基于TCP/IP的高级协议 默认端口号：80 基于请求响应模型，一次请求对应一次响应 无状态的：每次请求相互独立 历史版本： 1.0：每一次请求响应会建立新的连接 1.1：复用连接 请求消息数据格式 请求行 请求头 请求空行 请求体 请求方式(七种，只介绍常见两种)： GET： 参数在请求行中，在url后 请求的url长度有限制 不太安全 POST 参数在请求体中 请求的url长度没有限制 相对安全 请求头： Host：主机 User-Agent：使用的浏览器版本信息 Accept：可以接受什么格式 Accept-Language：可接受的语言 Referer：告诉服务器我从哪里来，作用 防盗链 统计信息 Connection：keep-alive(连接不会断开，可复用) 请求正文： 封装POST请求消息的请求参数的 RequestRequest和Response原理： tomcat根据url创建对应的Servlet对象 tomcat服务器会创建request和response对象，request对象中封装的是请求消息数据 tomcat将request和response传递给service方法，并调用service方法 程序员通过request对象获取请求消息数据，通过response对象设置响应数据 服务器在做出响应之前，会用response对象中拿程序员设置的响应消息数据 Request继承结构： ServletRequest(接口) –&gt; HttpServletRequest(接口) –&gt; RequestFacade(类，Tomcat编写) 获取请求消息数据 获取请求行 格式：GET 虚拟路径/Servlet路径?参数 HTTP/1.1 获取请求方式：getMethod 获取虚拟目录：getContextPath 获取Servlet路径：getServletPath 获取请求参数：getQueryString 获取URI：getURI 获取URL：getURL 获得协议及版本：getProtocol 获取客户机的IP地址：getRemoteAddr URL &lt; URI 获取请求头 通过请求头的名称获取请求头的值：getHeader(String name) 获取所有的请求头名称：Enumeration&lt;String&gt; getHeaderNames() 获取请求体 获取流数据 字符流：BufferedReader getReader() 字节流：ServletInputStream getInputStream() 再从流对象中 其他功能 获取请求方法通用方式(get和post都可以) String getParameter(String name)：根据参数名称获取参数值 String[] getParameterValues(String name)：根据参数名称获取参数值的数组(多用于复选框) Enumeration getParameterNames()：获取所有请求的参数名称 Map&lt;String, String[]&gt; getParameterMap：获取所有参数的Map集合 中文乱码问题： get：tomcat 8已经解决 post：设置流的编码 resquest.setCharacterEncoding(“utf-8”) 请求转发：一种在服务器内部的资源跳转的方式 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径没有发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享对象 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法 setAttribute(String name, Obkect obj)：存储数据 Object getAttribute(String name)：通过键获取值 void removeAttribute(String name)：删除键值对 获取ServletContext ServletContext getServletContext() 开发步骤： 创建项目，导入html，配置文件，jar包 创建数据库环境，User表 创建实体类User 创建UserDao，操作数据库中User表的类 BeanUtils简化数据封装 Map&lt;String String[]) map = req.getParameterMap();User user = new User();BeanUtils.populate(loginUser, map); 响应消息数据格式 响应行 响应头 响应空行 响应体 响应行： 协议以及版本：HTTP/1.1 响应状态码：200 1xx：服务器接客户端消息但是没有接收完成，一段时间后服务器向客户端询问是否还有数据发送 2xx：成功。 200 3xx：重定向。 302(重定向) 304(访问缓存) 4xx：客户端错误。 404(请求路径没有对应的资源) 405(请求方式没有对应的doXxx方法) 5xx：服务器端错误。 500(服务器内部出现异常) 状态码的描述：OK 响应头： 格式 名称：值 常见响应头 Content-Type：服务器告诉客户端响应体数据格式以及编码格式 Content-disposotion：服务器告诉客户端以什么格式打开我的响应体 in-line：默认值，在当前页面打开 attachment：以附件形式打开(文件下载) 响应体： 真实传输的数据 Response功能：设置响应消息的 设置响应行 设置状态码：setStatus(int sc) 设置响应头： setHeader(String name, String value) 设置响应体 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 重定向： 设置状态码302 设置响应头location 简单重定向方法： sendRedirect(String url) 重定向的特点： 地址栏发生变化 可以访问其他站点(服务器)的资源 两次请求(不可用Request域对象共享数据) 路径写法： 相对路径：当前资源与访问资源的路径关系(./index.html = index.html) 绝对路径：(/responseDemo2) 给客户端浏览器使用(a标签，表单，重定向等)：需要加虚拟目录(项目访问路径) req.getContextPath：动态获取虚拟目录 给服务器端使用：不需要加虚拟目录(如转发) 输出字符/字节： 乱码问题：浏览器默认以GBK解码(与操作系统有关，Windows在中文环境下是GBK) response.setHeader(\"content-type\", \"text/html;charset=utf-8\");//简便写法response.setContentType(\"text/html;charset=utf-8\"); 验证码： int width = 100;int height = 50;//设置图片的宽高和类型BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);//美化图片//获取画图对象Graphics g = image.getGraphics();//设置背景色g.setColor(Color.PINK);g.fileRect(0, 0, width, height);//设置边框色以及绘制g.setColor(Color.BLUE);g.drawRect(0,0 width - 1, height - 1);//获取随机字符并绘制String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";Random ran = new Random();for (int i = 1; i &lt;= 4; i++) &#123; index = ran.nextInt(str.length()); char ch = str.charAt(index); g.drawString(ch+\"\", 20*i, 25);&#125;//设置干扰线g.setColor(Color.GREEN);for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextIne(height); g.drawLine(x1, y1, x2, y2);&#125;//绘制到浏览器中ImageIO.writer(image, \"jpg\", response.getOutputStream()); ServletContext概念：代表整个Web应用，可以和程序的容器来通信。 获取： request对象获取：request.getServletContext() HttpServlet的方法：this.getServletContext() 功能： 获取MIME类型 MIME：互联网通信过程中定义的一种文件数据类型 格式：大类型/小类型(text/html image/jpeg) String getMimeType(String file) String fileName = \"a.jpg\"; String mimeType = servletContext.getMimeType(fileName); &lt;!--￼8--&gt; Cookie 会话： 概念：一次会话(浏览器第一次发生请求，直到一方断开)包含多次请求和响应 功能：一次会话的多次请求间共享数据 方式： 客户端：Cookie 服务器：Session 将数据保存到客户端，使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie,得到数据 Cookie[] request.getCookies() package web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo\")public class CookieDemo extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie c = new Cookie(\"msg\", \"hello\"); response.addCookie(c); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; package web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo2\")public class CookieDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); String value = cookie.getValue(); System.out.println(name + \": \" + value); &#125; &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 实现原理： response发送响应头：set-cookie:msg=hello request发送请求头：Cookie:mas=hello 细节： 一次可不可以发送多个Cookie 可以 Cookie能在浏览器中保存多长的时间 默认：浏览器关闭时Cookie数据被销毁 持久化存储： cookie.setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中，数值表示存活时间 负数：默认值 0：删除Cookie信息 Cookie能不能存中文 Tomcat 8之前不能直接存储中文信息，Tomcat 8之后可以 Cookie共享问题 一个Tomcat服务器部署了多个web项目，在这些项目中cookie能不能共享 默认不能共享 setPath(String path)：设置Cookie的获取范围，默认情况设置当前的虚拟目录 不同的Tomcat服务器间Cookie共享问题 setDomain(String path)：如果一级域名相同，那么多个服务器之间Cookie可以共享 特点： Cookie存储数据在浏览器 浏览器对于单个Cookie的大小有限制(4KB)，数目也有限制(20个) 作用： 一般用于存在少量不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次登录时间 package web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLDecoder;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.Date;@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); Cookie[] cookies = request.getCookies(); boolean flag = false; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie cookie: cookies) &#123; String name = cookie.getName(); if (\"lastTime\".equals(name)) &#123; flag = true; String time = cookie.getValue(); time = URLDecoder.decode(time, \"utf-8\"); Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy:MM:dd HH:mm:ss\"); String str_date = sdf.format(date); str_date = URLEncoder.encode(str_date, \"utf-8\"); cookie.setValue(str_date); cookie.setMaxAge(60 * 60 * 24 * 30); response.addCookie(cookie); response.getWriter().write(\"lastTime: \" + time); break; &#125; &#125; &#125; if (flag == false) &#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy:MM:dd HH:mm:ss\"); String str_date = sdf.format(date); str_date = URLEncoder.encode(str_date, \"utf-8\"); Cookie cookie = new Cookie(\"lastTime\", str_date); cookie.setMaxAge(60 * 60 * 24 * 30); response.addCookie(cookie); response.getWriter().write(\"欢迎首次访问\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; Session概念：服务器端会话技术，用以保存一次请求的数据，相关类为HttpSession HttpSession session = request.getSession(); 方法(Session是域对象)： setAttribute getAttribute removeAttribute 原理：Session的实现是依赖于Cookie的 细节： 客户端关闭，服务器不关闭获取的Session是同一个吗 不是 //如果希望是同一个，可以这么写 Cookie c = new Cookie(\"JSESSIONID\", session.getId()); c.setMaxAge(60 * 60); response.addCookie(c); &lt;!--￼12--&gt; JSTL概念：JavaServer Pages Tag Library 作用：简化和替换JSP页面上的Java代码 使用步骤： 导入jar包 引入标签库：taglib指令(&lt;%@ taglib %&gt;) 使用标签 常用标签： if &lt;c:if test=\"\"&gt; &lt;/c:if&gt; choose &lt;c:choose&gt; &lt;c:when test=\"\"&gt;&lt;/c:when&gt; ... ... &lt;c:otherwise&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; forEach &lt;c:forEach begin=\"\" end=\"\" var=\"\" step=\"\"&gt; &lt;/c:forEach&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"str\" varStatus=\"s\"&gt; $&#123;s.index&#125; $&#123;s.count&#125;&lt;/c:forEach&gt; Filter作用： 一般用于完成通用的操作，如登录验证、统一编码处理，敏感字符过滤 入门： 定义类实现接口Filter 实现方法 配置拦截路径 package web;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(\"/*\")public class FilterDemo implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"... ...\"); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo&lt;/filter-name&gt; &lt;filter-class&gt;web.FilterDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 生命周期： init doFilter destroy 过滤器配置： 拦截路径配置 具体路径：/index.jsp 目录拦截：/user/* 后缀名拦截：*.jsp 拦截所有资源：/* 拦截方式配置：资源被访问的方式 注解配置：设置dispatcherTypes属性 REQUEST：默认值，浏览器直接请求资源 FORWORD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 &lt;filter-mapping&gt; &lt;filter-name&gt;demo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;...&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 过滤器链的配置 如果有两个过滤器 Filter1 –&gt; Filter2 –&gt; 资源执行 –&gt; Filter2 –&gt; Filter1 执行顺序问题 注解配置：按照类名的字符串比较规则进行比较，最小的先则执行 AFilter &lt; BFilter(AFilter先执行) web.xml配置：谁定义在上面，谁先执行 代理： 概念 真实对象 代理对象 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 实现方式 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 代理对象和真实对象实现相同的接口 代理对象：Proxy.newProxyInstance() 第一个参数：类加载器 第二个参数：接口数组 第三个参数：处理器 invoke proxy method：代理对象调用的方法，被封装为对象 args：代理对象调用方法时，传递的实际对象 使用代理对象调用方法 Listener事件监听机制 事件源 监听器 注册监听 ServletContextLinstener：监听ServletContext对象的创建和监听 contextDestroyed(ServletXontextEvent sec) contextImitialized(ServletContextEvent sec) 步骤： 定义一个类，实现ServletContextLinstener接口 实现方法 配置 package web;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class ListenerDemo implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; System.out.println(\"服务器启动自动被调用\"); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; System.out.println(\"服务器正常关闭后被调用\"); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Web/"}]},{"title":"JDBC","date":"2019-08-14T16:00:00.000Z","path":"/JDBC/","text":"初识JDBC如果我们要使用Java来操作数据库，由于数据库的种类繁多，并且sql语句并不完全相同，总而言之不同的数据库千差万别，这是不是意味着我们要对不同的数据库写不同的程序，这样的话对程序员的要求有点高，并且学习的成本也很大，所以我们要定义一套规范，要求对所有的数据库程序员只要写相同的程序就可以了。就相当于插座，我们定义好插座的标准，那么所有的商家必须按我的标准来，否则就不能使用插座。同理，在Java中定义好数据库的接口，定义接口中的方法有什么作用，而具体的实现细节则有数据库的厂商进行编写，程序员只要调用接口里面的方法就可以了。这里给出一个摘至维基百科的定义 Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is a Java-based data access technology used for Java database connectivity. 所以使用JDBC的好处便显而易见 程序员如果要开发访问数据库的程序，只需要会调用JDBC接口中的方法即可，不用关注类是如何实现的 使用同一套Java代码，进行少量的修改就可以访问其他JDBC支持的数据库 我们使用Java操作数据库，会使用到数据库的驱动，由各大数据库厂商提供，需要额外去下载，里面是对JDBC接口实现的类，导入驱动jar包的具体的步骤如下 在项目中新建一个libs文件夹 将jar包复制到这个文件夹中 选中这个jar包，右击找到&quot;Add as Library&quot; 上面是导入jar包的通用步骤，后面会经常导入jar包，所以需要熟记。 第一个JDBC程序使用Java操作数据库一般包括下面几步 注册驱动 获得连接数据库的对象 获得执行sql语句的对象 执行sql语句 释放资源(断开连接) 程序如下(具体类后面解释) import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class Demo01 &#123; public static void main(String[] args) throws Exception&#123; //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db1\", \"root\", \"root\"); //创建sql语句 String sql = \"update account set balance = 2000 where id = 1\"; //创建执行sql语句的对象 Statement statement = conn.createStatement(); //执行sql语句 statement.executeUpdate(sql); //释放资源 statement.close(); conn.close(); &#125;&#125; 核心类下面就详细介绍JDBC的核心类(接口)以及它们的功能 DriverManager：驱动管理对象，功能如下 注册驱动：告诉程序该使用哪一个数据库驱动jar包 mysql5之后可以省略注册驱动的步骤，即不需要写Class.forName() 获取数据库连接 static Connection getConnection(String url, String user, String password) url：连接的路径 格式：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数=参数值 例子：jdbc:mysql://localhost:3306/db1 如果ip地址为本机地址且端口号为3306，则上面可省略ip地址和端口号，简写为：jdbc:mysql:///db1 如果出现乱码问题，可以指定参数?characterEncoding=utf8 user：用户名 password：密码 Connection：数据库连接对象，相当于是在Java程序与数据库之间建立了一条通道，功能如下 获取执行sql的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit)，传入false即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象，含有如下方法 boolean execute(String sql)：可以执行任意的sql语句，不常用，了解即可 int executeUpdate(String sql) 执行DML(insert、update、delete)语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql)：执行DQL(select)语句 ResultSet：结果集对象，封装查询结果，数据库通过通道返回的结果 boolean next() 判断游标所指向的行是否为空 getXxx() getXxx(int columnIndex) 根据列数来获得数据 getXxx(int columnLabel) 根据列名称获得数据 这里给出一个使用ResultSet的例子，比如我们要去查询account表 import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class Demo02 &#123; public static void main(String[] args) throws Exception &#123; Class.forName(\"com.mysql.jdbc.Driver\"); Connection conn = DriverManager.getConnection(\"jdbc:mysql:///db1\", \"user\", \"root\"); Statement statement = conn.createStatement(); String sql = \"select * from account\"; ResultSet resultSet = statement.executeQuery(sql); //将查询到的数据打印出来 while (resultSet.next()) &#123; //根据列名查询数据 int id = resultSet.getInt(\"id\"); String name = resultSet.getString(\"name\"); double balance = resultSet.getDouble(\"balance\"); System.out.println(id + \"---\" + name + \"---\" + balance); &#125; resultSet.close(); statement.close(); conn.close(); &#125;&#125; JDBC工具类其实上面的代码并不是十分的规范，因为资源的释放可能不能释放成功，因为前面发生异常就可以导致后面的程序执行不到，这样资源无法释放，就会导致内存越用越少(内存泄漏)，所以我们应当将资源释放的代码写到finally代码块中，如下 import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Demo01 &#123; public static void main(String[] args) &#123; //定义在try代码块外是为了在finally中能够访问 Connection conn = null; Statement statement = null; try &#123; conn = DriverManager.getConnection(\"jdbc:mysql:///db1\", \"root\", \"root\"); statement = conn.createStatement(); String sql = \"update account set balance = 2000 where id = 1\"; statement.executeUpdate(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 这时我们发现代码十分的冗长(特别是资源释放的部分)，并且每次写代码都会重复这些，再者程序所连接的数据库是写死的，如果需要改变的话还需要改动程序，我们可以将这些信息写在一个jdbc.properties的配置文件中，如果有改动直接改动配置文件即可 url=jdbc:mysql:///db1user=rootpassword=rootdriver=com.mysql.jdbc.Driver 将上面的这些操作抽离出来，写一个JDBC的工具类，在工具类中读取配置文件，以及抽离出一些方法，这样不用每次都写这么长的代码 import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; //读取jdbc.properties中的内容 获得url user password driver等信息 //因为只需要读取一次，所以写在static代码块中 static &#123; try &#123; Properties properties = new Properties(); ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); properties.load(new FileReader(path)); url = properties.getProperty(\"url\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); driver = properties.getProperty(\"driver\"); Class.forName(driver); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //返回连接对象 public static Connection getConnection() throws SQLException&#123; return DriverManager.getConnection(url, user, password); &#125; //释放资源 public static void close(Connection conn, Statement stam) &#123; if (stam != null) &#123; try &#123; stam.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //释放资源 public static void close(Connection conn, Statement stam, ResultSet resultSet) &#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //复用上面的代码 close(conn, stam); &#125;&#125; 用户登录练习我们来写一个方法来判断用户输入的用户名和密码是否正确，思路就是根据用户输入的用户名和密码去数据库中查询，如果返回的ResultSet有内容，那么就确定输入正确，否则失败。假设有下面这么一个表(user) +------+----------+----------+| id | user | password |+------+----------+----------+| 1 | zhangsan | 123 || 2 | lisi | 345 |+------+----------+----------+ 下面是检查用户名和密码的方法 public static boolean login(String user, String password) &#123; Connection conn = null; Statement statement = null; ResultSet resultSet = null; try &#123; conn = JDBCUtils.getConnection(); statement = conn.createStatement(); //拼接user和password未一个sql语句 String sql = \"select * from user where user = '\" + user + \"' and password = '\" + password + \"'\"; resultSet = statement.executeQuery(sql); //如果返回有数据则返回true 否则返回false return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn, statement, resultSet); &#125; return false;&#125; 下面在main方法中写测试代码 public static void main(String[] args) &#123; //用户输入用户名和密码 Scanner scanner = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String user = scanner.nextLine(); System.out.println(\"请输入密码：\"); String password = scanner.nextLine(); boolean flag = login(user, password); if (flag) &#123; System.out.println(\"登录成功\"); &#125; else &#123; System.out.println(\"用户名或密码错误\"); &#125;&#125; 我们来试验一下 请输入用户名：lisi请输入密码：234用户名或密码错误 请输入用户名：zhangsan请输入密码：123登录成功 PreparedStatementPreparedStatement的作用同Statement，也是用来执行sql命令的，但是已经有了Statement，为什么还需要PreparedStatement呢? 那就要知道Statement存在什么问题，我们来看上面的用户登录程序，如果我们登录时这么写 请输入用户名：daad请输入密码：a' or 'a' = 'a登录成功 得到的结果居然登录成功了，因为sql语句被拼接成了 select * from user where user &#x3D; &#39;daad&#39; and password &#x3D; &#39;a&#39; or &#39;a&#39; &#x3D; &#39;a&#39;; 最后的or ‘a’ = ‘a’得到的永远是true，所以总是可以得到返回结果，所以自然会显示登录成功，这种情况叫做SQL注入。PreparedStatement正是为了解决这一个问题的，上面出现问题是因为我们的sql语句是拼接而成的，所以才会出现问题，PreparedStatement采取的办法是首先使用?占据位置(占位符)，然后对?所占据的位置进行赋值，赋值的方法为 setXxx()：接收两个参数 第一个参数表示为第几个占位符赋值，从1开始 第二个参数是值 所以我们将上面的登录代码修改如下 public static boolean login(String user, String password) &#123; Connection conn = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; conn = JDBCUtils.getConnection(); //使用?作为占位符 String sql = \"select * from user where user = ? and password = ?\"; //创建PreparedStatement对象 preparedStatement = conn.prepareStatement(sql); //为占位符赋值 preparedStatement.setString(1, user); preparedStatement.setString(2, password); //不需要传入sql resultSet = preparedStatement.executeQuery(); //如果返回有数据则返回true 否则返回false return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn, preparedStatement, resultSet); &#125; return false;&#125; 这时还是使用与上面相同的操作 请输入用户名：dadd请输入密码：a or 'a' = 'a'用户名或密码错误 在实际中我们一般使用PreparedStatement，因为它不仅可以防止SQL注入，并且效率更高。 JDBC事务事务就是一组sql操作，这一组sql操作要么同时成功，要么同时失败。比如转账，一方钱的支出与另一方钱的到账必须同时成功或者同时失败，没有这里钱转出去了，另一方却没有到账的情况。有关事务一般包含下面三个操作 开启事务 setAutoCommit(false) 开启事务后，直至提交，执行的sql语句不会在数据库中生效，而是会写在日志中，只有提交后才会将根据日志修改数据库中的数据 默认是自动提交的，即每次执行一次sql命令都会更改数据库中的内容，我们将自动提交关闭就相当于是开启了事务 提交事务 commit() 回滚事务 rollback() 事务执行失败，这时我们就要回到执行事务前的状态，这时会把日志中的内容清空 一般在catch代码块中进行回滚操作 假设有下面这么一个表 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 2000 || 2 | 李四 | 1000 |+----+------+---------+ 现在张三要给李四转500块钱 import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Demo04 &#123; public static void main(String[] args) &#123; //转账的金额 double money = 500; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = JDBCUtils.getConnection(); String sql1 = \"update account set balance = balance - ? where id = ?\"; String sql2 = \"update account set balance = balance + ? where id = ?\"; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setDouble(1, money); preparedStatement1.setInt(2, 1); preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setDouble(1, money); preparedStatement2.setInt(2, 2); preparedStatement1.executeUpdate(); preparedStatement2.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(connection, preparedStatement1); //因为connection已经关闭了，所以传入null JDBCUtils.close(null, preparedStatement2); &#125; &#125;&#125; 执行上面的程序然后再次查表得 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1500 || 2 | 李四 | 1500 |+----+------+---------+ 但是如果我们在执行张三支出500块后手动添加一个异常，这时李四则不会收到500块 preparedStatement1.executeUpdate();int i = 3 / 0;preparedStatement2.executeUpdate(); +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1000 || 2 | 李四 | 1500 |+----+------+---------+ 张三的钱减少了500块，但是李四却没有收到。这就是问题，所以我们要开启事务，并且在catch代码块中进行回滚 import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Demo04 &#123; public static void main(String[] args) &#123; double money = 500; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = JDBCUtils.getConnection(); //开启事务 connection.setAutoCommit(false); String sql1 = \"update account set balance = balance - ? where id = ?\"; String sql2 = \"update account set balance = balance + ? where id = ?\"; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setDouble(1, money); preparedStatement1.setInt(2, 1); preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setDouble(1, money); preparedStatement2.setInt(2, 2); preparedStatement1.executeUpdate(); int i = 3 / 0; preparedStatement2.executeUpdate(); //提交事务 connection.commit(); &#125; catch (Exception e) &#123; try &#123; if (connection != null) &#123; //回滚事务 connection.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(connection, preparedStatement1); JDBCUtils.close(null, preparedStatement2); &#125; &#125;&#125; 这次再次执行 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1000 || 2 | 李四 | 1500 |+----+------+---------+ 虽然还是发生了异常，但是张三和李四并没有发生上面一方转出一方没有到账的情况，而是转账失败。 数据库连接池每次我们使用完连接对象后都会将该对象销毁，然后下次需要连接对象时又需要重新创建。如果考虑到有频繁的操作数据库的操作，每次创建销毁的开销是很大的，所以就有了数据库连接池，里面有很多的连接对象，当我们需要时就从里面拿，用完之后不是销毁，而是将对象归还给连接池，这样做能够有效的提升程序的性能。Java定义了一个DataSource接口，我们可以通过该接口的getConnection()方法获取一个连接，并且可以通过close()方法归还这个连接(前提是这个连接是从连接池中获得的)。DataSource接口的实现我们不需要关心，我们只要知道如何使用即可，我们学习如何使用两种数据库连接池技术 C3P0 Druid：阿里巴巴提供，目前最好的数据库连接池之一 C3P0C3P0的使用步骤 导入jar包 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 定义配置文件 只能为c3p0-config.xml或c3p0.properties，配置文件需放在src目录下 使用实现类ComboPooledDataSource获得连接池对象 下面给出配置文件c3p0-config.xml的内容 &lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql:///db1&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!--初始连接对象数--&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;!--最大连接对象数--&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;!--最大等待时间 3s--&gt; &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 下面给出一个使用的示例 import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class Demo05 &#123; public static void main(String[] args) throws SQLException &#123; //获得连接池对象 DataSource ds = new ComboPooledDataSource(); //获取连接 Connection conn = ds.getConnection(); &#125;&#125; DruidDruid的使用步骤 导入jar包 druid-1.0.9.jar 定义配置文件 .properties文件 可以放置在任何的地方 使用工厂方法DruidDataSourceFactory.createDataSource()获得连接池 需要传入一个Properties对象(配置文件) 下面给出druid.properties的内容 driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 想必上面的各参数的含义不必解释，那么就给出一个使用Druid的例子 import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;public class Demo06 &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); //得到配置文件的输入流对象 InputStream is = Demo06.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); &#125;&#125; 工具类我们发现每次使用连接池时会有很多重复的操作，同上面我们应该写一个工具类JDBCUtils将一些操作抽离出来，JDBCUtils类如下 import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static DataSource ds; //读取配置文件 初始化连接池对象 static &#123; Properties pro = new Properties(); try &#123; pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //返回连接对象 public static Connection getConnection() throws SQLException&#123; return ds.getConnection(); &#125; //关闭资源 public static void close(Connection conn, Statement stam) &#123; if (stam != null) &#123; try &#123; stam.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection conn, Statement stam, ResultSet resultSet) &#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //复用上面的代码 close(conn, stam); &#125; //返回连接池对象 public static DataSource getDataSource() &#123; return ds; &#125;&#125; Spring JDBCSpring对JDBC进行了简单的封装，提供了一个JdbcTemplate对象来简化JDBC的开发，使用步骤为 导入jar包 spring-beans-5.0.0.RELEASE.jar spring-core-5.0.0.RELEASE.jar spring-jdbc-5.0.0.RELEASE.jar spring-tx-5.0.0.RELEASE.jar commons-logging-1.2.jar 创建JdbcTemplate对象 new JdbcTemplate(ds)：ds为数据库连接池对象 使用JdbcTemplate对象的方法对数据库进行操作 update()：执行DML语句 第一个参数为sql语句 第二个参数为可变参数，是占位符?所对应的值 queryForMap()：将结果封装为Map对象 只能查询一行数据，将结果封装为Map对象 将列名最为Key，将字段值作为Value queryForList()：将结果封装为List对象 查询多行数据，每一行数据封装为一个Map对象，这些Map对象会被添加到一个List集合中返回 queryForObject()：将结果封装为对象 用以查询一些聚合函数 query()：将结果封装为JavaBean对象 下面就来做一个简单的演示，假设db1数据库中有一张表account其中内容如下 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 1000 || 2 | 李四 | 1000 |+----+------+---------+ update现在我们使用update命令修改张三的balance为2000 import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;public class Demo07 &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); //Junit单元测试 方法可以单独执行 不需要写在main方法中 @Test public void testUpdate() &#123; String sql = \"update account set balance = 2000 where id = ?\"; template.update(sql, 1); &#125;&#125; 我们再次查询account表 +----+------+---------+| id | NAME | balance |+----+------+---------+| 1 | 张三 | 2000 || 2 | 李四 | 1000 |+----+------+---------+ queryForMap查询张三所在行(id = 1)，得到一个Map对象，我们将其打印出来 @Testpublic void testQueryForMap() &#123; String sql = \"select * from account where id = ?\"; Map map = template.queryForMap(sql, 1); System.out.println(map);&#125; 结果为 &#123;id=1, NAME=张三, balance=2000.0&#125; queryForList如果我们需要查询多条数据怎么办，这个时候就使用queryForList，它会将每条数据封装为Map集合，然后将这些Map集合添加到List集合中 @Testpublic void testQueryForList() &#123; String sql = \"select * from account\"; List&lt;Map&lt;String, Object&gt;&gt; mapList = template.queryForList(sql); for (Map&lt;String, Object&gt; map: mapList) &#123; System.out.println(map); &#125;&#125; 得到的结果为 &#123;id=1, NAME=张三, balance=2000.0&#125;&#123;id=2, NAME=李四, balance=1000.0&#125; query更多的时候我们希望将得到的结果封装为一个对象，现在我们新建一个类Account如下 public class Account &#123; private Integer id; private String name; private Double balance; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", balance=\" + balance + '&#125;'; &#125;&#125; 现在我们希望将获得结果封装为一个个Account对象，这时我们就需要使用query()方法了，query方法的第一个参数是sql语句，第二个参数是RowMapper&lt;&gt;的实现类，这个类我们可以自己实现，也可以使用Spring提供好的实现类，我们就使用Spring提供好的实现类BeanPropertyRowMapper&lt;&gt;，我们只要将Account的class属性传递进去即可 @Testpublic void testQuery() &#123; String sql = \"select * from account\"; List&lt;Account&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); for (Account account : list) &#123; System.out.println(account); &#125;&#125; 结果为 Account&#123;id=1, name='张三', balance=2000.0&#125;Account&#123;id=2, name='李四', balance=1000.0&#125; queryForObject现在我们来查询account表中右多少条数据，我们使用聚合函数count()，得到的结果是一个long类型的数字，我们使用queryForObject()查询，接收两个参数，第一个参数是sql命令，第二个参数是返回类型的class属性 @Testpublic void testQueryForObject() &#123; String sql = \"select count(id) from account\"; Long num = template.queryForObject(sql, Long.class); System.out.println(num);&#125; 结果为 2","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JDBC/"}]},{"title":"Java注解","date":"2019-08-09T16:00:00.000Z","path":"/Java注解/","text":"我们在之前就有接触过注解，比如@Override，它可以帮我们检查是否重写了方法，如果没有，它在编译阶段就会报错。注解一般有下面三个功能 编译检查 比如@Override 代码分析 读取注解的属性，然后使用反射技术进行分析 编写文档 比如javadoc 系统自定的注解下面介绍三个系统自定义的注解 @Override 检查方法是否是重写父类的方法 @Deprecated 将该注解标记的内容显示为已过时 @SuppressWarnings(“all”) 压制所有的警告 如果有一个方法被@Deprecated修饰了，如 @Deprecatedpublic static void show() &#123; System.out.println(\"show ...\");&#125; 那么在调用时会这样 代表这个方法已经过时了，但是你想调用还是可以调用的。 在我们写代码时，经常会弹出一些警告，如 我们可以使用@SuppressWarnings(“all”)表示压制所有的警告 这时类里面所有的警告都压制了。 自定义注解格式要定义一个注解，首先我们看它的格式是什么 元注解public @interface 注解名称 &#123;&#125; 其实注解本质是一个接口，所以我们可以在里面定义抽象方法，这些抽象方法我们又把它叫做属性，这些抽象方法的返回值只能是下面这些类型 基本数据类型 String 枚举 注解 以上类型的数组 下面定义了一个MyAnno的注解，里面有两个属性，name和age import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//元注解暂时不必关注@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; String name(); int age();&#125; 下面我们使用MyAnno @MyAnno(name=\"小明\",age=18)public static void show() &#123; System.out.println(\"show ...\");&#125; 使用注解时，要为属性赋值，否则会报错，并且格式为属性名=值的形式，我们可以在MyAnno中设定默认值，这样在使用注解时就可以不赋值，如 String name() default \"小明\";int age() default 18; 现在我们在使用时可以不赋值 @MyAnno()public static void show() &#123; System.out.println(\"show ...\");&#125; 如果注解里面只有一个属性，并且属性名为value，那么在使用注解时可以省略value直接赋值，如 import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; int value();&#125; 那么使用时直接赋值 @MyAnno(12)public static void show() &#123; System.out.println(\"show ...\");&#125; 数组的赋值为属性名 = {}的形式，如果里面只有一个值，那么花括号可以省略。 元注解元注解就是描述注解的注解，这里只介绍两个 @Target() 表示注解能作用的位置，比如作用在类上 它有一个value属性，类型是ElementType枚举类型 我们一般使用TYPE, FIELD, METHOD分别表示能够作用在类、成员变量、方法上 @RETENTION() 表示注解被保留的阶段 它也有一个value属性，类型是RetentionPolicy枚举类型 我们一般使用RetentionPolicy.RUNTIME表示保留到运行时 解析注解在反射那里根据配置文件来创建一个类的对象，并且调用方法，现在我们将根据注解的属性来创建一个类的对象和调用相应的方法，现在有以下注解 import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; String className(); String methodName();&#125; 新建类使用该注解 import java.lang.annotation.Annotation;import java.lang.annotation.Target;import java.lang.reflect.Method;@MyAnno(className = \"Animal\", methodName = \"eat\")public class TestAnno &#123; public static void main(String[] args) throws Exception &#123; //获取该类的Class对象 Class&lt;TestAnno&gt; cla = TestAnno.class; //获取注解 会在内存中生成一个该注解的子类实现对象 MyAnno an = cla.getAnnotation(MyAnno.class); //调用方法会将属性值返回 String className = an.className(); String methodName = an.methodName(); //根据类名获取Class对象 Class cls = Class.forName(className); //获取方法 Method method = cls.getMethod(methodName); //使用无参构造方法创建对象 Object o = cls.newInstance(); //调用方法 method.invoke(o); &#125;&#125; 运行结果为 eat ... 这时我们只要改变注解的属性值，就可以创建任意类的对象，并且调用相应的方法。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"注解","slug":"注解","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Java异常","date":"2019-08-04T16:00:00.000Z","path":"/Java异常/","text":"所谓的异常就是不正常，我们在之前很多地方有碰到异常，比如对象向下转型时有碰到ClassCastException。所有的异常都继承自Exception类。Exception下面有一个重要的的子类叫做RuntimeException。 异常分为编译期异常和运行时异常，如Exception就是编译期异常，而RuntimeException是运行时异常，如果在方法中抛出了一个编译期异常，那么必须处理该异常，继续向上抛出或者就地处理，而对于运行异常可以选择不处理，那么就会默认交给JVM处理。 处理异常的过程首先JVM检测到了异常，这时JVM会创建一个异常对象，该对象包含发生错误的内容、原因和位置。如果在发生异常处的方法内没有异常处理逻辑，那么JVM会把该异常抛给这个方法的调用者，如果该调用者也没有异常处理逻辑，那么就会一直向上抛出，直到遇到main方法，如果main方法也没有异常处理逻辑，那么这时异常就会抛给JVM，JVM会打印红色字体至控制台，并且终止Java程序的运行。 与异常有关的关键字有五个，分别为throw, throws, try, catch, finally。下面介绍这五个关键字的作用。 throwthrow关键字用于在方法中抛出一个异常，如下 public static double divide(double a, double b) &#123; if (b == 0) &#123; throw new ArithmeticException(\"除0\"); &#125; return a/b;&#125; 这个方法的作用是a/b，在检测到b=0时，我们抛出了一个异常，并给出提示信息”除0”。现在我们在main方法中调用该方法 System.out.println(divide(5,0)); 由于我们没有对异常进行处理，所以程序会进行终结并在控制台打印出信息： 注意： throw必须写在方法的内部 new的必须是Exception或其子类 throwsthrows的作用是声明异常，或者说叫把异常抛给调用者，我们知道，编译期异常是必须要进行处理，那么处理的办法有两种，一种就是把继续向上抛出，另一种就是使用try-catch进行处理。而throws就是将异常继续抛出，现在我们将上面的ArithmeticException改为Exception，由于Exception为编译期异常，必须进行处理，否则编译不通过 由图片可以知道，由于我们没有对该异常处理，所以编译没有通过，我们这里的处理办法就是继续抛出 我们通过throws关键字抛出异常了，但是我们发现在main方法处又出现了问题，这是因为main方法没有处理divide()方法可能抛出的异常，因为divide()抛出的异常为编译期异常，必须进行处理，这里我们继续向上抛出，如下 这时代码就不会报错了。 注意： 使用throws时可以抛出多个异常，异常与异常之间使用逗号隔开 如果抛出的多个异常具有父子类关系，那么抛出父类异常就可以了 try-catch虽然我们通过throws可以向上抛出异常，但是如果不进行处理的话，最终还是会抛出给JVM，而JVM的处理方法就是打印异常信息然后终止程序。我们应该在异常发生时进行捕获，这个时候就不会将异常最终抛给JVM，程序就不会终止，而是会继续的执行下去。进行捕获的代码就是try-catch。具体格式为 try &#123; //可能发生异常的代码&#125; catch &#123;接收异常的变量&#125; &#123; //对异常进行处理&#125; 所以我们重写上面的那个方法为 public class TestException &#123; public static void main(String[] args) &#123; try &#123; //可能发生异常的代码 System.out.println(divide(5,0)); &#125; catch (ArithmeticException e) &#123; //这里对异常的处理只是将异常打印出来 //处理异常后并不会终止程序，所以后面的代码还是可以执行 System.out.println(e); &#125; System.out.println(\"后续代码\"); &#125; public static double divide(double a, double b) &#123; if (b == 0) &#123; throw new ArithmeticException(\"除0\"); &#125; return a/b; &#125;&#125; 运行结果为 java.lang.ArithmeticException: 除0后续代码 可见后面的代码执行了。 Throwable(它是Exception的父类)中有三个处理异常的方法 getMessage 打印简短信息 toString 就是上面的直接打印对象 printStackTrace JVM向控制台输出的信息就是调用这个方法，该方法打印的信息很全 finally其实在try-catch后面还可以跟一个finally块，我们知道如果没有发生异常的话，catch里面的代码块是不会执行的，而finally里的代码块，无论是是否抛出异常，都一定会执行的，所以finally里面的代码多用来释放资源的。我们来看一个例子 try &#123; System.out.println(divide(5,0));&#125; catch (ArithmeticException e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(\"finally代码块\");&#125; 这时是会抛出异常的，输出的结果为 可见finally里面的代码执行了，现在修改上面的代码为 try &#123; System.out.println(divide(5,1));&#125; catch (ArithmeticException e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(\"finally代码块\");&#125; 这时是不会抛出异常的，所以catch代码块里面的程序不会被执行，但是finally里面的代码始终会被执行，执行的结果为 注意： 由于finally里面的代码一定是会执行的，所以要避免在finally里面写return语句，否则返回的一直是finally里面的结果。 多异常捕获多次捕获，多次处理即使用多个try-catch语句块 try &#123; //可能发生异常的代码&#125; catch(异常1 e) &#123; //处理异常1&#125;try &#123; //可能发生异常的代码&#125; catch(异常2 e) &#123; //处理异常2&#125;... 一次捕获，多次处理即一个try匹配多个catch try &#123; //可能发生异常的代码&#125; catch (异常1 e) &#123; //处理异常1&#125; catch (异常2 e) &#123; //处理异常2&#125; ... 如果在try中发生了异常，那么首先会判断这个异常能不能被异常1接收，如果能那么就在第一个catch中进行处理，如果不能，那么就判断能不能被异常2接收，以此类推。 这里需要注意的点是，父类异常必须子类异常后面。假设父类异常写在前面，如果发生了子类异常，根据多态，父类能够接收这个异常，所以写在后面的子类异常永远接受=收不到这个异常，就相当于是死代码了。 一次捕获，一次处理就是在catch中使用Exception变量接收异常，因为所有的异常都是Exception的子类，所以可以接收所有的异常 try &#123; //可能发生异常的代码&#125; catch (Exception e) &#123; //处理异常&#125; 子类注意事项如果父类方法抛出多个异常，子类重写了该方法，那么子类方法有三种方案 抛出相同异常 抛出父类异常的子类 不抛出异常 如果父类的方法没有抛出异常，那么子类重写的方法也不能抛出异常。该子类产生的异常只能try-catch捕获处理，不能使用throws抛出。 自定义异常自定义的异常必须继承一个异常类。如果继承的是Exception，那么该异常就是编译期异常，如果继承的是RuntimeException，那么就是运行时异常。下面简单的演示 public class MyException extends RuntimeException&#123; //一个空参构造方法 public MyException()&#123;&#125; //一个带异常信息的构造方法 public MyException(String message) &#123; super(message); &#125;&#125; 现在进行测试 public class TestMyException &#123; public static void main(String[] args) &#123; divide(5,0); &#125; public static double divide(double a, double b) &#123; if (b == 0) &#123; //继承至RuntimeException，是运行时异常，可以不进行处理 throw new MyException(\"除0\"); &#125; return a / b; &#125;&#125; 结果为","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"异常","slug":"异常","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"Java文件操作","date":"2019-08-02T16:00:00.000Z","path":"/Java文件操作/","text":"FileFile类代表的是文件或者文件夹(目录)，将目录和文件抽象为一个类。File提供了很多方法用来操作文件夹或者文件。下面具体介绍该类。 静态成员变量File类有四个成员变量 pathSeparator pathSeparatorChar 这两个保存的路径分隔符 Windows下为;，Linux下为: separator separatorChar 这两个保存的是文件名称分隔符 Windows下为\\反斜杠，Linux下为/正斜杠 下面看这个例子 import java.io.File;public class TestFile &#123; public static void main(String[] args) &#123; System.out.println(File.pathSeparator); System.out.println(File.pathSeparatorChar); System.out.println(File.separator); System.out.println(File.separatorChar); &#125;&#125; 输出为 ;;\\\\ 构造方法File(String pathname) 传入一个字符串类型，这个字符串为第一个路径名 传入的路径可以是绝对路径，也可以是相对路径 传入的路径可以存在，也可以不存在 可以是文件结尾，也可以是文件夹结尾\\ 下面来看看该方法的使用 File file1 = new File(\"G:\\\\JavaProject\\\\FirstProject\"); //绝对路径写法System.out.println(file1);File file2 = new File(\"SecondProject\"); //相对路径写法System.out.println(file2); 输出为 G:\\JavaProject\\FirstProjectSecondProject 注意： 由于\\代表的是转义，所以要写两个\\\\ 可见File类重写了toString()方法 File(String parent,String child) 该构造方法需要传入两个参数，一个为父级目录的路径，一个为子级目录的路径 该种构造方法相比上面的要灵活一点 下面示例使用 String parent = \"C:\\\\JavaProject\\\\\";File file3 = new File(parent,\"FirstProject\");System.out.println(file3);File file4 = new File(parent,\"SecondProject\");System.out.println(file4); 输出为 C:\\JavaProject\\FirstProjectC:\\JavaProject\\SecondProject File(File parent, String child) 同上个构造方法，传入也是父级和子级的路径，不过传入的父级路径是一个File对象 这样可以调用File类的方法，更加灵活 下面示例使用 File parent = new File(\"C:\\\\JavaProject\");File file5 = new File(parent,\"FirstProject\");System.out.println(file5); 输出为 C:\\JavaProject\\FirstProject 常用方法按照功能不同分为了三类 获取功能 判断功能 创建删除 获取功能与获取功能有关的方法有四个 getAbsolutePath() 获得文件或文件夹的绝对路径 不论在构造方法中传入的是绝对路径还是相对路径，获得都是绝对路径 getPath() 在构造方法中传入的是什么，返回的就是什么 toString()调用的就是这个方法 getName() 获得文件或文件夹的名称，即路径的结尾部分 length() 获得文件的长度，以字节为单位 如果该文件不存在，那么返回0 下面示例这四个方法的使用 import java.io.File;public class TestFile &#123; public static void main(String[] args) &#123; File file = new File(\"src\\\\Dog.java\"); //传入的相对路径，获得是src目录下的Dog.java文件 //打印绝对路径 System.out.println(file.getAbsolutePath()); //G:\\JavaProject\\SecondProject\\src\\Dog.java //打印路径，传入什么打印什么 System.out.println(file.getPath()); //src\\Dog.java //获得文件的名称 System.out.println(file.getName()); //Dog.java //获得文件的大小 System.out.println(file.length()); //353 &#125;&#125; 判断功能与判断功能有关的方法有三个 exists() 判断传入构造方法的路径是否存在 isDirectory() 判断是不是目录(文件夹) 如果路径不存在，无论是否为目录(文件夹)，返回false isFile() 判断是否为文件 如果路径不存在，无论是否为文件，返回false 下面进行示例 File file = new File(\"src\\\\Dog.java\"); //传入的相对路径，获得是src目录下的Dog.java文件//判断该路径是否存在System.out.println(file.exists()); //true//是否为文件夹System.out.println(file.isDirectory()); //false//是否为文件System.out.println(file.isFile()); //true 创建删除与创建和删除有关的方法有四个 createNewFile() 如果该文件不存在，则创建该文件，如果存在则不创建 返回布尔值，创建返回true 不能创建目录，所以该文件所在目录必须存在，否则会抛出异常 delete() 删除该类代表的文件或文件夹，直接从硬盘删除，不走文件夹，要小心 删除成功返回true makdir() 创建由此File类代表的目录，只能创建单级目录 makdirs() 创建由此File类代表的目录，包括必需但不存在的父级目录 下面演示使用 import java.io.File;import java.io.IOException;public class TestFileMethod &#123; public static void main(String[] args) throws IOException &#123; //D:\\\\目录下没有1.txt File file1 = new File(\"D:\\\\1.txt\"); //createNewFile使用了throws抛出异常，需要处理，我们在main中直接抛出即可 System.out.println(file1.createNewFile()); //true //D:\\\\下没有新建文件夹 File file2 = new File(\"D:\\\\新建文件夹\"); //创建这个文件夹 System.out.println(file2.mkdir()); //true File file3 = new File(\"D:\\\\abc\\\\def\"); //创建多级目录 System.out.println(file3.mkdir()); //不能创建 mkdir只能创建单级目录 false System.out.println(file3.mkdirs()); //true //将上面创建的文件及文件夹全部删除 System.out.println(file1.delete()); //true System.out.println(file2.delete()); //true System.out.println(file3.delete()); //true abc这个文件夹还在 &#125;&#125; 目录遍历为了遍历目录，有两个方法 list() 返回一个字符串数组，这些字符串是文件名或文件夹名 listFiles() 返回时的File类对象数组 注意： 上面两个方法，如果目录不存在或者不是目录，那么会抛出空指针异常 隐藏文件和文件夹也能获取到 File file = new File(\"G:\\\\JavaProject\\\\SecondProject\\\\src\");String[] filename = file.list();for (int i = 0; i &lt; filename.length; i++) &#123; System.out.println(filename[i]);&#125;File[] files = file.listFiles();for (File file4 : files) &#123; System.out.println(file4.getName());&#125; 输出为 comDog.javaDoudizhu.javaGenericsDemo.javaJustForFun.javaMyException.javaMyThread.java... 递归递归就是在函数里面调用自己。 递归必须要用终止条件，否则会不断的调用自己，造成栈内存溢出 递归的次数也不能太多，否则也会造成栈内存溢出 构造方法 下面做几个小的练习来熟悉递归。 递归练习第一个练习是根据函数接收的参数$n$，来计算$1 + 2 … + n$，因为我们是从递归的角度看，所以应当这么看$$sum(n) = \\begin{cases}1, &amp;if ,, n =1 \\\\n + sum(n - 1), &amp;if ,,n &gt; 1 \\end{cases}$$ 所以程序我们应该这么写 //这里没有考虑输入为负数时的处理public static int sum(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n + sum(n - 1); &#125;&#125; 在main方法中调用该方法测试 int res = sum(100);System.out.println(res); 输出为 5050 可见程序是正确的。 第二个练习是计算阶乘，思路同上面完全是一样的$$fac(n) = \\begin{cases}1, &amp;if ,, n =0 \\\\n * fac(n - 1), &amp;if ,,n &gt; 1 \\end{cases}$$ 代码如下 public static int fac(int n) &#123; if (n == 0) &#123; return 1; &#125; else &#123; return n * fac(n - 1); &#125;&#125; 在main方法中调用测试 int res = fac(5);System.out.println(res); 输出为 120 文件夹遍历下面使用递归来实现文件夹的遍历，我们getFile()文件来进行文件夹的遍历，它接收一个File对象作为参数 public static void getFile(File file) &#123; File[] files = file.listFiles(); for (File file1 : files) &#123; System.out.println(file1.getName()); //如果是文件夹的，就遍历该文件夹 if (file1.isDirectory()) &#123; getFile(file1); &#125; &#125;&#125; 我在D盘下新建了一个Test文件夹，它的目录结构如下 Test a a.txt b.txt b c.txt d.txt 我们在main方法中遍历该文件夹 getFile(new File(\"D:\\\\Test\")); 输出为 aa.txtb.txtbc.txtd.txt 过滤器listFiles其实还可以接收一个叫做过滤器的参数。这个过滤器是一个接口，分为有FileFilter和FilenameFilter两个接口，这两个接口里面都只有一个方法accept()，listFiles会调用这个方法，将它获得的路径传入该方法中，如果得到的结果为true，那么就保留这个路径在最终返回的数组中，如果返回的是false，那么就不要这个路径。可见这样就起到了文件过滤的作用，而过滤什么样的文件，需要什么样的文件，完全由accept()方法决定，所以这也是它们为什么叫做过滤器的原因。 FileFilter下面来介绍FileFilter，FileFilter里面的accept(File pathname)接收一个参数，这个参数就是路径名，listFiles()会将它获得的路径传入accept()，accept()进行过滤，以决定要什么样的路径。下面我们做一个示范，打印出一个图片文件夹里面以.png结尾的图片 //传入的是图片文件夹的路径public static void printPNG(File file) &#123; //因为接口里面只要一个方法，所以这里使用Lambda表达式 File[] files = file.listFiles(pathname -&gt; &#123; //判断是不是以.png结尾 boolean b = pathname.getName().endsWith(\".png\"); if (b) &#123; //如果是以.png结尾，则加入到files数组中 return true; &#125; else &#123; return false; &#125; &#125;); //打印files数组，查看结果是否正确 for (File fi : files) &#123; System.out.println(fi.getName()); &#125;&#125; 我们在main方法调用测试 printPNG(new File(\"D:\\\\images\")); 打印输出为 可见只有.png结尾的图片才被放入了files数组中。 FilenameFilter它的accept(File dir, String name)接收两个参数，其余的与FileFilter相同，下面就同样的功能演示其代码 public static void printPNGAgain(File file) &#123; File[] files = file.listFiles(((dir, name) -&gt; &#123; //根据dir和name创建一个File对象 //后面的代码完全同上面一样 File newFile = new File(dir,name); boolean b = newFile.getName().endsWith(\".png\"); if (b) &#123; return true; &#125; else &#123; return false; &#125; &#125;)); for (File fi : files) &#123; System.out.println(fi.getName()); &#125;&#125; 在main方法中调用该方法 printPNGAgain(new File(\"D:\\\\images\")); 输出同上面一模一样 字节流下面介绍两个类用来从文件中读取数据和写入数据到文件的类。不管是读取数据还是写入数据，都是以字节为单位的。 OutputStream该类可以将内存中的数据写入到文件中。OutputStream类是一个抽象类，我们可以使用它的子类FileOutputStram，它的构造方法中传入的参数可以是一个File对象，也可以是一个代表路径的字符串。它里面主要有以下方法 write(byte b) 写入一个字节到文件中 write(byte[] bytes) 将一个字节数组写入到文件中 如果传入的byte是一个负数，那么该数与其后面的那个字节组成一个中文 write(byte[] bytes, int off, int len) 写入字节数组索引从off开始，长度为len字节的数据 close() 关闭流 下面示例其使用 //如果没有a.txt，会创建一个a.txt新文件OutputStream fos = new FileOutputStream(new File(\"a.txt\")); //可以传入\"a.txt\"字符串fos.write(97); //写入a//\\r\\n代表 回车换行fos.write(\"\\r\\n\".getBytes()); //String类的getBytes()方法可以得到一个byte数组fos.write(\"abc\".getBytes());fos.close(); 上面的程序是会把原来文件里面的内容情空，然后将数据写入了，如果想向文件中追加数据的话，那么就要在构造方法的第二个参数传入true，代表是追加。如 OutputStream fos = new FileOutputStream(new File(\"a.txt\"), true); InputStream与OutputStream相对的，该类的作用是读取文件中的内容，一般我们使用的是其子类FileInputStream，构造方法同OutputStream，包含的方法有 read() 读取一个字节并返回，如果读到了文件的末尾，那么返回-1，我们可以通过返回的是否是-1来判断是否已经读到了文件的末尾 read(byte[] bytes) 读取bytes大小的字节，返回的是读取的有效位数 假如文件有5个字节，我用长度为6的字节数组去读取，那么返回的就是5 如果已经读到了文件的末尾，不是返回0，而是返回-1。 close() 关闭流 InputStream fis = new FileInputStream(new File(\"a.txt\")); //可以传入\"a.txt\"字符串int len = fis.read(); //读取一个字符，读取的虽然是byte，但是返回时会被提升为int，所以用用int接收System.out.println((char)len);fis.close(); 文件复制综合读取数据和写入数据，我们通过这两个流复制一个文件 OutputStream fos = new FileOutputStream(new File(\"copy.jpg\"));InputStream fis = new FileInputStream(new File(\"a.jpg\"));byte[] bytes = new byte[1024]; //用来读取数据的数组，也是写数据的数组int len = 0;// 判断是否读取完毕while ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes,0, len);&#125;//先关闭写的流，因为写完了，说明肯定读完了fos.close();fis.close(); 字符流字节流是一个字节一个字节读取的，但是对于中文，如果使用GBK编码的话由2个字节组成，如果使用UTF-8编码的话由3个字节组成。所以如果一个字节进行读取的话就得不到想要的字符。那么这里就需要引入一个新的流来读取字符，以字符为单位进行读取。 ReaderReader就相当于是InputStream，它的作用就是从文件中读取数据到内存，不过不同的是，Reader读取的最小单位为字符，它的构造方法与InputStream一样，包含的方法也一样，不过参数有所不同，不在是字节，而是字符。Reader也是一个抽象类，我们在这里常使用它的子类FileReader。我们在本目录下新建一个文件b.txt，在里面写入你好，使用UTF-8编码(不要使用GBK) Reader reader = new FileReader(\"b.txt\"); //也可以传入一个File对象int c = 0;while ((c = reader.read()) != -1) &#123; System.out.println((char)c);&#125; 输出为 你好 FileReader其实也有新建一个字节流去读取数据，不过中间有一个将字节转为字符的过程，转换默认是按照UTF-8的方式解码的，所以如果你在Windows下直接新建文件，默认是GBK的，这样读取就会是乱码，可以直接在IDEA中新建文件，默认为UTF-8编码。 如果我们读取得到了一个字符数组，我们可以使用String类的构造方法 String(char[] value) String(char [] value, int off, int len) 将字符数组转化为字符串，方便处理。 WriterWriter就是向文件中写入一个字符，同OutputStream不同，Writer有一个特有的方法 flush() 该方法的作用是将缓存区里的内容写入到文件中 这是怎么回事，其实Writer的底层是创建一个了字节流写数据的，我们直接写入字符不是直接写在文件中，而是写在缓冲区中，然后缓冲区中的内容转化为字节写入文件中。在调用close()，在关闭流之前，会把缓冲区中的内容写到文件中，如果既没有调用flush()也没有调用close()，那么写入的数据不会写入文件中。 还有一个方法是 write(String str [, int off, int len]) 可以直接写入字符串，不用写字符数组那么麻烦了 //如果没有c.txt，那么会新建一个Writer writer = new FileWriter(\"c.txt\"); //也可以传入一个File对象//写入的默认是utf-8编码writer.write(\"你好啊\");//如果不调用close()，那么c.txt里面什么都没有writer.close(); 同OutputStream一样，这里的write也是覆盖重写，如果想要只是追加数据的话，在构造方法的第二个参数传入true Writer writer = new FileWriter(\"c.txt\",true); Properties属性集Properties是继承至HashTable的一个集合。它是与IO流关联起来的，通过load()和store()方法可以读取特定格式的文件数据，和将Properties集合中的数据写入到文件中。 store下面介绍将Properties中的数据写入到文件中。首先介绍如何向Properties集合中添加数据 setProperty(String key, String value) Properties集合中的键和值都是String类型的。store()分为两种，一种是字节流，传入的是OutputStream对象，一种是字符流，传入的是Writer对象 store(OutputStream in, String comment) store(Writer writer, String comment) 第二个参数String comment是注释，写入文件会写在第一行，并且以#开头，一般我们传入一个空字符串 Properties properties = new Properties();properties.setProperty(\"古力娜扎\",\"18\");properties.setProperty(\"迪丽热巴\",\"17\");properties.store(new FileWriter(\"properties.txt\"), \" \"); properties.txt文件里面的内容为 # #Fri Aug 09 11:28:20 CST 2019古力娜扎=18迪丽热巴=17 load在介绍load()之前，说明一下如何获取Properties中的元素 getProperty(String key) 通过键获取值，相当于Map中的get() stringPropertiesName() 相当于Map中的 keySet()，返回一个Set集合，泛型为String 下面介绍load()方法，load()就是读取指定格式的文件，比如，指定格式如下两种 古力娜扎=18 或者 古力娜扎 18 中间的分隔符可以使用=或者空格，如果碰到以#开头的，则不会读取，我们来读取刚刚写的properties.txt文件 Properties properties = new Properties();//读取文件properties.load(new FileReader(\"properties.txt\"));Set&lt;String&gt; propertiesName = properties.stringPropertyNames();//遍历集合for (String name : propertiesName) &#123; System.out.println(name+\"=\"+properties.getProperty(name));&#125; 输出为 古力娜扎=18迪丽热巴=17 缓冲流之前我们使用过字节流InputStream和OutputStream进行过文件复制的练习，但是其实我们可以发现，使用这两个流的速度很慢，所以这里就引入了缓冲流BufferedInputStream和BufferedOutPutStream，还有BufferedReader和BufferedWriter。为了感受字节流和缓冲流的差异，我们这次来复制一个1MB的文件。 字节流复制首先使用字节流，一个字节一个字节的读取 long start = System.currentTimeMillis();InputStream fis = new FileInputStream(\"file.pdf\");OutputStream fos = new FileOutputStream(\"copy.pdf\");int len = 0;while ((len = fis.read()) != -1) &#123; fos.write(len);&#125;fos.close();fis.close();long end = System.currentTimeMillis();System.out.println(\"共耗时\" + (end - start) + \"毫秒\"); 输出为 共耗时11738毫秒 现在还是使用字节流，不过一次读取1KB long start = System.currentTimeMillis();InputStream fis = new FileInputStream(\"G:\\\\JavaProject\\\\ThirdProject\\\\src\\\\file.pdf\");OutputStream fos = new FileOutputStream(\"copy.pdf\");int len = 0; //存储读取的有效位数byte[] bytes = new byte[1024]; //读取1KBwhile ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes,0,len);&#125;fos.close();fis.close();long end = System.currentTimeMillis(); 输出为 共耗时203毫秒 缓冲流复制这次使用缓冲流，先一个字节一个字节的读取 long start = System.currentTimeMillis();BufferedInputStream buffis = new BufferedInputStream(new FileInputStream(\"file.pdf\"));BufferedOutputStream buffos = new BufferedOutputStream(new FileOutputStream(\"copy.pdf\"));int len = 0;while ((len = buffis.read()) != -1) &#123; buffos.write(len);&#125;buffos.close();buffis.close();long end = System.currentTimeMillis();System.out.println(\"共耗时\" + (end - start) + \"毫秒\"); 输出为 共耗时94毫秒 这次一次读取一1KB long start = System.currentTimeMillis();BufferedInputStream buffis = new BufferedInputStream(new FileInputStream(\"file.pdf\"));BufferedOutputStream buffos = new BufferedOutputStream(new FileOutputStream(\"copy.pdf\"));int len = 0;byte[] bytes = new byte[1024];while ((len = buffis.read(bytes)) != -1) &#123; buffos.write(bytes,0,len);&#125;buffos.close();buffis.close();long end = System.currentTimeMillis();System.out.println(\"共耗时\" + (end - start) + \"毫秒\"); 输出为 共耗时16毫秒 下面我来做一个表格总结一下速度 缓冲流(ms) 字节流(ms) 1MB 94 11738 1KB 16 203 从这些数据看，就知道缓冲流的速度比字节流的快很多。 缓冲流的一些特有方法缓冲流提供了几个特有的方法，如BufferedOutputStream和BufferedReader中有一个方法为 readline() 一次读取一行数据，读到的数据不包括换行符 如果读到了末尾，那么返回null BufferedInputStream和BufferedWriter也提供了一个方法叫做 newline() 作用是换行，可以根据不同的操作系统进行换行 之前我们写的\\r\\n只适用于Windows系统 转换流我们在使用字符流时，只能读取UTF-8格式的文件，写出的数据的格式也是UTF-8的，现在假设我要读取一个GBK的文件，里面有中文”你好”，看看会发生什么。 FileReader reader = new FileReader(\"text.txt\");int len = 0;while ((len = reader.read()) != -1) &#123; System.out.print((char)len);&#125;reader.close(); 发现读取的只是乱码 这是因为FileReader是按照UTF-8的格式读取的，但是文件的格式却是GBK，编码不一样，那么解码当然会出问题。所以就有了转换流的出现，有两个类是做这件事情的，分别是InputStreamReader和OutputStreamWriter，它们的构造方法是 InputStreamReader(InputStream in, String charset) OutputStreamWriter(OutputStream out, String charset) 第二个参数就是用来指定字符集的，如果不指定字符集的话，就默认为UTF-8。 String path = \"text.txt\";InputStreamReader reader = new InputStreamReader(new FileInputStream(path), \"gbk\");int len = 0;while ((len = reader.read()) != -1) &#123; System.out.print((char) len);&#125;reader.close(); 输出为 你好 下面做一个小的练习，将一个GBK格式的文件转换为一个UTF-8格式的文件 String path = \"text.txt\";//也可写成GBKInputStreamReader reader = new InputStreamReader(new FileInputStream(path), \"gbk\"); //不指定字符集的话，默认为UTF-8(utf-8)OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"test.txt\"));int len = 0;while ((len = reader.read()) != -1) &#123; writer.write(len);&#125;writer.close();reader.close(); 序列流如果我们想将对象保存在硬盘中怎么办? 因为一旦断电，内存中的对象就会全部的消失。这个时候就需要序列流将对象保存在文件中，对应也有相应的序列流读取文件得到一个对象。 ObjectOutputStream 将文件写到文件中的类 writeObject(Object o) 该方法将对象写到文件中 ObjectInputStream 从文件中读取对象的类 readObject() 将文件中的对象读取出来，返回一个Object对象 下面介绍使用及注意事项。首先创建一个Person类 package IOProjectpublic class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.age = age; this.name = name; &#125; public Person() &#123; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 然后在测试类中创建一个对象，并使用ObjectOutputStream类的对象将这个对象写到文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person\"));Person p = new Person(\"迪丽热巴\",18);oos.writeObject(p);oos.close(); 这时抛出了一个异常 这时因为Person没有实现Serializable接口，这里谈第一个注意事项 只有实现了Serializable接口才能将其对象序列化和反序列化 Serilaizable是一个标志性接口，所谓的标志性指的是只起一个标志的作用，Serializable接口里面什么都没有，我们不需要实现任何的方法 现在将Person实现Serializable接口然后执行上面的程序就不会有问题了。 下面使用ObjectInputStream读取刚刚序列化的对象，这个过程叫做反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person\"));Object o = ois.readObject();System.out.println(o);ois.close(); 输出为 Person&#123;age=18, name='迪丽热巴'&#125; 说明我们读取成功了。 下面添加几个注意事项 static修饰的静态变量不能进行序列化 被transient修饰的成员变量也不能进行序列化 如果对象序列化后，修改了类文件，那么不能被序列化 现在我们修改Person类中的age使用transient修饰，进行序列化和反序列化操作，得到的结果为 Person&#123;age=0, name='迪丽热巴'&#125; age = 0并不等于18，说明age没有被序列化到文件中。 现在我们将Person类的对象序列化，然后修改Person类，接着在反序列化 Exception in thread \"main\" java.io.InvalidClassException: IOProject.Person; local class incompatible: stream classdesc serialVersionUID = -774581383406272369, local class serialVersionUID = -4004215360553243182 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at IOProject.TestSerial.main(TestSerial.java:13) 抛出了一个异常InvalidClassException，这是因为它们的serialVersionUID对不上。serialVersionUID是根据类文件自动计算的，当我们修改类文件时，serialVersionUID发生了改变，当我们反序列化时会比较serialVersionUID，由于这时它们的serialVersionUID不同，所以抛出了这个异常。我们可以在类里面为这个变量赋一个固定的值，这样serialVersionUID就不会发送改变，但是赋值也是有要求的 必须使用final static long修饰 我们在Person类中加入 private final static long serialVersionUID = 1L; 然后执行上面的操作，发现没有问题。输出为 Person&#123;age=18, name='迪丽热巴'&#125; //这里age没有使用transient修饰 打印流PrintStream是一个有关于打印流的类，我们一直使用的System.out其中的out就是一个PrintStream对象，下面是其在System类中的定义 public final static PrintStream out = null; 打印流有以下的特点 它只负责数据的输出 永不抛出IOExecption 它继承了OutputStream类 它有自己的特有方法，如print(), println()，这两个方法可以打印出任意的数据类型 当它调用OutputStream类的方法write()时，打印数据时会查编码表，如write(97)会打印出a，但是print(),println()方法输入什么，打印出什么，如print(97)打印出97。 下面简单介绍使用，首先看PrintStream的构造方法 PrintStream(File file) PrintStream(OutputStream out) PrintStream(String filename) PrintStream printStream = new PrintStream(\"a.txt\");printStream.write(97);printStream.println(97);printStream.println(22.2);printStream.println(true);printStream.println('a');printStream.println(\"abc\");printStream.close(); 打开a.txt文件，里面的内容为 a9722.2trueaabc System类有一个方法setOut(PrintStream out)，可以用来改变System.out的指向，这样打印出的内容不会在控制台显示，而是会在文件中 PrintStream printStream = new PrintStream(\"a.txt\");System.setOut(printStream);System.out.println(\"怎么了，你累了，说好的幸福呢？\"); 运行程序发现控制台没有任何的输出 而在a.txt中出现了打印的语句。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"文件","slug":"文件","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%96%87%E4%BB%B6/"},{"name":"File","slug":"File","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/File/"}]},{"title":"Java网络编程","date":"2019-07-25T16:00:00.000Z","path":"/Java网络编程/","text":"网络编程主要是客户端与服务器之间的交互，与客户端有关的类是Socket，与服务器有关的类是ServerSocket。客户端与服务器之间的通信主要是通过字节流实现的，客户端Socket含有方法 getInputStream() getOutputStream() 来获得流，而服务器通过accept()监听请求的客户端，该方法返回一个Socket类对象，这个对象就是访问的客户端，服务器通过这个Socket获得流，通过该流与客户端通信。 构造方法客户端Socket类的构造方法为 Socket(String host, int port) 第一个参数为域名地址或者IP地址 第二个参数为端口号 服务器端ServerSocket的构造方法为 ServerSocket(int port) 这个参数为端口号 客户端与服务器之间的简单通信下面写一个简单的示例来进行客户端与服务器的通信。 客户端代码 import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class Client &#123; public static void main(String[] args) throws IOException &#123; //创建客户端对象socket 服务器IP地址为127.0.0.1，代表本机 端口号为8888 Socket socket = new Socket(\"127.0.0.1\",8888); //获得输出流以便向服务器发送信息 OutputStream os = socket.getOutputStream(); //向服务器发送信息 os.write(\"这里是客户端\".getBytes()); //获得输入流，以接收服务器返回的信息 InputStream is = socket.getInputStream(); //读取服务器返回的信息并打印 byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0, len)); //释放资源 socket.close(); &#125;&#125; 服务器端代码 import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static void main(String[] args) throws IOException &#123; //创建一个服务器对象 ServerSocket serverSocket = new ServerSocket(8888); //通过accept()方法获得客户端对象 Socket socket = serverSocket.accept(); //通过客户端对象获得输入流，已读取客户端发送的消息 InputStream is = socket.getInputStream(); //读取客户端发送的消息并打印 byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes, 0, len)); //通过客户端对象获得输出流，以便发送消息给客户端 OutputStream os = socket.getOutputStream(); os.write(\"收到了，谢谢\".getBytes()); //释放资源 socket.close(); serverSocket.close(); &#125;&#125; 先运行服务器端的程序，然后运行客户端的程序，服务器的输出为 这里是客户端 客户端的输出为 收到了，谢谢 文件上传将本地的文件传输到服务器，其实原理就是文件的复制，之前我们写过，不过现在是使用网络流来实现，下面是代码，说明都在代码的注释中。 客户端代码 import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class ClientUpload &#123; public static void main(String[]args) throws IOException &#123; //创建输入流读取要上传的文件 InputStream fis = new FileInputStream(\"upload.pdf\"); //创建客户端对象 Socket client = new Socket(\"127.0.0.1\", 8888); //读取文件，并将文件通过socket的输出流传给服务器 byte[] bytes = new byte[1024]; int len = 0; OutputStream os = client.getOutputStream(); while ((len = fis.read(bytes)) != -1) &#123; os.write(bytes, 0, len); &#125; //由于read不会将最后读取到-1发送，那么服务器就得不到-1，就不会终止 //就会进入死循环，所以下面的代码是写入终止符，你可以把下面这行代码去掉，看看会发生什么 client.shutdownOutput(); //获得输入流以便获得服务器的返回信息 InputStream is = client.getInputStream(); while ((len = is.read(bytes)) != -1) &#123; System.out.println(new String(bytes,0,len)); &#125; //释放资源 fis.close(); client.close(); &#125;&#125; 服务器端代码 import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerUpload &#123; public static void main(String[] args) throws IOException &#123; //获得输出流，将上传的文件写到服务器的硬盘中 OutputStream fos = new FileOutputStream(\"uploadServer.pdf\"); //创建服务器对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); //获得输入流读取客户端发送的数据 InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = 0; //读到-1才会终止，所以客户端最后要发一个终止符-1，否则会不断循环 while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes); &#125; //向客户端返回数据\"已经上传完成\" OutputStream os = socket.getOutputStream(); os.write(\"已经上传完成\".getBytes()); socket.close(); fos.close(); server.close(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"网络编程","slug":"网络编程","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Java反射","date":"2019-07-19T16:00:00.000Z","path":"/Java反射/","text":"反射是框架设计的灵魂，通过反射我们可以在程序运行时读取配置文件动态的创建一个类，也可以通过读取注解来达到我们想到的功能。与反射有关的类是Class类。 Class类对象的获取方法Class类对象的获取方法有三种 Class.forName(String name) 参数是类的全类名(包名+类名)，可以获得该类的Class对象 类名.class 通过类的静态属性class可以获取Class对象 对象.getClass() 通过对象的getClass()方法可以获取Class对象 假设一个Animal类 public class Animal &#123; public Animal(String name, int age) &#123; this.name = name; this.age = age; &#125; public Animal() &#123; &#125; public String name; private int age; public void eat() &#123; System.out.println(\"eat ...\"); &#125; public void eat(String string) &#123; System.out.println(\"eat \" + string); &#125; private void sleep() &#123; System.out.println(\"sleep ...\"); &#125; @Override public String toString() &#123; return \"Animal&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 现在要通过上面的三种方法获取该类的Class对象 //通过全类名获取Class对象Class cls1 = Class.forName(\"Animal\");//通过类的静态属性class获取Class对象Class cls2 = Animal.class;//通过对象的getClass()获取静态对象Animal animal = new Animal();Class cls3 = animal.getClass(); 另外需要注意的是，通过上面三种方法获取的Class对象是同一个对象 System.out.println(cls1 == cls2); //trueSystem.out.println(cls1 == cls3); //true Class类的常见成员方法与成员变量有关的方法 getFields() 获取public修饰的所有成员变量，返回一个Field[] getField(String name) 获取指定名称被public修饰的成员变量 getDeclaredFields() 同getFields()，不过任意修饰符修饰的都可以获取 getDeclaredField(String name) 同getField(String name)，不过任意修饰符修饰的都可以获取 Field[] fields1 = cls1.getFields();//public java.lang.String Animal.namefor (Field field : fields1) &#123; System.out.println(field);&#125;Field[] fields2 = cls1.getDeclaredFields();//public java.lang.String Animal.name//private int Animal.agefor (Field field : fields2) &#123; System.out.println(field);&#125;Field field1 = cls1.getDeclaredField(\"age\");//private int Animal.ageSystem.out.println(field1); 可以通过set(Object obj, Object value)方法对指定的对象设定值，也可以通过get(Object obj)方法来获取值 Field field2 = cls1.getDeclaredField(\"name\");field2.set(animal,\"Dog\");System.out.println(animal.name); //DogSystem.out.println(field2.get(animal)); //Dog 如果我们要对age进行赋值，因为age变量是private修饰的，是不能在类外面直接访问的，我们可以调用setAccessible(true)方法，来忽略访问修饰符的安全检查(暴力反射) Field field1 = cls1.getDeclaredField(\"age\");field1.setAccessible(true);field1.set(animal,10);System.out.println(field1.get(animal)); //10//System.out.println(animal.age); //会报错，不能这么访问 与构造方法有关的方法 getConstructors() 得到由public修饰的所有构造方法 getConstructor() 获取指定参数的构造函数，如 getConstructor()：获取无参构造函数 getConstructor(String.class, int.class)：获得第一个参数类型为String类型和第二个参数类型为int类型的构造方法 cls1.getDeclaredConstructors() 参照Field cls1.getDeclaredConstructor() 参照Field //获得无参的构造方法Constructor cons1 = cls1.getConstructor();Stream.of(cons1).forEach(System.out::println); //public Animal()//获得参数类型分别为String类型和int类型的构造方法Constructor cons2 = cls1.getConstructor(String.class, int.class);Stream.of(cons1).forEach(System.out::println); //public Animal() 现在获得了构造方法，那么构造方法的作用就是创造对象，我们可以通过Contructor对象的的newInstance()方法创建一个对象，如 //newInstance方法返回的是一个Object对象Animal animal1 = (Animal) cons1.newInstance();Animal animal2 = (Animal) cons2.newInstance(\"Cat\", 2);System.out.println(animal1);System.out.println(animal2); 输出为 Animal&#123;name='null', age=0&#125;Animal&#123;name='Cat', age=2&#125; 如果想创建一个无参的对象，可以直接通过Class对象的newInsatance()方法创建，如 Animal animal3 = (Animal) cls1.newInstance(); 与成员方法有关的方法 getMethods 获取所有public修饰的方法 getMethod() 通过方法名和参数类型(区别重载的方法)获取public修饰的指定方法 getDeclaredMethods 忽略修饰符 getDeclaredMethod 忽略修饰符 //获取不带参数的eat方法Method eat1 = cls1.getMethod(\"eat\");//获取带一个参数类型为String的eat方法Method eat2 = cls1.getMethod(\"eat\",String.class);//获取private修饰的sleep方法Method sleep = cls1.getDeclaredMethod(\"sleep\"); 获取到了方法，那么接下来就是怎么使用的问题，我们可以使用invoke()方法来执行方法，需要传入相应的对象和需要的参数，如果方法不需要参数，那么可以不传，如 eat1.invoke(animal);//需要传入参数eat2.invoke(animal,\"饭\");//因为sleep是private修饰的，要执行就要执行下面这一步sleep.setAccessible(true);sleep.invoke(animal); 输出为 eat ...eat 饭sleep ... 我们还可以通过getName()方法获得方法名，如 System.out.println(eat1.getName()); //eat 我们可以通过Class对象的getName()方法获得该类的全类名(包名+类名) System.out.println(cls1.getName()); //Animal 使用反射读取配置文件动态创建任意的对象我们现在有这么一个需求，那就是希望创建任意一个类的对象，并且调用相应的方法，要求不能更改代码，而只需要更改配置文件即可。现在我们创建一个config.properties的配置文件，内容如下 className=AnimalmethodName=eat 我们要做的就是读取配置文件，然后根据配置文件创建相应类的对象并且调用其方法 import java.io.FileNotFoundException;import java.io.FileReader;import java.lang.reflect.Method;import java.util.Properties;public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; //创建Properties读取配置文件 Properties pro = new Properties(); pro.load(new FileReader(\"G:\\\\JavaProject\\\\Fourth\\\\src\\\\config.properties\")); //获得类名和方法名 String className = pro.getProperty(\"className\"); String methodName = pro.getProperty(\"methodName\"); //根据类名获取Class对象 Class cls = Class.forName(className); //获取方法 Method method = cls.getMethod(methodName); //使用无参构造方法创建对象 Object o = cls.newInstance(); //调用方法 method.invoke(o); &#125;&#125; 现在我们运行一下 eat ... 现在我们要创建什么类的对象并且要调用什么方法，只需要修改配置文件就可以了，不用修改代码了。虽然还有很多的问题，比如只能使用无参构造方法创建对象，只能调用无参的方法，不过即使是这样也让我们感受到了反射的强大。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java8新特性","date":"2019-07-13T16:00:00.000Z","path":"/Java8新特性/","text":"本篇文章会介绍Java 8中的一些新特性(不包括Lambda表达式，因为在Java多线程这篇文章中介绍过了)。主要内容是Java 8中新增的函数式接口以及Stream流，还有方法引用。 常用函数式接口函数式接口指的就是接口里面只含有一个抽象方法。这样我们就可以使用Lambda表达式编程，这是一种函数式编程的思想，强调的是怎么做。Java 8提供了很多的函数式接口，这里我们介绍常见的函数式接口。 Supplier\\&lt;T&gt; Consumer\\&lt;T&gt; Predicate\\&lt;T&gt; Functional\\&lt;T,R&gt; Supplier&lt;T&gt;该接口里面有一个T get()方法，按照字面意思，是提供者的意思，表示生产出一个与泛型类型T相同的数据。下面我们来讲一个例子说明此接口的使用。假设有一个方法，需要返回一个字符串，该字符串由Supplier接口的get()方法产生，而产生什么样的字符串，则由程序员在调用该方法是传入Lambda决定。如下方法传入一个Supplier接口得到一个字符串 public static String getString(Supplier&lt;String&gt; supplier) &#123; return supplier.get();&#125; 我们在main方法中调用该方法 String str = getString(() -&gt; &#123; return \"Hello World!\";&#125;); 输出为 Hello World! Consumer&lt;T&gt;与Supplier接口不同的是，Consumer接口是消费或者说处理一个与泛型类型相同数据类型的数据，它有一个accept(T t)方法，该方法用来消费数据，假设有下面这一个方法 public static void handleString(String str, Consumer&lt;String&gt; consumer) &#123; consumer.accept(str);&#125; 我们使用Consumer来消费(处理)传入的这个字符串，而怎么消费，就取决与程序员在调用该方法时传入的Lambda，这时对程序员来说，就是怎么做的问题，相当于传入一个方法去处理数据，这就是函数式编程，这里我们就简单的将传入的数据进行打印 handleString(\"Hello Again!\", (String str) -&gt; &#123; System.out.println(str);&#125;); 输出为 Hello Again! Consumer接口中有一个默认方法andThen(Consumer consumer)，看下面的程序说明它的用处 con1.andThen(con2).accept(str); //con1和con2都是Consumer接口的实现类对象//相当于下面的代码con1.accept(str);con2.accept(str); 假设有一个方法有需要传入两个Consumer接口对数据进行消费 public static void handleInterger(Integer i, Consumer&lt;Integer&gt; con1, Consumer&lt;Integer&gt; con2) &#123; con1.andThen(con2).accept(i);&#125; 在mian方法中使用，con1对数字进行+10然后打印，con2对数字进行*10然后打印 handleInteger(10, (i) -&gt; &#123; i = i + 10; System.out.println(i);&#125;, (i) -&gt; &#123; i = i * 10; System.out.println(i);&#125;); 输出为 20100 Predicate&lt;T&gt;Predicate接口中有一个test(T t)，它的作用是对某种数据类型进行判断，它返回一个boolean值。假设有一个集合，我们对其中的元素进行判断，符合条件放入一个新的集合，看下面的方法。 public static HashMap&lt;String, Integer&gt; getMap(HashMap&lt;String,Integer&gt; map, Predicate&lt;Integer&gt; predicate) &#123; //创建一个集合用以放符合条件的元素 HashMap&lt;String,Integer&gt; resmap = new HashMap&lt;&gt;(); //遍历集合 Set&lt;String&gt; key = map.keySet(); for (String str : key) &#123; int val = map.get(str); //对值进行判断 boolean res = predicate.test(val); //如果值符合条件，就加入新的集合 if (res) &#123; resmap.put(str,val); &#125; &#125; return resmap;&#125; 现在我们在main方法中进行调用 HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();map.put(\"迪丽热巴\",18);map.put(\"古力娜扎\",19);map.put(\"佟丽娅\",20);map.put(\"奥特曼\",100);//筛选出年龄小于等于20岁的HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123; if (i &lt;= 20) &#123; return true; &#125; return false;&#125;);System.out.println(resmap); 运行结果为 &#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125; Predicate还有三个默认方法 and(Predicate\\&lt;T&gt; pre) 与 or(Predicate\\&lt;T&gt; pre) 或 negate() 非 假设对于上面的那个方法，我提出一个新的需求，要求不仅年龄要小超过20岁，而且年龄要大于18 public static HashMap&lt;String, Integer&gt; getMap(HashMap&lt;String,Integer&gt; map, Predicate&lt;Integer&gt; predicate1, Predicate&lt;Integer&gt; predicate2) &#123; HashMap&lt;String,Integer&gt; resmap = new HashMap&lt;&gt;(); Set&lt;String&gt; key = map.keySet(); for (String str : key) &#123; int val = map.get(str); boolean res = predicate1.and(predicate2).test(val); if (res) &#123; resmap.put(str,val); &#125; &#125; return resmap;&#125; 在main方法中调用该方法 HashMap&lt;String,Integer&gt; resmap = getMap(map, (Integer i) -&gt; &#123; if (i &lt;= 20) &#123; return true; &#125; return false;&#125;, (Integer i) -&gt; &#123; if (i &gt; 18) &#123; return true; &#125; return false;&#125;);System.out.println(resmap); 输出结果为 &#123;佟丽娅=20, 古力娜扎=19&#125; 至于or()和negate()的使用方法同上。 Function&lt;T,R&gt;该接口的作用是将T这种数据类型转化为R这种数据类型，它里面有一个R apply(T t)方法。下面这个方法将一个字符串转化为一个整数 public static Integer StrToInt(String str, Function&lt;String, Integer&gt; fun) &#123; return fun.apply(str);&#125; 在main()方法中调用该方法 Integer integer = StrToInt(\"123\", (String str) -&gt; &#123; //将字符串转化为数字 return Integer.parseInt(str);&#125;);//打印该数字System.out.println(integer); 输出为 123 Function接口中还有一个默认方法andThen(Function&lt;T,R&gt; fun)，这个方法与在上面介绍的Consumer接口的andThen()很像，但是有点不同，Consumer接口的andThen是两个对象消费同一个数据，而Function接口的addThen()是将第一个fun处理后的结果拿给第二个fun去处理，相当于apply(apply())。比如现在我有一个需求，将一个字符串转化为数字，然后将这个数字，+10然后再转化为字符串，这个方法可以这么写 public static String StrPlus(String str, Function&lt;String,Integer&gt; fun1, Function&lt;Integer,String&gt; fun2) &#123; return fun1.andThen(fun2).apply(str);&#125; 我们在main方法中调用该方法 String s = StrPlus(\"123\", (String str) -&gt; &#123; //将字符串转化为数字并加10 Integer i = Integer.parseInt(str); i = i + 10; return i;&#125;, (Integer i) -&gt; &#123; //将数字转化为字符串 return i + \"\";&#125;);System.out.println(s); 输出为 133 Stream流Stream流是Java 8引入的新特性，首先它跟I/O流没有任何的关系，它主要是用来处理集合、数组问题的。要看Stream流有什么用处，还是要看集合处理有什么缺点。 问题引出有下面这么一个数组 String[] strings = &#123;\"张无忌\", \"张三丰\", \"赵敏\", \"张翠山\", \"小昭\", \"张良\"&#125;; 现在我们有如下要求 筛选出以”张”字开头的字符串，放入一个Arraylist集合中 在ArrayList集合中筛选出字符串长度为3的字符串，放入一个新的集合 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();for (String string : strings) &#123; if (string.startsWith(\"张\")) &#123; list1.add(string); &#125;&#125;System.out.println(list1);ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();for (String string : list1) &#123; if (string.length() == 3) &#123; list2.add(string); &#125;&#125;System.out.println(list2); 输出为 [张无忌, 张三丰, 张翠山, 张良][张无忌, 张三丰, 张翠山] 现在我们使Stream流的方式实现 Stream&lt;String&gt; stream = Stream.of(strings);stream.filter(str -&gt; str.startsWith(\"张\")) .filter(str -&gt; str.length() == 3) .forEach(str -&gt; System.out.print(str + \" \")); 输出为 张无忌 张三丰 张翠山 我们发现使用Stream流的代码比遍历集合简单很多，因为使用集合直接遍历真正核心的代码就那么一两句，比如 for (String string : strings) &#123; if (string.startsWith(\"张\")) &#123; list1.add(string); &#125;&#125; 这些代码中核心的就是string.startsWith(&quot;张&quot;)，而其他的代码是为了达到这个目的不得不写的代码。这就是集合相较于Stream流的局限性所在，观察Stream流的写法，根本没有什么遍历集合的代码，直接就是你想要干的事情。 获取Stream流的方法获取Stream流有两种方法 Collection中新加的stream()方法，该方法可以得到一个Stream流，对于Map集合，可以通过keySet(),values(),entrySet()等方法得到Set集合，然后通过Set对象调用stream()方法得到Stream流 Stream流的静态方法of()，该方法接收一个可变参数，所以可以传入一个数组 下面做一个演示 import java.util.*;import java.util.stream.Stream;public class getStream &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"哪吒\"); list.add(\"杨戬\"); Stream stream1 = list.stream(); stream1.forEach(s -&gt; System.out.println(s)); HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"迪丽热巴\",\"女\"); map.put(\"古力娜扎\",\"女\"); map.put(\"哪吒\",\"男\"); map.put(\"杨戬\",\"男\"); Set&lt;String&gt; key = map.keySet(); Stream stream2 = key.stream(); stream2.forEach(s -&gt; System.out.println(s)); Collection&lt;String&gt; vals = map.values(); Stream stream3 = vals.stream(); stream3.forEach(s -&gt; System.out.println(s)); Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet(); Stream stream4 = entries.stream(); stream4.forEach(s -&gt; System.out.println(s)); String[] strings = &#123;\"迪丽热巴\", \"古力娜扎\", \"哪吒\", \"杨戬\"&#125;; Stream stream5 = Stream.of(strings); stream5.forEach(s -&gt; System.out.println(s)); Stream&lt;Integer&gt; stream6 = Stream.of(1,2,3,4,5); stream6.forEach(s -&gt; System.out.println(s)); &#125;&#125; Stream中的常见方法Stream流中的方法分为两类，一类叫做延迟方法，该方法返回的还是一个Stream流对象，所以可以进行链式编程，如filter()；另一类叫做终结方法，该方法不返回Stream流对象，如forEach()， count()(终结方法只有这两个，其他的都是延迟方法)。 filter()该方法需要传入的是一个Predicate\\&lt;T&gt;接口，这个接口我们在常用函数式接口讲过，它是对某中数据进行测试，而filter的作用就是如果test(T t)返回的是true，那么就将这个数据加入到新的流中，遍历完流中所有的元素后返回。 //当字符串以迪开头时返回true，加入到新的流中，这个流会被返回Stream&lt;String&gt; stream1 = stream.filter(s -&gt; s.startsWith(\"迪\"));//forEach是后面要介绍的方法，这里只需要理解为遍历流并打印stream1.forEach(s -&gt; System.out.println(s)); 输出为 迪丽热巴 map()该方法传入的是一个Function&lt;T,R&gt;接口，所以它的作用是将一个类型的转转化为另一个类型的流。如下 //得到一个流，这个流是字符串的长度Stream&lt;Integer&gt; stream1 = stream.map(s -&gt; s.length());stream1.forEach(s -&gt; System.out.println(s)); 这时结果报错了 这是因为这个stream在调用上面的filter()的时候已经使用过了，而流使用了一次就会关闭，不能在使用，这就是为什么会报错的原因，所以我们把代码改为 //得到一个流，这个流是字符串的长度Stream&lt;Integer&gt; stream2 = Stream.of(strings).map(s -&gt; s.length());stream2.forEach(s -&gt; System.out.println(s)); 这时输出为 4422 forEach该方法传入的是一个Consumer\\&lt;T&gt;接口，是一个终结方法，该方法会遍历流中的元素，然后使用Consumer接口中的accept()方法对元素进行处理，比如 stream.forEach(s -&gt; System.out.println(s)); 会逐个打印出流中的元素。 limitlimit方法需要传入一个long类型的数值maxSize，该方法会截取流中的前maxSize个元素放到新流中并返回，如 //这是链式编程Stream.of(strings).limit(2).forEach(s -&gt; System.out.println(s)); 输出为 迪丽热巴古力娜扎 skip该方法接收一个long类型的数据n，它会跳过流中的前n个元素，将剩下的元素放入到一个新流中并返回，如 Stream.of(strings).skip(2).forEach(s -&gt; System.out.println(s)); 输出为 哪吒杨戬 count该方法不需要传入参数，返回一个long类型的整数，该整数是流中元素的个数，这个方法是一个终结方法，不返回Stream流 long num = Stream.of(strings).count();System.out.println(num); 输出为 4 方法引用我们之前在Stream流使用forEach()去打印流中的元素，如 stream.forEach(s -&gt; System.out.println(s)); 但是打印这个方法(System.out.println())是已经存在了的，我们可不可以直接传入这个方法，在这里或者说是引用这个方法，答案是可以的，如下 stream.forEach(System.out::println); 在这里我们引用了System.out对象的println方法，这行语句的作用是上面的语句作用是完全相同的，这就是方法的引用，::就是方法引用的运算符，这是新增的运算符。 那方法引用也要遵循一定的原则，比如你引用的对象必须是存在的，你引用的方法需要传入的参数的个数和类型必须是对的上的，否则就会抛出异常，由于方法的性质不同，所以有很多类型的引用，比如 对象引用成员方法 类引用静态方法 super引用父类方法 this引用成员方法 引用构造方法 引用数组构造方法 下面会详细的展开讲解。 对象引用成员方法其实 stream.forEach(System.out::println); 就是对象引用成员方法，我们引用了System.out对象的成员方法println。 类引用静态方法假设有一个接口Calculate，里面只有一个抽象方法cal(int i) public interface Calculate &#123; int cal(int i);&#125; 所以这是一个函数式接口，现在在有一个方法需要调用这个接口去得到一个数字的绝对值，如 public static int getAbs(int i, Calculate calculate) &#123; return calculate.cal(i);&#125; 我们知道Math类的静态方法abs()可以做到这件事情，所以我们可以直接引用这个方法，如 int num = getAbs(-10,Math::abs);System.out.println(num); 输出结果为 10 super引用父类成员方法假设有一个Greet接口，里面只有一个抽象方法greet()，所以这是一个函数接口 public interface Greet &#123; void greet();&#125; 现在有一个父类Person，里面有一个greet()方法，这个方法在后面是要被子类引用的 public class Person &#123; String name; public Person(String name) &#123; this.name = name; &#125; public Person() &#123; &#125; public void greet() &#123; System.out.println(\"I'm \" + name); &#125;&#125; 现在有一个子类Student继承了Person类 public class Student extends Person &#123; public Student(String name) &#123; super(name); &#125; public static void sayHello(Greet gre) &#123; gre.greet(); &#125; public void greet() &#123; sayHello(super::greet); &#125;&#125; Student中的sayHello()方法需要一个Greet接口，然后我们又在greet()方法中调用了这个方法，并且传入一个super::greet的方法引用(当然这样的代码没有什么意义，只是为了演示)，我们在main中创建一个对象，并调用此方法 Student student = new Student(\"小明\");student.greet(); 输出为 I'm 小明 this引用成员方法还是以上面的Student类为例，假设Student类中有一个成员方法为 public void tempt() &#123; System.out.println(\"我今晚有空哦\");&#125; 然后在greet()方法中再增加一个sayHello()，这时方法的引用指向的是tempt方法，如下 public void greet() &#123; sayHello(super::greet); sayHello(this::tempt);&#125; 现在在main方法中运行一下，输出为 I'm 小明我今晚有空哦 引用构造方法现在假设有这么一个接口 public interface Personable &#123; Person getPerson(String name);&#125; 里面只有一个抽象方法getPerson，所以这是一个函数式接口，该方法根据name返回一个Person对象，现在有一个方法需要传入这个接口得到一个Person对象 public static Person getPerson(String name, Personable personable) &#123; return personable.getPerson(name);&#125; 现在我们在main方法中调用该方法，传入的接口我们使用构造器引用Person::new Person person = getPerson(\"迪丽热巴\",Person::new);person.greet(); 运行输出为 I'm 迪丽热巴 引用数组构造方法引用数组构造方法的格式是int[]::new(这里只以int为例，当然也可以double[]::new)，具体的使用方法同上面的Person类的构造方法引用一致，这里就不多加介绍了。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"JDK 8","slug":"JDK-8","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/JDK-8/"}]},{"title":"Java多线程","date":"2019-07-12T16:00:00.000Z","path":"/Java多线程/","text":"多线程概述一个软件可以同时干多件事情，就是多线程，目前我们编写的程序都是单线程的，在main方法中从上到下的进行，执行完上面的程序才能执行后面的程序。下面就将讲解如何写多线程程序。 在Java中创建多线程有两种放法，一种是继承Thread类，然后重写它的run()方法。第二种是实现Runnable接口，并且实现run()方法。 继承Thread类继承Thread类实现多线程的步骤为 继承Thread类，重写run()方法 创建类对象，调用继承的start()方法 我们写一个MyThread类继承自Thread类，并重写run方法如下 public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"thread\" + i); &#125; &#125;&#125; 新建一个测试类，在其main方法中创建MyThread对象，并且调用对象继承自Thread的start()方法 MyThread thread = new MyThread();thread.start();for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\" + i);&#125; 程序输出为 观察到main方法中的程序和MyThread的run()方法中的程序在交替的进行。而不是在等待我执行完了，另一个在执行，而是两个在同时的执行，这就是多线程。 实现Runnable接口实现Runnable接口实现多线程的步骤为 实现Runnable接口并实现run()方法 在main中创建实现类对象 将实现类对象多为参数传入Thread()的构造方法，得到一个Thread对象 该Thread对象调用start()方法 下面进行演示，首先创建一个类实现Runnable接口 public class MyRun implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"Run\" + i); &#125; &#125;&#125; 下面在实现类中实现多线程，如下 Runnable run = new MyRun(); //创建实现类对象Thread thread = new Thread(run); //实现类对象作为参数传入Thread的构造方法thread.start(); //Thread对象调用start()方法启动线程for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\" + i);&#125; 输出为 可以观察到main中的程序和run()方法中的程序是在同时进行的。 Thread中的常见方法 getName() 获得线程的名称 currentThread() 获得正在执行的线程 setName(String str) 设置线程的名字 也可以通过new Thread(String str)设置线程的名字 sleep(long l) 线程休眠l毫秒 我们修改MyRun中的run()方法为 for (int i = 0; i &lt; 20; i++) &#123; //获得当前线程并且获得当前线程的名字 System.out.println(Thread.currentThread().getName() + i); &#125; 修改main方法为 Runnable run = new MyRun();Thread thread = new Thread(run);thread.setName(\"run\"); //增加了这一行，设置线程的名字thread.start();for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\" + i);&#125; 输出结果为 线程安全安全问题现在考虑这么一个问题，有三个售票机在售票，那么它们不能发生售出同样的票，也不能售出不存在的票。现在我要用一个类模拟售票机售票，并使用多线程模拟同时售票，新建一个SellTicket类 public class SellTicket implements Runnable&#123; private int ticket = 10; //总共10张票 @Override public void run() &#123; while (true) &#123; //表示一直售票 if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125; &#125; &#125;&#125; 在测试类的main方法中创建三个线程同时售票 Runnable sellTicket = new SellTicket();//创建三个线程 注意必须使用的同一个售票机对象 否则他们就是各自10张票而不是总共10张票new Thread(sellTicket).start();new Thread(sellTicket).start();new Thread(sellTicket).start(); 输出为 我们发现出现了不同的售票线程售出了相同的票，并且有的售票线程售出了不存在的票-1。 线程同步之所以会出现上面的问题，就是因为在有的售票机卖出了票，即进入了if语句后，但是还未进行ticket–操作，但是这个时候这个线程失去了CPU的执行权，并且别的线程拿到了CPU的执行权，由于未对ticket–，所以它们拿到的是同一张票，所以这就是为什么它们能卖出同一张票的原因。同理卖出不存在的票也是同种原因。 那么如何解决这个问题，我们必须要求在售票机在完成售票并且对ticket–之前，别的售票机不能对ticket进行操作，这样就不会出现票重复和卖出不存在的票的情况了，而实现这个的技术就叫做同步。有三种实现方式，分别是 synchronized代码块 同步方法 Lock锁 下面具体介绍用法。 sychronized代码块sychronized代码块的格式为 sychronized(锁对象) &#123; //需要同步的代码，也就是可能出现问题的代码&#125; 其中锁对象可以是任意的对象，当一个线程执行到同步代码块时，会将该锁对象交给这个线程，当这个线程执行完同步代码块时，会释放锁对象，所以如果这个线程在同步代码块内失去了CPU的执行权，因为别的线程没有锁对象，就不能进入同步代码块执行，就会进入堵塞状态，等待锁对象被释放。所以锁对象就相当于是钥匙了，要保证多个线程的锁对象要相同，这样就只有一把钥匙了。 我们重新修改SellTicket的类如下 public class SellTicket implements Runnable&#123; private int ticket = 10; //总共10张票 Object object = new Object(); //锁对象 @Override public void run() &#123; while (true) &#123; //表示一直售票 //同步代码块 一次只有一个线程执行 synchronized (object) &#123; if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125; &#125; &#125; &#125;&#125; 输出结果为 这次我们发现没有卖出重复的票，也没有卖出不可能的票。 同步方法同步方法其实就是使用synchronized修饰的方法，这个方法每次也只能有一个线程执行，它的锁对象是this，我们把上面买票的程序抽取出为一个方法sellTicket() public synchronized void sellTicket() &#123; if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125;&#125; 这时run()可简化为 @Overridepublic void run() &#123; while (true) &#123; //表示一直售票 sellTicket(); &#125;&#125; 输出为 也达到了同样的效果。 注意： 同步方法也可以为静态方法，不过这时的锁对象不在是this了，而是本类的class属性，也是一个对象。 Lock锁Lock是一个接口，它比较灵活。之前我们讲到，在线程执行到synchronized代码块时，会获得锁对象，在执行完代码块时，会释放锁对象，但是这些对我们都是不可见的，而Lock灵活在我们自己觉得在哪里加锁，哪里释放锁。它有两个方法 lock() 加锁 unlock() 释放锁 lock()一般写在同步代码前，unlock()写在同步代码后。ReentrantLock是Lock的实现类，下面我们将演示如何使用Lock锁同步，修改run方法为 Lock lock = new ReentrantLock(); //创建Lock锁实现类对象@Overridepublic void run() &#123; while (true) &#123; //表示一直售票 lock.lock(); //加锁 if (ticket &gt; 0) &#123; //如果还有票 try &#123; //为了增加出错的可能，使当前的线程休眠1ms Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票\"); ticket --; &#125; lock.unlock(); //释放锁 &#125;&#125; 输出为 可见达到了同步的效果。 等待唤醒当我们排队买奶茶时，我们对老板说我们要一杯奶茶，然后我们就等着，老板去制作奶茶，等老板制作好奶茶后去喊我们。这其实就是等待唤醒，当多个线程去操作同一个资源时，比如奶茶，就需要一方(顾客)等着，等待另一方(老板)唤醒，总不能奶茶没有好我去抢吧。 线程状态在讲解等待唤醒之前，我们先对线程的状态有一个大致的了解，看图 当我们创建一个线程对象还没有start()时，这时它处于New状态；当我们执行start()方法后，这时的线程状态由New转向Runnable运行状态；如果执行完run()方法，或者调用了stop()方法或者抛出了异常那么该线程进入死亡状态。如果在Runnable状态失去了CPU的执行权，那么就会进入Blocked阻塞状态；线程在这里等待CPU的执行权，拿到了CPU的执行权就会从该状态来到Runnable状态；如果线程在运行时执行了sleep(l)或wait(l)(l为等待的时间)方法，那么就会由Runnable状态进入Timed waiting状态，在这个状态中，线程放弃争夺CPU的执行权，当等待的时间到了之后，如果CPU空闲，那么就进入Runnable状态，如果忙碌，那么就进入Blocked状态，与其他线程一起争夺CPU的执行权。如果在Runnable执行了wait()(不带参数的)方法，就会进入Waiting永久等待状态，直到锁对象执行notify()方法唤醒，如果CPU空闲，就进入Runnable状态，否则进入Blocked状态争夺CPU执行权。 等待唤醒这里的等待唤醒指的就是上面提及的Runnable状态执行wait()方法到Waiting永久等待状态，以及执行notiify()方法有永久等待状态到Runnable状态。前者为等待，后者为唤醒。 注意： 只有锁对象才能调用wait()和notify()方法 wait()和notify()的调用者应该是同一锁对象，并且必须写在同步代码块中 执行wait()被唤醒后，会继续执行wait()后面的代码 notify()一次只能唤醒一个线程，唤醒的是睡眠最久的线程，notifyAll()能够唤醒所有的线程 下面以最先提及的买奶茶为例演示这一过程。首先创建Runnable顾客类和老板类和奶茶类 public class MilkTea &#123; String taste; //奶茶口味 boolean flag = false; //奶茶有没有做好&#125; public class CustomerThread implements Runnable &#123; private MilkTea milkTea; //作为锁对象 public CustomerThread(MilkTea milkTea) &#123; this.milkTea = milkTea; &#125; @Override public void run() &#123; while (true) &#123; synchronized (milkTea) &#123; if (milkTea.flag == false) &#123; //奶茶没有准备好 System.out.println(\"老板来杯珍珠奶茶\"); try &#123; milkTea.wait(); //等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(milkTea.taste + \"真好喝\"); //被唤醒后会执行这个 milkTea.flag = false; //奶茶喝完了 milkTea.notify(); &#125; &#125; &#125;&#125; public class Shopper implements Runnable &#123; private MilkTea milkTea; //作为锁对象 和Customer相同 public Shopper(MilkTea milkTea) &#123; this.milkTea = milkTea; &#125; @Override public void run() &#123; while (true) &#123; synchronized (milkTea) &#123; if (milkTea.flag == true) &#123; try &#123; milkTea.wait(); //等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; try &#123; System.out.println(\"做奶茶中 ...\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; milkTea.taste = \"珍珠奶茶\"; milkTea.flag = true; System.out.println(milkTea.taste + \"做好了\"); milkTea.notify(); &#125; &#125; &#125; &#125;&#125; 下面在测试类中创建两个线程 public class Test &#123; public static void main(String[] args) &#123; MilkTea milkTea = new MilkTea(); //作为锁对象 new Thread(new CustomerThread(milkTea)).start(); new Thread(new Shopper(milkTea)).start(); &#125;&#125; 输出为 这就是等待唤醒的过程。 线程池当我们需要一个新的线程执行任务，我们就会创建一个新的线程，但是如果这个线程执行的任务很少，并且我们需要频繁的创建线程，这个创建线程的过程会很耗费时间，所以我们就想有没有一个机制，我们不用创建线程，当我们需要线程时我们去取，当我们用完时，我们还给它。这样就不需要频繁创建线程，省去时间，提高效率。线程池可以帮我们实现这一个想法。 那接下来的问题我们怎么使用Java为我们准备的线程池，Executors提供了一个静态方法newFixedThreadPool(int nThreads)，这个方法接收的参数是线程池中线程的个数，返回一个ExecutorService对象，然后我们就可以使用该对象的submit(Runnable task)方法，传入一个Runnable实现类对象就可以了。下面我们来示例一番 import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPool &#123; public static void main(String[] args) &#123; //创建一个匿名内部类 Runnable run = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125; &#125;; //长度有三个线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); //三个线程执行任务 threadPool.submit(run); threadPool.submit(run); threadPool.submit(run); &#125;&#125; 输出为 pool-1-thread-1 0pool-1-thread-2 0pool-1-thread-1 1pool-1-thread-2 1pool-1-thread-1 2pool-1-thread-3 0pool-1-thread-2 2pool-1-thread-3 1pool-1-thread-1 3pool-1-thread-3 2pool-1-thread-2 3pool-1-thread-3 3pool-1-thread-1 4pool-1-thread-3 4pool-1-thread-2 4 Lambda表达式我们在创建一个线程时，我们一般需要做一下的步骤 创建一实现类实现Runnable接口 重写run方法 创建实现类对象 将该对象传入Thread的构造方法中 上面的写法可以简化，省去创建一个实现类，直接创建一个匿名内部类 创建一个Runnable匿名内部类 重写run方法 将该对象传入Thread的构造方法中 其实上面有很多的代码是多余，真正有用的代码就是run()方法里面的代码，但是为了创建一个线程我们不得不要创建一个对象，然后巴拉巴拉。其实有时候我们不关心谁来做，只需要告诉我怎么做，比如一个线程你只需要告诉我run()方法就可以了，告诉我怎么做就可以了，但是我们却要创建一个对象等等一系列的操作才能达到这个目的。 Lambda的使用Java在JDK 1.8中引入了Lambda表达式，可以极大简化我们的编程，可以做到我上面所说的只关心怎么做的问题，不需要创建对象。我们来看看下面这段代码用Lambda怎么写 new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;&#125;).start(); Lambda的写法为 new Thread(() -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;); 现在你可能没有看懂这个写法，下面让我为你解释一番。首先我们注意到 new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;&#125; 被简单的替换为了 () -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125; 两段代码很像，但是Lambda省略了很多的东西。首先我们知道Thread()里面传的是一个Runnable实现类的对象，该类重写类run方法，真正有用的就是run方法，所以我们把这些全部省略了，直接传入一个run()就可以了，并且由于run()方法的方法名是确定的，我们连run方法名都可以省去，返回值类型也是确定，所以我们也可以省去，最后只剩一个参数列表，在参数列表与方法体之间加入-&gt;就是Lambda表达式。使用Lambda不用创建对象，我们只需要传入一个方法，告诉它怎么做就可以了。这个也叫做函数式编程。 Lambda表达式的格式为 (参数列表) -&gt; &#123; //方法体&#125; 为了熟悉Lambda表达式的使用，我们来看一个例子，定义一个Calculator的接口，里面有一个方法叫calculate(int a, int b);，如下 public interface Calculator &#123; int calculate(int a, int b);&#125; 在测试类中定义一个方法，该方法需要Calculator接口作为参数 public static int cal(int a, int b, Calculator calculator) &#123; int result = calculator.calculate(a,b); return result;&#125; 这个方法表示的是，a,b经过Calculator计算之后得到一个数，而计算方法，根据我们传入的calculator而定，这明显是我们只需要告诉计算器怎么做就行，我们把做的方法告诉它，使用Lambda表达式 //加法计算器int result1 = cal(2,3, (int a, int b) -&gt; &#123; return a + b;&#125;);System.out.println(result1);//减法计算器int result2 = cal(2,3, (int a, int b) -&gt; &#123; return a - b;&#125;);System.out.println(result2); 输出为 5-1 根据我们传入的方法不同，这个计算器就不同，计算器关心的就是怎么做，你告诉怎么做就可以。 Lambda的省略格式其实上面的Lambda还可以进行化简，因为还有很多是可以推断出来的，比如参数列表里面的参数类型可以省略，因为这个参数类型时确定的，不可能会变的。如 int result1 = cal(2,3, (a, b) -&gt; &#123; return a + b;&#125;); 如果方法体里面只有一条语句时，那么花括号也可以省略，这时分号也可以省略，如果这条语句是return语句，那么return也可以省略，因为必须是要返回一个值的，这个可以推断出来，所以可以省略，所以上面又可以简写为 int result1 = cal(2,3, (a, b) -&gt; a + b); 如果参数列表里面只有一个参数的话，那么小括号也可以省略 param -&gt; &#123; //方法体&#125; Lambda表达式的使用前提虽然Lambda表达式这么好用，但是是有使用前提的 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 比如Runnable接口，里面只有一个run()方法是抽象方法 比如上面定义的Calculator接口，里面也只有一个抽象方法calculate() 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 不能是我要一个Calculator接口的calculate()方法，你给我传一个Runnable的run()方法，兄弟，暗号对不上啊。 备注：有且仅有一个抽象方法的接口，称为”函数式接口“。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java常用API","date":"2019-07-11T16:00:00.000Z","path":"/Java常用API/","text":"API全称叫做Application Programming Interface，翻译成应用程序编程接口，其实你把它看做是Java的使用说明书进行，它告诉你Java有哪些类，有哪些方法，你直接用就可以，相当于给你一个插座(接口)，你用的时候插上去就行。 Scanner我们之前做的都是从屏幕输出，现在将介绍如何获取从键盘输入。Scanner类是系统提供的一个类，它可以帮助我们从键盘获取输入。一般使用系统提供的类分为三部分 导包 创建对象 使用 导包语句放在package之后，放在public class之前，如果使用的类与当前类属于同一个包，那么不用导入，如果要使用的类在java.lang包下，也不需要导入。导包的格式为 import 包名.类名; //导入指定包下面的类import 包名.*; //导入指定包下的所有类 Scanner类位于java.util包下，所以我们需要导入，下面介绍如何使用Scanner类 import java.util.Scanner; //1. 导包public class TestScanner &#123; public static void main(String[] args) &#123; //2. 创建一个Scanner对象 //Scanner的构造方法需要传入参数，这里传入的是System.in，代表的是从键盘输入 Scanner sc = new Scanner(System.in); //3. 使用 int num = sc.nextInt(); //获得从键盘输入的一个整数 String str = sc.next(); //获得从键盘输入的一个字符串 //打印输入的结果 System.out.println(num); System.out.println(str); &#125;&#125; 程序运行效果为： 注意： 其实从键盘输入全部都是字符串，即使你输入的是65这里的整数，系统得到的只是对于的ASCII码值，而nextInt()方法之所以能获得整数，是因为nextInt()方法做了处理，将字符串转化为了整数。 next()方法只能获得一个字符串，如输入的是Hello World，它只能得到Hello。 RandomRandom类的作用主要是用于产生随机数的，它位于java.util包下面。下面介绍它的两个主要的方法 nextInt()：产生一个随机整数，范围时整个int的大小 nextInt(int n)：产生一个[0,n)的整数，左闭右开。 下面将介绍Random的使用。下面这个程序将产生10个随机整数，范围为整个int整数的范围 import java.util.Random;public class TestRandom &#123; public static void main(String[] args) &#123; Random r = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt()); &#125; &#125;&#125; 程序输出为 可见产生的整数是随机的，并且范围时整个int的范围，正值和负值都有。 下面这个程序将产生10范围为1-10的随机整数 import java.util.Random;public class TestRandomAgain &#123; public static void main(String[] args) &#123; Random r = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt(10) + 1); //nextInt(10)的范围为0-9，+1变为1-10 &#125; &#125;&#125; 程序输出为 输出的数字的范围在1-10之间，并且输出的数字是随机的。 StringString这个类是我们最常用的一个类了，因为我们会牵涉到很多的字符串的操作，所以这里要详细讲一下String类。 String类的定义String类位于java.lang包中，我们在之前讲过，java.lang是默认导入的，所以我们不需要导入这个包，这也是为什么在之前我们可以直接的使用String这个类。字符串效果上相当于是一个字节数组。 String作为引用类型，所以String对象的创建当然要借助于构造方法了，String的构造方法有很多，这里只讲常见的三种String构造方法。 public String() 创建一个空字符串 public String(char[] array) 根据一个字符数组来创建一个字符串 public String(byte[] array) 根据一个字节数组来创建一个字符串 下面我将演示通过这三种方法创建字符串对象。 public class TestString &#123; public static void main(String[] args) &#123; String str1 = new String(); //\"\" char[] chars = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars); //\"abc\" byte[] bytes = &#123;97, 98, 99&#125;; String str3 = new String(bytes); //\"abc\" System.out.println(str1); System.out.println(str2); System.out.println(str3); &#125;&#125; 输出为 abcabc 因为字符串是在是太常用，通过构造方法创建有点麻烦，所以系统设计出可以通过&quot;&quot;的字面量的形式来创建一个String对象，这也是我们经常使用的方式 String str = \"abc\"; 注意： Java程序中所有字符串的字面值（&quot;&quot;）都是String类的实例 字符串一旦创建不可改变 常量池我们知道可以通过字面量（&quot;&quot;）的形式来创建字符串对象，这样创建对象与使用构造方法创建的对象有什么不同呢? 下面我们来看一个字符串比较的例子 public class ConstantString &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; String str3 = new String(new char[]&#123;'a','b','c'&#125;); String str4 = new String(new byte[]&#123;97, 98, 99&#125;); System.out.println(str1); System.out.println(str2); System.out.println(str3); System.out.println(str4); &#125;&#125; 输出为 abcabcabcabc 在这里我们创建了四个字符串，他们的内容都是”abc”，现在我要对它们进行比较 System.out.println(str1 == str2);System.out.println(str1 == str3);System.out.println(str1 == str4);System.out.println(str3 == str4); 输出结果为 truefalsefalsefalse 这里得到的结果可能与你想象的不一样，所以我要详细讲一下。 首先==比较符比较的是什么？由于字符串都是引用类型，所以这里比较的是它们的地址，那按道理说，每创建一个对象，会在堆中开辟一个空间，每个空间的地址都不一样，那么它们比较的值应该都是false，那么为什么通过字面量创建的字符串对象比较出来的结果是true呢？ 要解释这一个现象，就需要知道一个东西，那就是常量池。程序中直接用双引号写上的（即通过字面量创建的字符串），都在常量池中，而new出来的对象不再常量池中。现在记住这一句话，我们去内存看看到底怎么回事，由于这次不牵涉到方法区，我们只画出栈内存和堆内存。 字符串的相关方法字符串比较之前我们说==比较是基于地址的比较，但是我们如果基于内容比较怎么办？比如说上面的字符串如果进行比较的话，就会返回true。有两个方法，第一个是equals()方法，该方法其实也是基于==比较的，不过String类重写了该方法，只要两个字符串的内容相同就会返回true。这里又提到了重写，不懂没关系，只要知道，字符串调用这个方法是基于内容的比较，而不是基于地址的比较，下面演示一番。 public class CompareString &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; String str3 = new String(new char[]&#123;'a','b','c'&#125;); String str4 = new String(new byte[]&#123;97, 98, 99&#125;); System.out.println(str1.equals(str2)); System.out.println(str1.equals(str3)); System.out.println(str1.equals(str4)); System.out.println(str3.equals(str4)); &#125;&#125; 输出为 truetruetruetrue 注意： equals()方法具有对称性 如果比较的双方一个是常量，一个是变量，推荐使用常量调用方法 针对第二条的原因是，如果变量str未被初始化，那么它的初始值是null，null根本没有equals方法，所以调用该方法会报错 String str; //str = nullstr.equals(\"abc\"); //会报错\"abc\".equals(str); //不会报错，会返回false 字符串比较的第二个方法是equalsIgnoreCase()，该方法与equals不同的是，该方法的比较忽略大小写，而equals()是大小写敏感的。 System.out.println(\"hello\".equalsIgnoreCase(\"Hello\")); 输出为 true 字符串截取与字符串截取有关的方法是substring()，该方法有两种常用的重载 substring(int index) 从index截取到末尾 substring(int begin, int end) 从begin截取到end，左闭右开[begin, end) 字符串转换介绍三个方法 toCharArray() 将字符串转换为char[] getBytes() 将字符串转换为byte[] replace(CharSequence oldString, CharSequence newString) 这里的CharSequence是接口，这里不懂也没关系，知道这个可以接收字符串类型就可以 这个方法的作用是新的字符串替换旧的字符串 字符串分割与字符串分割的方法只有一个 split(String regex) 按照regex的规则分割字符串，返回一个字符串数组 按照regex的规则分割字符串可能有点难以理解，其实这里的regex是正则表达式，不懂的话看懂下面的例子就可以 public class SplitString &#123; public static void main(String[] args) &#123; String str = \"a,b,c\"; String[] strings = str.split(\",\"); //按照逗号的分割字符串，得到的是[\"a\",\"b\",\"c\"] for (int i = 0; i &lt; strings.length; i++) &#123; System.out.println(strings[i]); &#125; &#125;&#125; 输出为 abc 注意： 如果要按”.”规则分割的话，不能写”.”，要写成”\\.”，因为.在正则表达式中有特殊的含义，所以需要转义。 ArraysArrays位于java.util包中。这个类提供了很多的静态方法，实现数组的常见操作。在这里我们介绍两个常用的方法 toString 接收一个数组参数 将参数数组变成字符串 [元素1，元素2， …] sort 按默认升序（从小到大）对数组进行排序 对于String，按字母在Unicode表中的大小排序 对于自定义的类型，需要Comparable或Comparator接口的支持 下面演示两个方法的使用 import java.util.Arrays;public class TestArrays &#123; public static void main(String[] args) &#123; //创建一个整型数组 int[] arrays = &#123;5, 8, 4, 12, 3, 7&#125;; //调用Arrays.toString() 我们不用遍历数组打印了 System.out.println(Arrays.toString(arrays)); //对数组进行排序 这里不是返回一个新的数组 而是对原有数组进行排序 Arrays.sort(arrays); //将排序后的数组打印出来 System.out.println(Arrays.toString(arrays)); &#125;&#125; 输出为 [5, 8, 4, 12, 3, 7][3, 4, 5, 7, 8, 12] MathMath类位于java.util包中，该类包含了很多与数学计算相关的静态方法。这里介绍几个与整数操作有关的方法 abs() 取绝对值 abs(-2) = 2 ceil() 向上取整 ceil(2.1) = 3，ceil(-2.1) = -2 floor() 向下取整 ·floor(2.1) = 2，floor(-2.1) = -3 round() 四舍五入 round(2.1) = 2，round(-2.1) = -2 当然Math类还包含很多的方法，具体的可以查阅资料。 ObjectObject类是所有类的父类，所有类都默认继承了（直接或间接）Object类。所以所有的类都默认有Object类中的成员方法。这里介绍两个比较重要的Object类的成员方法 toString() equals(Object object) toString我们在之前一直有用System.out.println()语句打印信息到控制台，当我们传入一个引用类型变量的时候，它会调用该对象的toString()方法，由于Object类的toString方法是默认打印堆内存的地址值，所以这也是为什么我们在打印数组时，打印出的是地址值。而我们打印String类型时，打印出的却是它的内容，这时因为String重写toString()方法。 为了验证我们的猜想，我们看下面这么一个类 public class Person &#123;&#125; 我们现在创建一个Person对象，并且打印出来，然后调用toString()方法，在打印一遍 public class TestToString &#123; public static void main(String[] args) &#123; Person per = new Person(); System.out.println(per); System.out.println(per.toString()); &#125;&#125; 输出为 Person@4554617cPerson@4554617c 我们发现结果是一样的，现在我们在Person类中重写toString()方法 public class Person &#123; @Override public String toString() &#123; return \"I'm a Person object\"; &#125;&#125; 在运行一遍，输出为 I'm a Person objectI'm a Person object equals在前面我们比较字符串时，我们说==是对象的地址值进行比较，而equals方法是基于内容的比较。事实上，Object类的equals方法也是进行对象地址值的比较，只不过是String类重写了equals方法。 我们可以通过重写equals方法来设置怎样两个对象才是相等的。比如还是以Person类进行举例，它有姓名和年龄两个成员变量，我们认为如果两个人的姓名和年龄都是一样的，那么我们就认为这两个人的对象是相同的 public class Person &#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object obj) &#123; //因为要使用Person对象的name和age属性，所以要向下转型 if (obj instanceof Person) &#123; Person person = (Person) obj; //如果姓名和年龄相同，就认为对象是相同的 if (this.name == person.name &amp;&amp; this.age == person.age) &#123; return true; &#125; &#125; return false; &#125;&#125; 现在我们在测试类类中测试一下 public class TestEquals &#123; public static void main(String[] args) &#123; Person person1 = new Person(\"迪丽热巴\",20); Person person2 = new Person(\"古力娜扎\",28); Person person3 = new Person(\"迪丽热巴\",20); System.out.println(person1.equals(person2)); //年龄和姓名不一样，返回false System.out.println(person1.equals(person3)); //名字和年龄一样，返回true System.out.println(person1 == person3); //地址值是不同的，所以是false &#125;&#125; 输出为 falsetruefalse DateDate是有关于日期的类，它位于java.util包中。现在主要介绍它的两种常用的构造方法，以及一个有关于格式化输出的类SimpleDateFormat。 构造方法Date date = new Date(); //默认得到的是当前时间的日期Date date = new Date(long l); //接收一个毫秒值，该毫秒值代表的是距离时间原点消耗的毫秒值 时间原点规定为1970年1月1日的00:00:00时刻。现在简单演示Date类的使用 import java.util.Date;public class TestDate &#123; public static void main(String[] args) throws ParseException &#123; Date date = new Date(); System.out.println(date); &#125;&#125; 输出为 Sat Jul 20 19:26:26 CST 2019 可见Date类重写了toString()方法。 Date类有一个getTime的方法，它可以获得该date对象对应的毫秒值，现在我们通过这个方法获得一个毫秒值，然后利用该毫秒值作为第二个构造函数的参数 import java.util.Date;public class TestDate &#123; public static void main(String[] args) throws ParseException &#123; Date date = new Date(); System.out.println(date); long ms = date.getTime(); Date date2 = new Date(ms); System.out.println(date2); &#125;&#125; 输出为 Sat Jul 20 19:29:24 CST 2019Sat Jul 20 19:29:24 CST 2019 SimpleDateFormat上面的时间输出其实不符合我们的使用习惯，所以我们可以让输出的日期符合我们的使用习惯。DateFormat这个类是为此而存在的，不过它是一个抽象类，SimpleDateFormat类继承了该类，我们可以使用该类格式化日期输出。 首先就是如何创建一个对象，如下 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(模式); 可能这里还不能理解模式是个什么鬼，那么就要看下面这个例子 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日\"); “yyyy年MM月dd日”就是模式，差不多就是模板吧，也就是你想要格式化输出的格式，其中yyyy代表年，MM代表月，dd代表日，HH代表小时，mm代表分，ss代表秒。 这里主要介绍它的两个方法 format 接收一个日期对象，返回一个字符串，这个字符串的格式与你上面定义的模式相同 parse 接收一个字符串，这个字符串的格式必须与你定义的模式相同，否则会报错 方法一个Date对象 parse方法会抛出一个异常，对于抛出异常的方法，要么继续抛出异常，要么使用try-catch处理 下面介绍这个类的使用 import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDate &#123; public static void main(String[] args) throws ParseException &#123; //parse方法有可能抛出这个异常，这里我们不处理，继续抛出 Date date = new Date(); //创建一个Date对象作为后面format方法的参数 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); //定义输出格式 String formatDate = simpleDateFormat.format(date); //获得由date转化得到的格式化输出字符串 System.out.println(formatDate); Date dateAgain = simpleDateFormat.parse(\"2017年5月13日 15:23:14\"); //根据指定的格式解析出一个Date对象 System.out.println(dateAgain); //打印该Date对象 &#125;&#125; 输出为 2019年07月20日 19:43:18Sat May 13 15:23:14 CST 2017 CalendarCalendar是一个有关于日期的类，它提供了一些操作日历的方法，它是一个抽象类，所以不能创建Calendar对象，我们可以通过它的静态方法getInstance()得到它的一个子类对象，如下 Calendar calendar = Calendar.getInstance(); 这里仅简单介绍它的四个方法 get(int field) 根据指定field值获取日历信息，field值一般为Calendar类的静态常量，如get(Calendar.YEAR)可以获得有关于年份的信息 set(int field, int value) 设置指定的field为指定的value add(int field, int amount) 为指定field加上amount 这里需要注意的是，如果加上数值之后超过范围之后，会有进位。比如现在为7月，我给MONTH加上了10，那么现在年份会加1年，并且此时的月份为7 + 10 -12 = 5。 getTime() 返回当前日历对应得Date对象 下面简单演示方法的使用 import java.util.Calendar;import java.util.Date;public class TestCalendar &#123; public static void main(String[] args) &#123; Calendar calendar = Calendar.getInstance(); System.out.println(calendar); //打印出的不是地址，可见Calendar也重写了toString()方法 System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); //西方的月份是从0开始的，所以这里我加1 System.out.println(calendar.get(Calendar.DATE)); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); //与上面DATE的效果是一样的 System.out.println(calendar.get(Calendar.HOUR)); System.out.println(calendar.get(Calendar.MINUTE)); System.out.println(calendar.get(Calendar.SECOND)); System.out.println(\"=============\"); calendar.set(Calendar.YEAR, 2020); //设置年份为2020年 System.out.println(calendar.get(Calendar.YEAR)); calendar.add(Calendar.MONTH,10); //给月份加10个月，现在为2021年5月了 System.out.println(calendar.get(Calendar.MONTH) + 1); Date dateAgain = calendar.getTime(); //得到一个日期对象 System.out.println(dateAgain); &#125;&#125; 输出为 java.util.GregorianCalendar[time=1563623852127,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2019,MONTH=6,WEEK_OF_YEAR=29,WEEK_OF_MONTH=3,DAY_OF_MONTH=20,DAY_OF_YEAR=201,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=3,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,MINUTE=57,SECOND=32,MILLISECOND=127,ZONE_OFFSET=28800000,DST_OFFSET=0]20197202075732=============20205Thu May 20 19:57:32 CST 2021 SystemSystem是有关于系统的类，这里不会介绍那么高深的内容，主要介绍两个静态方法 currentTimeMillis() 获得当前系统距时间原点的毫秒值 这个方法可以用来计算程序损耗的实践 在程序开始执行前获取一个时间，在程序执行完成获取一个时间，两个时间相减就可以知道程序执行的时间，就可以知道程序的哪一部分最耗时，从而做出优化 arraycopy() 该方法的作用是将源数组从指定位置开始复制，有一个参数规定了复制的长度，复制到另一个数组，这个数组也规定了起始的位置 该方法接收五个参数 第一个参数是一个源数组src，第二个参数是源数组的起始位置，第三个参数是目的数组，第四个参数是目的数组的起始位置，第五个参数是复制的长度 如果你在这里没有理解，请看下面的例子 下面简单演示这两个方法的使用 import java.util.Arrays;public class TestSystem &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //循环执行前获取一次时间 int sum = 0; for (int i = 0; i &lt; 10000000; i++) &#123; //1000万次 sum = sum + i; &#125; long end = System.currentTimeMillis(); //循环结束后获取一次时间 double time = (end - start) / 1000.0; //将单位转化为s System.out.println(\"共花费\" + time + \"s\"); //我们将源数组的前三个元素替换目的数组的前三个元素 int[] array1 = &#123;1, 2, 3, 4, 5&#125;; //源数组 int[] array2 = &#123;6, 7, 8, 9, 10&#125;; //目的数组 System.out.println(\"转换前\"); System.out.println(Arrays.toString(array1)); System.out.println(Arrays.toString(array2)); System.arraycopy(array1, 0, array2, 0, 3); //前三个元素，所以都是从索引0开始 System.out.println(\"转换后\"); System.out.println(Arrays.toString(array1)); System.out.println(Arrays.toString(array2)); &#125;&#125; 输出为 共花费0.011s转换前[1, 2, 3, 4, 5][6, 7, 8, 9, 10]转换后[1, 2, 3, 4, 5][1, 2, 3, 9, 10] 可见程序是执行的相当的快。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java集合与泛型","date":"2019-07-07T16:00:00.000Z","path":"/Java集合与泛型/","text":"CollectionCollection是集合的意思，你可以把它看做一种装东西的容器，就像数组一样。它是一个接口，有很多的类实现了它，比如Arralist，LinkedList，HashMap，等等很多。不同的类使用不同的方法去实现，所以他们之间的某些性能是不同的。 Collection中的方法我们这次学习的是Collection接口中的方法，虽然实现它的类很多，但是它们实现的方法的功能都是一样。这里介绍七个方法 add(E e) 添加元素 clear() 清空集合中的所有元素 remove(E e) 删除元素 contains(E e) 查看是否包含某个元素 isEmpty() 查看数组是否为空 size() 返回集合的长度，即元素的个数 toArray 返回一个Onject类型的数组 下面我们以ArrayList为例来学习上面的方法 import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;public class TestCollection &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); //多态写法 //测试add collection.add(\"张无忌\"); collection.add(\"令狐冲\"); collection.add(\"郭靖\"); collection.add(\"杨过\"); System.out.println(collection); //测试contains System.out.println(collection.contains(\"杨过\")); //测试size System.out.println(collection.size()); //测试remove collection.remove(\"杨过\"); System.out.println(collection); //测试toArray Object[] objects = collection.toArray(); System.out.println(Arrays.toString(objects)); //测试clear collection.clear(); System.out.println(collection); System.out.println(collection.size()); &#125;&#125; 我们注意到我们创建Collection对象时，与一般类相比创建多了&lt;&gt;，这个叫做泛型。是什么意思呢? 我们定义数组的话有不同的数据类型，来定义保存什么类型的数据，同样的Collection也有不同的数据类型，来决定里面保存的是什么类型的数据。而数据类型就是写在里面，目前我们就这么理解泛型，有关泛型更加详细的用法，下面会进行介绍。在=号的右边也有&lt;&gt;号，从JDK 1.7开始，右边的&lt;&gt;里面可以什么都不写，之前里面也要写数据类型，但是和右边的一样，所以没必要在写一遍。另一个需要注意的是，泛型（也就是&lt;&gt;里面的数据类型）必须是引用类型，不能是基本类型。 输出为 [张无忌, 令狐冲, 郭靖, 杨过]true4[张无忌, 令狐冲, 郭靖][张无忌, 令狐冲, 郭靖][]0 Iterator我们对集合一个重要的操作就是对集合进行遍历，不同于数组，集合不是所有的都是有序的，所以无法通过索引对集合进行遍历，那我们就只能通过迭代器Iterator来遍历集合，Iterator也是一个接口，集合有一个iterator()方法，可以获取迭代器实现类的对象。迭代器主要有两个方法 hasNext() 判断集合中是否还有下一个元素，有则返回true next() 取出集合中的下一个元素，如何集合中没有元素，使用该方法会抛出异常，所以应该先进行判断是否还有下一个元素 下面我们来示例使用方法 import java.util.Collection;import java.util.HashSet;public class TestIterator &#123; public static void main(String[] args) &#123; //HashSet是一个无序的集合 Collection&lt;String&gt; collection = new HashSet&lt;&gt;(); collection.add(\"亚瑟\"); collection.add(\"妲己\"); collection.add(\"安其拉\"); collection.add(\"狄仁杰\"); collection.add(\"李白\"); System.out.println(collection); &#125;&#125; 输出为 [李白, 妲己, 狄仁杰, 亚瑟, 安其拉] 可见HashSet是一个无序的集合，所以不能通过索引去获取集合中的元素，我们使用迭代器去遍历集合中的元素 Iterator&lt;String&gt; iterator = collection.iterator(); //由集合的iterator()方法创建迭代器while (iterator.hasNext()) &#123; //判断集合中是否还有下一个元素 String string = iterator.next(); //取出下一个元素，每取出一个元素，指针向后移动 System.out.println(string);&#125; 输出为 李白妲己狄仁杰亚瑟安其拉 foreach循环我们知道不能通过一般的for循环去遍历集合，所以Java中有一个增强的for循环，利用它可以遍历集合和数组，它的实现原理就是迭代器的原理，不过使用的是for循环的形式，我们把它叫做foreach循环，格式如下 for (元素类型 变量名 : 集合) 它会自动的取出集合中的元素，并且赋值给变量，然后你就可以在foreach循环中对取出的元素进行操作了，还是以上面的集合为例，演示如何使用foreach循环 for (String string : collection) &#123; System.out.println(string);&#125; 输出为 李白妲己狄仁杰亚瑟安其拉 泛型概述泛型我们之前在使用Collection集合时就已经接触过，那么为什么会使用泛型，比如你正在写一个集合给别人使用，但是你不知道别人会保存什么数据类型，你不能写死了说只能保存String类型，这个时候我就会使用泛型，保存什么类型的数据由别人自己觉得，就像数组一样。 如果省略泛型的话，那么默认为Object类型，比如下面我创建一个ArrayList集合，没有写泛型 import java.util.ArrayList;public class GenericsDemo &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(\"AA\"); list.add(2); list.add('c'); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 输出为 AA2c 这个时候ArrayList集合的对象能够添加任何的数据类型，因为所有的类都继承了Object类，而基本数据类型会进行自动装箱操作转化为对应的包装类。其实上面就是多态的写法，而多态的写法我们也知道它的弊端，他不能调用子类特有的方法，如果我们需要调用子类的方法的话就需要向下转型，这很容易发生异常，并且在编译时不会报错。并且一般我们在集合保存相同的数据类型，所以这个时候我们可以使用泛型。使用泛型的话至少有这两个优点 避免了类型转换的麻烦 编译时就可以看到错误 如果一个String的ArrayList添加Integer数据，那么编译时就会报错 泛型的定义类泛型定义在类中的格式应该如下 public class ClassName&lt;E&gt; &#123; &#125; 其中E就代表泛型，它会在创建对象的时候确定E是什么类型，比如ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();，那么这个时候E就是String。这么定义以后，我们就可以在类中的方法中使用E，如 public void method(E e) &#123; &#125; public E method() &#123; &#125; 可以让它作为方法的参数和返回值，如果在创建对象的时候传入的E是String，那么这些方法的参数或者返回全部都是String类型的。我们可以看做E是一个接收类类型的变量。 方法方法中定义泛型，格式如下 修饰符 &lt;泛型&gt; 返回值 方法名(参数列表) &#123; &#125; 比如下面这么定义 public &lt;M&gt; void method (M m) &#123; &#125; 泛型会在调用方法时确定，比如传入的是一个String类型的参数，那么M就是String。 接口在接口中定义的格式如下 public interface InterfaceName&lt;E&gt; &#123; &#125; 实现类实现接口可以指定泛型是什么或者不指定，就是这个意思 指定 实现类 implements InterfaceName&lt;String&gt; &#123; &#125; 不指定 实现类&lt;E&gt; implements InterfaceName&lt;E&gt; 通配符假设我要写一个方法，输入一个ArrayList对象，要求打印输入列表的所有元素，但是ArrayList是什么类型的不知道，所以方法参数类型不能写死，不能这么写 public void method(ArrayList&lt;String&gt; list) &#123; &#125; 但是我们在上面学了方法的泛型，所以我们可以这么写 public &lt;E&gt; void method(ArrayList&lt;E&gt; list) &#123; &#125; Java停供了一种更加方面的写法，即使用通配符 public void show(ArrayList&lt;?&gt; list) &#123; &#125; 其中?代表的就是通配符，指的就是能够匹配任何的数据类型。 不仅如此我们还能够对通配符进行限定，如 ? extends E 说明参数的类型必须是E的子类或者E本身 ? super E 说明参数的类型必须是E的父类或者E本身 比如下面 import java.util.ArrayList;public class TestTongpeifu &#123; //接收的类型必须为Number类的子类或者Number类本身 public static void show(ArrayList&lt;? extends Number&gt; list) &#123; System.out.println(list); &#125; //接收的类型必须为Number类的父类或者Number类本身 public static void show2(ArrayList&lt;? super Number&gt; list) &#123; System.out.println(list); &#125; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;Object&gt; list3 = new ArrayList&lt;&gt;(); ArrayList&lt;Number&gt; list4 = new ArrayList&lt;&gt;(); show(list1); //Interger是Number的子类，可以 show(list2); //String类与Number类没有关系，报错 show(list3); //Object不是Number的子类，报错 show(list4); //Number本身，可以 show2(list1); //Interger是子类，报错 show2(list2); //String没关系，报错 show2(list3); //Object是父类，可以 show2(list4); //Number本身，可以 &#125;&#125; 与我们分析的一致。 ListList接口是Collection的子接口，实现它的类有ArrayList和LinkedList，ArrayList的底层实现原理是数组，所以它的查询速度快，但是它的增删操作很慢，LinkedList的底层实现原理是链表，所以它的查询操作很慢，它的增删操作很快。 List集合的特点List接口的特点有 有序，所以可以通过索引访问元素 集合中的元素允许重复 因为List接口可以有索引，所以除了Collection中的方法，List还有其特有的方法如下 add(int index, E e) 在指定索引中的位置添加元素，后面的元素向后推移 remove(int index) 删除指定索引的元素，并且返回删除的元素 get(int index) 获得指定索引处的元素 set(int index, E e) 将索引处为元素替换为e 下面示例上面的四个方法 import java.util.ArrayList;import java.util.List;public class TestList &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(5); list.add(7); System.out.println(list); //[1, 5, 7] //add(int index, E e) list.add(2,8); //在索引为2的地方插入8 System.out.println(list); //[1, 5, 8, 7] //get(int index) int num1 = list.get(1); //获得索引为1的元素 System.out.println(num1); //5 //set(int index, E e) list.set(0, 4); //设置索引为0的元素为4 System.out.println(list); //[4, 5, 8, 7] int num2 = list.remove(2); //删除索引为2的元素 System.out.println(list); //[4, 5, 7] &#125;&#125; List的遍历因为List集合是有序的，所以有三种方法可以进行遍历 普通for循环 迭代器 增强for循环 下面进行示例 //普通for写法for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i));&#125;//迭代器写法Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; Integer i = iterator.next(); System.out.println(i);&#125;//增强for写法for (Integer i : list) &#123; System.out.println(i);&#125; ArrayListArrayList在之前我们讲解Collection时就有接触到，所以这里就简单的介绍它。ArrayList集合的使用非常的简单，在上面已经演示过了，并且它的方法都是实现List里面的方法，而这些方法的使用在上面已经了解了，下面看看ArrayList简单例子即可。 import java.util.ArrayList;public class TestArrayList &#123; public static void main(String[] args) &#123; //创建一个ArrayList对象 里面保存的都是String类型 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //向列表中添加三个元素 list.add(\"张三\"); list.add(\"李四\"); list.add(\"王五\"); //打印列表 System.out.println(list); //ArrayList对toString()方法重写了，所以打印输出不是地址值 //获取列表里面的元素 System.out.println(\"列表的第一个元素为：\" + list.get(0)); System.out.println(\"列表的第二个元素为：\" + list.get(1)); System.out.println(\"列表的第三个元素为：\" + list.get(2)); System.out.println(\"列表的长度为：\" + list.size()); //获取列表的长度 System.out.println(\"===============\"); //删除 System.out.println(\"删除的元素为：\" + list.remove(1)); //删除第二个元素，即删除李四 System.out.println(\"列表的长度为：\" + list.size()); //列表的长度 System.out.println(list); &#125;&#125; 输出为： [张三, 李四, 王五]列表的第一个元素为：张三列表的第二个元素为：李四列表的第三个元素为：王五列表的长度为：3===============删除的元素为：李四列表的长度为：2[张三, 王五] 上面代码的注释已经详细说明上面代码的功能，这里说一下一个特别的地方。当我们打印数组名时，会得到数组的地址，但是当我们打印ArrayList对象，输出的不是地址，而是里面的元素，这是因为ArrayList重写了toString()方法，当System.out.println()里面传入的是引用类型时，会调用该引用类型的toString方法，由于ArrayList重写了toString()方法，所以打印输出的不是地址，没有重写该方法的类，打印输出默认是地址。如果在这里你搞不懂什么重写，toString()方法都是什么，那么没关系，你只要知道直接打印ArrayList对象名，输出的不是地址，而是里面包含的所有元素，具体重写是什么，toString()是什么，在后面的继承部分将会有阐述。 需要注意的是，泛型只能是引用类型，不能是基本数据类型，那么如果我们想要保存基本数据类型怎么办。当然是有办法的，Java中为每一个基本数据类型提供了一个包装类，它虽然是一个类，但是你在使用时完全把它当做基本数据类型就可以，因为泛型里面不能是基本数据类型，才会有这么一个包装类。下表是基本数据类型与包装类对应的名称 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 上面除了int和char对应的包装类不只是首字母大写，其他都是只要首字母大写即可。下面我将演示如何存储基本数据类型，以int类型为例 import java.util.ArrayList;public class BasicDataToArrayList &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //把Integer当做int看待即可，我们不需要new 一个Integer对象 编译器会帮我们做处理，我们不需要担心 list.add(100); list.add(25); list.add(15); //打印列表 System.out.println(list); &#125;&#125; 输出为 [100, 25, 15] 在基本数据类型与包装类之间有自动装换，基本数据类型转换为包装类的过程叫做装箱，包装类转化为基本数据类型的过程叫做拆箱，从JDK 1.5开始就支持自动装箱和自动拆箱。即我们可以这么写 Interger a = 12; //自动装箱 int -- Intergerint b = a; //自动拆箱 Interger -- int 所以我们在使用时把Interger看做int就可以了。 LinkedListLinkedList是List的实现类，它的底层原理是基于链表实现的，所以除了List接口中的方法，它还提供了很多与头尾有关的方法，如 addFirst addLast removeFirst removeLast getFirst getLast push 同addFirst一样 pop 同removeFirst 下面进行示范 import java.util.LinkedList;public class TestLinkedList &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); linkedList.add(\"AAA\"); linkedList.add(\"BBB\"); //addFirst 在\"AAA\"前面添加元素\"CCC\" linkedList.addFirst(\"CCC\"); System.out.println(linkedList); //[CCC, AAA, BBB] //push 在\"CCC\"前面添加\"DDD\" linkedList.push(\"DDD\"); System.out.println(linkedList); //[DDD, CCC, AAA, BBB] //pop 删除\"DDD\" System.out.println(linkedList.pop()); //DDD //获得第一个元素 getFirst System.out.println(linkedList.getFirst()); //CCC //removeFirst 删除第一个元素 System.out.println(linkedList.removeFirst()); //CCC System.out.println(linkedList); //[AAA, BBB] //removeLast 删除最后一个元素 System.out.println(linkedList.removeLast()); //BBB System.out.println(linkedList); //[AAA] &#125;&#125; 基本类型与包装类在前面我们就讲过这个概念，不过当时讲的不够详细，现在深入讲解。首先我们知道包装类是什么，因为基本数据类型它不是引用类型，而由于泛型必须是引用类型，所以才有包装类。包装类就是将基本数据类型包装为一个类，这个类我们完全可以当做基本数据类型使用，并且包装类除此之外，还提供了一些方法用法操作基本数据类型，这是基本数据类型所没有的。 装箱与拆箱首先我们将如何进行装箱操作，即将基本数据类型转换为对象的包装类，下面全部以Integer为例，其余的同理，Integer对象的创建有两种方法，一种是通过构造方法，一种是通过Integer的一个静态方法 构造方法 Interger(int value) 接收一个int类型的数值 Interger(String str) 接收一个字符串，该字符串要符合规定的格式，如”100” 静态方法 valueOf() 接收的参数同构造方法，也可以接收字符串类型的参数 下面演示如何创建Interger对象 Integer in1 = new Integer(2);Integer in2 = new Integer(\"20\");Integer in3 = Integer.valueOf(200);Integer in4 = Integer.valueOf(\"2000\");System.out.println(in1 + \" \" + in2 + \" \" + in3 + \" \" + in4); 输出为 2 20 200 2000 那如何通过包装类得到一个基本数据类型呢？通过intValue方法，如下 int i = in1.intValue();System.out.println(i); 输出为 2 自动装箱和自动拆箱自从JDK 1.5以后就实现了自动装箱和拆箱，可以直接把基本数据类型赋值给包装类，也可以把包装类直接赋值给基本数据类型，如下 Integer num = 10; //自动装箱 相当于 Integer num = new Interger(10) 不过现在是自动进行的了int i = num; //自动拆箱 相当于 int i = num.intValue() 基本数据类型与字符串类型相互转换基本数据类型转换为字符串类型 基本数据类型 + “”,如100 + “”得到”100” 包装类的toString(参数)，这个不是Onject的toString()方法，因为它有参数，不是重写 如Integer.toString(100)得到”100” String类的valueOf(参数)方法，如String.valueOf(100)得到”100” 字符串转基本数据类型 包装类的parseXxx，如Integer.parseInt(“100”)得到基本数据类型100 SetSet接口也是Collection的子接口，它的实现类有HaseSet，LinkedHashSet，HashSet是无序的，LinkedHashSet是有序的。 Set集合的特点 集合中的元素不能重复 没有索引 下面看一个例子 import java.util.HashSet;import java.util.Set;public class TestSet &#123; public static void main(String[] args) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(1); set.add(3); set.add(2); set.add(1); System.out.println(set); //无序且不能重复 [1, 2, 3] &#125;&#125; 可见集合的顺序与添加的顺序无关，并且添加重复的元素是不行的。 Set集合不能添加重复元素的原理：Set集合的底层原理是Hash表，首先会根据要添加的元素计算出它的哈希值，根据哈希值添加到数组中，数组中存储的是链表或者红黑树，元素会添加到数组里面的链表或者红黑树中。一般不同的元素会添加到数组的不同索引中，即不同的链表或红黑树中，但是也有可能虽然元素不同，但是它们的哈希值相同，这个就叫做哈希冲突。如果发生了哈希冲突，那么会使用equals()方法判断该链表或红黑树中是否存在与这个元素相同的元素，如果有，那么就不添加，如果没有，那么就添加。 所以如果你要添加自定义的类型，那么就要重写Object类的hashCode()方法和equals()方法。 Set集合的遍历Set由于它是无序的，所以它不能使用普通for循环遍历，所以只能使用 迭代器 增强for 由于与List差不多，这里就不在演示了。 LinkedHashSetLinkedHashSet是HashSet的子类，但是它是有序的。如 import java.util.LinkedHashSet;import java.util.Set;public class TestLinkedHashSet &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); set.add(\"aaa\"); set.add(\"ccc\"); set.add(\"bbb\"); System.out.println(set); //[aaa, ccc, bbb] 与添加的顺序相同 &#125;&#125; 可变参数可变参数指的方法能够接受的参数可以为多个，定义格式如下 数据类型... 变量名 它的底层原理是数组，会把这多个元素放到一个数组中。假设下面方法接受多个整数类型的参数，但是不知道能接受多少个，然后打印出这些数的和，那么就可以这么写 public class TestKebiancanshu &#123; public static void sum(int... ints) &#123; //ints就是一个数组 int sum = 0; for (int i = 0; i &lt; ints.length; i++) &#123; sum += ints[i]; &#125; System.out.println(sum); &#125; public static void main(String[] args) &#123; sum(1,2,3); //可以传入多个参数，也可以不传 sum(1,5,7,8); &#125;&#125; 输出为 621 注意： 一个方法只能有一个可变参数 一个方法如果有多个参数，可变参数要写在末尾 CollectionsCollections是一个工具类，它提供了很多的静态方法用来对Collection集合进行操作。我们下面就简单介绍Collections类的三个方法 addAll(Collection&lt;? super T&gt; c, T… elements) 接收两个参数，第一个为Collection集合，第二个参数为可变参数 为集合添加多个元素，如addAll(list, 1, 2, 3) shuffle(List&lt;?&gt; list) 接收一个List集合，将集合里面的元素随机打乱 sort(List&lt;T&gt; list) 接收一个list集合，将按照默认升序的规则排序 如果集合里面装的是自定义的类的对象，那么该类要实现Comaprable接口，并且要重写compareTo()方法 sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 接收一个List集合和一个实现Comparator接口的类的对象，可以传入匿名类 下面演示方法的使用 addAll List&lt;Integer&gt; list1 = new ArratList&lt;&gt;();Collections.addAll(list1, 1, 2, 3);System.out.println(list1); //[1, 2, 3] shuffle List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();Collections.addAll(list2, 1, 2, 3, 4, 5, 6);Collections.shuffle(list2);System.out.println(list2); //[6, 4, 3, 5, 2, 1] sort(List&lt;T&gt; list) //先演示对Integer类的排序List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();Collections.addAll(list3, 1, 7, 10, 5, 6, 4);Collections.sort(list3);System.out.println(list3); //[1, 4, 5, 6, 7, 10] 下面演示自定义类的排序，首先我们定义一个Person类，它有name和age属性，我们根据age的大小进行升序排序，如下 public class Person implements Comparable&lt;Person&gt; &#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Person o) &#123; //升序 return this.age - o.age; //降序o.age - this.age &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试该类 Person p1 = new Person(\"古力娜扎\",20);Person p2 = new Person(\"迪丽热巴\", 18);Person p3 = new Person(\"刘亦菲\", 21);List&lt;Person&gt; list4 = new ArrayList&lt;&gt;();Collections.addAll(list4, p1, p2, p3);Collections.sort(list4);System.out.println(list4); 输出为 [Person&#123;name='迪丽热巴', age=18&#125;, Person&#123;name='古力娜扎', age=20&#125;, Person&#123;name='刘亦菲', age=21&#125;] sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 这次我们不需要实现Comparable接口，只需要传入一个Comparator的实现类对象就可以，该类重写Comparator中的compare方法，在该方法中规定了排序的规则，我们可以传入一个匿名类 List&lt;Person&gt; list5 = new ArrayList&lt;&gt;();Collections.addAll(list5, p1, p2, p3);Collections.sort(list5, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //升序 return o1.age - o2.age; &#125;&#125;);System.out.println(list5); 输出为 [Person&#123;name='迪丽热巴', age=18&#125;, Person&#123;name='古力娜扎', age=20&#125;, Person&#123;name='刘亦菲', age=21&#125;] Map之前我们介绍的集合如List，Set都是单列集合，下面我们将介绍双列集合Map，它是通过键K去寻找值V的，所以说它是一个双列集合。它是一个接口，它的常用子类有HashMap和LinkedHashMap。其中HashMap是无序的，即在集合中存储的顺序与你添加的顺序是不一致的。LinkedHashMap是有序，即添加顺序与保存的顺序相同。LinkedHashMap是HashMap的子类。我们之前介绍的HashSet类是调用HashMap实现的，它只利用了HashMap的K。 Map集合的方法下面介绍Map集合的常用方法 put(key, value) 向Map中添加一对键值对，由于Map集合中的key是不能重复的，如果Map中已经存在该key，那么将集合中该key所对应的value值替换为添加的value，即相当于更新，并且返回被替换的value值，如果该集合中不存在该key，那么将该键值对添加，并且返回null get(key) 通过键值来获得对应的value值，如果集合不存在该key，那么返回null remove(key) 根据键来删除该键值对，如果该key不存在，那么返回null，如果存在，那么返回对应的value值 containsKey(key) 判断集合中是否存在键key，有则返回true，否则返回false 下面简单演示这四个方法 import java.util.HashMap;import java.util.Map;public class TestMap &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); //添加元素 map.put(\"迪丽热巴\",18); map.put(\"古力娜扎\",19); map.put(\"佟丽娅\",20); System.out.println(map); //&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125; //这里已经有\"迪丽热巴\"这个键了，所以对应的值会被更改为20，并将该值18返回 //这里最好使用Integer接收，因为可能返回null 而基本数据类型不能被赋值为null Integer val1 = map.put(\"迪丽热巴\",20); System.out.println(val1); //18 System.out.println(map); //&#123;佟丽娅=20, 迪丽热巴=20, 古力娜扎=19&#125; //通过键去获得值 Integer val2 = map.get(\"古力娜扎\"); System.out.println(val2); //19 //删除键\"佟丽娅\"对于的键值对 Integer val3 = map.remove(\"佟丽娅\"); System.out.println(val3); //20 System.out.println(map); //&#123;迪丽热巴=20, 古力娜扎=19&#125; //判断是否包含键\"佟丽娅\" System.out.println(map.containsKey(\"佟丽娅\")); //false &#125;&#125; 遍历Map集合主要有两个方法用来遍历Map集合 keySet 该方法会返回Set集合，里面是key的值，然后我们可以遍历该Set集合来遍历Map集合 entrySet 该方法也返回一个Set集合，不过这个集合里面的是Entry对象，Entry是Map的内部类，该类会在添加键值对时创建一个Entry对象保存相应的key和value的信息，我们可以通过Entry对象的getKey()和getValue()方法来获得键和值。同样我们可以遍历该Set集合来遍历Map集合 下面演示两个方法的使用 keySet import java.util.HashMap;import java.util.Map;import java.util.Set;public class TestMap &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); //添加元素 map.put(\"迪丽热巴\",18); map.put(\"古力娜扎\",19); map.put(\"佟丽娅\",20); System.out.println(map); //&#123;佟丽娅=20, 迪丽热巴=18, 古力娜扎=19&#125; //获得key的Set集合 Set&lt;String&gt; set1 = map.keySet(); //遍历Set集合 for (String set: set1) &#123; System.out.println(set + \"=\" + map.get(set)); &#125; //获得Entry对象组成的Set集合 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set2 = map.entrySet(); //遍历该集合 for (Map.Entry&lt;String, Integer&gt; set : set2) &#123; System.out.println(set.getKey() + \"=\" + set.getValue()); &#125; &#125;&#125; 输出为 佟丽娅=20迪丽热巴=18古力娜扎=19佟丽娅=20迪丽热巴=18古力娜扎=19 斗地主案例练习该案例模拟斗地主的发牌和看牌过程，加强对集合的使用。 分析首先我们要使用Map&lt;Integer, String&gt;集合来保存一副扑克，Integer是索引，String是对应的扑克牌。我们通过索引去找牌，到时候把索引发给玩家就可以，这样因为玩家拿到的是索引，那么就可以进行排序。我们首先要创建一副扑克，可以使用两个String数组，一个保存花色，一个保存数字，然后通过循环组合两个数组来组合一副扑克牌。因为我们要进行排序，所以Integer的大小和牌的大小要一一对应，即0对应大王，1对应小王，2-5对应四个2，以此类推。洗牌我们可以使用Collections的shuffle()方法，由于该方法要求传入List集合，我们要创建一个List集合，该集合要保存Integer索引。发牌就把索引发给玩家，玩家通过索引去Map集合中看牌。 代码实现import java.util.*;public class Doudizhu &#123; public static void main(String[] args) &#123; //使用两个数组组合形成一幅扑克牌 String[] colors = &#123;\"♠\",\"♥\",\"♣\",\"♦\"&#125;; String[] numbers = &#123;\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"&#125;; //将扑克牌存储到Map集合中，键为整数索引，方便排序，值为牌，通过索引拿牌 Map&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //因为使用Collections.shuffle方法洗牌，所以要使用List集合存储索引 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //将大小王添加到Map中，并将索引添加到List中 int index = 0; poker.put(index,\"大王\"); list.add(index); index++; poker.put(index,\"小王\"); list.add(index); index++; //两个数组组合形成一副牌 for (String number : numbers) &#123; for (String color : colors) &#123; poker.put(index,color+number); list.add(index); index++; &#125; &#125; //洗牌 Collections.shuffle(list); ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; dipai = new ArrayList&lt;&gt;(); //发牌，将索引发给玩家 for (int i = 0; i &lt; list.size(); i++) &#123; if (i &gt;= 51) &#123; dipai.add(list.get(i)); &#125; else if (i % 3 == 0) &#123; player1.add(list.get(i)); &#125; else if (i % 3 == 1) &#123; player2.add(list.get(i)); &#125; else if (i % 3 == 2) &#123; player3.add(list.get(i)); &#125; &#125; //给牌排序 Collections.sort(player1); Collections.sort(player2); Collections.sort(player3); Collections.sort(dipai); //看牌 lookPoker(player1,poker,\"刘德华\"); lookPoker(player2,poker,\"周润发\"); lookPoker(player3,poker,\"周星驰\"); lookPoker(dipai,poker,\"底牌\"); &#125; //看牌方法 通过玩家的索引去Map集合中找到对应的牌 并打印出来 public static void lookPoker(ArrayList&lt;Integer&gt; list, Map&lt;Integer,String&gt; poker,String name) &#123; System.out.print(name + \"的牌是： \"); //通过玩家的索引，去poker中取牌 for (Integer number : list) &#123; System.out.print(poker.get(number) + \" \"); &#125; System.out.println(); &#125;&#125; 结果为","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"集合","slug":"集合","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java面向对象","date":"2019-07-04T16:00:00.000Z","path":"/Java面向对象/","text":"在最初的开始，人们编写程序的基于过程的，那时候的编程方式是面向过程的。但是人们发现，随着代码规模的扩大，编写大规模的程序使用面向过程的方法十分的困难，这时候人们必须提出一种新的编程思想，使得编写大型程序变得简单。这种思想就是面向对象的思想。 就像我们学习数学一样，随着我们学习的深入，我们一直在进行抽象，比如从数抽象到代数，并且不断提出新的概念，提出很多的定理，方便我们的学习研究。面向对象也是一样，它把实际中的事物抽象出来，这个事物可以是我们见到的实物，比如椅子，桌子，手机，也可以是我们我们看不见的东西，比如某个系统。这个抽象出来的东西我们叫做类，我们利用类的概念，可以清楚的把握类与类之间的关系，使得程序的结构十分的清晰，便于管理，便于开发大型的程序。 我们把抽象出来的东西叫做类，那么一个类的实例就是对象。比如，我们把人抽象为了一个类，这是一个抽象的概念，那么小明这个具体的人就是该类的一个实例，也叫做对象。我们把椅子抽象为一个类，一个具体的椅子就是一个对象。类可以看做是对象的模板，对象可以看做是类的具体实现。 我们可以通过两个方面是描述一个事物，一个是属性，比如说对于人这个类，它的属性就有姓名，身高，年龄等等，这些都是它的属性，另一个就是行为，比如说人的行为有吃饭，睡觉等等。 类的定义类使用关键字class进行定义，我们在之前用过很多次，但是我们之前不知道这是什么，比如在HelloWorld案例中 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 其中HelloWorld表示的就是类名。类定义的格式是 public class 类名 &#123; //成员变量 //成员方法&#125; 在上面我们有提到，一个事物可以由属性和行为两部分描述，表现在程序书写中为成员变量和成员方法，其中变量用来描述类的属性，方法用来描述类的行为，前面加上成员二字以表示与局部变量的不同，例如下面定义了一个Person类，它有姓名，年龄属性，有吃和睡的行为 public class Person &#123; String name; int age; public void eat() &#123; System.out.println(\"吃吃吃\"); &#125; public void sleep() &#123; System.out.println(\"睡睡睡\"); &#125;&#125; 我们注意到成员变量时定义在类当中的，并且成员方法没有使用关键字static修饰。 我们定义了一个类，那我们怎么使用它呢? 从前面我们了解到，类是一个抽象的概念，是一个模板，我们要将它具体化才能够使用它，类是不能够直接使用的，而具体化的过程就是创建一个对象。创建对象的格式为 类名 对象名称 = new 类名(); 例如下面创建一个per的对象 public class Person &#123; String name; int age; public void eat() &#123; System.out.println(\"吃吃吃\"); &#125; public void sleep() &#123; System.out.println(\"睡睡睡\"); &#125; public static void main(String[] args) &#123; Person per = new Person(); //创建一个名为per的对象 &#125;&#125; 我们创建这个对象的模板是Person类，那么它就应该有name, age属性和eat, sleep行为，那么我们怎么去使用这些东西呢? 方法就是通过点语法 对象名.属性 //使用属性对象名.方法() //使用方法 例如下面我们打印出per对象的属性值，并且调用它的方法 public static void main(String[] args) &#123; Person per = new Person(); //创建一个名为per的对象 System.out.println(per.name); System.out.println(per.age); per.eat(); per.sleep();&#125; 输出为 null0吃吃吃睡睡睡 我们发现per.name的值是null，per.age的值是0，实际上我们并没有给per.name和per.age赋值，系统在创建对象时会有默认值，规则和数组的一样。 类的内存模型我们来看看执行下面的代码，在内存中发生了什么 public class Person &#123; String name; int age; public void eat() &#123; System.out.println(\"吃吃吃\"); &#125; public void sleep() &#123; System.out.println(\"睡睡睡\"); &#125; public static void main(String[] args) &#123; Person per = new Person(); //创建一个名为per的对象 System.out.println(per.name); System.out.println(per.age); per.eat(); per.sleep(); &#125;&#125; 编译器首先会在方法区中找main方法，然后将它推入栈中 Person per = new Person(); 这行语句会在main中创建一个per变量，接着会在堆中开辟出一块空间，存储的是per这个对象，这个对象是以方法区中的类为模板的，该对象具有成员变量和成员方法。但是注意的是，对象的成员方法是地址值，指向方法区中的方法的信息，当调用方法时，会根据该地址值去方法区中寻找该方法。由于每个对象的行为都是一样的，只是属性不同，所以不需要在堆中为每一个对象都开辟空间来保存方法的信息，只需要保存一个地址值即可。这样做可以节省内存空间。 System.out.println(per.name);System.out.println(per.age);per.eat();per.sleep(); 上面的语句是访问对象的成员变量和成员方法，首先会根据per对象保存的地址值，去堆中寻找对应的保存地址，然后根据成员变量名去访问数据。调用成员方法，分为了四步，第一步是根据per对象的地址值找到堆中的方法；第二步，堆中的方法保存的地址值，根据堆中的地址值去方法区中查找方法的信息；第三步，将方法压入栈中，栈会为该方法开辟一块空间；第四步，方法执行完毕，方法被栈移除。 对象与方法对象作为一种数据类型，它也可以作为方法的参数和返回值。与数组一样，传递的是地址值，返回的也是地址值。 对象作为参数public static void printObject(Person per) &#123; System.out.println(per.name); System.out.println(per.age);&#125; 对象作为返回值public static Person getPersonObject() &#123; Person per = new Person(); return per;&#125; 成员变量与局部变量成员变量与局部变量的区别 定义的位置不一样 局部变量：定义在方法中 成员变量：定义在方法之外，定义在类中 作用范围不一样 局部变量：只能在方法中使用 成员变量：在类中都可以使用 默认值 局部变量：没有默认值 成员变量：有默认值，规则同数组 在内存中的位置不一样 局部变量：在栈内存中 成员变量：在堆内存中 生命周期 局部变量：随着方法的进栈而产生，随着方法的出栈而消失 成员变量：随着对象的创建而产生，随着对象的被垃圾回收而消失 封装面向对象有三大特性，分别为 封装 继承 多态 下面详细讲述其中的封装。 我们知道，当我们创建了一个对象之后，可以通过点(.)语法去访问成员变量，也可以为它赋值，如下 public class Person &#123; String name; int age; public static void main(String[] args) &#123; Person per = new Person(); per.name = \"李四\"; per.age = 20; System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; 输出为： 我叫做：李四，我：20岁。 但是一旦我们将成员变量使用修饰符private修饰的话，那么我们就不能通过.语法访问成员变量了，如下面的例子 public class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person per = new Person(); per.name = \"李四\"; //编译成功 per.age = 20; //编译成功 System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; 我们发现怎么使用private修饰的变量怎么还可以访问，不是说不可以访问了吗? 这是因为main方法是Person类的方法，在一个类里面是可以随便访问的，现在有一个Test类，然后我们去访问数据 public class Test &#123; public static void main(String[] args) &#123; Person per = new Person(); per.name = \"李四\"; //编译失败 per.age = 20; //编译失败 System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; private就是私有的意思，意味的这个变量的私密的，外部不可以访问，如果要访问的话，只能通过getter和setter方法 public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String who)&#123; name = who; &#125; public int getAge() &#123; return age; &#125; public void setAge(int num)&#123; age = num; &#125; &#125; 现在我们在Test类中创建Person对象访问 public class Test &#123; public static void main(String[] args) &#123; Person per = new Person(); per.setName(\"李四\"); //通过setter方法去设置成员变量的值 per.setAge(20); //通过setter方法去设置成员变量的值 System.out.println(\"我叫做：\" + per.name +\"，我：\" + per.age + \"岁。\"); &#125;&#125; 输出为 我叫做：李四，我：20岁。 明显可见，下面的代码量比上面大了很多，感觉这么做是多此一举，那么为什么要这么做呢？考虑下面这么一种情况，如果没有进行封装，那么我们可以使用.语法为age变量赋值，我们可以赋值为-20，这明显是不合理的，但是可以进行赋值，如果我们进行封装，那么我们可以在setter方法中进行判断，使得一些不合理的，有害的操作不能够正常赋值。 public void setAge(int num) &#123; if (num &gt; 0) &#123; age = num; &#125;&#125; getter方法和setter方法的格式一般为”get变量名”或”set变量名”，根据驼峰命名法，变量名首字母需要大写，如上面的setAge, getAge。但是如果getter方法的返回值是boolean类型的话，我们一般写成isXxx的形式。 this关键字考虑上例我们的setter方法 public void setName(String who)&#123; name = who;&#125; 其实我一直想写成这样 public void setName(String name)&#123; name = name;&#125; 我的想法是第一个name是成员变量name，第二个name是传入的参数，但是这样不行，因为这时的两个name都被看做是传入的参数，那有什么办法可以解决成员变量与局部变量重名的问题吗？方法就是使用this关键字，修改上面代码如下 public void setName(String name)&#123; this.name = name;&#125; 这时this.name就代表的是成员变量name。那么this到底是个什么东西？哪个对象调用这个方法，那么this就是调用这个方法的对象. per.setName(\"李四\"); per这个对象调用setName方法，那么这时的this就是per。 构造方法构造方法其实就是创建对象的方法，用new在创建对象，就是在调用这个方法。还记得我们是怎么创建对象的吗 Person per = new Person(); 其中Person()就是构造方法。 构造方法的定义构造方法定义的格式为 public 类名() &#123; &#125; 注意： 构造方法名要与类名的完全一样，包括大小写 不要写返回值类型，void也不要写 不能return一个具体的返回值 构造方法同成员方法一样，是定义在类中的，但是我们好像到现在从来没有定义过构造方法，但是我们却可以使用，这时为什么？ 如果我们没有编写构造方法，那么编译器会为我们自动生成一个构造方法，该构造方法没有参数，方法体为空，比如像这样 public Person() &#123; &#125; 但是一旦当我们定义了一个构造方法，那么编译器不会自动生成一个构造方法 public Person(String name, int age) &#123; this,name = name; this,age = age;&#125; 我们定义个一个构造方法，此时总共就这一个构造方法，编译器不会自动生成。但是我们一般还会写一个无参的构造方法，继承那里会讲到为什么。 构造方法也可以进行重载，在上面我们已经演示了 利用构造方法进行初始化我们一般可以利用构造方法进行初始化，注意我们之前初始化都是这样 Person per = new Person();per.setName(\"李四\");per.setAge(20); 现在我们定义一个有两个参数的构造方法 public Person(String name, int age) &#123; this.name = name; this.age = age;&#125; 然后就可以这么调用 Person per = new Person(\"李四\", 20); 这一行的代码与上面三行代码的效果是一样的。 一个标准的类一个标准的类应该满足一下特点 所有的成员变量都使用private修饰 为每一个成员变量编写一个setter,getter方法 编写一个无参构造函数 编写一个有参构造函数 一个标准的类也叫做Java Bean。 匿名对象所谓的匿名对象，指的就是没有名字的对象。即在创建对象时，并没有为它赋予变量名。由于它没有名字，没有变量保存它的地址，所以它只能够使用一次，如下 new Person().age; 如果某个对象只使用一次的话，我们可以考虑使用匿名对象。 匿名对象作为方法的参数匿名对象也是对象，当然可以作为方法的参数。匿名对象传入方法的是地址值，下面举一个例子 import java.util.Scanner;public class Anonymous &#123; //getNum方法接收一个Scanner对象，返回一个int类型的数值 public static int getNum(Scanner sc) &#123; int num = sc.nextInt(); return num; &#125; public static void main(String[] args) &#123; //传入了一个匿名对象 int num = getNum(new Scanner(System.in)); System.out.println(num); &#125;&#125; 程序运行效果为 匿名对象作为方法的返回值匿名对象也可以作为方法的返回值，返回的也是地址值 import java.util.Scanner;public class Anonymous &#123; //返回一个Scanner对象 public static Scanner getScannerObject() &#123; return new Scanner(System.in); &#125; public static void main(String[] args) &#123; //GetScannerObject方法返回一个Scanner对象 Scanner sc = getScannerObject(); String str = sc.next(); &#125;&#125; 程序运行效果为 static关键字static关键字我们在之前见到过很多次了，比如 public static void main(String[] args)&#123; &#125; 或者在定义方法时 public static void add() &#123; &#125; 都用到static，而在成员方法中却没有用到static，所以这里我们就来看看static到底是什么，它有什么用。 static修饰符的作用一旦被static修饰，不管是变量还是方法，那么这么变量或方法不再是属于某个对象的，而是属于类，相当于说被static修饰之后，就不是某个人的私有财产，而是大家的公共财产。被static修饰的变量和方法分别叫做静态变量和静态方法。 访问static修饰的变量或方法，可以通过.语法，可以通过类名.，也可以通过对象名.。以前我们调用成员变量和成员方法就是通过对象名.出来的。但是这里推荐使用类名.，这样大家一眼就可以看出这是共有财产而不是私有财产。而且即使你使用了对象名.，在编译器编译时也会自动转换为类名.。 为了理解static修饰符，我们来看这么一个例子。假设有一个Student类，里面有一个id成员变量，我们希望每当创建一个对象时，会自动赋予id变量一个值，比如说，如果one第一个创建的学生，那么它的id就是1，以此类推。我们可以使用一个static变量idCounter来计数，每创建一个对象它就加一 public class Student &#123; String name; int id; static int idCounter; public Student() &#123; //每创建一个对象，id计数器加一，并且赋给id this.id = ++idCounter; &#125; public Student(String name) &#123; this.name = name; //每创建一个对象，id计数器加一，并且赋给id this.id = ++idCounter; &#125; public static void main(String[] args) &#123; Student one = new Student(\"one\"); System.out.println(\"我的名字是：\" + one.name + \"我的id是：\" + one.id); Student two = new Student(\"two\"); System.out.println(\"我的名字是：\" + two.name + \"我的id是：\" + two.id); &#125;&#125; 输出为 我的名字是：one我的id是：1我的名字是：two我的id是：2 这里我要解释一下，为什么有的方法使用static修饰了，我们知道，如果使用static修饰，该方法就可以通过类.出来，如果这个方法是本类的，那么类名可以省略不写。比如这样 public static void add() &#123; &#125;public static void main(String[] args) &#123; //在这里调用add方法，属于同一个类，可以省略类名 add();&#125; 如果我们需要直接在main方法中直接使用这个方法，我们就会使用static修饰。这里只是解释前面为什么有的方法要使用static修饰，因为我们希望直接调用。 这里有关static有几个需要注意的事项 静态只能访问静态，静态不能访问非静态。即在静态方法里面，不能访问成员变量，也不能调用成员方法。这时因为在内存中，先有静态内容，后有非静态内容。”先人不知后人，后人知道先人”。 静态方法中不能使用this。我们知道，谁调用这个方法，那么this就是这个对象。但是调用静态方法是类，而不是对象，即使使用对象调用静态方法，编译器在编译时也会转换为类调用。 static的内存图在方法区中有一块内存空间，专门用以保存静态变量的 从上面的图可以看出来，静态变量与对象没有任何关系。 静态代码块静态代码块的格式是 static &#123; &#125; 该代码块写在类中。它的特点是在第一次创建对象的时候执行唯一的一次。后面在创建对象不会再执行。它先于构造方法的执行。它的作用一般是为了初始化静态变量。 继承继承，主要解决的是共性抽取。子类继承了父类，就拥有父类所有的成员变量和成员方法。除此之外，子类还可以拥有自己的内容。子类与父类的关系，可以这么理解：子类就是一个父类。比如父类是人，子类是学生，子类就是父类说的就是学生是人。也叫is-a关系。 继承的格式子类通过extends关键字基础父类，而父类的定义与一般类的定义相同，现在假设有一个父类Person和一个子类Student。 public class Person &#123; String name; int age; public void showA() &#123; System.out.println(\"我是父类的方法\"); &#125;&#125; public class Student extends Person &#123; int id; //子类拥有父类的成员变量和成员方法&#125; 子类访问父类成员变量上面讲过，一旦子类继承了父类，那么子类就拥有子类的所有成员变量和成员方法。那么子类怎么访问父类的成员变量，这里分为重名和不重名两种 不重名 这种情况最简单，这时是直接用子类对象.父类的成员变量就可以访问 Student stu = new Student();stu.name;stu.age; 重名 直接 如果使用子类对象.的话，访问的就是子类的成员变量 间接 间接指的就是通过成员方法访问，此时举个例子说明 假设父类有一个int num;，子类也有一个int num;。现在父类有一个showA方法如下 public void showA() &#123; System.out.println(num);&#125; 那么如果子类对象调用这个方法的话，那么使用的就是父类的num。现在如果子类有一个showB方法，如下 public void showB() &#123; System.out.println(num);&#125; 如果子类对象调用这个方法，那么使用就是子类的num。简而言之，方法属于谁，就用谁的。 区分三种变量这三种变量指的就是 父类的成员变量 子类的成员变量 局部变量 之前我们讲过区分局部变量和成员变量，我们使用this关键字加以区分。现在假设在子类的一个成员方法中，父类，子类有成员变量name，而该方法也有一个局部变量，这时我们这么区分，如下： super.name; //父类的namethis.name; //子类的namename //局部变量name 同理，如果子类有成员方法和父类的一个成员方法重名的话，如果我们想在子类的某个成员方法中使用父类的这个成员方法的话，我们可以使用super.父类方法()调用。super这个关键字指的就是父类对象。 重写之前我们有多次提到重写的概念，那么重写是什么? 重写指的就是子类的某个方法与父类的方法的方法名称一样，参数列表也一样，相当于把父类的这个方法覆盖了。当我们使用子类对象.这个方法时，优先使用子类的方法。 重写的方法需要满足一定的要求，如下： 必须父子类方法名相同，参数列表相同 子类方法的返回值范围要小于父类方法(Object &gt; String) 子类方法的权限必须大于等于父类的权限操作符 //权限修饰符的大小熟悉怒public &gt; protected &gt; (default) &gt; private 注意： 有一个注解，@Override，把它放在要重写的方法前面，可以检查是否重写正确，比如你重写的方法漏掉了一个字母，这相当于你自己有了一个新的成员方法，并不是重写，编译器不会报错，这可能会造成问题，因为你是想重写的。但是你如果在方法前面加上@Override，它会检查这个方法是不是重写，如果不是会报错。这个是可选的，但是推荐使用。 @Override //写在方法的前面public void show() &#123; &#125; 继承中的构造方法为了讲解清楚，假设有两个类，一个是Person类，是父类，另一个是Student类，是子类。两个方法的定义如下 public class Person &#123; public Person() &#123; System.out.println(\"父类的构造方法\") &#125;&#125; public class Student extends Person&#123; public Student() &#123; System.out.println(\"我是子类的构造方法\"); &#125;&#125; 我要讲的是，在子类构造方法的第一行，默认有super();，这个代表调用父类的构造方法，即在调用子类构造方法时，会先调用父类的无参构造方法，现在我们创建一个Student对象，看看打印输出 public class TestExtends &#123; public static void main(String[] args) &#123; Student student = new Student(); &#125;&#125; 打印输出为 我是父类的构造方法我是子类的构造方法 可见是默认会调用父类的无参构造方法。所以我们在之前建议为类写一个无参的构造方法，因为在创建子类对象时会先调用父类的无参构造方法，如果父类没有的话，会报错。 注意： super调用必须是第一个语句，比如下面会报错 public Student() &#123; System.out.println(\"我是子类的构造方法\"); super(); //会报错，因为不是第一个语句&#125; 这也意味着在方法中只能调用一次super()方法，因为第二个super不是第一个语句了 public Student() &#123; super(); super(\"name\",12); //假设父类有一个有参构造方法 由于不是第一个语句，报错 //这意味着只能调用一个super()方法 System.out.println(\"我是子类的构造方法\"); &#125; this()可以调用本类的构造方法，this()也必须是第一个语句，所以this()和super()不能同时出现。 如果父类有有参数的构造方法，我们可以在子类的构造方法中显式的调用该方法，如上面super(“name”,12)，这个时候就不会默认调用无参的构造方法。所以父类中没有无参的构造方法不一定会报错。建议最好还是写一个吧，即使什么都没有，有特殊需求的除外。 继承的三个特征 Java语言是单继承的，只能有一个直接父类 可以有多级继承，继承的源头是Object 一个子类的直接父类是唯一的，但是可以有多个子类 抽象类抽样方法：使用关键字abstract修饰的方法，抽象方法没有方法体，直接大括号结束。抽样方法所在的类必须是抽样类，抽样类的定义是在class前面加abstract。 如下定义了一个抽样类 public abstract class Animal &#123; public abstract void eat(); public abstract void sleep();&#125; eat(), sleep()方法是抽样方法，没有方法体，直接分号结束。 注意： 不能直接创建抽象类对象，应当用一个类继承该抽象类，该类必须重写所有的抽象方法，如果该类没有重写所有的抽象方法，那么该类也必须是抽象类。 抽象类可以有构造方法，给抽象类的成员变量初始化 抽样类不一定要有抽象方法，但是含抽象方法的类必须是抽象类 如下创建一个Dog类继承抽象类Animal public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"汪汪汪...\"); &#125; @Override public void sleep() &#123; System.out.println(\"呼呼呼...\"); &#125; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.eat(); dog.sleep(); &#125;&#125; 输出为 汪汪汪...呼呼呼... 接口接口就是公共的规范标准。 接口的定义我们类的定义是使用class关键字，而接口的定义是使用interface关键字。如下定义了一个接口 public interface MyInterface &#123; ...&#125; 接口里面可以有什么，这与版本有关。 Java 7 常量 抽象方法 Java 8(新增) 默认方法 静态方法 Java 9(新增) 私有方法 接口的使用 接口不能够直接使用，需要一个类去实现它。我们在之前使用extends去继承一个类，而实现一个接口使用implements关键字，如 public class MyClass implements MyInterface &#123; &#125; 实现必须实现接口中的所有抽样方法。如果没有全部实现，那么该类必须为抽样类 创建实现类对象使用 抽象方法接口中的抽样方法的修饰符必须是public abstract，所这两个关键字可以省去，如下的写法都是对的 public abstract void eat(); //不省略abstract void eat(); //只省略publicpublic void eat(); //只省略abstractvoid eat(); //两个都省略 默认方法默认方法的定义为 public default 返回值 方法名(参数列表) &#123; //修饰符必须是public，所以public可以省略 //方法体&#125; 默认方法就要解决的是升级问题。假设你要升级一个接口，如果你添加一个抽象方法的话，那么由于实现类没有实现该抽象方法，那么实现类就不能使用，这样是不合理的。但是添加默认方法的话，实现类不需要实现该方法，实现类可以正常的使用，并且可以通过实现类对象调用该默认方法。 静态方法静态方法的定义为 public static 返回值 方法名(参数列表)&#123; //同default方法，public可以省略 //方法体&#125; 实现类不能直接调用静态方法，只能通过接口.静态方法调用。因为一个实现类是可以同时实现多个接口的，如何多个接口有相同的静态方法，那么通过实现类调用静态方法，那么调用哪个呢？所以实现类是不能直接调用静态方法的。不同于继承，因为继承只有一个直接父类。 私有方法私有方法是为解决代码重复问题的。假设有两个默认方法，这两个默认方法的代码重复很多，那我们想着可以把重复的代码抽出来形成一个新的方法，然后在这两个默认方法中调用这个新方法就可以。但是这个新方法是一个中间方法，应当是只能在接口内才能够被调用，所以不能是默认方法。这个方法应该被定义为私有方法。 私有方法分为两类 普通私有方法 解决默认方法代码重复问题，只使用private修饰 静态私有方法 解决静态方法代码重复问题，使用private static修饰 常量接口中也能定义”成员变量”，只不过必须使用public static final修饰，final代表的就是不可变的意思，所以就相当于是一个常量。接口中的常量必须进行赋值，不能不赋值 public static final int NUM = 10； 对于常量，我们采用所有字母大写，并且单词之间使用下划线分割。接口使用常量的方法是接口.常量，原因同静态方法一样。 注意事项 接口没有静态代码块和构造方法 一个类可以同时实现多个接口 ... implements 接口1，接口2，... 如果实现的两个接口有相同的抽象方法，只需要实现一个即可 不能没有实现所有的抽象方法，那么就必须是抽象类 如果实现的两个接口有重复的默认方法，那么实现类必须重写该默认方法 一个类的直接父类与接口的默认方法重复的话，优先使用直接父类的方法 接口与接口之间多继承的 接口 extends 接口1，接口2，... 如果继承的多个接口默认方法重复，那么必须重写，且重写的方法必须为默认方法。如果抽象方法重复，只继承一个。 多态继承和实现接口是多态的基础。 多态的定义多态的定义就是父类引用指向子类对象。 父类 对象名 = new 子类();接口 对象名 = new 实现类(); 如假设有一个父类Person和一个子类Student如下 public class Person &#123; String name = \"父类\"; public Person() &#123; &#125; public void show() &#123; System.out.println(\"我是父类的show方法\"); &#125;&#125; public class Student extends Person&#123; String name = \"子类\"; @Override public void show() &#123; System.out.println(\"我是子类的show方法\"); &#125;&#125; 现在我使用多态的写法，创建一个Student对象指向Person引用，并且调用show方法 public class Muti &#123; public static void main(String[] args) &#123; Person per = new Student(); per.show(); System.out.println(per.name); &#125;&#125; 这时的输出为 我是子类的show方法父类 是不是有点难以理解上面的输出，下面讲解一下为什么会有上面的输出。 多态访问成员变量和成员方法的规则访问成员方法的规则 如果多态写法创建的对象，调用成员方法时，在编译时看左边，即看父类有没有这个方法，如果父类没有，那么会报错，如下面我在Student中新建了一个子类特有的方法，如果使用per对象调用的话，将会发生错误。 public class Student extends Person&#123; String name = \"子类\"; @Override public void show() &#123; System.out.println(\"我是子类的show方法\"); &#125; public void showAgain() &#123; System.out.println(\"我是子类特有的方法\"); &#125;&#125; 我们观察到程序报错了，因为父类并没有这个方法。 在运行时看右边，即如果这个方法子类重写了，那么调用子类的方法，我们在上面也看到了，输出的是子类的方法 口诀：”编译看左边，运行看右边” 访问成员变量的规则访问成员变量的规则与访问成员方法的规则不同。 访问成员变量时，编译时的规则也一样，如果父类没有该变量，则访问不了该变量。访问不了子类的变量。 即使子类中的成员变量与父类中的成员变量重名，那么访问的也是父类的成员变量，在上面我们已经看到了，我们在打印输出name是输出的是父类的成员变量。 口诀：”编译看左边，运行也看左边” 对象转型对象转型分为向上转型和向下转型。 对象向上转型多态就是向上转型，因为是子类对象指向父类的引用。创建的是子类的对象，但是使用却是当做父类对象使用。多态有一个明显的弊端就是无法使用子类特有的方法和子类的成员变量。 对象向下转型我们提到了多态的弊端，但是我就是要使用子类的特有方法怎么办，这个时候我们可以使用向下转型，比如 Person per = new Student();Student stu = (Student) per; //向下转型 这样我们就可以使用Student对象特有的方法了，比如 public class Muti &#123; public static void main(String[] args) &#123; Person per = new Student(); Student stu = (Student) per; stu.showAgain(); &#125;&#125; 输出为 我是子类特有的方法 但是，向下转型要注意，我原来是Student对象才能转为Student对象，我如果原来不是，那么运行时会抛出异常，如下面我创建一个Teacher继承了Person，现在我要把per强行转型为Teacher对象 我们观察到，在编译时并没有报错，现在我们来运行一下 抛出了ClassCastException异常，意思是类型转换异常。所以向下转型不安全。 那我们为什么不直接创建一个子类对象指向子类呢？何必多次一举使用多态写法然后又给转回来呢? 我们来看这么一个方法 public void someMethod(Person per) 这个类的方法参数只要求是Person就可以，它不管你是Student还是Teacher，所以如果我们把Student对象传进去，这是不是多态的写法，如果我们在里面要用到Student特有的方法，我们是不是要向下转型。 其实常常我们使用接口作为参数，表示的意思就是我才不管你是什么，你只有实现我的接口就可以了，那么我就可以使用你了。比如有一个接口叫做USB，那么传进来的参数，你只要实现了我们USB接口就可以，不管你是鼠标实现了还是键盘实现了，你只要实现了，我就可以用。这就是多态的用法啊。 instanceof上面我们说了，对象的向下转型是有风险的，因为如果我不是Student你给我转给Student那么会抛出异常的。现在instanceof关键字可以解决这个问题，他可以判断多态创建的父类引用为哪个子类。具体用法为 多态创建的父类引用 instanceof 子类 该表达式返回一个boolean值，如果多态创建的父类引用是这个子类，那么返回true，否则返回false。例如 Person per = new Student();per instanceof Student; //trueper instanceof Teacher; //false 现在考虑这么一个函数 public void someMethod(Person per) 我们现在就在方法中根据per instanceof Xxx的结果进行安全的向下转型 public void someMethod(Person per) &#123; if (per instanceof Student) &#123; Student student = (Student) per; //实现Student对象特有的操作 &#125; else if (per instanceof Teacher) &#123; Teacher teacher = (Teacher) per; //实现Teacher对象特有的操作 &#125;&#125; finalfinal关键字可以修饰 一个类 修饰一个类时，该类不能够被继承 所以final不能和abstract关键字一起使用，因为抽象类不能自己创建对象，只能被继承 方法 修饰一个方法时，子类不能重写该方法 局部变量 修饰一个局部变量时，这个变量不能进行更改 下面两种写法都可以 final int num = 10; final int num;num = 10; 成员变量 因为成员变量有默认值，所以要手动赋值 要么直接赋值，要么在构造方法中进行赋值，在构造方法中赋值时，所有的构造方法都要进行赋值，即使是无参构造方法，也要进行赋值 final int num = 10;//下面的写法是错误的final int num;num = 10; public Xxx() &#123; num = 0;&#125;public Xxx(int num) &#123; this.num = num;&#125; 权限修饰符权限修饰符总共有四种，权限从大到小的顺序为 public protected (default)，就是什么都不写 private 下表列出了不同修饰符下的访问规则 同一个类 同一个包 不同包的子类 不同包非子类 public 能 能 能 能 protected 能 能 能 不能 (default) 能 能 不能 不能 private 能 不能 不能 不能 内部类内部类是一个很重要的概念，主要分为两类 成员内部类 局部内部类 匿名内部类 下面我们来看一下内部类的使用 成员内部类成员内部类就像成员变量和成员方法一样定义在类里面，比如有一个叫做Body，内部还有一个类叫做Heart。我们可以这么定义 public class Body &#123; public class Heart &#123; &#125;&#125; 内部类可以随意的访问外部类的成员变量和成员方法，但是外部类要访问内部类要借助内部类对象。 如何使用成员内部类 在外部类的方法中使用内部类，然后在main方法中调用外部类的方法。 直接创建内部类的对象，创建格式为 外部类.内部类 对象名 = new 外部类().new 内部类(); 比如上面我想创建一个Heart对象就可以这么写 Body.Heart heart = new Body().new Heart(); 内部类变量与外部类变量重名问题，假设外部类有一个成员变量num，内部类也有一个成员变量num，在内部类的成员方法中也有一个局部变量num，现在在内部类的这个方法中怎么访问外部类的成员变量，怎么访问内部类的成员变量。如下 num //局部变量this.num //内部类的成员变量外部类名.this.name //外部类的成员变量 现在来看一个例子 public class Body &#123; int num = 10; //外部类的num public class Heart &#123; int num = 20; //内部类的num public void showNum(int num) &#123; System.out.println(num); //打印局部变量 System.out.println(this.num); //打印内部类的成员变量 System.out.println(Body.this.num); //打印外部类的成员变量 &#125; &#125; public static void main(String[] args) &#123; Body.Heart heart = new Body().new Heart(); heart.showNum(30); //局部变量num &#125;&#125; 输出结果为 302010 局部内部类局部内部类就是定义在方法内部的类，定义如下 class 局部内部类名 &#123; &#125; 注意，不要写任何的修饰符。这并不代表它的修饰符权限是(default)，因为修饰符没有意义，类定义在方法的内部，只有在方法内部在能够访问。 我们在这里适时的总结一下修饰符修饰类 外部类 只能是public, (default) 内部类 成员内部类 可以是四种修饰符的任意一种 局部内部类 什么都不能写 局部内部类如果想访问方法中的局部变量，那么这个变量必须是局部final的，什么叫做有效final呢？指的就是没有使用final修饰符修饰（当然你使用final修饰更加的保险），但是变量的值没有发生改变。比如下面 public void testlocalInnerClass() &#123; int num = 10; class LocalInnerClass &#123; public void printNum() &#123; System.out.println(num); &#125; &#125;&#125; 这里的num虽然没有使用final修饰符修饰，但是它只进行了一次赋值，所以是有效final的，所以在局部内部类中可以访问该变量。假设num又进行了赋值，那么将会编译失败。 匿名内部类匿名内部类是相当重要的概念了。如果接口实现类(或者是父类的子类)只使用一次，那么这种情况可省略掉该类的定义，而改为使用匿名内部类。 比如有一个接口，叫做USB好了，然后在一个Computer类中要使用该接口，如下 public interface USB &#123; public abstract void open(); public abstract void close();&#125; public class Computer &#123; public void useUsb(USB usb) &#123; usb.open(); usb.close(); &#125;&#125; 现在我们创建一个类去实现USB接口，然后创建对象，传入Computer的这个方法中 public class ImpUSB implements USB &#123; @Override public void open() &#123; System.out.println(\"打开USB设备\"); &#125; @Override public void close() &#123; System.out.println(\"关闭USB设备\"); &#125;&#125; public class Computer &#123; public void useUsb(USB usb) &#123; usb.open(); usb.close(); &#125; public static void main(String[] args) &#123; Computer computer = new Computer(); ImpUSB impUSB = new ImpUSB(); computer.useUsb(impUSB); &#125;&#125; 输出为 打开USB设备关闭USB设备 但是这样写未必太麻烦了，这个类只使用了一次，但是为了使用这个接口，我却要写一个类去实现该接口，然后创建对象使用，未必有点麻烦。Java提供了更加方便的方法，那就是匿名内部类。 匿名内部类的定义格式为 接口名称 对象名 = new 接口名称() &#123; //在这里覆盖重写接口所有的方法&#125; 现在我们匿名内部类来实现上面同样的效果 public static void main(String[] args) &#123; Computer computer = new Computer(); //创建匿名内部类 USB usb = new USB() &#123; @Override public void open() &#123; System.out.println(\"花式打开USB设备\"); &#125; @Override public void close() &#123; System.out.println(\"花式关闭USB设备\"); &#125; &#125;; computer.useUsb(usb);&#125; 输出为 花式打开USB设备花式关闭USB设备 在这里我们并没有创建一个实现类去实现USB接口，而是创建了一个匿名内部类，这个类没有名字（这也是为什么叫做匿名内部类），所以它不能通过它在创建新的对象。正如匿名对象一样，只能调用一次方法。 匿名内部类的注意事项 匿名内部类在创建对象时，只能使用唯一的一次 匿名对象在调用方法只能调用唯一的一次 匿名内部类是省略了类的名称，匿名对象是省略了对象的名称","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java基础知识","date":"2019-07-03T16:00:00.000Z","path":"/Java基础知识介绍/","text":"第一个程序: HelloWorld下面将书写Java的第一个程序，它的作用是在命令行输出Hello World!。新建一个文件，文件名为HelloWorld.java，使用记事本或其他代码编辑工具打开，敲入以下代码 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 然后在命令行中输入 javac HelloWorld.javajava HelloWorld 然后就可以在命令行中看到Hello World!输出了。 注意事项： class后面的HelloWorld要与文件名一样，包括大小写 在命令行使用javac或者java命令时，要保证所处的路径与文件HelloWorld.java在同一个路径，否则会报错，解决办法有两种 第一种，使用cd命令切换到HelloWorld.java文件的目录 第二种，javac或者java命令后跟上HelloWorld.java的完整路径名称 javac命令后面有后缀.java，java命令后面没有任何的后缀 现在稍微解释上面程序的意思，因为刚刚起步，很多东西现在都解释不了，所以在这里并不要求弄懂。第一行 public class HelloWorld 这里，我们只需要记住HelloWorld必须与文件名相同。第二行 public static void main(String[] args) 这个是固定的写法，几乎每个程序都是这么写的，这个是程序的入口，程序从这里开始执行。第三行 System.out.println(\"Hello World!\"); 这个语句是关键的程序，它的作用就是向屏幕输出字符，这里我们输入的是Hello World!，注意输出的语句需要被双引号括起来。 标识符与命名规范标识符的命名规范 由数字、字母、下划线和美元符组成 不能由数字开头 不能是关键字 上面是标识符命名的硬性规范，即如果不按照上面的来做，那么程序在编译时不能够通过，下面介绍软性规范，意思就是如果你不按照下面的来，编译器不会报错，但是软性规范是大家约定俗成的，大家都遵守的，所以我们要按照下面的来 类名：大驼峰命名法，即首字母全部大写，如HelloWorld 变量名与方法名：小驼峰命名法，即第一个首字母小写，后面的首字母全部大写，如helloWorld Java中的常量Java中的常量分为： 字符串常量：使用双引号括起来的，如”Hello World!” 整型常量：其实就是整数，如5 浮点数：小数，如2.5 字符常量：用单引号括起来的，单引号里面必须有一个字符，不可以没有，也不可以多于一个，如’ab’,’’都是错误的，另外这个字符可以是中文，如’中’ 布尔常量：只有两个值true和false 空常量：null，这个在这里不多做介绍 在前面我们学习了向屏幕输出Hello World!，类似的，在这里我们可以尝试着把常量输出出来，新建一个文件为Constant.java，注意前面提及的命名规范，Constant是类名，所以首字母需要大写，然后在该文件中敲入 public class Constant &#123; public static void main(String[] args) &#123; //下面我将输出一些常量 System.out.println(\"Hello\"); //输出字符串常量 System.out.println(5); //输出整型常量 System.out.println(2.5); //输出浮点型常量 System.out.println('a'); //输出字符型常量 System.out.println(true); //输出布尔型常量 &#125;&#125; 输出为： Hello52.5atrue 注意： 不能打印出null，如System.out.println(null)会报错 上面//后面的内容为注释，编译器会自动的忽略，注释是对程序的解释，是为了帮助人看懂程序的 基本数据类型Java中的数据类型分为基本数据类型和引用数据类型，引用数据类型暂且不提，这里的重点是掌握基本数据类型，基本数据类型分为四类： 整型 浮点型 字符型 布尔类型 整型可以细分为： byte short int long 上面整型数据类型都表示整数，只是表示的范围大小不一样，byte使用一个字节即8bit来表示一个整数的大小，表示的范围为-128~127，short使用两个字节来表示，范围比byte大一点，大约在几万左右，int使用四个字节来表示，是最常用的数据类型，因为它的范围已经大到足够我们日常使用了，long使用八个字节来表示，比int的范围还要大，但是由于使用int已经足够了，从节省空间的角度讲，没必要用long。 浮点型可以分为 float double float使用四个字节来表示小数，虽然使用的是四个字节，但是表示的范围比使用八个字节的long更大，double使用八个字节来表示小数，所以使用double表示小数更精确，我们在平常使用最多的就是double。 字符型没法细分，只有一个，那就是char类型，使用两个字节表示。 布尔型也没有办法细分，只有一个，那就是boolean，使用一个字节表示，它只有两个值true和false。 注意： 字符串不是基本数据类型，它是引用类型，这个后面详细阐述。 变量变量的命名需要服从前面所讲的标识符所需遵从的硬性或软性的规定。变量的声明方法为： 数据类型 变量名 比如： int a;float f;double d; 上面是对变量的声明，但是没有对变量进行赋值，没有被赋值的变量是不能被使用的，否则会报错，下面举一些例子： byte by = 20;short s = 10;int a = 2;long l = 122222222222222L;float f = 1.2F;double d = 2.5;char c = 'a';boolean b = true; 注意： 对float变量进行赋值时，后面需要加上F 对long类型的变量进行赋值时，后面需要加上L(大小写都可以，不过小写的l像1，所以建议使用大写)，当右边常量的值的大小小于int类型的范围时，L可以省略 long l = 2; Java中，整型常量的类型默认为int，浮点型常量的类型默认为double 在一个花括号内部，变量名不能相同 数据类型转换数据类型转换分为两种： 自动类型转换，也称为隐型转换 强制类型转换 自动类型转换当将某数据类型的值赋值给某个能够表示更大范围的数据类型的变量时，会发生自动类型转换，比如 byte b = 20;int a = b; 上面的b是byte类型，a是int类型，int类型的范围更加的大，所以将b赋值给a时会自动类型转换，将20转化为int类型赋值给a，但是b还是byte类型。但是不能将大范围的数据类型的值赋值给更小范围数据类型的变量，如 int a = 20;byte b = a; //不行，编译器会报错 范围从小到大的顺序为 箭头代表可以转换。 在前面我们提及到，当将一个整数赋值给long类型的变量时，如果表示的范围没有超过int，那么可以不写后面的L，这时因为发生了自动类型转换 long l = 12; //后面没有加L，Java默认整数类型为int，这里发生了自动类型转换 强制类型转换上面提及到大范围不能转向小范围，但是我们可以强行转换，比如我想将int类型的数值转化为byte类型的数值 int a = 20;byte b = (byte) a; 在要转换的数据前面加上(byte)就可以强行转化为byte类型。 虽然可以将大范围转化为小范围，但是我们在平常时不会这么干，因为往往将大范围的数转化为小范围的数时，会有精度损失，比如： double d = 3.5;int i = (int) d; //结果为3，小数点后面的数直接舍去，并不是四舍五入 我们知道Java的整数默认为int，那么下面的语句为什么没有报错 byte b = 20; //20是int类型，int不能转byte，为什么没有报错short s = 30; //同上 这是因为，在编译时，编译器会检查右边数值的范围，如果没有超过byte或者short能够表示的大小，那么编译器会自动帮我们强制类型转换为byte或short，相当于 byte b = (byte) 20;short s = (short) 30; 几点注意 char,short,byte类型在进行计算时，会自动提升为int类型参与计算 byte num1 = 10;byte num2 = 20;//下面这行语句会报错byte num3 = num1 + num2; //在计算时，num1和num2会自动的提升为int类型，而int类型不能转为byte，所以会报错 但是，下面的写法是正确的 byte b = 1 + 2; 当右边全是常量时，编译器在编译时会直接计算，相当于下面 byte b = 3; 由于3没有超出byte能够表示的范围，所以会被强制转换为byte。 char c = 'A';//下面这行语句会输出一个数字System.out.println(c + 0); //65 我们知道char是一个字符，那么为什么字符可以进行计算呢？这是因为计算机在底层是使用数字表示字符的，比如上面’A’就是使用数字65表示的，上面的字符与数字0进行计算，会自动提升为int类型，所以最后输出的就是数字。 我们需要知道几个特殊字符对应的数字 字符 ASCII码 ‘0’ 48 ‘A’ 65 ‘a’ 97 大写字母与小写字母之间差32。 boolean类型不能进行数据类型转换 例如，下面将对boolean类型进行转换，是错误的写法： int i = 1;boolean b1 = i; //错误boolean b2 = (boolean) i; //错误 boolean b = true;int i1 = b; //错误int i2 = (int) b; //错误 运算符Java中的运算符分为以下几种： 算术运算符 赋值运算符 比较运算符 逻辑运算符 三元运算符 算术运算符算术运算符包括以下几种： +，加法 -，减法 *，乘法 /，除法 %，取余 ++，自增 –，自减 不同类型的数据之间进行运算，得到的结果的数据类型为范围最大的那个数据类型，如： double d = 2 + 3.5; //int + double ==&gt; doubleint i = 2 + 3.5; //该写法错误 加法有两种作用： 两数字间进行加法运算 字符串的连接 int c = 3 + 5; //进行加法运算，结果为8String s = \"Hello\" + \"World\"; //拼接为HelloWorld 注意：任何数据类型与字符串连接时，会自动变成字符串 String s = 1 + \"Hello\"; //1Hello 除法需要注意的是，两个整数相除，得到的还是整数，即使除不尽，如 int a = 10/3; //a = 3 下面重点介绍++和–，由于二者十分的相似，这里只介绍++。++的作用是自动加1，如 int a = 3;a++; //相当于a = a + 1 a变为了4 其中++可以在变量的前面，也可以在变量的后面，如下 a++;++a; 二者的作用均是使变量a加1，当二者如上单独使用时，二者没有区别，但是当混合使用时，有区别，具体表现如下 ++a：先将a进行+1，然后使用a a++：先使用a，再将其进行+1 例如： int a = 3;b = a++; //先使用a，即先将a的值赋值给b，所以b=3，然后+1，所以最后a=4 int a = 3;b = ++a; //先将a+1，即a=4，然后将a赋值给b，所以b=4 –的作用是减1，其用法同++一模一样，这里不多加介绍。 注意： 常量不能进行++,–运算 30++; //该写法是错误的 赋值运算符赋值运算符分为基本赋值运算符和复合赋值运算符 基本赋值运算符 = 复合赋值运算符 += -= *= /= %= 基本赋值运算符的作用就是把右边的值赋给左边的变量 int a = 3; //把3赋给变量a 注意： 常量是不变的，不能被赋值，所以常量不能出现在赋值运算符的左边 50 = 30; //该写法是错误的 复合赋值运算符，这里介绍+=，其他与它类似 int a = 3;a += 3; //相当于a = a + 3a *= 3; //相当于a = a * 3// 其他的同理可以知道... ... 注意： 复合赋值运算符隐含了强制类型转换 short s = 2;s += 2; //这里暗含了强制类型转换，s + 2得到的是一个int类型，被强制转换为了short类型，所以相当于s = (short) (s + 2); 比较运算符比较运算符对操作数进行比较，得到一个boolean数据类型的值，比较运算符包含以下： ==：判断两个数是否相等 &gt; &lt; &gt;=：大于等于 &lt;= !=：判断两个数是否不相等 注意： 在判断某变量属于某区间，比如是否大于3小于5时，不能写成3 &lt; x &lt; 5，应当使用后面提及的逻辑运算符3 &lt; x &amp;&amp; x &lt; 5 逻辑运算符逻辑运算符的对象是boolean数据类型的值，包含下面三个操作 &amp;&amp;：与操作，当两个操作数同时为true时，结果才为true ||：或操作，两个操作数中有一个操作数为true时，结果就为true !：非操作，!true = false, !false = true 注意： 逻辑运算符的操作对象为boolean，所以如果操作对象不为boolean类型时，会报错 boolean b = 5 &amp;&amp; 2; //会报错boolean b = 5 &amp;&amp; true; //会报错 短路 表达式1 &amp;&amp; 表达式2：当表达式1为假时，已经可以判断出结果为假，所以不会对表达式2进行判断，不会执行表达式2 表达式1 || 表达式2：当表达式1为真时，已经可以判断出结果为真，同上。 int a = 3;System,out.println(false &amp;&amp; a++ &lt; 100); //此时进行了短路运算，a++ &lt; 100没有得到执行，所以a = 3 int a = 3;System.out.println(true || a++ &lt; 100); //同上 三元运算符这里的三元指的是有三个操作数，上面我们介绍的运算符的操作数要么是一个的，如++,–,!，要么是两个的，如+,-,…，三元运算符的格式是 变量 = 条件判断 ? 表达式1 : 表达式2; 首先会进行条件判断，如果条件判断得到的结果为true，那么会将表达式1的结果赋值给变量，此时表达式2不会得到执行；否则将表达式2的结果赋值为变量。 int a= 3;int b = 4;int c = 4 &gt; 3 ? a : b++; //c = 3，表达式2没有执行，b = 4System.out.println(b); //输出为4 注意： 变量的类型必须与表达式的结果的类型一致，否则会报错 int c = 4 &gt; 3 ? 2 : 2.5; //该语句是错的，2.5是double类型，不能转化为int 可能有的人会说返回的2，为什么会报错，因为在实际中，判断语句的结果不是确定的，否则直接将2赋值给c好了，根本不需要判断，因此两个表达式的结果都有可能赋值给变量，编译器会检查表达式得到的数据类型。 单独写三元表达式是错误的 int a = 4; b = 3;a &gt; b ? a : b; //这么单独写是错误的 但是可以这么写 System.out.println(a &gt; b ? a : b); //这么写是对的 流程控制流程指的就是程序执行的顺序，写过汇编的同学都知道，用汇编写程序的流程控制都是jump的，各种跳来跳去，这会导致程序的流程极其的不清楚，当出现bug时，极其的难以调试，我们称这种程序为“意大利面条”，意思就是像意大利面条一样交缠在一起，极其混乱。 后来人们发现，只需要三种结构就可以写出任何的程序，这三种结构就是顺序结构，选择结构，循环结构，使用这三种结构使得程序条理清晰，结构清晰。下面就详细的介绍这三种结构。 顺序结构顺序结构指的就是程序从上到下，按照顺序执行，例如 System.out.println(\"我是第一条语句\");System.out.println(\"我是第二条语句\"); 输出为 我是第一条语句我是第二条语句 选择结构有时候我们需要根据某种状态来判断哪段程序应该执行，比如用户输入用户名和密码，根据是否输入正确来决定程序的行为。 选择结构分为两大类，一个与关键字if,else有关，一个与关键字switch,case有关，下面详细进行介绍。 if-else语句单独一个if使用方法为 if (判断语句) &#123; //代码&#125; 对判断语句进行判断，如果结果为真，则执行if里面的代码，如果为假，则跳过整个语句。 if-else语句上面if语句是当结果为真时执行语句块，但是当结果为假却什么都不干，我们希望当结果为假时，也能有相应的操作，那么就要用到if-else语句 if (判断语句) &#123; //if语句块&#125; else &#123; //else语句块&#125; 当结果为真时，执行if语句块，结果为假时，执行else语句块。 if-else-if else语句级联有时候，我们不仅需要的是一次判断，而是多个判断，比如有一个分段函数，根据函数的不同取值，选择不同的函数，比如$$y =\\begin{cases}2x - 1, &amp;x &lt; 1 \\\\2x, &amp;1 \\leq x &lt; 2 \\\\2x + 1, &amp;x \\geq 2\\end{cases}$$ if (x &lt; 1) &#123; y = 2 * x - 1;&#125; else if (1 &lt;= x &amp;&amp; x &lt; 2) &#123; y = 2 * x;&#125; else &#123; //x &gt;= 2 y = 2 * x + 1&#125; switch-case语句switch-case语句的格式为 switch (表达式) &#123; case 常量1: 语句1; break; case 常量2: 语句2; break; ... case 常量n: 语句n; break; default: 语句n+1; break;&#125; 该段程序的执行过程为，首先计算switch表达式的结果，然后将表达式的结果与常量1,常量2,…比较，看是否相等，如果与其中某个常量相等，则会执行相应的语句块。如果与所有的case常量都不相等，那么就会执行default中的语句。 注意： 多个case的常量不能相同 switch表达式的结果只能是下面的几种类型 基本数据类型：byte,short,char,int 引用类型：String，枚举类型 case的顺序可以发生改变 另外，比较重要的是，其实break不是必须的，可以省略，如果省略的话，由于没有break，程序会继续执行下去，直到遇到break或者程序执行结束。 switch (1) &#123; case 1: System.out.println(1); //不会退出程序，继续执行 case 2: System.out.println(2); break; //在这里遇到break，退出 default: System.out.println(3); break;&#125; 程序的输出为 12 循环结构循环指的就是重复执行某段程序，一般循环由下面四部分组成 初始化 条件判断 循环体 循环控制语句 循环有三种，分别是 for循环 while循环 do-while循环 下面详细介绍。 for循环for循环的格式为 for (初始化语句; 条件判断; 循环控制) &#123; 循环体;&#125; 执行的顺序为，先执行初始化语句，然后进行条件判断，如果结果为真，那么进入循环体，如果结果为假，那么退出循环，执行完循环体后，接着执行循环控制语句，然后进行条件判断，循环往复。如下面的例子打印出1-100的和 int sum = 0;for (int i = 1; i &lt;= 100; i++) &#123; //注意，这个i只能在for循环里面用，在外面不能用 sum = sum + i;&#125; while循环while循环的格式为 while (判断语句) &#123; 循环体&#125; 首先会对判断语句进行判断，真就执行循环体，假就退出循环。执行完循环体，接着进行判断，循环往复。下面的例子计算1-100的和 int sum = 0;int i = 1; //初始化语句while (i &lt;= 100) &#123; //判断语句 sum = sum + i; //循环体 i++; //循环控制语句&#125; do-while循环do-while循环的格式为 do &#123; 循环体&#125; while (条件判断); 首先会执行一次循环体，然后进行条件判断，真就继续执行循环体，否则退出循环。 do-while循环与while循环的区别是，do-while一定会执行一次循环体，例如 int i = -1;do &#123; System.out.println(1);&#125; while (i &gt; 0); 输出为 1 循环控制break和continue当在循环体中执行到break时，会直接退出循环，如 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(i); if (i == 2) &#123; break; //当i = 2时退出循环 &#125;&#125; 程序输出为 12 当在循环体中执行到continue时，退出此次循环，直接进行下一次循环，如 for (int i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; continue; //退出此次循环，后面的代码不执行了，直接执行循环控制语句i++，进入下一次循环 &#125; System.out.println(i);&#125; 输出为 1245 死循环当循环一直进行下去，不能退出，那么就成为了死循环，例如下面就是一个死循环 while (true) &#123; System.out.println(\"Hello\");&#125;for (int i = 0; ; i++) &#123; //省略了条件判断语句，默认为真，是死循环 System.out.println(i);&#125;for (int i = 0; i &lt; 10; ) &#123; //省略了循环控制语句，i一直为0，条件判断一直为真，为死循环 System.out.println(i);&#125; 循环嵌套循环里面可以嵌套着一个循环，例如输出九九乘法表 for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.printf(\"%d*%d=%2d \",j,i,j*i); //类似于C语言，格式化输出，以便对齐 &#125; System.out.println();&#125; 输出为 1*1= 1 1*2= 2 2*2= 4 1*3= 3 2*3= 6 3*3= 9 1*4= 4 2*4= 8 3*4=12 4*4=16 1*5= 5 2*5=10 3*5=15 4*5=20 5*5=25 1*6= 6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7= 7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8= 8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9= 9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 方法入门方法定义方法定义的格式为 修饰符 返回类型 方法名(参数类型 参数) &#123; 代码 ...; return ...;&#125; 其中修饰符目前固定为public static，方法要符合之前在标识符里面的规定。 注意： 方法不能定义在方法里面 方法定义的前后顺序无所谓 方法应在class和main方法之间定义 return的作用有两个，第一个是终止程序退出方法，第二个是返回值 如果返回值的类型时void，可以只写return;，代表退出方法 public class Hello &#123; //定义了一个方法，该方法的作用是计算两个int整数的和，并返回一个int类型的值 //该方法接收两个int类型的参数，返回一个int类型的值 public static int add (int x, int y) &#123; return x + y; &#125; //main方法的顺序可以和上面add方法的顺序颠倒 public static void main(String[] args) &#123; //... ... //不能在里面定义方法 &#125;&#125; 方法调用方法调用的格式为 方法名(参数); 例如，在main方法中调用上面定义的add方法 public class Hello &#123; public static int add (int x, int y) &#123; return x + y; &#125; public static void main(String[] args) &#123; //调用add方法，其中2 和 3是参数，必须是int类型，否则会报错 int c = add(2, 3); //使用变量c来接受方法返回的结果，此时c = 5 &#125;&#125; 方法重载方法重载指的是两个方法的方法名相同，但是参数列表不同，参数列表不同包括三个方面 参数个数不同 参数类型不同 参数顺序不同 例如，下面的方法是重载 public static void add (int i, intj);static int add (double i, double j);public void add (double i, intj); 注意： 判断方法是否是重载，关键是看方法名是否相同，参数列表是否不同，与修饰符，返回值没有任何的关系 例如，下面的方法不是重载 public static void add (int i, int j);static void add (int i, int j); //与修饰符无关，参数列表相同，所以不是重载，编译会报错public static int (int i, int j); //与返回值无关，参数列表相同，所以也不是重载，编译会报错 下面举一个注意事项，假设有下面这么一个方法 public static void add (int i, double j); 在main方法中，我们可以这么调用 add(2, 2); //我们可以传入两个整数，因为会进行自动类型转换为double 然后我们对该方法重载了 public static void add (double i, int j); //参数列表的顺序不同，是重载 如果我们还在main方法中传入两个整数 add (2, 2); //这时会报错 因为在调用这个方法时，发现两个方法都可以，所以编译器就会感到模糊，不知道调用哪一个方法，就会报错。 数组假设你要保存一组学生的成绩，我们会考虑每个学生用不同的变量保存，如 int score1 = 100;int score2 = 80;... ... 这样写的话代码很长，并且不利于批量操作，比如如果我要给每个学生加上十分，那我们只能这么写 score1 = score1 + 10;... ... 这只是体力活。 Java中专门有一类数据类型用来保存这样的数据，它叫做数组，下面我们将详细介绍。 数组的初始化数组的初始化分为两组，分别为动态初始化（指定长度）和静态初始化（指定内容）。 动态初始化动态初始化的格式为 数据类型[] 数组名 = new 数据类型[数组长度]; 例如，下面声明了一个长度为3的int类型的数组 int[] array = new array[3]; 动态初始化其实可以分为两部分 int[] array;array = new array[3]; 静态初始化静态初始化的格式为 数据类型[] 数组名 = new 数据类型[] &#123;内容&#125;; 例如，下面创建了一个String类型的数组，里面有3个字符串，内容之间使用逗号隔开 String[] str = new String[]&#123; \"Hello\", \"World\", \"!!!\" &#125;; 编译器会自动计算内容的个数来确定数组的长度。静态初始化还有省略格式 数据类型[] 数组名 = &#123;内容&#125;; 例如上面的例子用省略格式重写为 String[] str = &#123; \"Hello\", \"World\", \"!!!\" &#125; 静态初始化也可以看做是由两部分组成 String[] str;str = new String[] &#123; \"Hello\", \"World\", \"!!!\" &#125;; 但是省略格式不能这样看，例如下面的写法是错误的 String[] str;str = &#123; \"Hello\", \"World\", \"!!!\" &#125;; 注意： 数组的长度在程序运行期间是固定的，不能够发生改变 可以通过数组名.length来得到数组的长度 静态初始化会根据内容来自动推算出数组的长度 访问数组我们通过数组名[索引]的方式来访问数组里面的内容，这里需要注意的是索引值是从0开始的，所以索引的范围为0~数组长度-1 int[] array = &#123; 1, 2, 3 &#125;;System.out.println(arrays[0]); //访问数组中的第一个元素，输出1System.out.println(arrays[1]); //访问数组中的第二个元素，输出2 注意： 索引的范围不能超过数组的长度，否则会报错 例如对于上面定义的数组，下面的代码会报错 array[3]; //会报错 动态初始化有默认值，不同类型的默认值不同，如下 数据类型 默认值 整型(byte,short,int,long) 0 浮点型(float和double) 0.0 字符(char) ‘\\u0000’ 布尔型(boolean) false 引用内容 null 静态初始化其实也有默认值，不过马上又被赋值被覆盖了 Java的内存模型Java的内容模型分为五部分，分别是 栈(Stack) 存放的都是局部变量，变量一旦超出作用域，立刻从栈内存中消失 当调用方法运行时，栈会为方法开辟一块空间 堆(Heap) 凡是new出来的，都在堆中 堆内存里面的东西都有一个地址值 堆内存里的数据都有默认值，同数组的默认值 方法区(Method Area) 存储class相关的信息，包括方法的信息 本地方法栈(Native Method Stack) 与操作系统相关 寄存器(PC Register) 与CPU相关，速度非常的快 目前我们需要关注的前三个。 数组的内存图下面我们来看一段代码，然后从内存的角度看看发生了什么 public static void main(String[] args) &#123; int[] array1 = new int[3]; System.out.println(array1); // 猜猜打印出什么 array1[0] = 10; System.out.println(array1[0]); int[] array2 = array1; System.out.println(array2); array2[1] = 200; System.out.println(array1[1]);&#125; 上面代码的输出为 [I@15db974210[I@15db9742200 下面将从内存的角度解释，首先第一行 public static void main(String[] args) 该方法的信息会保存在方法区中，如果方法区中没有该方法，那么程序会报错。然后找到main方法后，这时会把main推入栈中，栈内存会为main方法开辟一块空间 int[] array1 = new int[3]; 这一行是动态初始化数组，首先会在main方法中分配一块空间保存变量array1的值，在堆中会开辟一块空间，空间的大小为3个int的大小，里面的默认值为0，在堆中存放的东西都有一个地址，array1保存的就是这个地址。访问数组就是通过这个地址去访问在堆中保存的数据的。 System.out.println(array1); 这一行打印变量array1的值，我们知道array1保存的是数组在堆中的地址，所以输出的是[I@15db9742，其中[代表类型为数组，I代表是int类型，@符号后面的十六进制数字是地址的哈希值。 array1[0] = 10;System.out.println(array1[0]); 第一行是对数组中的第一个元素赋值为10，原来数组中的元素默认为0，现在改变为了10。在内存中的过程为，首先根据array1保存的地址去寻找在堆中的数组，然后根据索引值去寻找对应的位置，然后对数据进行修改 int[] array2 = array1;System.out.pritnln(array2); 这行语句声明了一个数组变量array2，它的值与array1的值相同，所以输出结果为[I@15db9742。这表示两个数组变量指向在堆中的同一个数组 array2[1] = 200;System.out.println(array1[1]); 上面的语句表示通过array2修改数组中的元素array2[1]为200，由于array1和array2指向的是同一个数组，所以array2对数组进行修改也会影响到array1。所以输出的结果是200而不是0。 数组练习学习了数组的内容之后，我们做几个练习巩固一下知识。 遍历数组遍历数组指的就是访问数组中的每一个元素。我们使用for循环，将数组中的每一个元素打印出来。 int[] array = &#123; 1, 4, 7, 9, 5&#125;;for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]);&#125; 输出为 14795 找到数组中的最大值思路为，想象为这是一个打擂台，数组中的元素就是挑战者，首先让数组中的第一个元素为擂主，后面的挑战者（数组元素）去挑战，比擂主强的话就成为新的擂主，比擂主弱那么擂主就继续在台上，那么最后所有人都挑战完了，那么此刻的擂主就是最强的男人。 int[] array = &#123; 1, 4, 7, 9, 5&#125;;int max = array[0]; //擂主为第一个元素for (int i = 1; i &lt; array.length; i++) &#123; //挑战者不断挑战 if (array[i] &gt; max) &#123; max = array[i]; //如果挑战者比擂主强，那么换擂主，否则擂主不变 &#125;&#125;System.out.println(max); //此刻的擂主就是最强的 输出为 9 数组反转所谓的数组反转就是相对应的位置调换顺序，比如索引为0与索引为array.length-1（最后一个元素）调换位置，一般的索引为i的元素与索引为array.length-1-i的元素交换位置，那么交换的条件就是i &lt; array.length -1 - i得到i &lt; (array.length -1) / 2 int[] array = &#123; 1, 4, 7, 9, 5&#125;;int len = array.length;for (int i = 0; i &lt; (len - 1) / 2; i++) &#123; int temp = array[i]; array[i] = array[len -1 -i]; array[len -1 -i] = temp;&#125;for (int i = 0; i &lt; len; i++) &#123; System.out.println(array[i]);&#125; 输出为 59741 数组与方法数组可以作为函数的参数，也可以作为函数的返回值返回。 方法作为函数参数下面定义一个方法，该方法的作用是打印出数组里面的所有的元素，该方法接收一个整型的数组参数。 public static void printArray (int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125;&#125; 下面在main方法中调用该方法 int[] array = &#123; 1, 2, 3 &#125;;printArray(array); 输出为 123 注意： 数组传递的是地址值，所以printArray方法中的array与main方法中的array指向的是同一个数组，所以如果在printArray方法中对数组元素进行修改的话，会影响到main方法中的array。 随着printArray方法的执行完成，在栈内存中会将为printArray开辟的空间出栈，此时printArray方法中的array变量会立即消失。 不仅是数组，引用类型作为方法的参数，传递的都是地址值 数组作为方法返回值下面有一个方法，该方法接收一个数组，返回该数组的所有数字之和及平均数，由于return语句只能返回0或1个值，要返回两个值的话，我们可以返回一个数组，数组的第一个值表示和，第二个值表示平均数。 public static double[] getSumAndAvg (int[] array) &#123; double sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; //求和 sum = sum + array[i]; &#125; double avg = sum / array.length; //得到平均数 double[] result = &#123; sum, avg &#125;; //创建一个数组，第一个值为sum 第二个值为avg return result;&#125; 在main方法中调用该方法 int[] array = &#123; 1, 4, 7, 9, 5&#125;;double[] resArr = getSumAndAvg(array); //得到数组System.out.println(\"Sum is \" + resArr[0]); //打印输出和System.out.println(\"Average is \" + resArr[1]); //打印输出平均数 输出为 Sum is 26.0Average is 5.2 注意： 方法返回时数组的地址值，内存分析过程同上类似 返回引用数据类型，返回的也是地址值","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Java开发环境搭建","date":"2019-06-30T16:00:00.000Z","path":"/Java环境搭建/","text":"Java环境搭建分为三步： 下载JDK 安装JDK 环境变量配置 下面将详细介绍安装的步骤。 下载JDK首先进入Oracle官网进行下载 在搜索框输入 Java，弹出的第一条就是 Java Download，进入页面，选择 JDK 8 进行下载 选择符合自己操作系统版本的 JDK 下载 勾选同意，并点击下载 这时需要你进行登录 有账号的登录下载，没账号的注册一个即可。登录成功后就开始下载了 安装JDK安装JDK就是一直点next即可，因为JDK是包含JRE的，所以JRE可以不必安装。 需要注意的是，不要将安装目录安装在中文目录下，因为可能会碰到各种各样的问题，我们将它扼杀在摇篮里即可。这里需要记住安装的路径，比如我安装的路径是 D:\\Java\\jdk1.8.0_271 进入你的安装目录，内容如下 环境变量配置现在要进行环境变量的配置，可能你不知道为什么需要进行配置。我们看这么一个情况，你在命令行输入一个命令，比如 notepad(它会打开一个记事本)，但是当你输入一串乱七八糟的字符时，它会提示你 那命令行怎么知道 notepad 是一个命令，而你乱输入的字符不是命令呢? 因为当你输入字符后，命令行会去一个路径找是否有这个命令，如果有那么执行该命令，没有就会报出上面那样的错误。为了我们能够在命令行中使用有关于 Java 的命令，我们就要将有关 Java 的命令添加到路径中，这个路径就是我们要去配置的东西。那么与Java 有关的命令放在哪里，放在安装目录下的 bin 目录下，然后进入 bin 目录，这个文件夹里面就是有关 Java 的各种命令，我们复制 bin 的路径，如 D:\\Java\\jdk1.8.0_271\\bin 现在来到桌面，右键我的电脑，点击属性 然后按照以下步骤 会进入下面这个界面 点击新建，将 bin 目录所在的路径写上去 接着一路点确定返回。为了检验是否配置成功，我们打开命令行，输入java和javac命令，如果出现下面的命令行输出就说明成功了 C:\\Users\\22231λ java用法: java [-options] class [args...] (执行类) 或 java [-options] -jar jarfile [args...] (执行 jar 文件)其中选项包括: -d32 使用 32 位数据模型 (如果可用) -d64 使用 64 位数据模型 (如果可用) -server 选择 \"server\" VM 默认 VM 是 server. -cp &lt;目录和 zip/jar 文件的类搜索路径&gt; -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt; 用 ; 分隔的目录, JAR 档案 和 ZIP 档案列表, 用于搜索类文件。 -D&lt;名称&gt;=&lt;值&gt; 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出 -version:&lt;值&gt; 警告: 此功能已过时, 将在 未来发行版中删除。 需要指定的版本才能运行 -showversion 输出产品版本并继续 -jre-restrict-search | -no-jre-restrict-search 警告: 此功能已过时, 将在 未来发行版中删除。 在版本搜索中包括/排除用户专用 JRE -? -help 输出此帮助消息 -X 输出非标准选项的帮助 -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 按指定的粒度启用断言 -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 禁用具有指定粒度的断言 -esa | -enablesystemassertions 启用系统断言 -dsa | -disablesystemassertions 禁用系统断言 -agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof 另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;选项&gt;] 按完整路径名加载本机代理库 -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;] 加载 Java 编程语言代理, 请参阅 java.lang.instrument -splash:&lt;imagepath&gt; 使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。C:\\Users\\22231λ javac用法: javac &lt;options&gt; &lt;source files&gt;其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:&#123;lines,vars,source&#125; 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:&#123;none,only&#125; 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:&#123;none,class&#125; 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名 如果提示命令找不到之类的，说明配置失败了，就要回头仔细看看是不是漏掉了什么。","tags":[{"name":"Java","slug":"Java","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/Java/"},{"name":"软件安装及配置","slug":"软件安装及配置","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"}]},{"title":"CSS基础","date":"2019-02-11T16:00:00.000Z","path":"/CSS基础/","text":"CSS入门之前我们学习过HTML的基本知识，对于网页来说，HTML搭建的只是框架，而对于网页的美容，则需要用到CSS，CSS就可以看做是网页的美容师。CSS的全称叫做Cascading Style Sheets,中文名字叫层叠样式表。我们可以用CSS设置字体的颜色，字体的大小以及图片外形，排版布局等等”美颜”的工作。 CSS的书写位置行内式CSS的书写位置有三个，第一个是行内，如下 &lt;标签 style=\"属性1:属性值1; 属性2:属性值2 ...\"&gt; 下面就是把这个一级标题设置为红色。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style = \"color:red\"&gt;CSS入门&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 内嵌式内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： &lt;head&gt; &lt;style&gt; 选择器&#123;属性1:属性值1; 属性2:属性值2; ...&#125; &lt;/style&gt;&lt;/head&gt; 比如下面 &lt;head&gt; &lt;style&gt; h1&#123;color:red;&#125; &lt;/style&gt;&lt;/head&gt; 就是把所有的h1标签的文字颜色设置为红色。 外链式外链式指的是HTML文件与CSS文件分开写，在实际工作中就是这么干的。但是为了方便，我在介绍CSS的使用的时候一般会用内嵌式。外链式的写法如下 &lt;link rel=\"stylesheet\" href=\"CSS文件的路径\" type=\"text/CSS\"/ &gt; link标签是单标签，它是放在head标签内的。在使用link标签时，必须指定link标签的三个属性,如下: href:定义所链接外部样式表文件的URL,可以是相对路径，也可以是绝对路径。 type:定义所链接文档的类型，在这里需要指定为”text/CSS”,表示链接的外部文件为CSS样式表。 rel:定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个样式表文件。 选择器标签选择器使用HTML的标签名作为选择器，为HTML的某一标签指定统一的CSS样式。比如上面的 h1&#123;color:red;&#125; 就是标签选择器，使用h1作为选择器，所有的h1标签包含的文字都被设置为红色。 类选择器类选择器是最常用的选择器，类选择器使用.（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： .类名&#123; 属性:属性值; ... ...&#125; 标签在调用CSS样式时，使class=”类名”即可，比如 &lt;head&gt; &lt;style&gt; .red&#123; color : red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=\"red\"&gt;CSS入门&lt;/h1&gt;&lt;/body&gt; 我们声明了一个类选择器，类名叫做red,在h1标签中，我们通过class=”red”调用了该类，所以h1标签所包含的文字设置成了红色。 多类名选择器如果我们在标签中需要调用多个类怎么办，比如有两个类分别为 .red&#123; color:red;&#125;.font14&#123; font-size=14px;&#125; 如果加入h1标签要调用这两个类的话，写法如 &lt;h1 class = \"red font14\"&gt;标题&lt;/h1&gt; 这个就叫做多类名选择器。 还有一个问题就是，如果调用的多个类有冲突怎么办?比如调用的两个类一个设置颜色为红色，一个设置颜色为蓝色，是如何处理这种冲突? .red&#123; color:red;&#125;.blue&#123; color:blue;&#125; 假设h1调用如下 &lt;h1 class=\"blue red\"&gt;标题&lt;/h1&gt; 你觉得会是蓝色还是红色的?答案是蓝色的，虽然调用时blue写在red前面，你想red会覆盖blue,所以会是红色，实际上最终的效果与调用的顺序无关，而与CSS书写的顺序有关，由于CSS书写时red在blue的上面，所以只有最后的blue生效。 id选择器与类选择器很相似，不管调用方式是通过id来调用的，并且书写方式上有差别，即将.改为了#。如下 #id名&#123; 属性:属性值; ... ...&#125; 调用方式同类调用方式，不过用的不是class=””而是id=””。与类选择器不同的是，由于id是唯一的，不同的标签的id不能相同，所以该种方法只能给唯一的一个id设置样式。并且id选择器能做到的，类选择器也能做到，所以实际上类选择器是用的最多的。 通配符选择器书写方式如下 *&#123; 属性:属性值; ... ... &#125; *就是通配符，代表所有标签的意思，意思是所有的标签都会被设置成这样的样式，该种方法在开发几乎不用。 字体样式字体大小font-size属性是用来设置字体大小的，字体大小的单位有很多，其中最常用的就是px,代表的是像素，1px代表的就是一个像素的大小。比如 font-size: 20px; 在网页中普遍使用14px+,并且尽量用偶数大小，因为奇数可能在低版本的浏览器中出现莫名的问题。 字体font-family属性是用来设置字体的，比如 font-family: \"楷体\"; 英文字体可以不加引号，但是如果英文字体含有空格，则需要加上引号，比如 font-family: \"Times New Roman\"; 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、UTF-8等)不匹配时会产生乱码的错误。xp系统不支持类似微软雅黑的中文。解决办法是可以使用CSS Unicode字体表示，比如 font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot; 就表示设置字体为微软雅黑。其中 \\5FAE\\8F6F\\96C5\\9ED1 就是Unicode字体。常见中文对应的Unicode字体如下: 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 字体粗细font-weight属性是用来设置字体粗细的，可选属性值有normal, bold, older, lighter,除了有着四种值可选外，其值还可以是数字，范围为100-900并且必须为100的倍数。normal相当于是400,bold相当于是700,一般建议用数字。 font-weight: 400; 字体风格font-style属性是用来设置字体风格的，有两种值可选，分别是normal对于正常的字体风格，另一个是italic对应的是斜体风格。 font-style: italic; 综合连写假如我们设置字体的时候，四个都要设置，假如我要设置字体大小为20px,字体为微软雅黑，字体粗细为500,字体风格为斜体，我们会这样写: .font &#123; font-size: 20px; font-family: \"\\5FAE\\8F6F\\96C5\\9ED1\"; font-weight: 500; font-style: italic;&#125; 因为对于字体样式写的比较频繁，这么写的话过于的繁琐，所以CSS规定可以对其综合连写，如下 .font &#123; font: italic 500 20px \"\\5FAE\\8F6F\\96C5\\9ED1\";&#125; 其中书写顺序必须为font-style, font-weight, font-size, font-family,其中font-size和font-family不可以省略。 文本样式颜色color属性用以设置文本的颜色，其取值有三种方法: red,green,blue…等内置的颜色 使用十六进制，比如#FF0000，其中十六进制的前两位代表三基色中的红色，中间两位代表绿色，后两位代表蓝色。所以#FF0000代表的就是红色。 使用RGB代码，比如红色为rgb(255,0,0)。 其中第二种方法使用的最多，如果十六进制的三对每两位是相同的，则可以缩写为一个，比如#FF0000可以缩写为#F00。#FFDD66可以缩写为#FD6。 行高line-height属性用以设置行高，比如对一个段落来说，其行与行之间的距离太小了，则可以通过设置行高来调整行间的距离。 p&#123; line-height: 40px;&#125; 文本对齐方式text-align用以设置文本的水平对齐方式，可选值有三个，分别为left, right, center。 text-align: center; 缩进text-indent用以设置段落首行的缩进距离，一般设置为2em即两个字的距离： text-indent: 2em; 文本修饰text-decoration属性用来修饰文本，有一下几个值可选: none：取消文本修饰或无修饰 underline：下划线 overline：上划线 line-through：删除线 复合选择器后代选择器假如有下面这么一个例子 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;后代选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;开心&lt;/p&gt; &lt;p&gt;快乐&lt;/p&gt; &lt;/div&gt; &lt;p&gt;乐观&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我们希望将开心和快乐变成红色，而不影响乐观，即将div标签下的p标签设置为红色，但不是所有的p标签设置为红色，所以不能这么写 p &#123; color: red;&#125; 也许你们可能会写一个类，然后让这两个p标签去调用，但是假设div下有很多这样的p标签的话，这样做就不现实，我这里使用的是后代选择器，如下 div p &#123; color: red;&#125; 即设置div标签下的p标签设置为红色。因为乐观所处的p标签不在div标签下，所以乐观不受影响。效果如下: 子代选择器假设有这么一个案例 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;子代选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;div&gt;&lt;a href=\"#\"&gt;二级菜单&lt;/a&gt;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 我们希望一级菜单变为红色，而二级菜单不受到影响，如果我们使用后代选择器 ul li a &#123; color: red;&#125; 那么li标签下的所有a标签都会受到影响，二级菜单也会受到影响，这个时候我们需要用子代选择器 ul&gt;li&gt;a &#123; color: red;&#125; 上面便是子代选择器的写法，与后代选择器不同，子代只包括”儿子”,而后代则是包括后代所有的。所以使用子代选择器，受到影响的只有li标签下的a标签，二级菜单没有受到影响。效果为: 交集选择器假设有下面这么一个案例 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;交集选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;啊啊&lt;/div&gt; &lt;div&gt;啊啊&lt;/div&gt; &lt;div&gt;啊啊&lt;/div&gt; &lt;p&gt;一一&lt;/p&gt; &lt;p&gt;一一&lt;/p&gt; &lt;p&gt;一一&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我们希望将第三个div标签中的文字设置为红色。很简单的一个方法就是这样 .red &#123; color: red;&#125; 然后让第三个div标签去调用，但是我们这里做出要求，当p标签去调用这个类时，它的颜色不会改变。这个时候我们就要用到交集选择器 div.red &#123; color: red;&#125; 上面的选择器表明，只有div标签调用这个类才会生效，其他标签调用这个类不会生效，这就是交集选择器。 并集选择器假设又有下面这个案例 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;并集选择器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;p&gt;123&lt;/p&gt; &lt;h1&gt;123&lt;/h1&gt; &lt;a href=\"#\"&gt;123&lt;/a&gt; &lt;strong&gt;123&lt;/strong&gt; &lt;/body&gt;&lt;/html&gt; 我们希望div,p.h1标签都设置为红色，其他的不变，我们可以这样写 div &#123; color: red;&#125;p &#123; color: red;&#125;h1 &#123; color: red;&#125; 使用并集选择器可以使上面的代码大大减少 div, p, h1 &#123; color: red;&#125; 使用逗号将标签或者类名隔开。 链接伪类选择器什么是伪类选择器，伪类选择器是向某些选择器添加特殊效果，比如为链接添加特殊效果,链接伪类选择器有四个，分别为 link：未访问过的链接状态 visited：已访问过的链接状态 hover：鼠标放上去时的链接状态 active：鼠标按下时的链接状态 类选择器使用点.,而伪类选择器使用冒号:。现在我们有这个需要，当未访问链接时，链接字体为25px,无下划线，当鼠标放上去时，颜色变为红色，当按下时颜色变为橙色，当访问后，颜色为绿色。CSS样式按如下写 a:link &#123; font-size: 25px; text-decoration: none; /*取消下划线*/&#125;a:visited &#123; color: green;&#125;a:hover &#123; color: red;&#125;a:active &#123; color: orange;&#125; 效果为 当未按下链接时，链接为蓝色，按把鼠标放上去时，链接变为红色，当按下链接时，链接变为橙色，当访问完链接后，链接变为了绿色。需要注意的一点是，伪类选择器的顺序必须按照lvha的顺序来，否则会达不到想要的效果。在实际的开发中，一般只用到hover,不会写的这么复杂，即我们只需要当鼠标放上去变颜色就行，如下 a &#123; font-size: 25px; text-decoration: none;&#125;a:hover &#123; color: red;&#125; 标签显示模式我们把标签分为三类，一类为块级(block)标签，一类为行内(inline)标签,最后一类为二者的综合，为行内块(inline-block)标签。每个块标签通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。常见的块级标签包括 &lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; 行内标签（内联标签）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。常见的行内标签包括 &lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; 假设我们对行内标签设置其宽高属性 a &#123; width: 20px; height: 30px;&#125; 这样做是没有效果的。链接a的宽高属性不会改变。 在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块标签。那么标签的这种显示模式可不可以转换呢? 答案是可以，我们可以使用display属性对其进行转换，如 display: inline; /*将块级标签转换为行内标签*/display: block; /*将行内标签转换为块级标签*/display: inline-block; /*将块级标签或者行内标签转换为行内块标签*/ 我们来看一个例子，假设有下面的程序 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标签显示模式&lt;/title&gt; &lt;style&gt; a &#123; text-decoration: none; /*取消下划线*/ background: pink; /*设置背景颜色，用以观察该标签显示模式的转换*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#\"&gt;链接&lt;/a&gt; &lt;a href=\"#\"&gt;链接&lt;/a&gt; &lt;a href=\"#\"&gt;链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 因为标签a是行内标签，所以这三个标签是显示在一行内的，如下: 并且无法对其设置宽高以及对齐属性。现在我们将标签a的显示模式改为块级模式 a &#123; text-decoration: none; background: pink; display: block;&#125; 效果为 可见链接已经变为了块级标签，一个标签占据一整行，并且我们可以对其设置宽高属性以及对其方式，如下 a &#123; text-decoration: none; background: pink; display: block; width: 400px; height: 100px; text-align: center;&#125; 效果为 可见链接a的宽高发生了变化，并且其内的文字水平居中对齐了。我们可以把所有的标签看做是一个盒子，有的盒子是占据一行的，并且可以设置其大小，有的盒子只能在行内，并且不能设置其大小，还有的盒子虽然在行内，但是可以设置其大小。我们就用CSS对盒子进行操作，或摆放，或修饰，或改变盒子的显示模式等等。 导航栏练习现在我们要做一个导航栏，其最终效果如下 我们要求导航栏的布局居中显示，并且其内的文字也要居中对齐。并且当鼠标放在网站导航上，其背景图片发生变换。 首先第一步便是显示着六个链接，如下 &lt;div class=\"nav\"&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt;&lt;/div&gt; 效果如下: 第二步，取消下划线，并且设置字体颜色为白色，并且添加背景图片，由于链接标签a是行内标签，其大小不可以改变，为了使添加的背景图片吻合，还需要改变其显示模式为display: inline-block,然后设置其宽高属性为图片宽高的大小。如下: .nav a &#123; text-decoration: none; /*取消下划线*/ color: #FFF; /*设置字体颜色为白色*/ display: inline-block; width: 120px; height: 50px; background-image: url(bg.png);&#125; 在这里，为了只影响导航栏的链接标签，这里我们用了后代选择器。效果如下: 这个时候我们发现导航栏没有居中对齐，并且里面的文字没有居中对齐 .nav &#123; text-align: center;&#125; 我们设置.nav类里的文字居中对齐，但是div里面的是链接，text-align属性还有用吗? 答案是可以，链接在块类标签里面可以当做是文字处理，这是一个知识点，记住了。效果如下： 我们发现导航栏居中对齐了现在我们需要将链接里面的文字水平居中对齐和垂直居中对齐，在.nav a加入如下 text-align: center;line-height: 50px; /*当行高等于标签设置的高度时，会使文字垂直居中对齐*/ 效果如下 现在最后一步就是将鼠标放上去，背景图片改变，我们使用伪类hover,如下 .nav a:hover &#123; background-image: url(\"bgc.png\");&#125; 这里为了只对导航栏的链接生效，这里也用了后代选择器，效果如下: 到这里我们已经完整的实现了导航栏的案例，下面贴出完整的代码。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;导航栏案例&lt;/title&gt; &lt;style&gt; .nav a &#123; text-decoration: none; /*取消下划线*/ color: #FFF; /*设置字体颜色为白色*/ display: inline-block; width: 120px; height: 50px; background-image: url(bg.png); text-align: center; line-height: 50px; &#125; .nav a:hover &#123; background-image: url(\"bgc.png\"); &#125; .nav &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;a href=\"#\"&gt;网站导航&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 行高在之前我们有提到这个属性line-height，该属性用来设置行高，并且我们用它来设置过行间距。为了明白行高指的是什么之间的距离，我们需要明白下面这个图 一个文本内容被四条线划分，而行高指的就是基线与基线之间的距离，当不设置行高时，行高的大小为字体的大小，所以行与行之间是紧贴着的。 在导航栏练习中，为了使文字能够垂直居中对齐，我们让line-height的大小等于盒子的大小，为了解释这一现象，我们先看一下盒子的组成，盒子的高度由上距离，下距离和文本内容的高度组成，上距离的大小为(行高-内容高度)/2,下距离的高度=盒子高度-上距离的高度-内容高度。当文本垂直居中显示时，上距离的高度等于下距离的高度，这时上距离的高度=(盒子高度-内容高度)/2,对比于上距离高度的公式，得到此时行高等于盒子的高度。所以这就解释了为什么当行高等于盒子高度时，文字会垂直水平居中，当行高增大时，上距离的高度增大，文字会向下移动。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/CSS/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"HTML基础","date":"2019-02-07T16:00:00.000Z","path":"/HTML入门/","text":"需要的开发工具由于目前的市场上Google的占有率最高，所以我们用Chorme作为开发用的浏览器，而写代码的工具有很多，我一般用WebStorm。 第一个HTML页面一般新入手一个语言，都是先敲一个代码，然后在解释这个代码，按照惯例都是显示Hello World,所以这里就在网页中显示Hello World。 &lt;html&gt; &lt;head&gt; &lt;title&gt;第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World &lt;/body&gt;&lt;/html&gt; 以上的程序可以写在任何文本编辑器中，然后将后缀名改为.html，用浏览器打开即可。 一般写html的格式应该如下 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 其中&lt;html&gt;,&lt;head&gt;等等称为标签，在html中，内容都是由标签来呈现的，而标签分为双标签和单标签，一般我们遇到的都是双标签，比如上面的&lt;html&gt;&lt;/html&gt;是双标签，&lt;html&gt;是开始标签，&lt;/html&gt;是结束标签。单标签比如&lt;br /&gt;是换行标签，它的作用是换行。 其中&lt;body&gt;&lt;/body&gt;标签里写的东西才是网页呈现的内容，比如上面的Hello World就是写在body标签里面的,而&lt;head&gt;&lt;/head&gt;标签里写的东西都不会呈现在网页中，一般写的都是网页的信息，比如所用的编码，网页的标题，网页的版权等等。 我们一般会在第一行加上&lt;!DOCTYPE html&gt;,这个是用来告诉浏览器我们使用的浏览器版本，这么写的话就代表我们使用的是html5的版本。 排版标签标题在html中共有6种标题，分别是 &lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;... ...&lt;h6&gt;&lt;/h6&gt; 其中h1为最大的标题，称为一级标题，h6称为六级标题，上面的标题标签都是双标签。 我们在网页中看看标题的效果: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;h4&gt;四级标题&lt;/h4&gt; &lt;h5&gt;五级标题&lt;/h5&gt; &lt;h6&gt;六级标题&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 段落段落标签是用&lt;p&gt;&lt;/p&gt;标签来呈现的，在&lt;p&gt;标签内部的内容视为一个段落，该标签会根据浏览器窗口的大小自动换行。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。 予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清， 亭亭净植，可远观而不可亵玩焉。(甚爱 一作：盛爱)&lt;/p&gt; &lt;p&gt;予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。 噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人?牡丹之爱，宜乎众矣!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 在html代码中进行换行操作时，在网页显示时不会进行换行操作，html中所有的功能都是由标签实现的，所以换行也需要换行标签实现。 我们可以见到，段落之间会自动换行，并且段落之间还隔有一个空行。 水平线水平线标签&lt;hr /&gt;是一个单标签，它的作用是显示一条水平线。 换行换行标签为&lt;br /&gt;,也是一个单标签，它的作用是换行，换行之后，不会像段落一样之间还有一个空行，而是两行会紧贴着。 两个无语义化的标签&lt;div&gt;&lt;/div&gt;和&lt;span&gt;&lt;/span&gt;,这两个标签没有实际的功能，在后面主要是配合CSS进行布局，所以这里就不要管它好了。 &lt;div&gt;标签会实现自动换行，所以一行只能有一个&lt;div&gt;标签，&lt;span&gt;不会自动换行，所以一行可以有多个&lt;span&gt;标签。 我们来看一个简单的例子: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;会自动换行&lt;/div&gt; &lt;span&gt;不会自动换行&lt;/span&gt;&lt;span&gt;可以有多个&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 文本格式化字体加粗加粗标签有两个，分别为&lt;b&gt;&lt;/b&gt;和&lt;strong&gt;&lt;/strong&gt;,二者都能进行加粗，不过&lt;strong&gt;标签比较有语义，所以用的比较多。 斜体斜体标签也有两个，分别为&lt;i&gt;&lt;/i&gt;和&lt;em&gt;&lt;/em&gt;,同样的，&lt;em&gt;用的比较多。 删除线同样也有两个，分别为&lt;s&gt;&lt;/s&gt;和&lt;del&gt;&lt;/del&gt;,后面的有语义，用的多。 下划线两个，分别为&lt;u&gt;&lt;/u&gt;和&lt;ins&gt;&lt;/ins&gt;,后面的有语义，为insert的缩写，用的较多。 简单的演示一下: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;strong&gt;粗体&lt;/strong&gt;&lt;/br &gt; &lt;em&gt;斜体&lt;/em&gt;&lt;/br &gt; &lt;del&gt;删除线&lt;/del&gt;&lt;/br &gt; &lt;ins&gt;下划线&lt;/ins&gt;&lt;/br &gt; &lt;/body&gt;&lt;/html&gt; 展示显示效果： 图像标签向网页中添加图片的方法为 &lt;img src=\"图片的路径\"&gt; 这是一个单标签，src称为标签&lt;img&gt;的属性，它的值应该为图片的路径。 而路径又分为绝对路径和相对路径,下面将简单介绍一下二者，假设有如下的目录结构 磁盘C file1文件夹 html.md p1.png image文件夹 p2.png p3.png 现在我打开的是html.md文件,如果我要与绝对路径插入p1.png, p2.png, p3.png这三张图片，那么方法是这样的 &lt;img src=\"C:/file1/p1.png\"&gt;&lt;img src=\"C:/file1/image/p2.png\"&gt;&lt;img src=\"C:/p3.png\"&gt; 如果以相对路径插入图片，那么图片相对于该文件的位置就很重要，下面演示如何以相对路径插入图片 &lt;img src=\"p1.png\"&gt;&lt;img src=\"image/p2.png\"&gt;&lt;img src=\"../p3.png\"&gt; p1.png和文件html.md处于同一级目录，所以直接写src=”p1.png”即可，而p2.png位于image文件夹，该文件夹与html.md文件处于同一目录，所以写为src=”image/p2.png”,而p3.png位于上级目录，..表示上一级目录，所以写为src=”../p3.png”。 图像标签除了有src属性外，还有其他的属性，如下 属性 功能 alt 图像不能显示时的替换文本 title 鼠标悬停显示的内容 width, height 宽度和高度，设置其中一个就可以，会等比例的缩放 border 添加边框，其值为边框的粗细 下面给一个示例写法: &lt;img src=\"p1.png\" width=\"60%\" title=\"p1.png\" border=\"1\"&gt; 链接标签我们碰到，当我们点击一句话就可以跳转到一个网页，或者点击一张图片跳转。那么这个就是用链接标签实现的。链接标签为: &lt;a href=\"链接地址\"&gt;跳转的文字或图片&lt;/a&gt; 比如你点击这里就会跳转到百度。比较需要注意的是，跳转到外部的网页要写成https://www.baidu.com，而不要写成www.baidu.com。 另外，注意这个跳转是在本页面打开的，而不是新打开一个页面，如果需要在新页面打开，则可以改变其属性target的值，如下 &lt;a href=\"https://www.baidu.com\" target = \"_blank\"&gt;点击这里&lt;/a&gt; target有两种值可选，分别为_self和_blank,默认为_self，即在本页面打开。除了可以跳转到外链，也可以在页面内进行跳转，你可以给一个标签设定一个id值,比如 &lt;img src=\"1.png\" id = \"1\"&gt; 我给这张插入的图片设了id值为1,那么我可以通过下面的语句跳转到这张图片 &lt;a href=\"#1\"&gt;跳转到1.png&lt;/a&gt; 通过id跳转前面要加#号。 列表无序列表该种列表在实际中使用的较多,效果大概是这样 足球 篮球 无序列表的标签为 &lt;ul&gt; &lt;li&gt;足球&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt;&lt;/ul&gt; 注意:&lt;ul&gt;&lt;/ul&gt;标签里面只能放&lt;li&gt;&lt;/li&gt;标签，而&lt;li&gt;&lt;\\li&gt;能放任何内容。 有序列表有序列表也经常用，其标签与无序的很相似 &lt;ol&gt; &lt;li&gt;足球&lt;/li&gt; &lt;li&gt;篮球&lt;/li&gt;&lt;/ol&gt; 效果是这样 足球 篮球 注意事项同无序。 自定义列表使用以下格式定义自定义列表 &lt;dl&gt; &lt;dt&gt;球类&lt;/dt&gt; &lt;dd&gt;足球&lt;/dd&gt; &lt;dd&gt;篮球&lt;/dd&gt;&lt;/dl&gt; 效果如下 球类 足球 篮球 表格表格在网页中也很常见，其写法为 &lt;table&gt; &lt;tr&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;物理&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 其效果为 学科 分数 物理 99 &lt;table&gt;&lt;/table&gt;标签就表示表格，而&lt;tr&gt;&lt;/tr&gt;表示一行，&lt;td&gt;&lt;/td&gt;表示一个单元格。table标签有很多的属性，如下 属性 功能 align 该属性设定对齐方式，有left,center,right三个值可选 cellspacing 单元格与单元格之间的距离，默认为2 cellpadding 单元格内的字与单元格之间的距离，默认为1 一般我们设置table的以下三个属性为0，这三个属性分别为cellspacing, cellpadding, border，称之为”三参为0”。我们还可使用&lt;caption&gt;&lt;/caption&gt;标签设置表格的标题，如 &lt;table&gt; &lt;caption&gt;成绩单&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;物理&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 成绩单 学科 分数 物理 99 因为表头比较特殊，所以有的时候我们在表头中不用td，使用th,该标签会加粗居中，我们改动如下 &lt;th&gt;学科&lt;/th&gt;&lt;th&gt;分数&lt;/th&gt; 效果为 成绩单 学科 分数 物理 99 下面讲的这个在实际中也经常遇到的是单元格合并。假如有下面这个表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 123 123 123 123 123 123 123 123 123 我希望将最后一行的后两列合并成一个单元格,首先我们要知道单元格的合并分为行和并rowspan和列合并colspan,行合并是自左而右的，列合并是自上而下的。将最后一行的后两列合并为一个，所以是列和并，并且是两个合并成一个，所以colspan = “2”,所以上面的程序改为 &lt;table&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123&lt;/td&gt; &lt;td colspan=\"2\"&gt;123&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果为 123 123 123 123 123 123 123 123 在第三个tr(代表第三行)的第二个td处设置colspan=”2”,因为要合并最后一列，所以要删去最后一个td。 表单现实中会经常提交表单，比如在注册邮箱时，你就需要提交表单，表单由三部分组成，表单控件，提示文本和表单域。 现在重点介绍表单控件，因为这个包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。与表单有关的标签是&lt;input/ &gt;,&lt;input/ &gt;是一个单标签，根据其属性type设置不同的值，可以指定不同的控件类型，如: type的值 控件 text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像形式的提交按钮 file 文件域 &lt;input/ &gt;还有其他的属性配合type属性使用，如下 属性 功能 name 控件的名称 value 控件的默认文本值 size 控件在页面中的显示宽度，只能为正整数 checked 定义选择控件默认被选中的项 maxlength 控件允许输入的最大字符数 这里我想说一下单选按钮，假设有两个单选按钮，比如男和女让你选，按道理只能选一个，如下 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"radio\"&gt;男&lt;input type=\"radio\"&gt;女 &lt;/body&gt;&lt;/html&gt; 你可以发现两个都可以选到，解决办法将二者的name属性设置为相同的，比如sex,相同的name代表他们是同一组的，对于单选按钮，同一组的只能选中一个。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男&lt;input type=\"radio\" name=\"sex\"&gt;女 &lt;/body&gt;&lt;/html&gt; 这个时候你只能选一个。 下面要介绍一个&lt;label&gt;&lt;/label&gt;标签，当label与一个表单控件绑定时，点击该label会获得该控件的输入焦点,那么如何与表单控件绑定呢?使用for属性,如下 &lt;label for=\"word\"&gt;Sex&lt;/label&gt;&lt;input type = \"text\" id = \"word\"&gt; 当你点击Sex,会自动获得输入焦点。效果如下: text只能输入一行的文本，事实上，我们在网页中经常见可以输入多行文本的输入框，比如在我们发表评论时的输入框，多行输入的标签是textarea,使用方法如下: &lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 默认显示文本&lt;/textarea&gt; 效果如下 最后一个要介绍的就是下拉菜单，下拉菜单的标签是 &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;青岛&lt;/option&gt;&lt;/select&gt; 如下所示 北京 上海 青岛 当option中设置selected属性为selected=”selected”,那么这个option是默认选中项。比如我要设置上海为默认选中项那么 &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=\"selected\"&gt;上海&lt;/option&gt; &lt;option&gt;青岛&lt;/option&gt;&lt;/select&gt; 北京 上海 青岛","tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTML","slug":"HTML","permalink":"https://lastknightcoder.github.io/lastknightcoder/tags/HTML/"}]}]